// Cargar variables de entorno desde archivo .env
require('dotenv').config();

// FunciÃ³n para validar URL
const isValidUrl = (string) => {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
};

// Cache simple en memoria para respuestas pesadas (24h)
const RESPONSE_CACHE = new Map();
const CACHE_TTL_MS_24H = 24 * 60 * 60 * 1000;

const buildCacheKey = (req) => {
  const keys = Object.keys(req.query || {}).sort();
  const queryString = keys.map(key => `${key}=${String(req.query[key])}`).join('&');
  return `${req.path}?${queryString}`;
};

const getCachedResponse = (key) => {
  const entry = RESPONSE_CACHE.get(key);
  if (!entry) return null;
  const ttlMs = entry.ttlMs || CACHE_TTL_MS_24H;
  if (Date.now() - entry.timestamp > ttlMs) {
    RESPONSE_CACHE.delete(key);
    return null;
  }
  return entry.payload;
};

const setCachedResponse = (key, payload, ttlMs = null) => {
  RESPONSE_CACHE.set(key, { timestamp: Date.now(), payload, ttlMs });
};

const parseDateSafe = (value) => {
  if (!value) return null;
  if (value instanceof Date) return value;
  if (typeof value === 'object') {
    if (typeof value.toDate === 'function') {
      const converted = value.toDate();
      return isNaN(converted.getTime()) ? null : converted;
    }
    if (typeof value._seconds === 'number') {
      const converted = new Date(value._seconds * 1000);
      return isNaN(converted.getTime()) ? null : converted;
    }
    if (typeof value.seconds === 'number') {
      const converted = new Date(value.seconds * 1000);
      return isNaN(converted.getTime()) ? null : converted;
    }
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

const calculateWeeksFromBirthDate = (birthDate) => {
  const start = parseDateSafe(birthDate);
  if (!start) return null;
  const now = new Date();
  const diffMs = now.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  const weeks = Math.floor(diffDays / 7) + 1;
  return Math.max(1, weeks);
};

const calculateMonthsFromBirthDate = (birthDate) => {
  const start = parseDateSafe(birthDate);
  if (!start) return null;
  const now = new Date();
  const diffMs = now.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  const months = Math.floor(diffDays / 30.44);
  return Math.max(0, months);
};

const calculateAgeInMonthsAtDate = (birthDate, targetDate) => {
  const birth = parseDateSafe(birthDate);
  const target = parseDateSafe(targetDate);
  if (!birth || !target) return null;
  let years = target.getFullYear() - birth.getFullYear();
  let months = target.getMonth() - birth.getMonth();
  if (target.getDate() < birth.getDate()) {
    months--;
  }
  if (months < 0) {
    years--;
    months += 12;
  }
  return Math.max(0, years * 12 + months);
};

const addMonthsToDate = (date, months) => {
  const base = parseDateSafe(date);
  if (!base || !Number.isFinite(months)) return null;
  const result = new Date(base.getTime());
  const targetMonth = result.getMonth() + months;
  result.setMonth(targetMonth);
  return result;
};

const addWeeksToDate = (date, weeks) => {
  const base = parseDateSafe(date);
  if (!base || !Number.isFinite(weeks)) return null;
  return new Date(base.getTime() + weeks * 7 * 24 * 60 * 60 * 1000);
};

const getTodayDateKey = () => new Date().toISOString().slice(0, 10);

const stripUndefined = (payload) => {
  if (!payload || typeof payload !== 'object') return payload;
  return Object.fromEntries(Object.entries(payload).filter(([, value]) => value !== undefined));
};

const TEETH_DEFINITIONS = [
  { id: 'upper-central-incisor-left', name: 'Central incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [8, 12], shedRangeYears: [6, 7] },
  { id: 'upper-central-incisor-right', name: 'Central incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [8, 12], shedRangeYears: [6, 7] },
  { id: 'upper-lateral-incisor-left', name: 'Lateral incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [9, 13], shedRangeYears: [7, 8] },
  { id: 'upper-lateral-incisor-right', name: 'Lateral incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [9, 13], shedRangeYears: [7, 8] },
  { id: 'upper-canine-left', name: 'Canine (cuspid)', arch: 'upper', type: 'canine', eruptRangeMonths: [16, 22], shedRangeYears: [10, 12] },
  { id: 'upper-canine-right', name: 'Canine (cuspid)', arch: 'upper', type: 'canine', eruptRangeMonths: [16, 22], shedRangeYears: [10, 12] },
  { id: 'upper-first-molar-left', name: 'First molar', arch: 'upper', type: 'molar', eruptRangeMonths: [13, 19], shedRangeYears: [9, 11] },
  { id: 'upper-first-molar-right', name: 'First molar', arch: 'upper', type: 'molar', eruptRangeMonths: [13, 19], shedRangeYears: [9, 11] },
  { id: 'upper-second-molar-left', name: 'Second molar', arch: 'upper', type: 'molar', eruptRangeMonths: [25, 33], shedRangeYears: [10, 12] },
  { id: 'upper-second-molar-right', name: 'Second molar', arch: 'upper', type: 'molar', eruptRangeMonths: [25, 33], shedRangeYears: [10, 12] },
  { id: 'lower-central-incisor-left', name: 'Central incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [6, 10], shedRangeYears: [6, 7] },
  { id: 'lower-central-incisor-right', name: 'Central incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [6, 10], shedRangeYears: [6, 7] },
  { id: 'lower-lateral-incisor-left', name: 'Lateral incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [10, 16], shedRangeYears: [7, 8] },
  { id: 'lower-lateral-incisor-right', name: 'Lateral incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [10, 16], shedRangeYears: [7, 8] },
  { id: 'lower-canine-left', name: 'Canine (cuspid)', arch: 'lower', type: 'canine', eruptRangeMonths: [17, 23], shedRangeYears: [9, 12] },
  { id: 'lower-canine-right', name: 'Canine (cuspid)', arch: 'lower', type: 'canine', eruptRangeMonths: [17, 23], shedRangeYears: [9, 12] },
  { id: 'lower-first-molar-left', name: 'First molar', arch: 'lower', type: 'molar', eruptRangeMonths: [14, 18], shedRangeYears: [9, 11] },
  { id: 'lower-first-molar-right', name: 'First molar', arch: 'lower', type: 'molar', eruptRangeMonths: [14, 18], shedRangeYears: [9, 11] },
  { id: 'lower-second-molar-left', name: 'Second molar', arch: 'lower', type: 'molar', eruptRangeMonths: [23, 31], shedRangeYears: [10, 12] },
  { id: 'lower-second-molar-right', name: 'Second molar', arch: 'lower', type: 'molar', eruptRangeMonths: [23, 31], shedRangeYears: [10, 12] }
];

const TEETH_ALIASES = {
  'upper-incisor1-left': 'upper-central-incisor-left',
  'upper-incisor1-right': 'upper-central-incisor-right',
  'upper-incisor2-left': 'upper-lateral-incisor-left',
  'upper-incisor2-right': 'upper-lateral-incisor-right',
  'lower-incisor1-left': 'lower-central-incisor-left',
  'lower-incisor1-right': 'lower-central-incisor-right',
  'lower-incisor2-left': 'lower-lateral-incisor-left',
  'lower-incisor2-right': 'lower-lateral-incisor-right',
  'upper-molar1-left': 'upper-first-molar-left',
  'upper-molar1-right': 'upper-first-molar-right',
  'upper-molar2-left': 'upper-second-molar-left',
  'upper-molar2-right': 'upper-second-molar-right',
  'lower-molar1-left': 'lower-first-molar-left',
  'lower-molar1-right': 'lower-first-molar-right',
  'lower-molar2-left': 'lower-second-molar-left',
  'lower-molar2-right': 'lower-second-molar-right'
};

const getToothDefinition = (toothId) => {
  const resolvedId = TEETH_ALIASES[toothId] || toothId;
  return TEETH_DEFINITIONS.find((t) => t.id === resolvedId) || null;
};

const normalizeTeethingType = (rawType) => {
  if (!rawType) return null;
  const value = String(rawType).toLowerCase().trim();
  if (['erupt', 'eruption', 'erupted', 'erupcion', 'erupciÃ³n', 'salio', 'saliÃ³'].includes(value)) {
    return 'erupt';
  }
  if (['shed', 'fall', 'lost', 'caida', 'caÃ­da', 'cayo', 'cayÃ³'].includes(value)) {
    return 'shed';
  }
  return ['erupt', 'shed'].includes(value) ? value : null;
};

const shouldSendDoulaGreeting = async (uid) => {
  if (!db) return true;
  const ref = db.collection('doula_daily_greetings').doc(uid);
  const doc = await ref.get();
  const todayKey = getTodayDateKey();
  if (doc.exists && doc.data()?.lastGreetedDate === todayKey) {
    return false;
  }
  await ref.set({ lastGreetedDate: todayKey, updatedAt: new Date() }, { merge: true });
  return true;
};

const normalizeDoulaGreeting = (text, userName, shouldGreet) => {
  if (!text) return text;
  const safeName = userName || 'MamÃ¡';
  const response = String(text).trim();
  if (!response) return response;
  const lines = response.split('\n');
  const firstLine = (lines[0] || '').trim();
  const hasGreeting = /^Â¡?hola\b/i.test(firstLine);
  if (shouldGreet) {
    if (hasGreeting) return response;
    return `Â¡Hola ${safeName}!\n\n${response}`;
  }
  if (hasGreeting) {
    lines.shift();
    while (lines.length && lines[0].trim() === '') lines.shift();
    return lines.join('\n');
  }
  return response;
};

const getWeeksFromChildData = (child) => {
  if (!child) return null;
  if (child.isUnborn) {
    const info = getChildCurrentInfo(child);
    return info.currentGestationWeeks || null;
  }
  if (child.birthDate) {
    const birthDate = child.birthDate.toDate ? child.birthDate.toDate() : child.birthDate;
    return calculateWeeksFromBirthDate(birthDate);
  }
  if (typeof child.ageInMonths === 'number') {
    return Math.max(1, Math.round(child.ageInMonths * 4.3));
  }
  const info = getChildCurrentInfo(child);
  if (info.currentAgeInMonths !== null && info.currentAgeInMonths !== undefined) {
    return Math.max(1, Math.round(info.currentAgeInMonths * 4.3));
  }
  return null;
};

const getMonthsFromChildData = (child) => {
  if (!child) return null;
  if (child.isUnborn) return null;
  if (child.birthDate) {
    const birthDate = child.birthDate.toDate ? child.birthDate.toDate() : child.birthDate;
    return calculateMonthsFromBirthDate(birthDate);
  }
  if (typeof child.ageInMonths === 'number') {
    return Math.max(0, Math.floor(child.ageInMonths));
  }
  const info = getChildCurrentInfo(child);
  if (info.currentAgeInMonths !== null && info.currentAgeInMonths !== undefined) {
    return Math.max(0, Math.floor(info.currentAgeInMonths));
  }
  return null;
};

const express = require('express');
const cors = require('cors');
const compression = require('compression');
const multer = require('multer');
const path = require('path');
const jwt = require('jsonwebtoken');
const OpenAI = require('openai');
const { format } = require('date-fns');

const app = express();
const PORT = process.env.PORT || 3000;

// JWT Secret para tokens de admin
const JWT_SECRET = process.env.JWT_SECRET || 'munpa-secret-key-2025-change-in-production';

// ConfiguraciÃ³n de CORS mejorada
const allowedOrigins = [
  // ProducciÃ³n
  'https://munpa.online', 
  'https://www.munpa.online',
  'https://munpa.app',
  'https://www.munpa.app',
  'https://dash.munpa.online',
  'https://dashboardmunpa-ey7a5gscn-mishu-lojans-projects.vercel.app',
  // Desarrollo
  'http://localhost:3000', 
  'http://localhost:3001', 
  'http://localhost:4200', 
  'http://localhost:5173', 
  'http://localhost:8081', 
  'http://localhost:19006'
];

app.use(cors({
  origin: (origin, callback) => {
    // Permitir requests sin origin (como mobile apps o curl)
    if (!origin) return callback(null, true);
    
    // Verificar si el origin estÃ¡ en la lista permitida
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    // Verificar si coincide con el patrÃ³n de Vercel preview
    if (/^https:\/\/dashboardmunpa-[a-z0-9]+-mishu-lojans-projects\.vercel\.app$/.test(origin)) {
      return callback(null, true);
    }
    
    // Rechazar otros origins
    callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  preflightContinue: false,
  optionsSuccessStatus: 204
}));

// CompresiÃ³n para respuestas mÃ¡s rÃ¡pidas
app.use(compression());

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// ConfiguraciÃ³n de multer para subida de archivos en memoria (compatible con Vercel)
const upload = multer({ 
  storage: multer.memoryStorage(), // Usar memoria en lugar de disco
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB mÃ¡ximo
  },
  fileFilter: function (req, file, cb) {
    // Solo permitir imÃ¡genes
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen'), false);
    }
  }
});

// Middleware para manejar peticiones OPTIONS (preflight)
app.options('*', cors());

// Middleware de logging (ligero por defecto)
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  if (process.env.LOG_HEADERS === 'true') {
    console.log('ðŸ“‹ Headers recibidos:', req.headers);
  }
  res.on('finish', () => {
    const ms = Date.now() - start;
    if (ms >= 1000) {
      console.log(`â±ï¸ [SLOW] ${req.method} ${req.path} - ${ms}ms`);
    }
  });
  next();
});

// Middleware para capturar informaciÃ³n del dispositivo/app
app.use((req, res, next) => {
  // Extraer informaciÃ³n de headers personalizados
  // Acepta tanto el formato con 'x-' como sin Ã©l
  const deviceInfo = {
    appVersion: req.headers['x-app-version'] || req.headers['appversion'] || null,
    platform: req.headers['x-platform'] || req.headers['platform'] || null, // 'ios' o 'android'
    buildNumber: req.headers['x-build-number'] || req.headers['buildnumber'] || null,
    deviceModel: req.headers['x-device-model'] || req.headers['devicemodel'] || null,
    osVersion: req.headers['x-os-version'] || req.headers['osversion'] || null,
    userAgent: req.headers['user-agent'] || null
  };

  // Adjuntar al objeto request para uso posterior
  req.deviceInfo = deviceInfo;

  // Log solo si hay informaciÃ³n del dispositivo
  if (deviceInfo.appVersion || deviceInfo.platform) {
    console.log(`ðŸ“± [DEVICE] ${deviceInfo.platform || 'unknown'} v${deviceInfo.appVersion || 'unknown'} - ${req.path}`);
  }

  next();
});

// Configurar Firebase usando el archivo JSON
let auth = null;
let db = null;
let admin = null;
let FieldValue = null;
let firebaseStatus = 'No inicializado';

// Configurar OpenAI
let openai = null;
let openaiStatus = 'No inicializado';

// Middleware de autenticaciÃ³n (declarado antes de su uso)
const authenticateToken = async (req, res, next) => {
  try {
    console.log('ðŸ” [AUTH] Iniciando verificaciÃ³n de token para:', req.path);
    
    if (!auth) {
      console.log('âŒ [AUTH] Firebase no estÃ¡ configurado');
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado'
      });
    }
    
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      console.log('âŒ [AUTH] No se encontrÃ³ token en headers');
      return res.status(401).json({
        success: false,
        message: 'Token de acceso requerido'
      });
    }

    console.log('ðŸ”‘ [AUTH] Token encontrado, longitud:', token.length);

    try {
      // PRIMERO intentar verificar como JWT del admin dashboard
      console.log('ðŸ”„ [AUTH] Intentando verificar como JWT admin...');
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        console.log('âœ… [AUTH] JWT admin verificado exitosamente:', decoded);
        
        req.user = { 
          uid: decoded.uid,
          email: decoded.email,
          role: decoded.role
        };
        console.log('âœ… [AUTH] req.user configurado desde JWT:', req.user);
        
        // Actualizar deviceInfo si estÃ¡ disponible (admin no necesita)
        next();
        return;
      } catch (jwtError) {
        console.log('âŒ [AUTH] No es un JWT vÃ¡lido:', jwtError.message);
      }

      // SEGUNDO intentar extraer uid del customToken JWT
      console.log('ðŸ”„ [AUTH] Intentando extraer UID del customToken...');
      const tokenParts = token.split('.');
      
      if (tokenParts.length === 3) {
        try {
          const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());
          console.log('ðŸ” [AUTH] Payload del token:', payload);
          
          if (payload.uid) {
            console.log('âœ… [AUTH] UID extraÃ­do del customToken:', payload.uid);
            
            req.user = { uid: payload.uid };
            console.log('âœ… [AUTH] req.user configurado:', req.user);
            
            // Actualizar deviceInfo en background
            updateDeviceInfoAsync(req);
            
            next();
            return;
          }
        } catch (decodeError) {
          console.log('âŒ [AUTH] Error decodificando customToken:', decodeError.message);
        }
      }
      
      // TERCERO intentar como idToken
      console.log('ðŸ”„ [AUTH] Intentando verificar como idToken...');
      const decodedIdToken = await auth.verifyIdToken(token);
      console.log('âœ… [AUTH] IdToken verificado exitosamente');
      
      req.user = decodedIdToken;
      console.log('âœ… [AUTH] req.user configurado:', req.user);
      
      // Actualizar deviceInfo en background
      updateDeviceInfoAsync(req);
      
      next();
      
    } catch (idTokenError) {
      console.log('âŒ [AUTH] Error verificando idToken:', idTokenError.message);
      return res.status(403).json({
        success: false,
        message: 'Token invÃ¡lido o expirado'
      });
    }
  } catch (error) {
    console.error('âŒ [AUTH] Error general en autenticaciÃ³n:', error);
    return res.status(403).json({
      success: false,
      message: 'Token invÃ¡lido o expirado'
    });
  }
};

// FunciÃ³n helper para actualizar deviceInfo en background
const updateDeviceInfoAsync = (req) => {
  if (!req.user || !req.user.uid || !req.deviceInfo || !db) {
    return;
  }

  const hasDeviceInfo = req.deviceInfo.appVersion || req.deviceInfo.platform;
  if (!hasDeviceInfo) {
    return;
  }

  setImmediate(async () => {
    try {
      const deviceInfoToSave = {
        appVersion: req.deviceInfo.appVersion,
        platform: req.deviceInfo.platform,
        buildNumber: req.deviceInfo.buildNumber,
        deviceModel: req.deviceInfo.deviceModel,
        osVersion: req.deviceInfo.osVersion,
        userAgent: req.deviceInfo.userAgent,
        lastUpdated: new Date()
      };

      await db.collection('users').doc(req.user.uid).update({
        deviceInfo: deviceInfoToSave,
        lastDeviceUpdate: new Date()
      });

      console.log(`ðŸ“± [AUTO] Device info actualizado para ${req.user.uid}: ${deviceInfoToSave.platform} v${deviceInfoToSave.appVersion}`);
    } catch (error) {
      console.error('âš ï¸ [AUTO] Error actualizando device info:', error.message);
    }
  });
};

const setupFirebase = () => {
  try {
    console.log('ðŸ”¥ Configurando Firebase con variables de entorno...');
    
    admin = require('firebase-admin');
    
    // Verificar que las variables de entorno estÃ©n disponibles
    const requiredEnvVars = [
      'FIREBASE_TYPE',
      'FIREBASE_PROJECT_ID',
      'FIREBASE_PRIVATE_KEY_ID',
      'FIREBASE_PRIVATE_KEY',
      'FIREBASE_CLIENT_EMAIL',
      'FIREBASE_CLIENT_ID',
      'FIREBASE_AUTH_URI',
      'FIREBASE_TOKEN_URI',
      'FIREBASE_AUTH_PROVIDER_X509_CERT_URL',
      'FIREBASE_CLIENT_X509_CERT_URL'
    ];

    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
    
    if (missingVars.length > 0) {
      throw new Error(`Variables de entorno faltantes: ${missingVars.join(', ')}`);
    }

    // Crear objeto de configuraciÃ³n desde variables de entorno
    const serviceAccount = {
      type: process.env.FIREBASE_TYPE,
      project_id: process.env.FIREBASE_PROJECT_ID,
      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
      private_key: process.env.FIREBASE_PRIVATE_KEY
        .replace(/\\n/g, '\n')
        .replace(/"/g, '')
        .trim(),
      client_email: process.env.FIREBASE_CLIENT_EMAIL,
      client_id: process.env.FIREBASE_CLIENT_ID,
      auth_uri: process.env.FIREBASE_AUTH_URI,
      token_uri: process.env.FIREBASE_TOKEN_URI,
      auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL,
      client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL
    };
    
    console.log('âœ… Variables de entorno cargadas correctamente');

    // Inicializar Firebase
    if (!admin.apps.length) {
      admin.initializeApp({
        credential: admin.credential.cert(serviceAccount),
        storageBucket: 'mumpabackend.firebasestorage.app'
      });
      console.log('âœ… Firebase Admin inicializado con Storage Bucket: mumpabackend.firebasestorage.app');
    } else {
      console.log('âœ… Firebase Admin ya estaba inicializado');
    }
    
    auth = admin.auth();
    db = admin.firestore();
    FieldValue = admin.firestore.FieldValue;
    
    console.log('âœ… Firebase Auth y Firestore configurados');
    firebaseStatus = 'Configurado correctamente';
    return true;
  } catch (error) {
    console.error('âŒ Error configurando Firebase:', error.message);
    firebaseStatus = `Error: ${error.message}`;
    return false;
  }
};

// FunciÃ³n para validar si un mensaje es relevante al tema de doula
const isRelevantToDoulaScope = (message) => {
  const lowerMessage = message.toLowerCase();
  
  // Palabras clave relacionadas con el Ã¡mbito de doula (embarazo, parto, crianza)
  const onTopicKeywords = [
    'embarazo', 'embarazada', 'gestaciÃ³n', 'bebÃ©', 'bebe', 'hijo', 'hija', 'niÃ±o', 'niÃ±a',
    'parto', 'dar a luz', 'contracciones', 'posparto', 'postparto', 'recuperaciÃ³n',
    'lactancia', 'amamantar', 'leche materna', 'pecho', 'teta',
    'reciÃ©n nacido', 'recien nacido', 'neonato', 'cuidados',
    'trimestre', 'semana', 'mes', 'desarrollo', 'crecimiento',
    'paÃ±al', 'panal', 'baÃ±o', 'sueÃ±o', 'dormir', 'alimentaciÃ³n', 'alimentacion',
    'maternidad', 'paternidad', 'crianza', 'familia',
    'sÃ­ntoma', 'sintoma', 'dolor', 'malestar', 'nÃ¡usea', 'nausea', 'vÃ³mito', 'vomito',
    'vitamina', 'Ã¡cido fÃ³lico', 'acido folico', 'hierro', 'calcio',
    'ecografÃ­a', 'ecografia', 'ultrasonido', 'ginecÃ³logo', 'ginecologo', 'obstetra', 'matrona',
    'cesÃ¡rea', 'cesarea', 'parto natural', 'epidural',
    'depresiÃ³n posparto', 'depresion posparto', 'ansiedad', 'estrÃ©s', 'estres',
    'cordÃ³n umbilical', 'cordon umbilical', 'placenta', 'Ãºtero', 'utero',
    'movimientos fetales', 'patadas', 'feto', 'embriÃ³n', 'embrion'
  ];
  
  // Palabras clave ALTAMENTE prohibidas (siempre rechazar, incluso si menciona embarazo)
  const strictlyOffTopicKeywords = [
    'taco', 'tacos', 'pizza', 'hamburguesa', 'burrito', 'enchilada', 'quesadilla',
    'programaciÃ³n', 'programacion', 'cÃ³digo', 'codigo', 'javascript', 'python', 'html', 'css', 'desarrollo web', 'software',
    'fÃºtbol', 'futbol', 'basketball', 'basquetbol', 'partido de', 'equipo deportivo',
    'pelÃ­cula', 'pelicula', 'serie', 'netflix', 'cine', 'actor', 'actriz',
    'videojuegos', 'gaming', 'consola', 'playstation', 'xbox', 'nintendo',
    'automÃ³vil', 'automovil', 'carro', 'coche', 'auto mecÃ¡nica', 'mecÃ¡nico automotriz', 'arreglo carro'
  ];
  
  // Palabras clave fuera del Ã¡mbito (rechazar solo si NO hay palabras de embarazo)
  const generalOffTopicKeywords = [
    'finanzas', 'dinero', 'inversiÃ³n', 'inversion', 'banco', 'crÃ©dito', 'credito', 'prÃ©stamo', 'prestamo', 'economÃ­a', 'economia',
    'derecho', 'ley', 'legal', 'abogado', 'contrato', 'trÃ¡mite', 'tramite', 'notario',
    'tecnologÃ­a', 'tecnologia', 'computadora', 'smartphone', 'internet', 'redes sociales', 'facebook', 'instagram',
    'cocina general', 'cocinar', 'chef', 'restaurante', 'menÃº restaurante', 'menu restaurante',
    'gimnasio', 'musculaciÃ³n', 'musculacion', 'pesas', 'entrenamiento deportivo',
    'polÃ­tica', 'politica', 'elecciones', 'gobierno', 'presidente', 'partido polÃ­tico', 'partido politico',
    'viajes', 'turismo', 'hotel', 'aviÃ³n', 'avion', 'crucero',
    'mÃºsica concierto', 'musica concierto', 'festival musical'
  ];
  
  // Patrones de preguntas claramente sobre comida no relacionada con embarazo
  const foodPatterns = [
    /receta de (taco|pizza|hamburguesa|pasta|postre|pastel|torta)/i,
    /cÃ³mo (hacer|preparar|cocinar) (taco|pizza|hamburguesa|pasta)/i,
    /como (hacer|preparar|cocinar) (taco|pizza|hamburguesa|pasta)/i,
    /ingredientes (para|de) (taco|pizza|hamburguesa|pasta)/i,
    /(dÃ³nde|donde) (comprar|comer|encontrar) (taco|pizza|hamburguesa)/i
  ];
  
  // Verificar patrones de comida prohibidos
  const matchesFoodPattern = foodPatterns.some(pattern => pattern.test(message));
  
  // Verificar palabras estrictamente prohibidas
  const hasStrictlyOffTopicKeyword = strictlyOffTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // Verificar palabras generalmente fuera de tema
  const hasGeneralOffTopicKeyword = generalOffTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // Verificar si contiene palabras relacionadas con el tema
  const hasOnTopicKeyword = onTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // LÃ³gica de validaciÃ³n:
  // 1. Si coincide con patrones de comida prohibidos -> RECHAZAR
  // 2. Si tiene palabras estrictamente prohibidas -> RECHAZAR siempre
  // 3. Si tiene palabras generalmente fuera de tema Y NO tiene palabras de embarazo -> RECHAZAR
  // 4. De lo contrario -> PERMITIR
  
  if (matchesFoodPattern) {
    return false; // Rechazar recetas de comida
  }
  
  if (hasStrictlyOffTopicKeyword) {
    return false; // Rechazar temas estrictamente prohibidos
  }
  
  if (hasGeneralOffTopicKeyword && !hasOnTopicKeyword) {
    return false; // Rechazar temas generales fuera del Ã¡mbito si no menciona embarazo
  }
  
  return true; // Permitir el resto
};

// FunciÃ³n para generar respuestas de doula predefinidas
const generateDoulaResponse = (message, userContext, childrenInfo, userName = 'MamÃ¡') => {
  const lowerMessage = message.toLowerCase();
  
  // Verificar si el tema es relevante
  const isOffTopic = !isRelevantToDoulaScope(message);
  
  if (isOffTopic) {
    return `Soy Douli, tu asistente de Munpa especializada en acompaÃ±amiento durante el embarazo, parto y crianza temprana.

ðŸ¤± **Mi especialidad es:**
â€¢ Embarazo y preparaciÃ³n al parto
â€¢ Lactancia y cuidados del bebÃ©
â€¢ Apoyo emocional para familias
â€¢ SeÃ±ales de alarma y cuÃ¡ndo consultar

ðŸ“ž **Para tu consulta sobre ${message}, te recomiendo:**
â€¢ Consultar con un profesional especializado
â€¢ Buscar informaciÃ³n en fuentes oficiales
â€¢ Contactar servicios especÃ­ficos para ese tema

Â¿Hay algo relacionado con tu embarazo, parto o crianza en lo que pueda ayudarte? ðŸ’`;
  }
  
  // Extraer informaciÃ³n de los hijos del contexto
  let childrenContext = '';
  let hasUnbornChildren = false;
  let hasYoungChildren = false;
  let hasMultipleChildren = false;
  let childrenNames = [];
  let unbornChildrenNames = [];
  let youngChildrenNames = [];
  
  if (childrenInfo) {
    const childrenMatch = childrenInfo.match(/Hijos nacidos: (\d+)/);
    const unbornMatch = childrenInfo.match(/Hijos por nacer: (\d+)/);
    
    if (childrenMatch && unbornMatch) {
      const bornCount = parseInt(childrenMatch[1]);
      const unbornCount = parseInt(unbornMatch[1]);
      
      hasUnbornChildren = unbornCount > 0;
      hasMultipleChildren = (bornCount + unbornCount) > 1;
      
      // Extraer nombres de los hijos
      const nameMatches = childrenInfo.matchAll(/- ([^:]+):/g);
      for (const match of nameMatches) {
        const name = match[1].trim();
        childrenNames.push(name);
        
        // Determinar si es hijo por nacer o nacido
        const lineAfterName = childrenInfo.substring(match.index).split('\n')[0];
        if (lineAfterName.includes('Por nacer')) {
          unbornChildrenNames.push(name);
        } else if (lineAfterName.includes('mes') || lineAfterName.includes('aÃ±o')) {
          youngChildrenNames.push(name);
        }
      }
      
      // Determinar si tiene hijos pequeÃ±os (menos de 3 aÃ±os)
      if (childrenInfo.includes('mes') || childrenInfo.includes('aÃ±o')) {
        hasYoungChildren = true;
      }
    }
  }
  
  // Respuestas para sÃ­ntomas del primer trimestre
  if (lowerMessage.includes('sÃ­ntoma') || lowerMessage.includes('primer trimestre') || lowerMessage.includes('nÃ¡usea')) {
    let personalizedIntro = `Soy Douli, tu asistente de Munpa. Te puedo ayudar con los sÃ­ntomas del primer trimestre.`;
    
    if (hasUnbornChildren) {
      const unbornNames = unbornChildrenNames.join(' y ');
      personalizedIntro += ` Veo que tienes a ${unbornNames} en camino, Â¡quÃ© emociÃ³n!`;
    } else if (hasYoungChildren) {
      const youngNames = youngChildrenNames.join(' y ');
      personalizedIntro += ` Como ya has pasado por esto antes con ${youngNames}, sabes que cada embarazo es diferente.`;
    } else if (hasMultipleChildren) {
      const allNames = childrenNames.join(' y ');
      personalizedIntro += ` Con tu experiencia como madre de ${allNames}, sabes que cada embarazo tiene sus particularidades.`;
    }
    
    return `${personalizedIntro}

ðŸ¤° **SÃ­ntomas normales:**
â€¢ NÃ¡useas matutinas
â€¢ Fatiga
â€¢ Sensibilidad en senos
â€¢ Cambios de humor

ðŸ’¡ **Para las nÃ¡useas:**
â€¢ Come poco y frecuente
â€¢ Galletas saladas en la cama
â€¢ Bebe mucha agua
â€¢ Evita comidas grasosas

âš ï¸ **Consulta al mÃ©dico si:**
â€¢ NÃ¡useas muy intensas
â€¢ Fiebre alta
â€¢ Sangrado

Â¿QuÃ© sÃ­ntoma te preocupa mÃ¡s?`;
  }
  
  // Respuestas para ejercicios durante el embarazo
  if (lowerMessage.includes('ejercicio') || lowerMessage.includes('actividad fÃ­sica') || lowerMessage.includes('deporte')) {
    return `Â¡Excelente pregunta! Soy Douli, tu asistente de Munpa. Te recomiendo mantenerte activa durante el embarazo, pero con precauciÃ³n:

ðŸƒâ€â™€ï¸ **Ejercicios seguros durante el embarazo:**
â€¢ Caminar (30 minutos diarios)
â€¢ Yoga prenatal
â€¢ NataciÃ³n
â€¢ Pilates adaptado
â€¢ Ejercicios de Kegel
â€¢ Estiramientos suaves

âš ï¸ **Ejercicios a evitar:**
â€¢ Deportes de contacto
â€¢ Ejercicios que requieran acostarse boca arriba despuÃ©s del primer trimestre
â€¢ Actividades con riesgo de caÃ­da
â€¢ Levantar pesos pesados

ðŸ’¡ **Consejos importantes:**
â€¢ Escucha a tu cuerpo
â€¢ MantÃ©n una respiraciÃ³n constante
â€¢ Bebe mucha agua
â€¢ Detente si sientes dolor o mareos
â€¢ Consulta con tu mÃ©dico antes de comenzar

Â¿QuÃ© tipo de actividad fÃ­sica te gustarÃ­a practicar?`;
  }
  
  // Respuestas para preparaciÃ³n al parto
  if (lowerMessage.includes('parto') || lowerMessage.includes('dar a luz') || lowerMessage.includes('preparar')) {
    return `Â¡QuÃ© emociÃ³n! Soy Douli, tu asistente de Munpa.

ðŸ¤± **PreparaciÃ³n fÃ­sica:**
â€¢ Ejercicios de respiraciÃ³n
â€¢ TÃ©cnicas de relajaciÃ³n
â€¢ Fortalece suelo pÃ©lvico
â€¢ Buena postura

ðŸ§˜â€â™€ï¸ **PreparaciÃ³n mental:**
â€¢ Lee sobre el parto
â€¢ Visualiza tu parto ideal
â€¢ Practica meditaciÃ³n
â€¢ ConfÃ­a en tu cuerpo

ðŸ“‹ **PreparaciÃ³n prÃ¡ctica:**
â€¢ Maleta para hospital
â€¢ Plan de parto
â€¢ Apoyo postparto
â€¢ Todo listo en casa

Â¿En quÃ© aspecto necesitas ayuda?`;
  }
  
  // Respuestas para lactancia
  if (lowerMessage.includes('lactancia') || lowerMessage.includes('amamantar') || lowerMessage.includes('leche materna')) {
    return `Â¡La lactancia es maravillosa! Soy Douli, tu asistente de Munpa.

ðŸ¤± **Beneficios:**
â€¢ NutriciÃ³n perfecta
â€¢ Fortalece sistema inmune
â€¢ Crea vÃ­nculo especial
â€¢ Ayuda recuperaciÃ³n

ðŸ’¡ **Consejos:**
â€¢ Contacto piel con piel
â€¢ Amamanta a demanda
â€¢ Buen agarre
â€¢ PosiciÃ³n cÃ³moda

âš ï¸ **Alerta si:**
â€¢ Dolor intenso
â€¢ Grietas en pezones
â€¢ Fiebre
â€¢ BebÃ© no gana peso

Â¿QuÃ© te preocupa especÃ­ficamente?`;
  }
  
  // Respuestas para alimentaciÃ³n durante el embarazo
  if (lowerMessage.includes('comida') || lowerMessage.includes('alimentaciÃ³n') || lowerMessage.includes('dieta') || lowerMessage.includes('nutriciÃ³n')) {
    return `Â¡La nutriciÃ³n es fundamental! Soy Douli, tu asistente de Munpa.

ðŸ¥— **Come:**
â€¢ Frutas y verduras
â€¢ ProteÃ­nas magras
â€¢ Granos enteros
â€¢ LÃ¡cteos bajos en grasa

âš ï¸ **Evita:**
â€¢ Pescado alto en mercurio
â€¢ Carne cruda
â€¢ Quesos sin pasteurizar
â€¢ Alcohol y cafeÃ­na

ðŸ’¡ **Consejos:**
â€¢ 5-6 comidas pequeÃ±as
â€¢ 8-10 vasos de agua
â€¢ Vitaminas prenatales
â€¢ Escucha tu cuerpo

Â¿QuÃ© alimento te preocupa?`;
  }
  
  // Respuestas para el postparto
  if (lowerMessage.includes('postparto') || lowerMessage.includes('despuÃ©s del parto') || lowerMessage.includes('recuperaciÃ³n')) {
    return `Â¡El postparto es un perÃ­odo muy importante! Soy Douli, tu asistente de Munpa. Te preparo para esta etapa:

ðŸ¤± **Primeras semanas postparto:**
â€¢ Descansa cuando el bebÃ© duerma
â€¢ Pide ayuda a familiares y amigos
â€¢ Come alimentos nutritivos
â€¢ Bebe mucha agua
â€¢ No te presiones por "volver a la normalidad"

ðŸ’™ **Cuidado emocional:**
â€¢ Es normal sentir emociones intensas
â€¢ Habla sobre tus sentimientos
â€¢ Busca apoyo si te sientes abrumada
â€¢ No te compares con otras madres
â€¢ Celebra cada pequeÃ±o logro

ðŸ¥ **Alerta si:**
â€¢ Fiebre alta
â€¢ Sangrado excesivo
â€¢ Dolor intenso
â€¢ Tristeza profunda

ðŸ’¡ **Consejos:**
â€¢ Comidas preparadas
â€¢ Organiza visitas
â€¢ Acepta ayuda
â€¢ No te olvides de ti

Â¿CÃ³mo te sientes?`;
  }
  
  // Verificar si pregunta por un hijo especÃ­fico o sobre edades
  const askedChildName = childrenNames.find(name => 
    lowerMessage.includes(name.toLowerCase())
  );
  
  // Verificar si pregunta sobre edad especÃ­fica
  if (askedChildName && (lowerMessage.includes('aÃ±o') || lowerMessage.includes('edad') || lowerMessage.includes('cuÃ¡nto') || lowerMessage.includes('cuantos'))) {
    // Buscar la informaciÃ³n especÃ­fica del hijo en childrenInfo
    const childLine = childrenInfo.split('\n').find(line => line.includes(askedChildName));
    
    if (childLine) {
      if (childLine.includes('Por nacer')) {
        const gestationMatch = childLine.match(/\((\d+) semanas de gestaciÃ³n\)/);
        const weeks = gestationMatch ? gestationMatch[1] : 'desconocidas';
        return `Soy Douli, tu asistente de Munpa. 

ðŸ¤± **${askedChildName}:**
${askedChildName} estÃ¡ por nacer (${weeks} semanas de gestaciÃ³n).

ðŸ’¡ **PrÃ³ximos pasos:**
â€¢ Prepara la maleta para el hospital
â€¢ Ten todo listo en casa
â€¢ Practica tÃ©cnicas de respiraciÃ³n

Â¿Necesitas ayuda con la preparaciÃ³n?`;
      } else {
        // Extraer edad del texto
        const ageMatch = childLine.match(/: (.+?) de edad/);
        if (ageMatch) {
          const age = ageMatch[1];
          return `Soy Douli, tu asistente de Munpa. 

ðŸ‘¶ **${askedChildName}:**
${askedChildName} tiene ${age}.

ðŸ’¡ **Consejos para esta edad:**
â€¢ MantÃ©n rutinas estables
â€¢ Celebra sus logros
â€¢ Dedica tiempo individual

Â¿QuÃ© aspecto especÃ­fico te preocupa?`;
        }
      }
    }
  }
  
  // Verificar si pregunta por un hijo especÃ­fico (sin edad)
  if (askedChildName) {
    const isUnborn = unbornChildrenNames.includes(askedChildName);
    const isYoung = youngChildrenNames.includes(askedChildName);
    
    if (isUnborn) {
      return `Soy Douli, tu asistente de Munpa.

ðŸ¤± **${askedChildName}:**
${askedChildName} estÃ¡ por nacer.

ðŸ’¡ **PreparaciÃ³n:**
â€¢ Todo listo para su llegada
â€¢ Prepara a tus otros hijos
â€¢ Maleta para hospital
â€¢ TÃ©cnicas de respiraciÃ³n

Â¿QuÃ© necesitas saber especÃ­ficamente?`;
    } else if (isYoung) {
      return `Soy Douli, tu asistente de Munpa.

ðŸ‘¶ **${askedChildName}:**
${askedChildName} estÃ¡ en etapa de desarrollo.

ðŸ’¡ **Consejos:**
â€¢ Rutina estable
â€¢ Tiempo individual
â€¢ Celebra logros
â€¢ Paciencia

Â¿QuÃ© te preocupa especÃ­ficamente?`;
    } else {
      return `Soy Douli, tu asistente de Munpa.

ðŸ‘¶ **${askedChildName}:**
${askedChildName} es parte de tu familia.

ðŸ’¡ **Consejos:**
â€¢ Necesidades Ãºnicas
â€¢ Tiempo individual
â€¢ Celebra logros
â€¢ ComunicaciÃ³n abierta

Â¿QuÃ© necesitas saber?`;
    }
  }
  
  // Respuesta general para cualquier otra pregunta
  let personalizedIntro = `Soy Douli, tu asistente de Munpa.`;
  
  if (hasUnbornChildren) {
    const unbornNames = unbornChildrenNames.join(' y ');
    personalizedIntro += ` Veo que tienes a ${unbornNames} en camino. Â¡QuÃ© momento tan especial!`;
  } else if (hasYoungChildren) {
    const youngNames = youngChildrenNames.join(' y ');
    personalizedIntro += ` Como madre experimentada con ${youngNames}, sabes que cada dÃ­a trae nuevos aprendizajes.`;
  } else if (hasMultipleChildren) {
    const allNames = childrenNames.join(' y ');
    personalizedIntro += ` Con tu experiencia criando a ${allNames}, eres una madre sabia.`;
  } else {
    personalizedIntro += ` Estoy aquÃ­ para acompaÃ±arte en este hermoso viaje del embarazo y la maternidad.`;
  }
  
  // Respuestas para preguntas sobre el nombre del usuario
  if (lowerMessage.includes('nombre') || lowerMessage.includes('llamas') || lowerMessage.includes('sabes mi nombre')) {
    return `Â¡Hola ${userName}! Soy Douli, tu asistente de Munpa.

ðŸ’ **Sobre tu nombre:**
Tu nombre es ${userName} y es hermoso. Me encanta poder llamarte por tu nombre para hacer nuestra conversaciÃ³n mÃ¡s personal y cercana.

ðŸ¤± **Como tu asistente:**
Estoy aquÃ­ para acompaÃ±arte en tu viaje de maternidad, ${userName}. Puedo ayudarte con consejos sobre embarazo, parto, lactancia y crianza.

Â¿En quÃ© puedo ayudarte hoy ${userName}?`;
  }
  
  // Respuestas para preguntas generales sobre hijos
  if (lowerMessage.includes('hijo') || lowerMessage.includes('hijos') || lowerMessage.includes('cuÃ¡ntos') || lowerMessage.includes('nombres')) {
    if (childrenNames.length > 0) {
      const bornChildren = childrenNames.filter(name => !unbornChildrenNames.includes(name));
      const unbornChildren = unbornChildrenNames;
      
      let response = `Soy Douli, tu asistente de Munpa. 

ðŸ‘¶ **Tu familia:**
Tienes ${childrenNames.length} hijo${childrenNames.length > 1 ? 's' : ''}.`;

      if (bornChildren.length > 0) {
        response += `\n\nðŸ‘¶ **Nacidos:**
${bornChildren.map(name => `â€¢ ${name}`).join('\n')}`;
      }
      
      if (unbornChildren.length > 0) {
        response += `\n\nðŸ¤± **Por nacer:**
${unbornChildren.map(name => `â€¢ ${name}`).join('\n')}`;
      }
      
      response += `\n\nðŸ’¡ **Puedo ayudarte con:**
â€¢ Consejos especÃ­ficos por edad
â€¢ PreparaciÃ³n para nuevos bebÃ©s
â€¢ Manejo de mÃºltiples hijos

Â¿Sobre cuÃ¡l necesitas ayuda?`;
      
      return response;
    } else {
      return `Â¡Hola ${userName}! Soy Douli, tu asistente de Munpa. 

ðŸ‘¶ **Sobre tu familia:**
Actualmente no tienes hijos registrados en el sistema, pero estoy aquÃ­ para acompaÃ±arte en tu viaje hacia la maternidad.

ðŸ’ **Puedo ayudarte con:**
â€¢ PreparaciÃ³n para el embarazo
â€¢ InformaciÃ³n sobre el parto
â€¢ Cuidado postparto
â€¢ Lactancia materna
â€¢ Apoyo emocional

Â¿Te gustarÃ­a que te ayude con algÃºn tema especÃ­fico ${userName}?`;
    }
  }
  
  return `${personalizedIntro}

ðŸ’¡ **Puedo ayudarte con:**
â€¢ Embarazo y parto
â€¢ Lactancia
â€¢ Cuidado postparto
â€¢ Apoyo emocional
${hasMultipleChildren ? 'â€¢ MÃºltiples hijos' : ''}
${hasYoungChildren ? 'â€¢ NiÃ±os pequeÃ±os' : ''}
${hasUnbornChildren ? 'â€¢ PreparaciÃ³n bebÃ©' : ''}

Â¿En quÃ© necesitas ayuda especÃ­ficamente ${userName}?`;
};

// FunciÃ³n para configurar OpenAI
const setupOpenAI = () => {
  try {
    console.log('ðŸ¤– Configurando OpenAI...');
    
    if (!process.env.OPENAI_API_KEY) {
      console.log('âš ï¸ OPENAI_API_KEY no estÃ¡ configurada - OpenAI serÃ¡ opcional');
      openaiStatus = 'No configurado (opcional)';
      return false;
    }

    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    console.log('âœ… OpenAI configurado correctamente');
    openaiStatus = 'Configurado correctamente';
    return true;
  } catch (error) {
    console.error('âŒ Error configurando OpenAI:', error.message);
    openaiStatus = `Error: ${error.message}`;
    return false;
  }
};

// Inicializar Firebase
const firebaseReady = setupFirebase();

// Inicializar OpenAI
const openaiReady = setupOpenAI();

// Ruta de salud
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Servidor funcionando correctamente',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    firebase: {
      status: firebaseStatus,
      ready: firebaseReady,
      hasAuth: !!auth,
      hasDb: !!db,
      hasAdmin: !!admin,
      hasStorage: !!(admin && admin.storage)
    },
    openai: {
      status: openaiStatus,
      ready: openaiReady,
      hasClient: !!openai
    }
  });
});

// Endpoint de la Doula Virtual
app.post('/api/doula/chat', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { message, context } = req.body;

    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje es requerido'
      });
    }

    // âš ï¸ VALIDACIÃ“N DE TEMA: Verificar si el mensaje es relevante al Ã¡mbito de doula
    if (!isRelevantToDoulaScope(message)) {
      console.log('âš ï¸ [DOULA] Mensaje fuera del Ã¡mbito detectado:', message.substring(0, 50));
      
      // Obtener nombre del usuario para personalizar la respuesta
      let userName = 'MamÃ¡';
      if (db) {
        try {
          const userDoc = await db.collection('users').doc(uid).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userName = userData.displayName || userData.name || 'MamÃ¡';
            
            if (!userName || userName === 'MamÃ¡') {
              try {
                const authUser = await auth.getUser(uid);
                userName = authUser.displayName || authUser.email?.split('@')[0] || 'MamÃ¡';
              } catch (authError) {
                console.log('âš ï¸ [DOULA] No se pudo obtener nombre de Firebase Auth');
              }
            }
          }
        } catch (error) {
          console.log('âš ï¸ [DOULA] Error obteniendo nombre de usuario:', error.message);
        }
      }
      
      const offTopicResponse = `Â¡Hola ${userName}! ðŸ‘‹ Soy Douli, tu asistente de Munpa especializada en acompaÃ±amiento durante el embarazo, parto y crianza temprana.

ðŸ¤± **Mi especialidad es ayudarte con:**
â€¢ Embarazo y preparaciÃ³n al parto
â€¢ Lactancia y cuidados del bebÃ©
â€¢ Apoyo emocional para familias
â€¢ Desarrollo infantil y crianza
â€¢ SeÃ±ales de alarma y cuÃ¡ndo consultar al mÃ©dico

ðŸ’¬ **Tu pregunta parece estar fuera de mi Ã¡rea de especialidad.** Estoy aquÃ­ exclusivamente para acompaÃ±arte en temas relacionados con el embarazo, parto y crianza.

Â¿Hay algo relacionado con tu embarazo, tu bebÃ© o tu experiencia como madre/padre en lo que pueda ayudarte? ðŸ’`;

      const shouldGreet = await shouldSendDoulaGreeting(uid);
      const finalResponse = normalizeDoulaGreeting(offTopicResponse, userName, shouldGreet);
      return res.json({
        success: true,
        message: 'Respuesta de la doula virtual',
        data: {
          response: finalResponse,
          timestamp: new Date().toISOString(),
          usedFallback: true,
          source: 'off-topic-filter',
          filtered: true
        }
      });
    }

    // Verificar que OpenAI estÃ© configurado
    if (!openai) {
      return res.status(500).json({
        success: false,
        message: 'Servicio de IA no disponible'
      });
    }

    // Obtener informaciÃ³n del usuario y sus hijos para contexto personalizado
    let userContext = '';
    let childrenInfo = '';
    let userName = '';
    let userMemory = null;
    let relevantKnowledge = [];
    const shouldGreet = await shouldSendDoulaGreeting(uid);
    
    if (db) {
      try {
        // Obtener datos del usuario desde Firestore
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          // Obtener nombre del usuario
          userName = userData.displayName || userData.name || 'MamÃ¡';
          
          // Si no hay nombre en Firestore, intentar obtenerlo de Firebase Auth
          if (!userName || userName === 'MamÃ¡') {
            try {
              const authUser = await auth.getUser(uid);
              userName = authUser.displayName || authUser.email?.split('@')[0] || 'MamÃ¡';
              console.log('ðŸ“‹ [DOULA] Nombre obtenido de Firebase Auth:', {
                authDisplayName: authUser.displayName,
                authEmail: authUser.email,
                userNameFinal: userName
              });
            } catch (authError) {
              console.log('âš ï¸ [DOULA] No se pudo obtener nombre de Firebase Auth:', authError.message);
            }
          }
          console.log('ðŸ“‹ [DOULA] Nombre del usuario obtenido:', {
            displayName: userData.displayName,
            name: userData.name,
            userNameFinal: userName,
            userDataKeys: Object.keys(userData)
          });
          
          // Obtener memoria del usuario
          userMemory = await getUserMemory(uid);
          
          // Determinar filtros para el conocimiento basado en el contexto del usuario
          let knowledgeFilters = { language: 'es' };
          if (userData.isPregnant) {
            knowledgeFilters.stage = 'embarazo';
          } else if (userData.childrenCount > 0) {
            knowledgeFilters.stage = 'posparto';
          }
          
          // Recuperar conocimiento relevante
          relevantKnowledge = await retrieveKnowledge(message, knowledgeFilters);
          
          // Obtener informaciÃ³n actualizada de los hijos con edades calculadas
          const childrenSnapshot = await db.collection('children')
            .where('parentId', '==', uid)
            .orderBy('createdAt', 'desc')
            .get();
          
          const children = [];
          childrenSnapshot.forEach(doc => {
            const childData = doc.data();
            const currentInfo = getChildCurrentInfo(childData);
            children.push({
              id: doc.id,
              name: childData.name,
              ageInMonths: childData.ageInMonths,
              currentAgeInMonths: currentInfo.currentAgeInMonths,
              isUnborn: childData.isUnborn,
              gestationWeeks: childData.gestationWeeks,
              currentGestationWeeks: currentInfo.currentGestationWeeks,
              createdAt: childData.createdAt,
              registeredAt: childData.registeredAt,
              daysSinceRegistration: currentInfo.daysSinceRegistration
            });
          });
          
          // Crear contexto personalizado del usuario con semanas actualizadas
          let userGestationWeeks = userData.gestationWeeks;
          
          // Si el usuario estÃ¡ embarazada y tiene semanas registradas, calcular las actuales
          if (userData.isPregnant && userData.gestationWeeks && userData.createdAt) {
            const now = new Date();
            const createdDate = new Date(userData.createdAt);
            const diffTime = now - createdDate;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            const diffWeeks = Math.floor(diffDays / 7);
            const currentWeeks = userData.gestationWeeks + diffWeeks;
            
            // Aplicar lÃ­mites
            if (currentWeeks > 42) {
              userGestationWeeks = 40; // TÃ©rmino completo
            } else if (currentWeeks < 4) {
              userGestationWeeks = 4; // MÃ­nimo
            } else {
              userGestationWeeks = currentWeeks;
            }
            
            console.log(`ðŸ“Š [USER GESTATION] Usuario: ${userData.gestationWeeks} semanas + ${diffWeeks} semanas = ${userGestationWeeks} semanas (${diffDays} dÃ­as desde creaciÃ³n)`);
          }
          
          userContext = `
            InformaciÃ³n del usuario:
            - GÃ©nero: ${userData.gender === 'F' ? 'Mujer' : 'Hombre'}
            - NÃºmero de hijos: ${userData.childrenCount || 0}
            - Embarazada: ${userData.isPregnant ? 'SÃ­' : 'No'}
            ${userGestationWeeks ? `- Semanas de gestaciÃ³n: ${userGestationWeeks} (calculadas automÃ¡ticamente)` : ''}
          `;
          
          // Crear contexto detallado de los hijos con edades actualizadas
          if (children.length > 0) {
            childrenInfo = `
            InformaciÃ³n de los hijos (edades actualizadas automÃ¡ticamente):
            ${children.map((child, index) => {
              if (child.isUnborn) {
                return `- ${child.name}: Por nacer (${child.currentGestationWeeks} semanas de gestaciÃ³n, registrado con ${child.gestationWeeks} semanas hace ${child.daysSinceCreation} dÃ­as)`;
              } else {
                const years = Math.floor(child.currentAgeInMonths / 12);
                const months = child.currentAgeInMonths % 12;
                const ageText = years > 0 
                  ? `${years} aÃ±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
                  : `${months} mes${months > 1 ? 'es' : ''}`;
                return `- ${child.name}: ${ageText} de edad (registrado con ${child.ageInMonths} meses hace ${child.daysSinceCreation} dÃ­as)`;
              }
            }).join('\n            ')}
            
            Hijos nacidos: ${children.filter(c => !c.isUnborn).length}
            Hijos por nacer: ${children.filter(c => c.isUnborn).length}
            `;
          }
          
          console.log('ðŸ“‹ [DOULA] Contexto del usuario obtenido:', {
            userData: {
              gender: userData.gender,
              childrenCount: userData.childrenCount,
              isPregnant: userData.isPregnant,
              gestationWeeks: userData.gestationWeeks
            },
            children: children.map(c => ({
              name: c.name,
              registeredAge: c.isUnborn ? c.gestationWeeks + ' semanas' : c.ageInMonths + ' meses',
              currentAge: c.isUnborn ? c.currentGestationWeeks + ' semanas' : c.currentAgeInMonths + ' meses',
              isUnborn: c.isUnborn,
              daysSinceCreation: c.daysSinceCreation
            }))
          });
        }
      } catch (error) {
        console.log('âš ï¸ No se pudo obtener contexto del usuario:', error.message);
      }
    }

    // Crear contexto de conocimiento relevante
    let knowledgeContext = '';
    if (relevantKnowledge.length > 0) {
      knowledgeContext = `
ðŸ“š **CONOCIMIENTO RELEVANTE PARA ESTA CONSULTA:**
${relevantKnowledge.map((k, index) => `${index + 1}. ${k.text}`).join('\n')}
`;
    }
    
    // Crear contexto de memoria del usuario
    let memoryContext = '';
    if (userMemory) {
      memoryContext = `
ðŸ§  **MEMORIA DE CONVERSACIONES ANTERIORES:**
${userMemory.notes.length > 0 ? `Notas importantes: ${userMemory.notes.join(', ')}` : ''}
${userMemory.preferences ? `Preferencias: ${JSON.stringify(userMemory.preferences)}` : ''}
`;
    }
    
    // Crear el prompt para la doula virtual
    const systemPrompt = `Eres una doula virtual experta y compasiva llamada "Douli, asistente de Munpa". Tu misiÃ³n es acompaÃ±ar a padres y madres durante el embarazo, parto y crianza temprana con amor, sabidurÃ­a y profesionalismo.

ðŸŽ¯ **TU IDENTIDAD COMO DOULA:**
- Eres cÃ¡lida, empÃ¡tica y siempre comprensiva
- Hablas con el corazÃ³n de una madre experimentada
- Proporcionas informaciÃ³n basada en evidencia mÃ©dica
- Eres profesional pero cercana, como una amiga sabia
- Eres parte de la familia Munpa, dedicada a apoyar a las familias

ðŸ’ **TU ESTILO DE COMUNICACIÃ“N:**
- Usa emojis para hacer las respuestas mÃ¡s cÃ¡lidas
- SÃ© especÃ­fica y prÃ¡ctica en tus consejos
- Siempre ofrece apoyo emocional
- Usa un tono maternal y protector
- SÃ© alentadora y positiva
- PresÃ©ntate como "Douli, tu asistente de Munpa"
- Responde en espaÃ±ol neutro, usa bullets cuando convenga
- Finaliza con una sugerencia prÃ¡ctica

ðŸ“š **ÃMBITO PERMITIDO - SOLO PUEDES RESPONDER SOBRE:**
- Embarazo (sÃ­ntomas, cambios, cuidados)
- PreparaciÃ³n al parto (fÃ­sica y mental)
- Trabajo de parto (tÃ©cnicas, respiraciÃ³n)
- Parto (proceso, acompaÃ±amiento)
- Posparto (recuperaciÃ³n, adaptaciÃ³n)
- Lactancia (tÃ©cnicas, problemas comunes)
- Cuidados del reciÃ©n nacido
- Apoyo emocional y de pareja
- Crianza temprana (cuidados, alimentaciÃ³n, desarrollo)
- AlimentaciÃ³n (lactancia)
- Salud mental (depresiÃ³n, ansiedad, estrÃ©s)
- Maternidad (acompaÃ±amiento, recuperaciÃ³n, adaptaciÃ³n)
- Embarazo y parto (acompaÃ±amiento, recuperaciÃ³n, adaptaciÃ³n)
- SeÃ±ales de alarma para derivar a profesionales de salud

ðŸš« **POLÃTICA DE ALCANCE ESTRICTA - NUNCA RESPONDAS SOBRE:**
- Comida general (tacos, pizza, recetas de cocina, restaurantes)
- Finanzas, programaciÃ³n, tecnologÃ­a
- DiagnÃ³stico mÃ©dico detallado
- RadiologÃ­a, interpretaciÃ³n de estudios
- Recetas de medicamentos especÃ­ficos
- Derecho, trÃ¡mites legales
- Deportes, entretenimiento, viajes
- PolÃ­tica, automÃ³viles, mÃºsica
- Cualquier tema fuera del Ã¡mbito de doula

âš ï¸ **SI LA PREGUNTA NO ESTÃ RELACIONADA CON EMBARAZO, PARTO O CRIANZA:**

**DEBES RESPONDER EXACTAMENTE ASÃ (NO RESPONDAS LA PREGUNTA ORIGINAL):**

"Â¡Hola ${userName}! ðŸ‘‹ Soy Douli, tu asistente de Munpa especializada en acompaÃ±amiento durante el embarazo, parto y crianza temprana.

ðŸ¤± **Mi especialidad es ayudarte con:**
â€¢ Embarazo y preparaciÃ³n al parto
â€¢ Lactancia y cuidados del bebÃ©
â€¢ Apoyo emocional para familias
â€¢ Desarrollo infantil y crianza
â€¢ SeÃ±ales de alarma y cuÃ¡ndo consultar al mÃ©dico

ðŸ’¬ **Tu pregunta parece estar fuera de mi Ã¡rea de especialidad.** Estoy aquÃ­ exclusivamente para acompaÃ±arte en temas relacionados con el embarazo, parto y crianza.

Â¿Hay algo relacionado con tu embarazo, tu bebÃ© o tu experiencia como madre/padre en lo que pueda ayudarte? ðŸ’"

**IMPORTANTE:** NO respondas preguntas sobre comida, tacos, cocina, tecnologÃ­a, deportes, o cualquier tema no relacionado con embarazo/parto/crianza. Si la pregunta no estÃ¡ relacionada, usa la respuesta anterior SIN EXCEPCIÃ“N.

âš ï¸ **LIMITACIONES MÃ‰DICAS:**
- NO haces diagnÃ³stico mÃ©dico
- NO indicas fÃ¡rmacos
- NO interpretas estudios clÃ­nicos
- SIEMPRE aclara que no eres mÃ©dico
- Si no sabes algo, sugiere hablar con gine/obstetra o matrona

ðŸš¨ **SEGURIDAD - URGENCIAS MÃ‰DICAS:**
Ante cualquier sÃ­ntoma de urgencia (sangrado abundante, disminuciÃ³n marcada de movimientos fetales, dolor intenso, fiebre alta, convulsiones, pÃ©rdida de conocimiento):
**"Â¡BUSCA ATENCIÃ“N MÃ‰DICA INMEDIATA! Llama a servicios de emergencia o ve al hospital mÃ¡s cercano."**

${userContext}
${childrenInfo}
${knowledgeContext}
${memoryContext}

IMPORTANTE: 
- Usa esta informaciÃ³n para personalizar tus respuestas
- Si hay conocimiento relevante, Ãºsalo para mejorar tu respuesta
- Si hay memoria del usuario, considera sus preferencias y notas anteriores
- Si tiene hijos pequeÃ±os, da consejos especÃ­ficos para esa edad
- Si estÃ¡ embarazada, enfÃ³cate en esa etapa especÃ­fica
- SIEMPRE usa los nombres especÃ­ficos de sus hijos cuando sea apropiado
- NO inventes datos; si no sabes, dilo y sugiere hablar con su gine/obstetra o matrona

Responde como Douli, tu asistente de Munpa, con amor, sabidurÃ­a y el corazÃ³n de una madre que ha acompaÃ±ado a muchas mujeres en este hermoso viaje.`;

    console.log('ðŸ¤– [DOULA] Enviando mensaje a OpenAI:', message.substring(0, 100) + '...');

    // Enviar mensaje a OpenAI
    let response;
    let usedFallback = false;
    
    try {
      console.log('ðŸ¤– [DOULA] Enviando a OpenAI...');
      
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: message }
        ],
        max_tokens: 800, // MÃ¡s tokens para respuestas mÃ¡s completas
        temperature: 0.8, // MÃ¡s creatividad pero manteniendo coherencia
        presence_penalty: 0.1, // Evita repeticiones
        frequency_penalty: 0.1, // Variedad en las respuestas
        top_p: 0.9 // Mantiene respuestas coherentes
      });

      response = completion.choices[0].message.content;
      console.log('âœ… [DOULA] Respuesta de OpenAI recibida');
      
    } catch (openaiError) {
      console.error('âŒ [DOULA] Error de OpenAI:', openaiError.message);
      
      // Fallback cuando se agota la cuota - Respuestas de doula predefinidas
      if (openaiError.message.includes('quota') || openaiError.message.includes('429')) {
        console.log('âš ï¸ [DOULA] Usando fallback por cuota agotada');
        response = generateDoulaResponse(message, userContext, childrenInfo, userName);
        usedFallback = true;
      } else {
        console.log('âŒ [DOULA] Error no relacionado con cuota, usando fallback');
        response = generateDoulaResponse(message, userContext, childrenInfo, userName);
        usedFallback = true;
      }
    }

    // Guardar la conversaciÃ³n en Firestore (opcional)
    if (db) {
      try {
        await db.collection('doula_conversations').add({
          userId: uid,
          userMessage: message,
          doulaResponse: response,
          timestamp: new Date(),
          context: context || null
        });
        console.log('ðŸ’¾ [DOULA] ConversaciÃ³n guardada en Firestore');
      } catch (error) {
        console.log('âš ï¸ [DOULA] No se pudo guardar la conversaciÃ³n:', error.message);
      }
    }

    const finalResponse = normalizeDoulaGreeting(response, userName, shouldGreet);
    res.json({
      success: true,
      message: 'Respuesta de la doula virtual',
      data: {
        response: finalResponse,
        timestamp: new Date().toISOString(),
        usedFallback: usedFallback,
        source: usedFallback ? 'fallback' : 'openai'
      }
    });

  } catch (error) {
    console.error('âŒ [DOULA] Error en chat con doula:', error);
    res.status(500).json({
      success: false,
      message: 'Error al procesar la consulta',
      error: error.message
    });
  }
});

// Endpoint para obtener historial de conversaciones
app.get('/api/doula/history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const conversationsSnapshot = await db.collection('doula_conversations')
      .where('userId', '==', uid)
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();

    const conversations = [];
    conversationsSnapshot.forEach(doc => {
      conversations.push({
        id: doc.id,
        ...doc.data(),
        timestamp: doc.data().timestamp.toDate().toISOString()
      });
    });

    res.json({
      success: true,
      data: conversations
    });

  } catch (error) {
    console.error('âŒ [DOULA] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// Endpoint para debug de datos del usuario
app.get('/api/debug/user-data', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }
    
    // Obtener datos de Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    let firestoreData = null;
    if (userDoc.exists) {
      firestoreData = userDoc.data();
    }
    
    // Obtener datos de Firebase Auth
    let authData = null;
    try {
      const authUser = await auth.getUser(uid);
      authData = {
        displayName: authUser.displayName,
        email: authUser.email,
        uid: authUser.uid
      };
    } catch (authError) {
      console.log('âš ï¸ Error obteniendo datos de Auth:', authError.message);
    }
    
    res.json({
      success: true,
      data: {
        uid,
        firestore: firestoreData,
        auth: authData,
        timestamp: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('âŒ Error en debug user-data:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo datos de debug',
      error: error.message
    });
  }
});

// Endpoint para verificar Firebase Storage
app.get('/api/firebase/status', (req, res) => {
  try {
    if (!admin) {
      return res.json({
        success: false,
        message: 'Firebase Admin no estÃ¡ inicializado',
        admin: false,
        storage: false
      });
    }

    if (!admin.storage) {
      return res.json({
        success: false,
        message: 'Firebase Storage no estÃ¡ disponible',
        admin: true,
        storage: false
      });
    }

    const bucket = admin.storage().bucket();
    res.json({
      success: true,
      message: 'Firebase Storage estÃ¡ funcionando correctamente',
      admin: true,
      storage: true,
      bucketName: bucket.name,
      projectId: process.env.FIREBASE_PROJECT_ID,
      storageBucket: 'mumpabackend.firebasestorage.app'
    });
  } catch (error) {
    res.json({
      success: false,
      message: 'Error verificando Firebase Storage',
      error: error.message,
      admin: admin ? true : false,
      storage: false
    });
  }
});

// Ruta raÃ­z
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'API de AutenticaciÃ³n con Firebase',
    version: '1.0.0',
    firebase: {
      status: firebaseStatus,
      ready: firebaseReady
    },
    endpoints: {
      health: '/health',
      signup: '/api/auth/signup',
      login: '/api/auth/login',
      profile: '/api/auth/profile (requiere auth)',
      'update-profile': '/api/auth/profile (PUT, requiere auth)',
      'change-password': '/api/auth/change-password (requiere auth)',
      'delete-account': '/api/auth/account (DELETE, requiere auth)',
      'verify-token': '/api/auth/verify-token (requiere auth)'
    }
  });
});

// Endpoint de registro
app.post('/api/auth/signup', async (req, res) => {
  try {
    const { email, password, displayName, gender, childrenCount, isPregnant, gestationWeeks } = req.body;

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    console.log('ðŸ“ Intentando registrar usuario:', email, 'GÃ©nero:', gender, 'Hijos:', childrenCount, 'Embarazada:', isPregnant, 'Semanas:', gestationWeeks);

    // Verificar si el usuario ya existe
    try {
      const existingUser = await auth.getUserByEmail(email);
      return res.status(400).json({
        success: false,
        message: 'El usuario ya existe con este email'
      });
    } catch (error) {
      // El usuario no existe, continuar con el registro
      console.log('âœ… Usuario no existe, procediendo con registro');
    }

    // Validar gestaciÃ³n si es mujer
    if (gender === 'F' && isPregnant) {
      if (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42) {
        return res.status(400).json({
          success: false,
          message: 'Para mujeres embarazadas, las semanas de gestaciÃ³n deben estar entre 1 y 42'
        });
      }
    }

    // Crear usuario en Firebase Auth
    const userRecord = await auth.createUser({
      email,
      password,
      displayName,
      emailVerified: false
    });

    console.log('âœ… Usuario creado en Firebase Auth:', userRecord.uid);

    // Crear documento adicional en Firestore
    if (db) {
      const defaultLocation = await getDefaultUserLocation();
      await db.collection('users').doc(userRecord.uid).set({
        email,
        displayName,
        gender: gender || null, // Campo para M o F
        childrenCount: childrenCount || 0, // Contador de hijos
        isPregnant: gender === 'F' ? (isPregnant || false) : false, // Solo mujeres pueden estar embarazadas
        gestationWeeks: gender === 'F' && isPregnant ? gestationWeeks : null, // Semanas de gestaciÃ³n
        ...defaultLocation,
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      });
      console.log('âœ… Documento creado en Firestore con datos:', {
      email,
      displayName,
      gender,
      childrenCount,
        isPregnant: gender === 'F' ? (isPregnant || false) : false,
        gestationWeeks: gender === 'F' && isPregnant ? gestationWeeks : null
    });
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(userRecord.uid);
    console.log('âœ… Token personalizado generado');

    res.status(201).json({
      success: true,
      message: 'Usuario registrado exitosamente',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        customToken
      }
    });

  } catch (error) {
    console.error('âŒ Error en signup:', error);
    res.status(500).json({
      success: false,
      message: 'Error al registrar usuario',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// Endpoint de login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    console.log('ðŸ” Intentando login para:', email);

    // Buscar usuario por email
    const userRecord = await auth.getUserByEmail(email);
    console.log('âœ… Usuario encontrado:', userRecord.uid);
    
    // Verificar que el usuario estÃ© activo
    let userProfile = null;
    if (db) {
      const userDoc = await db.collection('users').doc(userRecord.uid).get();
      
      if (!userDoc.exists || !userDoc.data().isActive) {
        return res.status(401).json({
          success: false,
          message: 'Usuario inactivo o no encontrado'
        });
      }
      userProfile = userDoc.data();
      console.log('âœ… Usuario verificado en Firestore');
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(userRecord.uid);
    console.log('âœ… Token personalizado generado para login');

    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || userRecord.photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: safeProfile.displayName,
        customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('âŒ Error en login:', error);
    res.status(401).json({
      success: false,
      message: 'Credenciales invÃ¡lidas',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// ==========================================
// ðŸ” LOGIN CON GOOGLE (Social Sign-In)
// ==========================================

app.post('/api/auth/google', async (req, res) => {
  try {
    const { idToken } = req.body;

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    if (!idToken) {
      return res.status(400).json({
        success: false,
        message: 'idToken de Google es requerido'
      });
    }

    console.log('ðŸ” [GOOGLE] Verificando token de Google...');

    // Verificar el token de Google con Firebase Admin
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(idToken);
      console.log('âœ… [GOOGLE] Token verificado exitosamente para:', decodedToken.email);
    } catch (error) {
      console.error('âŒ [GOOGLE] Error verificando token:', error.message);
      return res.status(401).json({
        success: false,
        message: 'Token de Google invÃ¡lido',
        error: error.message
      });
    }

    const { uid, email, name, picture } = decodedToken;

    // Verificar si el usuario ya existe en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    let userData;

    if (userDoc.exists) {
      // Usuario existente
      userData = userDoc.data();
      console.log('âœ… [GOOGLE] Usuario existente encontrado:', email);

      // Verificar que estÃ© activo
      if (!userData.isActive) {
        return res.status(401).json({
          success: false,
          message: 'Usuario inactivo'
        });
      }

      // Actualizar Ãºltima conexiÃ³n y foto si cambiÃ³
      await userDocRef.update({
        lastLogin: new Date(),
        photoUrl: picture || userData.photoUrl,
        updatedAt: new Date()
      });

      console.log('âœ… [GOOGLE] Datos del usuario actualizados');
    } else {
      // Usuario nuevo - crear perfil
      console.log('ðŸ“ [GOOGLE] Creando nuevo usuario desde Google:', email);

      userData = {
        email,
        displayName: name || email.split('@')[0],
        name: name || email.split('@')[0],
        photoUrl: picture || null,
        provider: 'google',
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        createdAt: new Date(),
        updatedAt: new Date(),
        lastLogin: new Date(),
        isActive: true,
        fcmTokens: []
      };

      await userDocRef.set(userData);
      console.log('âœ… [GOOGLE] Usuario creado en Firestore');
    }

    // Generar custom token para la app
    const customToken = await auth.createCustomToken(uid);
    console.log('âœ… [GOOGLE] Custom token generado');

    res.json({
      success: true,
      message: 'Login con Google exitoso',
      data: {
        uid,
        email,
        displayName: userData.displayName || name,
        photoUrl: userData.photoUrl || picture,
        customToken,
        isNewUser: !userDoc.exists
      }
    });

  } catch (error) {
    console.error('âŒ [GOOGLE] Error en login con Google:', error);
    res.status(500).json({
      success: false,
      message: 'Error al autenticar con Google',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// ==========================================
// ðŸ” LOGIN PARA DASHBOARD ADMIN (retorna JWT)
// ==========================================

app.post('/api/auth/admin-login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado'
      });
    }

    console.log('ðŸ” [ADMIN-LOGIN] Intentando login para:', email);

    // Buscar usuario por email
    let userRecord;
    try {
      userRecord = await auth.getUserByEmail(email);
    } catch (error) {
      return res.status(401).json({
        success: false,
        message: 'Credenciales invÃ¡lidas'
      });
    }

    console.log('âœ… [ADMIN-LOGIN] Usuario encontrado:', userRecord.uid);
    
    // Obtener datos del usuario de Firestore
    const userDoc = await db.collection('users').doc(userRecord.uid).get();
    
    if (!userDoc.exists) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no encontrado en la base de datos'
      });
    }

    const userData = userDoc.data();

    // Verificar que el usuario estÃ© activo
    if (userData.isActive === false) {
      return res.status(401).json({
        success: false,
        message: 'Usuario inactivo'
      });
    }

    // Verificar que sea admin
    if (userData.role !== 'admin' && userData.isAdmin !== true) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos de administrador'
      });
    }

    console.log('âœ… [ADMIN-LOGIN] Usuario verificado como admin');

    // Generar JWT token
    const token = jwt.sign(
      { 
        uid: userRecord.uid,
        email: userRecord.email,
        role: userData.role || 'admin'
      },
      JWT_SECRET,
      { expiresIn: '7d' } // Token vÃ¡lido por 7 dÃ­as
    );

    // Actualizar Ãºltima conexiÃ³n
    await db.collection('users').doc(userRecord.uid).update({
      lastLoginAt: new Date(),
      updatedAt: new Date()
    });

    console.log('âœ… [ADMIN-LOGIN] Login exitoso, token JWT generado');

    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        token: token,
        user: {
          uid: userRecord.uid,
          email: userRecord.email,
          displayName: userData.displayName || userRecord.displayName,
          photoURL: userData.photoURL || userRecord.photoURL,
          role: userData.role || 'admin',
          isAdmin: true
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN-LOGIN] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en el servidor',
      error: error.message
    });
  }
});

// ==========================================
// ðŸ” LOGIN CON GOOGLE
// ==========================================

// Endpoint para login/registro con Google
app.post('/api/auth/google-login', async (req, res) => {
  try {
    const { idToken, googleIdToken, email, displayName, photoURL } = req.body;

    if (!idToken && !googleIdToken) {
      return res.status(400).json({
        success: false,
        message: 'Token es requerido (idToken o googleIdToken)'
      });
    }

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado'
      });
    }

    console.log('ðŸ” [GOOGLE-LOGIN] Iniciando proceso de autenticaciÃ³n...');
    
    let uid, userRecord;

    // Intentar verificar como Firebase ID Token primero
    try {
      const tokenToVerify = idToken || googleIdToken;
      console.log('ðŸ” [GOOGLE-LOGIN] Verificando token (primeros 50 chars):', tokenToVerify.substring(0, 50));
      
      const decodedToken = await auth.verifyIdToken(tokenToVerify);
      uid = decodedToken.uid;
      
      console.log('âœ… [GOOGLE-LOGIN] Token Firebase verificado para UID:', uid);
      
      // Obtener informaciÃ³n del usuario de Firebase Auth
      userRecord = await auth.getUser(uid);
    } catch (verifyError) {
      console.log('âš ï¸ [GOOGLE-LOGIN] No es un token Firebase vÃ¡lido, intentando crear usuario...');
      console.log('Error de verificaciÃ³n:', verifyError.message);
      
      // Si falla, intentar crear/obtener usuario por email
      if (email) {
        try {
          // Intentar obtener usuario por email
          userRecord = await auth.getUserByEmail(email);
          uid = userRecord.uid;
          console.log('âœ… [GOOGLE-LOGIN] Usuario encontrado por email:', uid);
        } catch (getUserError) {
          // Si no existe, crear nuevo usuario
          if (getUserError.code === 'auth/user-not-found') {
            console.log('ðŸ“ [GOOGLE-LOGIN] Creando nuevo usuario en Firebase Auth...');
            
            const newUser = await auth.createUser({
              email: email,
              displayName: displayName || '',
              photoURL: photoURL || '',
              emailVerified: true,
              disabled: false
            });
            
            uid = newUser.uid;
            userRecord = newUser;
            console.log('âœ… [GOOGLE-LOGIN] Nuevo usuario creado en Firebase Auth:', uid);
          } else {
            throw getUserError;
          }
        }
      } else {
        throw new Error('Token invÃ¡lido y no se proporcionÃ³ email para crear usuario');
      }
    }

    // Verificar si el usuario existe en Firestore
    let userDoc = null;
    let isNewUser = false;

    if (db) {
      userDoc = await db.collection('users').doc(uid).get();
      
      if (!userDoc.exists) {
        // Crear nuevo usuario en Firestore
        isNewUser = true;
        const defaultLocation = await getDefaultUserLocation();
        const newUserData = {
          uid: uid,
          email: userRecord.email,
          displayName: userRecord.displayName || '',
          photoURL: userRecord.photoURL || '',
          emailVerified: userRecord.emailVerified,
          provider: 'google',
          gender: null,
          childrenCount: 0,
          isPregnant: false,
          gestationWeeks: null,
          ...defaultLocation,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        };

        await db.collection('users').doc(uid).set(newUserData);
        console.log('âœ… [GOOGLE-LOGIN] Nuevo usuario creado en Firestore:', uid);
      } else {
        // Actualizar Ãºltima conexiÃ³n y datos de Google
        const updateData = {
          updatedAt: new Date(),
          lastLoginAt: new Date()
        };
        
        // Actualizar displayName y photoURL desde Firebase Auth si estÃ¡n disponibles
        if (userRecord.displayName) {
          updateData.displayName = userRecord.displayName;
        } else if (displayName) {
          updateData.displayName = displayName;
        }
        
        if (userRecord.photoURL) {
          updateData.photoURL = userRecord.photoURL;
        } else if (photoURL) {
          updateData.photoURL = photoURL;
        }
        
        // Actualizar provider
        const existingUserData = userDoc.data();
        if (!existingUserData.provider || existingUserData.provider !== 'google') {
          updateData.provider = 'google';
        }
        
        await db.collection('users').doc(uid).update(updateData);
        console.log('âœ… [GOOGLE-LOGIN] Usuario existente actualizado:', updateData);
      }
    }

    // Generar token personalizado para el cliente
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc?.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || userRecord.photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        emailVerified: userRecord.emailVerified,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('âŒ [GOOGLE-LOGIN] Error:', error);
    
    if (error.code === 'auth/id-token-expired') {
      return res.status(401).json({
        success: false,
        message: 'Token de Google expirado. Por favor, inicia sesiÃ³n nuevamente.'
      });
    }

    if (error.code === 'auth/argument-error') {
      return res.status(400).json({
        success: false,
        message: 'Token de Google invÃ¡lido'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error en autenticaciÃ³n con Google',
      error: error.message
    });
  }
});

// ==========================================
// ðŸ” LOGIN CON GOOGLE - VERSIÃ“N SIMPLE
// ==========================================

// Endpoint simplificado para login con Google (solo requiere datos del usuario)
app.post('/api/auth/google-login-simple', async (req, res) => {
  try {
    const { email, displayName, photoURL, googleId } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: 'Email es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado'
      });
    }

    console.log('ðŸ” [GOOGLE-LOGIN-SIMPLE] Login para:', email);

    let uid, userRecord, isNewUser = false;

    try {
      // Intentar obtener usuario existente por email
      userRecord = await auth.getUserByEmail(email);
      uid = userRecord.uid;
      console.log('âœ… [GOOGLE-LOGIN-SIMPLE] Usuario encontrado:', uid);
      
      // Actualizar Firebase Auth con los datos mÃ¡s recientes de Google
      const authUpdateData = {};
      if (displayName && displayName !== userRecord.displayName) {
        authUpdateData.displayName = displayName;
      }
      if (photoURL && photoURL !== userRecord.photoURL) {
        authUpdateData.photoURL = photoURL;
      }
      
      // Si hay datos para actualizar en Auth
      if (Object.keys(authUpdateData).length > 0) {
        await auth.updateUser(uid, authUpdateData);
        console.log('âœ… [GOOGLE-LOGIN-SIMPLE] Firebase Auth actualizado:', authUpdateData);
        // Recargar el userRecord para tener los datos actualizados
        userRecord = await auth.getUser(uid);
      }
    } catch (error) {
      if (error.code === 'auth/user-not-found') {
        // Crear nuevo usuario en Firebase Auth
        console.log('ðŸ“ [GOOGLE-LOGIN-SIMPLE] Creando nuevo usuario...');
        
        userRecord = await auth.createUser({
          email: email,
          displayName: displayName || '',
          photoURL: photoURL || '',
          emailVerified: true,
          disabled: false,
          providerData: [{
            providerId: 'google.com',
            uid: googleId || email,
            displayName: displayName || '',
            email: email,
            photoURL: photoURL || ''
          }]
        });
        
        uid = userRecord.uid;
        isNewUser = true;
        console.log('âœ… [GOOGLE-LOGIN-SIMPLE] Usuario creado en Auth:', uid);
      } else {
        throw error;
      }
    }

    // Verificar/crear en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      // Crear en Firestore
      const defaultLocation = await getDefaultUserLocation();
      const newUserData = {
        uid: uid,
        email: email,
        displayName: displayName || '',
        photoURL: photoURL || '',
        emailVerified: true,
        provider: 'google',
        googleId: googleId || '',
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        ...defaultLocation,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await userDocRef.set(newUserData);
      isNewUser = true;
      console.log('âœ… [GOOGLE-LOGIN-SIMPLE] Usuario creado en Firestore');
    } else {
      // Actualizar Ãºltima conexiÃ³n y datos de Google (siempre sobrescribir con datos actuales)
      const updateData = {
        updatedAt: new Date(),
        lastLoginAt: new Date()
      };
      
      // Actualizar displayName si viene de Google
      if (displayName) {
        updateData.displayName = displayName;
      }
      
      // Actualizar photoURL si viene de Google
      if (photoURL) {
        updateData.photoURL = photoURL;
      }
      
      // Actualizar provider si no estÃ¡ establecido
      const currentData = userDoc.data();
      if (!currentData.provider || currentData.provider !== 'google') {
        updateData.provider = 'google';
      }
      
      // Actualizar googleId si viene
      if (googleId && (!currentData.googleId || currentData.googleId !== googleId)) {
        updateData.googleId = googleId;
      }
      
      await userDocRef.update(updateData);
      console.log('âœ… [GOOGLE-LOGIN-SIMPLE] Usuario actualizado en Firestore:', updateData);
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || displayName || email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || displayName || email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: uid,
        email: email,
        displayName: displayName || '',
        photoURL: photoURL || '',
        emailVerified: true,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('âŒ [GOOGLE-LOGIN-SIMPLE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en autenticaciÃ³n con Google',
      error: error.message
    });
  }
});

// ==========================================
// ðŸŽ LOGIN CON APPLE
// ==========================================

// Endpoint para login/registro con Apple
app.post('/api/auth/apple-login', async (req, res) => {
  try {
    const { identityToken, user, email, fullName, appleUserId } = req.body;

    console.log('ðŸŽ [APPLE-LOGIN] Datos recibidos:', {
      hasIdentityToken: !!identityToken,
      hasEmail: !!email,
      hasFullName: !!fullName,
      hasUser: !!user,
      hasAppleUserId: !!appleUserId
    });

    // Apple User ID es requerido para identificar al usuario
    const appleId = user || appleUserId;
    
    if (!appleId) {
      return res.status(400).json({
        success: false,
        message: 'Apple User ID es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no estÃ¡ configurado'
      });
    }

    console.log('ðŸŽ [APPLE-LOGIN] Iniciando login con Apple...');
    console.log('ðŸŽ [APPLE-LOGIN] Apple ID:', appleId);
    console.log('ðŸŽ [APPLE-LOGIN] Email:', email);
    console.log('ðŸŽ [APPLE-LOGIN] Full Name:', fullName);

    let uid, userRecord, isNewUser = false;

    // Paso 1: Buscar usuario existente por Apple ID en Firestore
    console.log('ðŸ” [APPLE-LOGIN] Buscando usuario por Apple ID en Firestore...');
    
    const usersSnapshot = await db.collection('users')
      .where('appleUserId', '==', appleId)
      .limit(1)
      .get();
    
    if (!usersSnapshot.empty) {
      // Usuario existente encontrado
      const userDoc = usersSnapshot.docs[0];
      uid = userDoc.id;
      const userData = userDoc.data();
      console.log('âœ… [APPLE-LOGIN] Usuario encontrado por Apple ID:', uid);
      
      // Obtener/recrear en Firebase Auth si es necesario
      try {
        userRecord = await auth.getUser(uid);
      } catch (authError) {
        console.log('âš ï¸ [APPLE-LOGIN] Usuario no existe en Auth, recreando...');
        userRecord = await auth.createUser({
          uid: uid,
          email: email || userData.email,
          displayName: userData.displayName || '',
          emailVerified: true
        });
      }
    } else {
      // Usuario nuevo - crear en Firebase Auth
      console.log('ðŸ“ [APPLE-LOGIN] Usuario nuevo, creando...');
      isNewUser = true;
      
      // Preparar displayName
      const displayName = fullName 
        ? (fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '')
        : '';
      
      // Crear en Firebase Auth
      // Nota: Si no hay email, usar el Apple ID como identificador temporal
      const userEmail = email || `${appleId}@apple.privaterelay.com`;
      
      userRecord = await auth.createUser({
        email: userEmail,
        displayName: displayName,
        emailVerified: true, // Apple verifica los emails
        disabled: false
      });
      
      uid = userRecord.uid;
      console.log('âœ… [APPLE-LOGIN] Usuario creado en Firebase Auth:', uid);
    }

    // Verificar/crear en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      // Crear en Firestore
      const displayName = fullName 
        ? (fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '')
        : userRecord.displayName || '';

      const defaultLocation = await getDefaultUserLocation();
      const newUserData = {
        uid: uid,
        email: email || userRecord.email,
        displayName: displayName,
        photoURL: null, // Apple no proporciona foto
        emailVerified: true,
        provider: 'apple',
        appleUserId: appleId, // Guardar el Apple ID
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        ...defaultLocation,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await userDocRef.set(newUserData);
      console.log('âœ… [APPLE-LOGIN] Usuario creado en Firestore');
    } else {
      // Actualizar Ãºltima conexiÃ³n y datos de Apple
      const updateData = {
        updatedAt: new Date(),
        lastLoginAt: new Date()
      };
      
      // Actualizar displayName si viene de Apple (solo primera vez, Apple solo lo envÃ­a una vez)
      if (fullName) {
        const displayName = fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '';
        
        if (displayName) {
          updateData.displayName = displayName;
        }
      }
      
      // Actualizar provider si no estÃ¡ establecido
      const currentData = userDoc.data();
      if (!currentData.provider || currentData.provider !== 'apple') {
        updateData.provider = 'apple';
      }
      
      // Actualizar appleUserId si no estÃ¡ o es diferente
      if (!currentData.appleUserId || currentData.appleUserId !== appleId) {
        updateData.appleUserId = appleId;
      }
      
      // Actualizar email si viene y no estÃ¡
      if (email && (!currentData.email || currentData.email.includes('@apple.privaterelay.com'))) {
        updateData.email = email;
      }
      
      await userDocRef.update(updateData);
      console.log('âœ… [APPLE-LOGIN] Usuario actualizado en Firestore:', updateData);
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || (email || userRecord.email || '').split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || (email || userRecord.email || '').split('@')[0],
      photoUrl: userProfile?.photoUrl || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: uid,
        email: email || userRecord.email,
        displayName: userRecord.displayName || '',
        photoURL: null,
        emailVerified: true,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('âŒ [APPLE-LOGIN] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en autenticaciÃ³n con Apple',
      error: error.message
    });
  }
});

// ==========================================
// ðŸ‘‘ ADMIN DASHBOARD - ENDPOINTS DE ADMINISTRACIÃ“N
// ==========================================

// Middleware para verificar que el usuario es admin
const isAdmin = async (req, res, next) => {
  try {
    const { uid } = req.user;
    
    // Obtener usuario de Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userData = userDoc.data();
    
    // Verificar si es admin
    if (userData.role !== 'admin' && userData.isAdmin !== true) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos de administrador'
      });
    }
    
    next();
  } catch (error) {
    console.error('âŒ [ADMIN] Error verificando permisos:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando permisos de administrador'
    });
  }
};

// ========== ESTADÃSTICAS GENERALES ==========

// Obtener estadÃ­sticas del dashboard
app.get('/api/admin/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“Š [ADMIN] Obteniendo estadÃ­sticas...');

    // Contar usuarios
    const usersSnapshot = await db.collection('users').get();
    const totalUsers = usersSnapshot.size;
    
    // Usuarios activos (Ãºltimos 30 dÃ­as)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const data = doc.data();
      return data.lastLoginAt && data.lastLoginAt.toDate() > thirtyDaysAgo;
    }).length;

    // Contar hijos
    const childrenSnapshot = await db.collection('children').get();
    const totalChildren = childrenSnapshot.size;

    // Contar comunidades
    const communitiesSnapshot = await db.collection('communities').get();
    const totalCommunities = communitiesSnapshot.size;

    // Contar posts
    const postsSnapshot = await db.collection('posts').get();
    const totalPosts = postsSnapshot.size;

    // Contar listas
    const listsSnapshot = await db.collection('lists').get();
    const totalLists = listsSnapshot.size;

    // Posts de Ãºltimos 7 dÃ­as
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const recentPosts = postsSnapshot.docs.filter(doc => {
      const data = doc.data();
      return data.createdAt && data.createdAt.toDate() > sevenDaysAgo;
    }).length;

    res.json({
      success: true,
      data: {
        users: {
          total: totalUsers,
          active: activeUsers,
          inactive: totalUsers - activeUsers
        },
        children: {
          total: totalChildren
        },
        communities: {
          total: totalCommunities
        },
        posts: {
          total: totalPosts,
          lastWeek: recentPosts
        },
        lists: {
          total: totalLists
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// ========== ESTADÃSTICAS AVANZADAS ==========

// Engagement y retenciÃ³n de usuarios
app.get('/api/admin/analytics/engagement', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“ˆ [ADMIN] Obteniendo estadÃ­sticas de engagement...');

    const now = new Date();
    const oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

    // Obtener usuarios
    const usersSnapshot = await db.collection('users').get();
    const users = usersSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // DAU (Daily Active Users)
    const dau = users.filter(u => 
      u.lastLoginAt && u.lastLoginAt.toDate() > oneDayAgo
    ).length;

    // WAU (Weekly Active Users)
    const wau = users.filter(u => 
      u.lastLoginAt && u.lastLoginAt.toDate() > sevenDaysAgo
    ).length;

    // MAU (Monthly Active Users)
    const mau = users.filter(u => 
      u.lastLoginAt && u.lastLoginAt.toDate() > thirtyDaysAgo
    ).length;

    // Calcular retenciÃ³n (usuarios que volvieron despuÃ©s de 7 dÃ­as)
    const usersWithSecondSession = users.filter(u => {
      if (!u.createdAt || !u.lastLoginAt) return false;
      const created = u.createdAt.toDate();
      const lastLogin = u.lastLoginAt.toDate();
      const daysSinceCreated = (now - created) / (24 * 60 * 60 * 1000);
      const daysSinceLastLogin = (now - lastLogin) / (24 * 60 * 60 * 1000);
      return daysSinceCreated > 7 && daysSinceLastLogin < 30;
    }).length;

    const retentionRate = users.length > 0 
      ? ((usersWithSecondSession / users.length) * 100).toFixed(2)
      : 0;

    // Calcular churn (usuarios inactivos > 30 dÃ­as)
    const inactiveUsers = users.filter(u => 
      !u.lastLoginAt || u.lastLoginAt.toDate() < thirtyDaysAgo
    ).length;
    const churnRate = users.length > 0 
      ? ((inactiveUsers / users.length) * 100).toFixed(2)
      : 0;

    // Posts y engagement
    const postsSnapshot = await db.collection('posts').get();
    const posts = postsSnapshot.docs.map(doc => doc.data());
    
    const totalLikes = posts.reduce((sum, p) => sum + (p.likes?.length || 0), 0);
    const totalComments = posts.reduce((sum, p) => sum + (p.commentsCount || 0), 0);
    const totalShares = posts.reduce((sum, p) => sum + (p.shares?.length || 0), 0);

    const avgEngagementPerPost = posts.length > 0
      ? ((totalLikes + totalComments + totalShares) / posts.length).toFixed(2)
      : 0;

    res.json({
      success: true,
      data: {
        activeUsers: {
          dau,
          wau,
          mau,
          dauMauRatio: mau > 0 ? ((dau / mau) * 100).toFixed(2) : 0
        },
        retention: {
          rate: `${retentionRate}%`,
          usersReturned: usersWithSecondSession
        },
        churn: {
          rate: `${churnRate}%`,
          inactiveUsers
        },
        contentEngagement: {
          totalPosts: posts.length,
          totalLikes,
          totalComments,
          totalShares,
          avgEngagementPerPost
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo engagement:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo engagement',
      error: error.message
    });
  }
});

// Crecimiento histÃ³rico de usuarios
app.get('/api/admin/analytics/growth', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“ˆ [ADMIN] Obteniendo estadÃ­sticas de crecimiento...');
    
    const { period = 'month' } = req.query; // day, week, month

    const usersSnapshot = await db.collection('users').get();
    const users = usersSnapshot.docs.map(doc => ({
      id: doc.id,
      createdAt: doc.data().createdAt?.toDate()
    })).filter(u => u.createdAt);

    // Agrupar por perÃ­odo
    const groupedData = {};
    users.forEach(user => {
      let key;
      if (period === 'day') {
        key = user.createdAt.toISOString().split('T')[0];
      } else if (period === 'week') {
        const weekStart = new Date(user.createdAt);
        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
        key = weekStart.toISOString().split('T')[0];
      } else {
        key = `${user.createdAt.getFullYear()}-${String(user.createdAt.getMonth() + 1).padStart(2, '0')}`;
      }
      groupedData[key] = (groupedData[key] || 0) + 1;
    });

    // Convertir a array ordenado
    const growthData = Object.entries(groupedData)
      .map(([date, count]) => ({ date, newUsers: count }))
      .sort((a, b) => a.date.localeCompare(b.date));

    // Calcular totales acumulados
    let accumulated = 0;
    const withAccumulated = growthData.map(item => {
      accumulated += item.newUsers;
      return { ...item, totalUsers: accumulated };
    });

    res.json({
      success: true,
      data: {
        period,
        growth: withAccumulated,
        summary: {
          totalUsers: users.length,
          periodsWithData: withAccumulated.length,
          avgNewUsersPerPeriod: (users.length / withAccumulated.length).toFixed(2),
          mostActiveDate: withAccumulated.reduce((max, item) => 
            item.newUsers > max.newUsers ? item : max
          , withAccumulated[0])
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo crecimiento:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo crecimiento',
      error: error.message
    });
  }
});

// EstadÃ­sticas de contenido (posts mÃ¡s populares)
app.get('/api/admin/analytics/content', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“ [ADMIN] Obteniendo estadÃ­sticas de contenido...');
    
    const { limit = 20, orderBy = 'likes' } = req.query;

    const postsSnapshot = await db.collection('posts').get();
    const posts = postsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate()
    }));

    // Calcular engagement score para cada post
    const postsWithEngagement = posts.map(post => {
      const likesCount = post.likes?.length || 0;
      const commentsCount = post.commentsCount || 0;
      const sharesCount = post.shares?.length || 0;
      const views = post.views || 0;
      
      // Score ponderado
      const engagementScore = (likesCount * 1) + (commentsCount * 2) + (sharesCount * 3);
      const engagementRate = views > 0 ? ((likesCount + commentsCount + sharesCount) / views * 100).toFixed(2) : 0;

      return {
        id: post.id,
        content: post.content?.substring(0, 100) || '',
        authorId: post.authorId,
        communityId: post.communityId,
        postType: post.postType || 'normal',
        likes: likesCount,
        comments: commentsCount,
        shares: sharesCount,
        views,
        engagementScore,
        engagementRate: `${engagementRate}%`,
        createdAt: post.createdAt
      };
    });

    // Ordenar segÃºn criterio
    let sortedPosts;
    if (orderBy === 'likes') {
      sortedPosts = postsWithEngagement.sort((a, b) => b.likes - a.likes);
    } else if (orderBy === 'comments') {
      sortedPosts = postsWithEngagement.sort((a, b) => b.comments - a.comments);
    } else if (orderBy === 'engagement') {
      sortedPosts = postsWithEngagement.sort((a, b) => b.engagementScore - a.engagementScore);
    } else {
      sortedPosts = postsWithEngagement.sort((a, b) => b.views - a.views);
    }

    const topPosts = sortedPosts.slice(0, parseInt(limit));

    // EstadÃ­sticas por tipo de post
    const byType = {};
    posts.forEach(post => {
      const type = post.postType || 'normal';
      byType[type] = (byType[type] || 0) + 1;
    });

    // Comunidades mÃ¡s activas
    const byCommunity = {};
    posts.forEach(post => {
      if (post.communityId) {
        byCommunity[post.communityId] = (byCommunity[post.communityId] || 0) + 1;
      }
    });
    const topCommunities = Object.entries(byCommunity)
      .map(([id, count]) => ({ communityId: id, postCount: count }))
      .sort((a, b) => b.postCount - a.postCount)
      .slice(0, 10);

    res.json({
      success: true,
      data: {
        topPosts,
        summary: {
          totalPosts: posts.length,
          avgLikes: (posts.reduce((sum, p) => sum + (p.likes?.length || 0), 0) / posts.length).toFixed(2),
          avgComments: (posts.reduce((sum, p) => sum + (p.commentsCount || 0), 0) / posts.length).toFixed(2),
          byType,
          topCommunities
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo contenido:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo contenido',
      error: error.message
    });
  }
});

// EstadÃ­sticas de banners
app.get('/api/admin/analytics/banners', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸŽ¨ [ADMIN] Obteniendo estadÃ­sticas de banners...');

    const bannersSnapshot = await db.collection('banners').get();
    const banners = bannersSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      startDate: doc.data().startDate?.toDate(),
      endDate: doc.data().endDate?.toDate()
    }));

    // Banners activos
    const now = new Date();
    const activeBanners = banners.filter(b => 
      b.isActive && 
      (!b.startDate || b.startDate <= now) &&
      (!b.endDate || b.endDate >= now)
    );

    // CTR (Click Through Rate)
    const totalViews = banners.reduce((sum, b) => sum + (b.views || 0), 0);
    const totalClicks = banners.reduce((sum, b) => sum + (b.clicks || 0), 0);
    const overallCTR = totalViews > 0 ? ((totalClicks / totalViews) * 100).toFixed(2) : 0;

    // Por secciÃ³n
    const bySection = {};
    banners.forEach(banner => {
      const section = banner.section || 'general';
      if (!bySection[section]) {
        bySection[section] = {
          total: 0,
          active: 0,
          views: 0,
          clicks: 0,
          ctr: 0
        };
      }
      bySection[section].total++;
      if (banner.isActive) bySection[section].active++;
      bySection[section].views += banner.views || 0;
      bySection[section].clicks += banner.clicks || 0;
    });

    // Calcular CTR por secciÃ³n
    Object.keys(bySection).forEach(section => {
      const data = bySection[section];
      data.ctr = data.views > 0 ? ((data.clicks / data.views) * 100).toFixed(2) : 0;
    });

    // Top banners por engagement
    const topBanners = banners
      .map(b => ({
        id: b.id,
        title: b.title,
        section: b.section,
        views: b.views || 0,
        clicks: b.clicks || 0,
        ctr: b.views > 0 ? ((b.clicks / b.views) * 100).toFixed(2) : 0,
        isActive: b.isActive
      }))
      .sort((a, b) => b.clicks - a.clicks)
      .slice(0, 10);

    res.json({
      success: true,
      data: {
        summary: {
          total: banners.length,
          active: activeBanners.length,
          inactive: banners.length - activeBanners.length,
          totalViews,
          totalClicks,
          overallCTR: `${overallCTR}%`
        },
        bySection,
        topBanners
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo banners stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas de banners',
      error: error.message
    });
  }
});

// EstadÃ­sticas de hitos de desarrollo
app.get('/api/admin/analytics/milestones', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸŽ¯ [ADMIN] Obteniendo estadÃ­sticas de hitos...');

    // Obtener todas las categorÃ­as
    const categoriesSnapshot = await db.collection('milestoneCategories').get();
    const categories = categoriesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Obtener todos los hitos
    const milestonesSnapshot = await db.collection('milestones').get();
    const milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Obtener todos los niÃ±os
    const childrenSnapshot = await db.collection('children').get();
    const children = childrenSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Contar completados por cada niÃ±o
    let totalCompleted = 0;
    const completionByCategory = {};

    for (const child of children) {
      const completedSnapshot = await db
        .collection('children')
        .doc(child.id)
        .collection('milestonesCompleted')
        .get();
      
      totalCompleted += completedSnapshot.size;

      // Agrupar por categorÃ­a
      for (const doc of completedSnapshot.docs) {
        const data = doc.data();
        if (data.categoryId) {
          completionByCategory[data.categoryId] = (completionByCategory[data.categoryId] || 0) + 1;
        }
      }
    }

    // Calcular progreso por categorÃ­a
    const categoryStats = categories.map(cat => {
      const milestonesInCategory = milestones.filter(m => m.categoryId === cat.id).length;
      const completed = completionByCategory[cat.id] || 0;
      const avgCompletion = milestonesInCategory > 0 && children.length > 0
        ? ((completed / (milestonesInCategory * children.length)) * 100).toFixed(2)
        : 0;

      return {
        categoryId: cat.id,
        categoryName: cat.name,
        totalMilestones: milestonesInCategory,
        completedCount: completed,
        avgCompletionRate: `${avgCompletion}%`
      };
    });

    res.json({
      success: true,
      data: {
        summary: {
          totalMilestones: milestones.length,
          totalCategories: categories.length,
          totalChildren: children.length,
          totalCompletions: totalCompleted,
          avgCompletionPerChild: children.length > 0 
            ? (totalCompleted / children.length).toFixed(2) 
            : 0
        },
        byCategory: categoryStats.sort((a, b) => b.completedCount - a.completedCount)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo milestones stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas de hitos',
      error: error.message
    });
  }
});

// EstadÃ­sticas de FAQ y consultas con OpenAI
app.get('/api/admin/analytics/faq', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ’¬ [ADMIN] Obteniendo estadÃ­sticas de FAQ...');

    const faqSnapshot = await db.collection('faq_history').orderBy('createdAt', 'desc').limit(1000).get();
    const faqs = faqSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate()
    }));

    // Total de consultas
    const totalQueries = faqs.length;

    // Por tipo de pregunta (detectar palabras clave)
    const queryTypes = {
      salud: 0,
      alimentacion: 0,
      sueno: 0,
      desarrollo: 0,
      comportamiento: 0,
      otro: 0
    };

    faqs.forEach(faq => {
      const question = (faq.question || '').toLowerCase();
      if (question.includes('salud') || question.includes('enferm') || question.includes('doctor')) {
        queryTypes.salud++;
      } else if (question.includes('comida') || question.includes('alimenta') || question.includes('comer')) {
        queryTypes.alimentacion++;
      } else if (question.includes('dormir') || question.includes('sueÃ±o') || question.includes('noche')) {
        queryTypes.sueno++;
      } else if (question.includes('desarrollo') || question.includes('crecer') || question.includes('aprende')) {
        queryTypes.desarrollo++;
      } else if (question.includes('comporta') || question.includes('llora') || question.includes('rabieta')) {
        queryTypes.comportamiento++;
      } else {
        queryTypes.otro++;
      }
    });

    // Por dÃ­a de la semana
    const byDayOfWeek = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
    faqs.forEach(faq => {
      if (faq.createdAt) {
        const day = faq.createdAt.getDay();
        byDayOfWeek[day]++;
      }
    });

    // Usuarios mÃ¡s activos
    const userCounts = {};
    faqs.forEach(faq => {
      if (faq.userId) {
        userCounts[faq.userId] = (userCounts[faq.userId] || 0) + 1;
      }
    });
    const topUsers = Object.entries(userCounts)
      .map(([userId, count]) => ({ userId, queryCount: count }))
      .sort((a, b) => b.queryCount - a.queryCount)
      .slice(0, 10);

    // Ãšltimas 10 consultas
    const recentQueries = faqs.slice(0, 10).map(faq => ({
      id: faq.id,
      question: faq.question?.substring(0, 100),
      userId: faq.userId,
      createdAt: faq.createdAt
    }));

    res.json({
      success: true,
      data: {
        summary: {
          totalQueries,
          uniqueUsers: Object.keys(userCounts).length,
          avgQueriesPerUser: Object.keys(userCounts).length > 0
            ? (totalQueries / Object.keys(userCounts).length).toFixed(2)
            : 0
        },
        queryTypes,
        byDayOfWeek: {
          domingo: byDayOfWeek[0],
          lunes: byDayOfWeek[1],
          martes: byDayOfWeek[2],
          miercoles: byDayOfWeek[3],
          jueves: byDayOfWeek[4],
          viernes: byDayOfWeek[5],
          sabado: byDayOfWeek[6]
        },
        topUsers,
        recentQueries
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo FAQ stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas de FAQ',
      error: error.message
    });
  }
});

// ========== GESTIÃ“N DE USUARIOS ==========

// Obtener todos los usuarios (con paginaciÃ³n)
app.get('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', orderBy = 'createdAt', order = 'desc' } = req.query;
    
    console.log('ðŸ‘¥ [ADMIN] Obteniendo usuarios:', { page, limit, search, orderBy, order });

    let query = db.collection('users');

    // Aplicar ordenamiento
    query = query.orderBy(orderBy, order);

    // Obtener todos los documentos
    const snapshot = await query.get();
    
    // Filtrar por bÃºsqueda si existe
    let users = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate(),
      lastLoginAt: doc.data().lastLoginAt?.toDate()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      users = users.filter(user => 
        user.email?.toLowerCase().includes(searchLower) ||
        user.displayName?.toLowerCase().includes(searchLower)
      );
    }

    // Aplicar paginaciÃ³n manual
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedUsers = users.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedUsers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: users.length,
        totalPages: Math.ceil(users.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo usuarios',
      error: error.message
    });
  }
});

// Crear nuevo usuario administrador
app.post('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { email, password, displayName, role = 'admin', isAdmin: isAdminUser = true } = req.body;
    
    console.log('âž• [ADMIN] Creando nuevo usuario administrador:', email);

    // Validaciones
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email y contraseÃ±a son requeridos'
      });
    }

    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'La contraseÃ±a debe tener al menos 6 caracteres'
      });
    }

    // Validar formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Email invÃ¡lido'
      });
    }

    // Verificar si el email ya existe
    try {
      const existingUser = await auth.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'El email ya estÃ¡ registrado'
        });
      }
    } catch (error) {
      // Si no existe, continuar (esto es lo esperado)
      if (error.code !== 'auth/user-not-found') {
        throw error;
      }
    }

    // Crear usuario en Firebase Auth
    const userRecord = await auth.createUser({
      email,
      password,
      displayName: displayName || email.split('@')[0],
      emailVerified: false
    });

    console.log('âœ… [ADMIN] Usuario creado en Firebase Auth:', userRecord.uid);

    // Crear documento en Firestore
    const defaultLocation = await getDefaultUserLocation();
    const userData = {
      email,
      displayName: displayName || email.split('@')[0],
      role: role, // 'admin' por defecto
      isAdmin: isAdminUser, // true por defecto
      isActive: true,
      photoURL: null,
      childrenCount: 0,
      ...defaultLocation,
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLoginAt: null
    };

    await db.collection('users').doc(userRecord.uid).set(userData);

    console.log('âœ… [ADMIN] Usuario creado en Firestore');

    res.json({
      success: true,
      message: 'Usuario administrador creado exitosamente',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userData.displayName,
        role: userData.role,
        isAdmin: userData.isAdmin,
        createdAt: userData.createdAt
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando usuario:', error);
    
    let errorMessage = 'Error creando usuario';
    if (error.code === 'auth/email-already-exists') {
      errorMessage = 'El email ya estÃ¡ registrado';
    } else if (error.code === 'auth/invalid-email') {
      errorMessage = 'Email invÃ¡lido';
    } else if (error.code === 'auth/weak-password') {
      errorMessage = 'La contraseÃ±a es muy dÃ©bil';
    }

    res.status(500).json({
      success: false,
      message: errorMessage,
      error: error.message
    });
  }
});

// Obtener detalle de un usuario especÃ­fico
app.get('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    
    console.log('ðŸ‘¤ [ADMIN] Obteniendo detalle del usuario:', userId);

    // Obtener usuario de Firestore
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Obtener hijos del usuario
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', userId)
      .get();
    
    const children = childrenSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Obtener comunidades del usuario
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', userId)
      .get();
    
    const communities = communitiesSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name
    }));

    // Obtener posts del usuario
    const postsSnapshot = await db.collection('posts')
      .where('authorId', '==', userId)
      .orderBy('createdAt', 'desc')
      .limit(10)
      .get();
    
    const posts = postsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: {
        user: {
          id: userDoc.id,
          ...userDoc.data(),
          createdAt: userDoc.data().createdAt?.toDate(),
          updatedAt: userDoc.data().updatedAt?.toDate(),
          lastLoginAt: userDoc.data().lastLoginAt?.toDate()
        },
        children,
        communities,
        posts,
        stats: {
          childrenCount: children.length,
          communitiesCount: communities.length,
          postsCount: postsSnapshot.size
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalle del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle del usuario',
      error: error.message
    });
  }
});

// Actualizar usuario (admin puede modificar cualquier campo)
app.put('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const updates = req.body;
    
    console.log('âœï¸ [ADMIN] Actualizando usuario:', userId, updates);

    // Verificar que el usuario existe
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Preparar datos de actualizaciÃ³n
    const updateData = {
      ...updates,
      updatedAt: new Date()
    };

    // No permitir actualizar ciertos campos crÃ­ticos
    delete updateData.uid;
    delete updateData.createdAt;

    // Actualizar en Firestore
    await db.collection('users').doc(userId).update(updateData);

    // Si se actualiza el email o displayName, tambiÃ©n actualizar en Firebase Auth
    if (updates.email || updates.displayName) {
      const authUpdates = {};
      if (updates.email) authUpdates.email = updates.email;
      if (updates.displayName) authUpdates.displayName = updates.displayName;
      
      try {
        await auth.updateUser(userId, authUpdates);
      } catch (authError) {
        console.log('âš ï¸ [ADMIN] No se pudo actualizar Firebase Auth:', authError.message);
      }
    }

    res.json({
      success: true,
      message: 'Usuario actualizado exitosamente',
      data: {
        id: userId,
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando usuario',
      error: error.message
    });
  }
});

// Desactivar/activar usuario
app.patch('/api/admin/users/:userId/toggle-active', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    
    console.log('ðŸ”„ [ADMIN] Cambiando estado del usuario:', userId);

    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const currentState = userDoc.data().isActive !== false; // Por defecto true
    const newState = !currentState;

    // Actualizar en Firestore
    await db.collection('users').doc(userId).update({
      isActive: newState,
      updatedAt: new Date()
    });

    // Actualizar en Firebase Auth
    try {
      await auth.updateUser(userId, {
        disabled: !newState
      });
    } catch (authError) {
      console.log('âš ï¸ [ADMIN] No se pudo actualizar Firebase Auth:', authError.message);
    }

    res.json({
      success: true,
      message: `Usuario ${newState ? 'activado' : 'desactivado'} exitosamente`,
      data: {
        isActive: newState
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error cambiando estado del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error cambiando estado del usuario',
      error: error.message
    });
  }
});

// Eliminar usuario (soft delete)
app.delete('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const { permanent = false } = req.query;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando usuario:', userId, 'Permanente:', permanent);

    if (permanent === 'true') {
      // EliminaciÃ³n permanente
      await db.collection('users').doc(userId).delete();
      
      try {
        await auth.deleteUser(userId);
      } catch (authError) {
        console.log('âš ï¸ [ADMIN] No se pudo eliminar de Firebase Auth:', authError.message);
      }
      
      res.json({
        success: true,
        message: 'Usuario eliminado permanentemente'
      });
    } else {
      // Soft delete
      await db.collection('users').doc(userId).update({
        isActive: false,
        deletedAt: new Date(),
        updatedAt: new Date()
      });
      
      res.json({
        success: true,
        message: 'Usuario desactivado (soft delete)'
      });
    }

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando usuario',
      error: error.message
    });
  }
});

// ============================================================================
// DEVICE INFO & APP ANALYTICS
// ============================================================================

// Endpoint para actualizar informaciÃ³n del dispositivo del usuario
app.post('/api/users/device-info', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { 
      appVersion, 
      platform, 
      buildNumber, 
      deviceModel, 
      osVersion 
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // TambiÃ©n usar info de headers si no viene en body
    const deviceInfo = {
      appVersion: appVersion || req.deviceInfo.appVersion,
      platform: platform || req.deviceInfo.platform,
      buildNumber: buildNumber || req.deviceInfo.buildNumber,
      deviceModel: deviceModel || req.deviceInfo.deviceModel,
      osVersion: osVersion || req.deviceInfo.osVersion,
      userAgent: req.deviceInfo.userAgent,
      lastUpdated: new Date()
    };

    console.log(`ðŸ“± [DEVICE INFO] Actualizando info para usuario ${uid}:`, deviceInfo);

    await db.collection('users').doc(uid).update({
      deviceInfo,
      lastDeviceUpdate: new Date()
    });

    res.json({
      success: true,
      message: 'InformaciÃ³n del dispositivo actualizada',
      data: deviceInfo
    });

  } catch (error) {
    console.error('âŒ [DEVICE INFO] Error actualizando:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando informaciÃ³n del dispositivo',
      error: error.message
    });
  }
});

// Endpoint admin para ver estadÃ­sticas de versiones y plataformas
app.get('/api/admin/analytics/app-versions', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('ðŸ“Š [ADMIN] Obteniendo estadÃ­sticas de versiones de app...');

    // Obtener todos los usuarios con deviceInfo
    const usersSnapshot = await db.collection('users')
      .where('deviceInfo', '!=', null)
      .get();

    const stats = {
      total: usersSnapshot.size,
      byPlatform: {
        ios: 0,
        android: 0,
        unknown: 0
      },
      byVersion: {},
      byOsVersion: {},
      devices: []
    };

    usersSnapshot.docs.forEach(doc => {
      const userData = doc.data();
      const deviceInfo = userData.deviceInfo || {};

      // Contar por plataforma
      const platform = deviceInfo.platform || 'unknown';
      if (stats.byPlatform[platform] !== undefined) {
        stats.byPlatform[platform]++;
      } else {
        stats.byPlatform.unknown++;
      }

      // Contar por versiÃ³n de app
      const appVersion = deviceInfo.appVersion || 'unknown';
      stats.byVersion[appVersion] = (stats.byVersion[appVersion] || 0) + 1;

      // Contar por versiÃ³n de OS
      const osKey = deviceInfo.platform && deviceInfo.osVersion 
        ? `${deviceInfo.platform}-${deviceInfo.osVersion}`
        : 'unknown';
      stats.byOsVersion[osKey] = (stats.byOsVersion[osKey] || 0) + 1;

      // Agregar a lista de dispositivos
      stats.devices.push({
        userId: doc.id,
        email: userData.email || 'Sin email',
        platform: deviceInfo.platform || 'unknown',
        appVersion: deviceInfo.appVersion || 'unknown',
        buildNumber: deviceInfo.buildNumber || 'unknown',
        deviceModel: deviceInfo.deviceModel || 'unknown',
        osVersion: deviceInfo.osVersion || 'unknown',
        lastUpdated: deviceInfo.lastUpdated
      });
    });

    // Ordenar versiones por uso
    const sortedVersions = Object.entries(stats.byVersion)
      .sort((a, b) => b[1] - a[1])
      .map(([version, count]) => ({
        version,
        count,
        percentage: ((count / stats.total) * 100).toFixed(2)
      }));

    // Ordenar OS versions por uso
    const sortedOsVersions = Object.entries(stats.byOsVersion)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10) // Top 10
      .map(([os, count]) => ({
        os,
        count,
        percentage: ((count / stats.total) * 100).toFixed(2)
      }));

    // Ordenar dispositivos por fecha de actualizaciÃ³n
    stats.devices.sort((a, b) => {
      const dateA = a.lastUpdated?.toDate ? a.lastUpdated.toDate() : new Date(0);
      const dateB = b.lastUpdated?.toDate ? b.lastUpdated.toDate() : new Date(0);
      return dateB - dateA;
    });

    res.json({
      success: true,
      data: {
        summary: {
          totalUsers: stats.total,
          platforms: stats.byPlatform,
          mostUsedVersion: sortedVersions[0]?.version || 'unknown',
          mostUsedVersionCount: sortedVersions[0]?.count || 0
        },
        versions: sortedVersions,
        osVersions: sortedOsVersions,
        recentDevices: stats.devices.slice(0, 20) // Solo los 20 mÃ¡s recientes
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// Endpoint admin para buscar usuarios por versiÃ³n/plataforma
app.get('/api/admin/analytics/users-by-app', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { platform, version, minVersion } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('ðŸ” [ADMIN] Buscando usuarios:', { platform, version, minVersion });

    let query = db.collection('users').where('deviceInfo', '!=', null);
    
    const usersSnapshot = await query.get();

    let users = usersSnapshot.docs.map(doc => ({
      id: doc.id,
      email: doc.data().email,
      deviceInfo: doc.data().deviceInfo
    }));

    // Filtrar por plataforma
    if (platform) {
      users = users.filter(u => u.deviceInfo?.platform === platform);
    }

    // Filtrar por versiÃ³n exacta
    if (version) {
      users = users.filter(u => u.deviceInfo?.appVersion === version);
    }

    // Filtrar por versiÃ³n mÃ­nima (versiones anteriores)
    if (minVersion && !version) {
      users = users.filter(u => {
        const userVersion = u.deviceInfo?.appVersion;
        if (!userVersion) return false;
        return compareVersions(userVersion, minVersion) < 0;
      });
    }

    res.json({
      success: true,
      data: {
        total: users.length,
        users: users.slice(0, 100) // Limitar a 100 usuarios
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error buscando usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error buscando usuarios',
      error: error.message
    });
  }
});

// FunciÃ³n auxiliar para comparar versiones
function compareVersions(v1, v2) {
  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const p1 = parts1[i] || 0;
    const p2 = parts2[i] || 0;
    
    if (p1 > p2) return 1;
    if (p1 < p2) return -1;
  }
  
  return 0;
}

// ========== GESTIÃ“N DE COMUNIDADES ==========

// Obtener todas las comunidades
app.get('/api/admin/communities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('ðŸ˜ï¸ [ADMIN] Obteniendo comunidades');

    const snapshot = await db.collection('communities')
      .orderBy('createdAt', 'desc')
      .get();
    
    let communities = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      communities = communities.filter(comm => 
        comm.name?.toLowerCase().includes(searchLower) ||
        comm.description?.toLowerCase().includes(searchLower)
      );
    }

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedCommunities = communities.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedCommunities,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: communities.length,
        totalPages: Math.ceil(communities.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo comunidades:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades',
      error: error.message
    });
  }
});

// Crear nueva comunidad
app.post('/api/admin/communities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, imageUrl, isPrivate = false } = req.body;
    
    console.log('âž• [ADMIN] Creando nueva comunidad:', name);

    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la comunidad es requerido'
      });
    }

    const communityData = {
      name,
      description: description || '',
      imageUrl: imageUrl || null,
      isPrivate,
      members: [req.user.uid], // El admin es el primer miembro
      createdBy: req.user.uid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      memberCount: 1,
      postCount: 0
    };

    const communityRef = await db.collection('communities').add(communityData);

    res.json({
      success: true,
      message: 'Comunidad creada exitosamente',
      data: {
        id: communityRef.id,
        ...communityData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comunidad',
      error: error.message
    });
  }
});

// Editar comunidad
app.put('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { name, description, imageUrl, isPrivate } = req.body;
    
    console.log('âœï¸ [ADMIN] Editando comunidad:', communityId);

    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isPrivate !== undefined) updateData.isPrivate = isPrivate;

    await communityRef.update(updateData);

    res.json({
      success: true,
      message: 'Comunidad actualizada exitosamente',
      data: {
        id: communityId,
        ...communityDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error editando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando comunidad',
      error: error.message
    });
  }
});

// Obtener detalle de una comunidad especÃ­fica con sus posts
app.get('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('ðŸ˜ï¸ [ADMIN] Obteniendo detalle de comunidad:', communityId);

    // Obtener datos de la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    // Obtener posts de la comunidad
    const postsSnapshot = await db.collection('posts')
      .where('communityId', '==', communityId)
      .orderBy('createdAt', 'desc')
      .get();
    
    const allPosts = postsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedPosts = allPosts.slice(startIndex, endIndex);

    // Obtener informaciÃ³n de miembros
    const communityData = communityDoc.data();
    const memberCount = communityData.members?.length || 0;

    res.json({
      success: true,
      data: {
        community: {
          id: communityDoc.id,
          ...communityData,
          createdAt: communityData.createdAt?.toDate(),
          updatedAt: communityData.updatedAt?.toDate()
        },
        posts: paginatedPosts,
        stats: {
          totalPosts: allPosts.length,
          memberCount: memberCount
        },
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: allPosts.length,
          totalPages: Math.ceil(allPosts.length / limit)
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalle de comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de comunidad',
      error: error.message
    });
  }
});

// Obtener miembros de una comunidad
app.get('/api/admin/communities/:communityId/members', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('ðŸ‘¥ [ADMIN] Obteniendo miembros de comunidad:', communityId);

    // Obtener la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    const memberIds = communityData.members || [];

    if (memberIds.length === 0) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          page: 1,
          limit: parseInt(limit),
          total: 0,
          totalPages: 0
        }
      });
    }

    // Obtener informaciÃ³n detallada de cada miembro
    const memberPromises = memberIds.map(async (memberId) => {
      try {
        const userDoc = await db.collection('users').doc(memberId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          return {
            id: userDoc.id,
            displayName: userData.displayName || 'Sin nombre',
            email: userData.email || null,
            photoURL: userData.photoURL || null,
            isActive: userData.isActive !== false,
            createdAt: userData.createdAt?.toDate(),
            lastLoginAt: userData.lastLoginAt?.toDate()
          };
        }
        return null;
      } catch (error) {
        console.error(`Error obteniendo usuario ${memberId}:`, error);
        return null;
      }
    });

    const allMembers = (await Promise.all(memberPromises)).filter(m => m !== null);

    // Ordenar por displayName
    allMembers.sort((a, b) => {
      const nameA = a.displayName?.toLowerCase() || '';
      const nameB = b.displayName?.toLowerCase() || '';
      return nameA.localeCompare(nameB);
    });

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedMembers = allMembers.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedMembers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: allMembers.length,
        totalPages: Math.ceil(allMembers.length / limit)
      },
      communityInfo: {
        id: communityId,
        name: communityData.name,
        memberCount: allMembers.length
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo miembros:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo miembros de la comunidad',
      error: error.message
    });
  }
});

// Eliminar comunidad
app.delete('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando comunidad:', communityId);

    await db.collection('communities').doc(communityId).delete();

    res.json({
      success: true,
      message: 'Comunidad eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comunidad',
      error: error.message
    });
  }
});

// ========== GESTIÃ“N DE HIJOS ==========

// Obtener todos los hijos
app.get('/api/admin/children', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('ðŸ‘¶ [ADMIN] Obteniendo hijos');

    const snapshot = await db.collection('children')
      .orderBy('createdAt', 'desc')
      .get();
    
    let children = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate(),
      registeredAt: doc.data().registeredAt?.toDate()
    }));

    // Filtrar por bÃºsqueda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      children = children.filter(child => 
        child.name?.toLowerCase().includes(searchLower) ||
        child.parentId?.toLowerCase().includes(searchLower)
      );
    }

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedChildren = children.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedChildren,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: children.length,
        totalPages: Math.ceil(children.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hijos',
      error: error.message
    });
  }
});

// Obtener un hijo especÃ­fico
app.get('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    
    console.log('ðŸ‘¶ [ADMIN] Obteniendo hijo:', childId);

    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();

    // Obtener informaciÃ³n del padre
    let parentInfo = null;
    if (childData.parentId) {
      try {
        const parentDoc = await db.collection('users').doc(childData.parentId).get();
        if (parentDoc.exists) {
          const parentData = parentDoc.data();
          parentInfo = {
            uid: childData.parentId,
            displayName: parentData.displayName || 'Usuario',
            email: parentData.email,
            photoURL: parentData.photoURL || null
          };
        }
      } catch (error) {
        console.log('âš ï¸ [ADMIN] Error obteniendo info del padre:', childData.parentId);
      }
    }

    res.json({
      success: true,
      data: {
        id: childDoc.id,
        ...childData,
        parent: parentInfo,
        createdAt: childData.createdAt?.toDate(),
        updatedAt: childData.updatedAt?.toDate(),
        registeredAt: childData.registeredAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hijo',
      error: error.message
    });
  }
});

// Editar hijo (admin puede editar cualquier hijo)
app.put('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento
      dueDate,          // Nuevo: fecha esperada de parto
      isUnborn, 
      photoUrl,
      // Legacy
      ageInMonths, 
      gestationWeeks 
    } = req.body;
    
    console.log('âœï¸ [ADMIN] Editando hijo:', childId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const currentData = childDoc.data();
    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (photoUrl !== undefined) updateData.photoUrl = photoUrl;
    if (isUnborn !== undefined) updateData.isUnborn = isUnborn;

    // Determinar el estado final de isUnborn
    const finalIsUnborn = isUnborn !== undefined ? isUnborn : currentData.isUnborn;

    // Manejar actualizaciÃ³n de fechas/edades segÃºn el estado
    if (finalIsUnborn) {
      // Es un bebÃ© no nacido
      if (dueDate) {
        updateData.dueDate = new Date(dueDate);
        updateData.gestationWeeks = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
      } else if (gestationWeeks !== undefined) {
        // Legacy: usar semanas de gestaciÃ³n
        if (gestationWeeks < 1 || gestationWeeks > 42) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaciÃ³n deben estar entre 1 y 42'
      });
    }
        updateData.gestationWeeks = parseInt(gestationWeeks);
        updateData.dueDate = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
        updateData.registeredAt = new Date();
      }
    } else {
      // Es un bebÃ© nacido
      if (birthDate) {
        updateData.birthDate = new Date(birthDate);
        updateData.ageInMonths = null;
        updateData.dueDate = null;
        updateData.gestationWeeks = null;
      } else if (ageInMonths !== undefined) {
        // Legacy: usar edad en meses
        if (ageInMonths < 0) {
      return res.status(400).json({
        success: false,
        message: 'La edad en meses debe ser mayor o igual a 0'
      });
    }
        updateData.ageInMonths = parseInt(ageInMonths);
        updateData.birthDate = null;
        updateData.dueDate = null;
      updateData.gestationWeeks = null;
        updateData.registeredAt = new Date();
      }
    }

    await db.collection('children').doc(childId).update(updateData);

    // Obtener el hijo actualizado con informaciÃ³n calculada
    const updatedChildDoc = await db.collection('children').doc(childId).get();
    const updatedChild = getChildCurrentInfo({ id: childId, ...updatedChildDoc.data() });

    res.json({
      success: true,
      message: 'Hijo actualizado exitosamente',
      data: updatedChild
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error editando hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando hijo',
      error: error.message
    });
  }
});

// Eliminar hijo (admin puede eliminar cualquier hijo)
app.delete('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando hijo:', childId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    const parentId = childData.parentId;

    // Eliminar el hijo
    await db.collection('children').doc(childId).delete();

    // Actualizar el contador de hijos del padre (solo si el padre existe)
    if (parentId) {
      try {
        // Verificar que el usuario padre existe
        const parentDoc = await db.collection('users').doc(parentId).get();
        
        if (parentDoc.exists) {
          const childrenSnapshot = await db.collection('children')
            .where('parentId', '==', parentId)
            .get();
          
          const actualChildrenCount = childrenSnapshot.size;
          
          await db.collection('users').doc(parentId).update({
            childrenCount: actualChildrenCount,
            updatedAt: new Date()
          });
          
          console.log(`âœ… [ADMIN] Contador de hijos actualizado para usuario ${parentId}: ${actualChildrenCount}`);
        } else {
          console.log(`âš ï¸ [ADMIN] Usuario padre ${parentId} no encontrado, no se actualizarÃ¡ el contador`);
        }
      } catch (updateError) {
        // Si falla la actualizaciÃ³n del padre, solo lo registramos pero no fallamos la operaciÃ³n
        console.error('âš ï¸ [ADMIN] Error actualizando contador del padre:', updateError.message);
      }
    }

    res.json({
      success: true,
      message: 'Hijo eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hijo',
      error: error.message
    });
  }
});

// ========== GESTIÃ“N DE POSTS ==========

// Obtener todos los posts
app.get('/api/admin/posts', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    
    console.log('ðŸ“ [ADMIN] Obteniendo posts');

    const snapshot = await db.collection('posts')
      .orderBy('createdAt', 'desc')
      .get();
    
    const posts = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedPosts = posts.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedPosts,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: posts.length,
        totalPages: Math.ceil(posts.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo posts:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo posts',
      error: error.message
    });
  }
});

// Crear nuevo post
app.post('/api/admin/posts', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { content, imageUrl, communityId, attachedLists = [] } = req.body;
    
    console.log('âž• [ADMIN] Creando nuevo post');

    if (!content) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del post es requerido'
      });
    }

    if (!communityId) {
      return res.status(400).json({
        success: false,
        message: 'El ID de la comunidad es requerido'
      });
    }

    // Verificar que la comunidad existe
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    // Validar y verificar que las listas existen
    const validatedLists = [];
    if (attachedLists && Array.isArray(attachedLists) && attachedLists.length > 0) {
      console.log(`ðŸ“‹ [ADMIN] Validando ${attachedLists.length} listas adjuntas`);
      
      for (const listId of attachedLists) {
        try {
          const listDoc = await db.collection('lists').doc(listId).get();
          
          if (!listDoc.exists) {
            console.warn(`âš ï¸ [ADMIN] Lista no encontrada: ${listId}`);
            continue;
          }

          const listData = listDoc.data();
          validatedLists.push({
            id: listId,
            title: listData.title,
            description: listData.description || '',
            imageUrl: listData.imageUrl || null,
            isPublic: listData.isPublic,
            totalItems: listData.totalItems || 0,
            completedItems: listData.completedItems || 0
          });
          console.log(`âœ… [ADMIN] Lista validada: ${listData.title}`);
        } catch (error) {
          console.error(`âŒ [ADMIN] Error validando lista ${listId}:`, error.message);
        }
      }
    }

    const postData = {
      content,
      authorId: req.user.uid,
      communityId,
      isPinned: false,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      likes: [],
      commentCount: 0
    };

    // Solo agregar imageUrl si se proporciona
    if (imageUrl) {
      postData.imageUrl = imageUrl;
    }

    // Agregar listas adjuntas si hay
    if (validatedLists.length > 0) {
      postData.attachedLists = validatedLists;
      console.log(`ðŸ“‹ [ADMIN] ${validatedLists.length} listas adjuntadas al post`);
    }

    const postRef = await db.collection('posts').add(postData);

    // Incrementar el contador de posts en la comunidad
    await db.collection('communities').doc(communityId).update({
      postCount: admin.firestore.FieldValue.increment(1)
    });

    console.log('âœ… [ADMIN] Post creado exitosamente:', postRef.id);

    // Enviar notificaciones push a todos los miembros de la comunidad
    try {
      const communityData = communityDoc.data();
      const authorDoc = await db.collection('users').doc(req.user.uid).get();
      const authorData = authorDoc.exists ? authorDoc.data() : {};
      const authorName = authorData.displayName || authorData.name || 'Administrador';
      const communityName = communityData.name || 'la comunidad';

      // Obtener tokens de todos los miembros (incluyendo al admin autor, si es miembro)
      const membersToNotify = communityData.members || [];
      
      if (membersToNotify.length > 0) {
        console.log(`ðŸ“¤ [ADMIN] Enviando notificaciÃ³n de nueva publicaciÃ³n a ${membersToNotify.length} miembros`);
        
        const tokensPromises = membersToNotify.map(async (memberId) => {
          try {
            const memberDoc = await db.collection('users').doc(memberId).get();
            if (memberDoc.exists) {
              const memberData = memberDoc.data();
              return { userId: memberId, tokens: memberData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`âš ï¸ [ADMIN] Error obteniendo tokens del miembro ${memberId}:`, error.message);
          }
          return { userId: memberId, tokens: [] };
        });
        
        const usersWithTokens = await Promise.all(tokensPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);
        
        if (allTokens.length > 0) {
          const notification = {
            title: `ðŸ“¢ ${authorName} publicÃ³ en ${communityName}`,
            body: content.length > 100 ? content.substring(0, 100) + '...' : content
          };

          const notificationData = {
            type: 'community_post',
            postId: postRef.id,
            communityId: communityId,
            communityName: communityName,
            authorId: req.user.uid,
            authorName: authorName,
            screen: 'CommunityPostScreen'
          };

          const pushResult = await sendPushNotification(allTokens, notification, notificationData);
          console.log(`âœ… [ADMIN] Notificaciones enviadas: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

          // Guardar notificaciones en Firestore para cada usuario
          const batch = db.batch();
          usersWithTokens.forEach(userWithTokens => {
            if (userWithTokens.tokens.length > 0) {
              const notifRef = db.collection('notifications').doc();
              batch.set(notifRef, {
                userId: userWithTokens.userId,
                type: 'community_post',
                title: notification.title,
                body: notification.body,
                data: notificationData,
                read: false,
                createdAt: admin.firestore.Timestamp.fromDate(new Date())
              });
            }
          });
          await batch.commit();
          console.log(`âœ… [ADMIN] ${membersToNotify.length} notificaciones guardadas en Firestore`);
        } else {
          console.log('âš ï¸ [ADMIN] NingÃºn miembro tiene tokens FCM registrados');
        }
      } else {
        console.log('âš ï¸ [ADMIN] La comunidad no tiene miembros para notificar');
      }
    } catch (notificationError) {
      console.error('âŒ [ADMIN] Error enviando notificaciones de nueva publicaciÃ³n:', notificationError);
      // No fallar la creaciÃ³n del post si falla la notificaciÃ³n
    }

    res.json({
      success: true,
      message: 'Post creado exitosamente',
      data: {
        id: postRef.id,
        ...postData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando post',
      error: error.message
    });
  }
});

// Editar post
app.put('/api/admin/posts/:postId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { content, imageUrl, attachedLists } = req.body;
    
    console.log('âœï¸ [ADMIN] Editando post:', postId);

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (content !== undefined) updateData.content = content;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;

    // Actualizar listas adjuntas si se envÃ­an
    if (attachedLists !== undefined) {
      console.log(`ðŸ“‹ [ADMIN] attachedLists recibido:`, attachedLists);
      
      if (attachedLists === null || (Array.isArray(attachedLists) && attachedLists.length === 0)) {
        // Remover listas si se envÃ­a null o array vacÃ­o
        updateData.attachedLists = admin.firestore.FieldValue.delete();
        console.log('ðŸ—‘ï¸ [ADMIN] Removiendo listas adjuntas del post');
      } else if (Array.isArray(attachedLists)) {
        // Validar y verificar que las listas existen
        const validatedLists = [];
        console.log(`ðŸ“‹ [ADMIN] Validando ${attachedLists.length} listas adjuntas`);
        
        for (const listId of attachedLists) {
          console.log(`ðŸ” [ADMIN] Buscando lista: ${listId}`);
          try {
            const listDoc = await db.collection('lists').doc(listId).get();
            
            if (!listDoc.exists) {
              console.warn(`âš ï¸ [ADMIN] Lista no encontrada: ${listId}`);
              continue;
            }

            const listData = listDoc.data();
            validatedLists.push({
              id: listId,
              title: listData.title,
              description: listData.description || '',
              imageUrl: listData.imageUrl || null,
              isPublic: listData.isPublic,
              totalItems: listData.totalItems || 0,
              completedItems: listData.completedItems || 0
            });
            console.log(`âœ… [ADMIN] Lista validada: ${listData.title}`);
          } catch (error) {
            console.error(`âŒ [ADMIN] Error validando lista ${listId}:`, error.message);
          }
        }
        
        if (validatedLists.length > 0) {
          updateData.attachedLists = validatedLists;
          console.log(`ðŸ“‹ [ADMIN] ${validatedLists.length} listas serÃ¡n actualizadas en el post`);
        } else {
          console.warn(`âš ï¸ [ADMIN] Ninguna lista fue validada. No se actualizarÃ¡n listas.`);
        }
      }
    }

    console.log(`ðŸ’¾ [ADMIN] Actualizando post con datos:`, JSON.stringify(updateData, null, 2));
    await postRef.update(updateData);

    // Obtener el documento actualizado
    const updatedPostDoc = await postRef.get();
    const updatedData = updatedPostDoc.data();

    console.log(`âœ… [ADMIN] Post actualizado. attachedLists:`, updatedData.attachedLists);

    res.json({
      success: true,
      message: 'Post actualizado exitosamente',
      data: {
        id: postId,
        ...updatedData,
        createdAt: updatedData.createdAt?.toDate?.(),
        updatedAt: updatedData.updatedAt?.toDate?.()
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error editando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando post',
      error: error.message
    });
  }
});

// Eliminar post
app.delete('/api/admin/posts/:postId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando post:', postId);

    await db.collection('posts').doc(postId).delete();

    res.json({
      success: true,
      message: 'Post eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando post',
      error: error.message
    });
  }
});

// Fijar/Desfijar post (Pin/Unpin)
app.patch('/api/admin/posts/:postId/pin', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { isPinned } = req.body;
    
    if (isPinned === undefined) {
      return res.status(400).json({
        success: false,
        message: 'El campo isPinned es requerido'
      });
    }

    console.log(`ðŸ“Œ [ADMIN] ${isPinned ? 'Fijando' : 'Desfijando'} post:`, postId);

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    await postRef.update({
      isPinned: isPinned,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    console.log(`âœ… [ADMIN] Post ${isPinned ? 'fijado' : 'desfijado'} exitosamente`);

    res.json({
      success: true,
      message: `Post ${isPinned ? 'fijado' : 'desfijado'} exitosamente`,
      data: {
        id: postId,
        isPinned: isPinned
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error fijando/desfijando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error al fijar/desfijar post',
      error: error.message
    });
  }
});

// Obtener comentarios de un post
app.get('/api/admin/posts/:postId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('ðŸ’¬ [ADMIN] Obteniendo comentarios del post:', postId);

    // Obtener todos los comentarios del post
    const commentsSnapshot = await db.collection('comments')
      .where('postId', '==', postId)
      .get();

    const comments = [];
    for (const doc of commentsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaciÃ³n del autor del comentario
      let authorInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.authorId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          authorInfo = {
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('âš ï¸ [ADMIN] Error obteniendo info del autor:', data.authorId);
        authorInfo = {
          displayName: 'Usuario',
          email: null,
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        postId: data.postId,
        authorId: data.authorId,
        author: authorInfo,
        content: data.content,
        likeCount: data.likeCount || 0,
        likes: data.likes || [],
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (mÃ¡s recientes primero)
    comments.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = comments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: comments.length,
        totalPages: Math.ceil(comments.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo comentarios del post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Obtener likes de un post
app.get('/api/admin/posts/:postId/likes', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('â¤ï¸ [ADMIN] Obteniendo likes del post:', postId);

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();
    
    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    const postData = postDoc.data();
    const likes = postData.likes || [];
    const likeCount = postData.likeCount || 0;

    console.log('ðŸ“Š [ADMIN] Total likes:', likeCount);

    // Obtener informaciÃ³n de los usuarios que dieron like
    const likesWithUserInfo = [];
    for (const userId of likes) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          likesWithUserInfo.push({
            userId: userId,
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          });
        } else {
          likesWithUserInfo.push({
            userId: userId,
            displayName: 'Usuario desconocido',
            email: null,
            photoURL: null
          });
        }
      } catch (error) {
        console.log('âš ï¸ [ADMIN] Error obteniendo info del usuario:', userId);
        likesWithUserInfo.push({
          userId: userId,
          displayName: 'Usuario',
          email: null,
          photoURL: null
        });
      }
    }

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedLikes = likesWithUserInfo.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedLikes,
      stats: {
        totalLikes: likeCount
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: likesWithUserInfo.length,
        totalPages: Math.ceil(likesWithUserInfo.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo likes del post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo likes',
      error: error.message
    });
  }
});

// Eliminar comentario de un post
app.delete('/api/admin/posts/:postId/comments/:commentId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId, commentId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando comentario:', commentId, 'del post:', postId);

    // Eliminar el comentario
    await db.collection('comments').doc(commentId).delete();

    // Decrementar el contador de comentarios en el post
    const postRef = db.collection('posts').doc(postId);
    await postRef.update({
      commentCount: admin.firestore.FieldValue.increment(-1)
    });

    res.json({
      success: true,
      message: 'Comentario eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comentario',
      error: error.message
    });
  }
});

// ========== GESTIÃ“N DE CATEGORÃAS ==========

// ===== ENDPOINTS PARA LA APP =====

// ============================================================================
// ðŸŒŽ LOCATIONS (PAÃSES Y CIUDADES)
// ============================================================================

const resolveCountryCity = async (countryId, cityId) => {
  const resolved = {
    countryId: countryId ? String(countryId).trim() : null,
    countryName: null,
    cityId: cityId ? String(cityId).trim() : null,
    cityName: null
  };

  let countryDoc = null;
  if (resolved.countryId) {
    countryDoc = await db.collection('countries').doc(resolved.countryId).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      throw new Error('PaÃ­s no encontrado o inactivo');
    }
    resolved.countryName = countryDoc.data().name || null;
  }

  if (resolved.cityId) {
    const cityDoc = await db.collection('cities').doc(resolved.cityId).get();
    if (!cityDoc.exists || cityDoc.data().isActive === false) {
      throw new Error('Ciudad no encontrada o inactiva');
    }
    const cityData = cityDoc.data();
    resolved.cityName = cityData.name || null;
    if (cityData.countryId) {
      if (resolved.countryId && cityData.countryId !== resolved.countryId) {
        throw new Error('La ciudad no pertenece al paÃ­s seleccionado');
      }
      resolved.countryId = cityData.countryId;
      if (!resolved.countryName) {
        const derivedCountryDoc = await db.collection('countries').doc(cityData.countryId).get();
        if (!derivedCountryDoc.exists || derivedCountryDoc.data().isActive === false) {
          throw new Error('PaÃ­s no encontrado o inactivo');
        }
        resolved.countryName = derivedCountryDoc.data().name || null;
      }
    }
  }

  return resolved;
};

const buildLocationFields = (data) => ({
  countryId: data.countryId || null,
  countryName: data.countryName || null,
  cityId: data.cityId || null,
  cityName: data.cityName || null
});

const DEFAULT_COUNTRY_NAME = 'Ecuador';
const DEFAULT_CITY_NAME = 'Quito';

const getDefaultUserLocation = async () => {
  if (!db) {
    return {
      countryId: null,
      countryName: DEFAULT_COUNTRY_NAME,
      cityId: null,
      cityName: DEFAULT_CITY_NAME
    };
  }

  let countryId = null;
  let cityId = null;
  let countryName = DEFAULT_COUNTRY_NAME;
  let cityName = DEFAULT_CITY_NAME;

  const countrySnapshot = await db.collection('countries')
    .where('name', '==', DEFAULT_COUNTRY_NAME)
    .limit(1)
    .get();
  if (!countrySnapshot.empty) {
    countryId = countrySnapshot.docs[0].id;
  } else {
    const ref = await db.collection('countries').add({
      name: DEFAULT_COUNTRY_NAME,
      isActive: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    countryId = ref.id;
  }

  const citySnapshot = await db.collection('cities')
    .where('name', '==', DEFAULT_CITY_NAME)
    .where('countryId', '==', countryId)
    .limit(1)
    .get();
  if (!citySnapshot.empty) {
    cityId = citySnapshot.docs[0].id;
  } else {
    const ref = await db.collection('cities').add({
      name: DEFAULT_CITY_NAME,
      countryId,
      isActive: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    cityId = ref.id;
  }

  return {
    countryId,
    countryName,
    cityId,
    cityName
  };
};

const filterRecommendationsByLocation = ({
  items,
  userLat,
  userLng,
  cityId,
  countryId,
  maxDistanceKm = 100
}) => {
  const normalizedCityId = cityId ? String(cityId).trim() : null;
  const normalizedCountryId = countryId ? String(countryId).trim() : null;
  const cappedMax = Math.min(Math.max(Number(maxDistanceKm) || 100, 1), 100);
  const hasCoords = Number.isFinite(userLat) && Number.isFinite(userLng);

  const withDistance = hasCoords
    ? items.map(item => {
        if (item.latitude && item.longitude) {
          const distance = calculateDistance(userLat, userLng, item.latitude, item.longitude);
          return {
            ...item,
            distance: Math.round(distance * 10) / 10
          };
        }
        return { ...item };
      })
    : items.map(item => ({ ...item }));

  const baseList = items;
  const isGlobal = (item) => !item.countryId;
  const isCountryMatch = (item) => normalizedCountryId && String(item.countryId || '') === normalizedCountryId;
  const isCityMatch = (item) => normalizedCityId && String(item.cityId || '') === normalizedCityId;
  if (hasCoords) {
    const nearby = withDistance.filter(item => typeof item.distance === 'number' && item.distance <= cappedMax);
    if (nearby.length > 0) {
      const ids = new Set(nearby.map(item => item.id));
      let extra = [];
      if (normalizedCityId) {
        extra = baseList.filter(item =>
          !ids.has(item.id) && (isCityMatch(item) || (!item.cityId && isCountryMatch(item)) || isGlobal(item))
        );
      } else if (normalizedCountryId) {
        extra = baseList.filter(item =>
          !ids.has(item.id) && (isCountryMatch(item) || isGlobal(item))
        );
      } else {
        extra = baseList.filter(item => !ids.has(item.id) && isGlobal(item));
      }
      return nearby.concat(extra);
    }
  }

  if (normalizedCityId) {
    const cityMatches = baseList.filter(item =>
      isCityMatch(item) || (!item.cityId && isCountryMatch(item)) || isGlobal(item)
    );
    if (cityMatches.length > 0) return cityMatches;
  }

  if (normalizedCountryId) {
    const countryMatches = baseList.filter(item => isCountryMatch(item) || isGlobal(item));
    if (countryMatches.length > 0) return countryMatches;
  }

  return [];
};

const reverseGeocode = async (latitude, longitude) => {
  const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}&zoom=10&addressdetails=1`;
  const response = await fetch(url, {
    headers: {
      'User-Agent': 'munpa-backend/1.0 (support@munpa.online)'
    }
  });
  if (!response.ok) {
    throw new Error('No se pudo resolver la ubicaciÃ³n');
  }
  const data = await response.json();
  const address = data.address || {};
  const city = address.city || address.town || address.village || address.municipality || address.state_district || null;
  const country = address.country || null;
  return { city, country, raw: address };
};

const getUserLocationFromProfile = async (userId) => {
  if (!db) return {};
  const userDoc = await db.collection('users').doc(userId).get();
  if (!userDoc.exists) return {};
  const data = userDoc.data();
  const baseLocation = {
    latitude: data.latitude ?? null,
    longitude: data.longitude ?? null,
    cityId: data.cityId || null,
    countryId: data.countryId || null
  };
  if (!baseLocation.countryId || !baseLocation.cityId) {
    const defaultLocation = await getDefaultUserLocation();
    return {
      ...baseLocation,
      countryId: baseLocation.countryId || defaultLocation.countryId,
      cityId: baseLocation.cityId || defaultLocation.cityId,
      countryName: data.countryName || defaultLocation.countryName,
      cityName: data.cityName || defaultLocation.cityName
    };
  }
  return baseLocation;
};

const getUserCountryForMarketplace = async (userId) => {
  const location = await getUserLocationFromProfile(userId);
  if (!location.countryId) {
    const defaultLocation = await getDefaultUserLocation();
    return defaultLocation;
  }
  return location;
};

const normalizeMarketplaceLocation = (data) => {
  const location = data.location ? { ...data.location } : null;
  if (location) {
    if (data.cityName) location.city = data.cityName;
    if (data.countryName) location.country = data.countryName;
  }
  return location;
};

const getCategoriesMap = async () => {
  if (!db) return new Map();
  const cacheKey = 'categories_map';
  const cached = getCachedResponse(cacheKey);
  if (cached) return cached;

  const snapshot = await db.collection('categories').get();
  const map = new Map();
  snapshot.forEach(doc => {
    const data = doc.data();
    map.set(doc.id, {
      id: doc.id,
      name: data.name,
      icon: data.icon,
      imageUrl: data.imageUrl
    });
  });

  setCachedResponse(cacheKey, map, 10 * 60 * 1000);
  return map;
};

// ===== ENDPOINTS APP (LECTURA) =====

app.get('/api/locations/countries', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('countries')
      .where('isActive', '==', true)
      .orderBy('name', 'asc')
      .get();

    const countries = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name
    }));

    res.json({ success: true, data: countries });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error obteniendo paÃ­ses:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo paÃ­ses', error: error.message });
  }
});

app.get('/api/locations/cities', authenticateToken, async (req, res) => {
  try {
    const { countryId } = req.query;
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const snapshot = await db.collection('cities')
      .where('countryId', '==', String(countryId))
      .where('isActive', '==', true)
      .orderBy('name', 'asc')
      .get();

    const cities = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      countryId: doc.data().countryId
    }));

    res.json({ success: true, data: cities });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error obteniendo ciudades:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo ciudades', error: error.message });
  }
});

// Resolver ciudad y paÃ­s desde lat/long (app)
app.get('/api/locations/reverse', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude } = req.query;
    if (!latitude || !longitude) {
      return res.status(400).json({ success: false, message: 'latitude y longitude son requeridos' });
    }

    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return res.status(400).json({ success: false, message: 'latitude y longitude deben ser nÃºmeros vÃ¡lidos' });
    }

    const result = await reverseGeocode(lat, lng);
    res.json({
      success: true,
      data: {
        latitude: lat,
        longitude: lng,
        city: result.city,
        country: result.country
      }
    });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error reverse geocode:', error);
    res.status(500).json({ success: false, message: 'Error resolviendo ubicaciÃ³n', error: error.message });
  }
});

// ===== ENDPOINTS ADMIN (CRUD) =====

app.post('/api/admin/locations/countries', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, isActive = true } = req.body;
    if (!name || !String(name).trim()) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }

    const now = admin.firestore.FieldValue.serverTimestamp();
    const payload = {
      name: String(name).trim(),
      isActive: isActive === true || isActive === 'true',
      createdAt: now,
      updatedAt: now
    };

    const ref = await db.collection('countries').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error creando paÃ­s:', error);
    res.status(500).json({ success: false, message: 'Error creando paÃ­s', error: error.message });
  }
});

app.get('/api/admin/locations/countries', authenticateToken, isAdmin, async (req, res) => {
  try {
    const snapshot = await db.collection('countries').orderBy('name', 'asc').get();
    const countries = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: countries });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error obteniendo paÃ­ses (admin):', error);
    res.status(500).json({ success: false, message: 'Error obteniendo paÃ­ses', error: error.message });
  }
});

app.put('/api/admin/locations/countries/:countryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId } = req.params;
    const { name, isActive } = req.body;

    const ref = db.collection('countries').doc(countryId);
    const doc = await ref.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'PaÃ­s no encontrado' });
    }

    const update = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };
    if (name !== undefined) update.name = String(name).trim();
    if (isActive !== undefined) update.isActive = isActive === true || isActive === 'true';

    await ref.update(update);
    res.json({ success: true, message: 'PaÃ­s actualizado' });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error actualizando paÃ­s:', error);
    res.status(500).json({ success: false, message: 'Error actualizando paÃ­s', error: error.message });
  }
});

app.post('/api/admin/locations/cities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, countryId, isActive = true } = req.body;
    if (!name || !String(name).trim()) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const countryDoc = await db.collection('countries').doc(String(countryId)).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      return res.status(400).json({ success: false, message: 'PaÃ­s no encontrado o inactivo' });
    }

    const now = admin.firestore.FieldValue.serverTimestamp();
    const payload = {
      name: String(name).trim(),
      countryId: String(countryId),
      isActive: isActive === true || isActive === 'true',
      createdAt: now,
      updatedAt: now
    };

    const ref = await db.collection('cities').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error creando ciudad:', error);
    res.status(500).json({ success: false, message: 'Error creando ciudad', error: error.message });
  }
});

app.get('/api/admin/locations/cities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId } = req.query;
    let query = db.collection('cities');
    if (countryId) query = query.where('countryId', '==', String(countryId));
    const snapshot = await query.orderBy('name', 'asc').get();
    const cities = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: cities });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error obteniendo ciudades (admin):', error);
    res.status(500).json({ success: false, message: 'Error obteniendo ciudades', error: error.message });
  }
});

app.put('/api/admin/locations/cities/:cityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { cityId } = req.params;
    const { name, countryId, isActive } = req.body;

    const ref = db.collection('cities').doc(cityId);
    const doc = await ref.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Ciudad no encontrada' });
    }

    const update = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };
    if (name !== undefined) update.name = String(name).trim();
    if (countryId !== undefined) {
      const countryDoc = await db.collection('countries').doc(String(countryId)).get();
      if (!countryDoc.exists || countryDoc.data().isActive === false) {
        return res.status(400).json({ success: false, message: 'PaÃ­s no encontrado o inactivo' });
      }
      update.countryId = String(countryId);
    }
    if (isActive !== undefined) update.isActive = isActive === true || isActive === 'true';

    await ref.update(update);
    res.json({ success: true, message: 'Ciudad actualizada' });
  } catch (error) {
    console.error('âŒ [LOCATIONS] Error actualizando ciudad:', error);
    res.status(500).json({ success: false, message: 'Error actualizando ciudad', error: error.message });
  }
});

// Crear recomendaciÃ³n (usuario app) - queda pendiente de aprobaciÃ³n
app.post('/api/recommendations', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      countryId,
      cityId
    } = req.body;

    if (!categoryId || !name) {
      return res.status(400).json({
        success: false,
        message: 'categoryId y name son requeridos'
      });
    }

    // Verificar que la categorÃ­a existe y estÃ¡ activa
    const categoryDoc = await db.collection('categories').doc(categoryId).get();
    if (!categoryDoc.exists || !categoryDoc.data().isActive) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a seleccionada no existe o estÃ¡ inactiva'
      });
    }

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({
        success: false,
        message: err.message
      });
    }

    const recommendationData = {
      categoryId,
      name: name.trim(),
      description: description ? description.trim() : '',
      address: address ? address.trim() : '',
      latitude: latitude !== undefined && latitude !== null ? parseFloat(latitude) : null,
      longitude: longitude !== undefined && longitude !== null ? parseFloat(longitude) : null,
      phone: phone ? phone.trim() : '',
      email: email ? email.trim() : '',
      website: website ? website.trim() : '',
      facebook: facebook ? facebook.trim() : '',
      instagram: instagram ? instagram.trim() : '',
      twitter: twitter ? twitter.trim() : '',
      whatsapp: whatsapp ? whatsapp.trim() : '',
      imageUrl: imageUrl || null,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      // Campos de control/moderaciÃ³n
      isActive: false, // pendiente de aprobaciÃ³n
      verified: false,
      status: 'pending',
      submittedBy: userId,
      submittedAt: admin.firestore.FieldValue.serverTimestamp(),
      // Stats iniciales
      totalReviews: 0,
      averageRating: 0,
      // Badges y features por defecto
      badges: [],
      features: {
        hasChangingTable: false,
        hasNursingRoom: false,
        hasParking: false,
        isStrollerAccessible: false,
        acceptsEmergencies: false,
        is24Hours: false
      },
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    const recRef = await db.collection('recommendations').add(recommendationData);

    console.log('âœ… [APP] RecomendaciÃ³n creada (pending):', recRef.id);

    res.status(201).json({
      success: true,
      message: 'RecomendaciÃ³n enviada para revisiÃ³n',
      data: {
        id: recRef.id,
        ...recommendationData
      }
    });
  } catch (error) {
    console.error('âŒ [APP] Error creando recomendaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando recomendaciÃ³n',
      error: error.message
    });
  }
});

// ===== ENDPOINTS PARA LA APP (SOLO LECTURA) =====

// Obtener todas las categorÃ­as activas (para la app)
app.get('/api/categories', authenticateToken, async (req, res) => {
  try {
    console.log('ðŸ“‚ [APP] Obteniendo categorÃ­as');

    const snapshot = await db.collection('categories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .get();

    const categories = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      description: doc.data().description,
      imageUrl: doc.data().imageUrl,
      order: doc.data().order,
      icon: doc.data().icon
    }));

    res.json({
      success: true,
      data: categories
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Obtener una categorÃ­a especÃ­fica (para la app)
app.get('/api/categories/:categoryId', authenticateToken, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('ðŸ“‚ [APP] Obteniendo categorÃ­a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const categoryData = categoryDoc.data();

    if (!categoryData.isActive) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no disponible'
      });
    }

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        name: categoryData.name,
        description: categoryData.description,
        imageUrl: categoryData.imageUrl,
        order: categoryData.order,
        icon: categoryData.icon
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­a',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN (CRUD COMPLETO) =====

// Obtener todas las categorÃ­as (admin)
app.get('/api/admin/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('ðŸ“‚ [ADMIN] Obteniendo categorÃ­as');

    const snapshot = await db.collection('categories')
      .orderBy('order', 'asc')
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    // Filtrar por bÃºsqueda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(category => 
        category.name?.toLowerCase().includes(searchLower) ||
        category.description?.toLowerCase().includes(searchLower)
      );
    }

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedCategories = categories.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedCategories,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: categories.length,
        totalPages: Math.ceil(categories.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Obtener una categorÃ­a especÃ­fica (admin)
app.get('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('ðŸ“‚ [ADMIN] Obteniendo categorÃ­a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const categoryData = categoryDoc.data();

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        ...categoryData,
        createdAt: categoryData.createdAt?.toDate(),
        updatedAt: categoryData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­a',
      error: error.message
    });
  }
});

// Crear nueva categorÃ­a (admin)
app.post('/api/admin/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, imageUrl, icon, order, isActive = true } = req.body;
    
    console.log('âž• [ADMIN] Creando nueva categorÃ­a:', name);

    // Validaciones
    if (!name || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la categorÃ­a es requerido'
      });
    }

    // Si no se proporciona orden, obtener el siguiente nÃºmero
    let categoryOrder = order;
    if (categoryOrder === undefined || categoryOrder === null) {
      const snapshot = await db.collection('categories').get();
      categoryOrder = snapshot.size;
    }

    const categoryData = {
      name: name.trim(),
      description: description ? description.trim() : '',
      imageUrl: imageUrl || null,
      icon: icon || null,
      order: parseInt(categoryOrder),
      isActive: isActive === true || isActive === 'true',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const categoryRef = await db.collection('categories').add(categoryData);

    console.log('âœ… [ADMIN] CategorÃ­a creada:', categoryRef.id);

    res.json({
      success: true,
      message: 'CategorÃ­a creada exitosamente',
      data: {
        id: categoryRef.id,
        ...categoryData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categorÃ­a',
      error: error.message
    });
  }
});

// Actualizar categorÃ­a (admin)
app.put('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const { name, description, imageUrl, icon, order, isActive } = req.body;
    
    console.log('âœï¸ [ADMIN] Actualizando categorÃ­a:', categoryId);

    const categoryRef = db.collection('categories').doc(categoryId);
    const categoryDoc = await categoryRef.get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (icon !== undefined) updateData.icon = icon;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive === true || isActive === 'true';

    await categoryRef.update(updateData);

    console.log('âœ… [ADMIN] CategorÃ­a actualizada');

    res.json({
      success: true,
      message: 'CategorÃ­a actualizada exitosamente',
      data: {
        id: categoryId,
        ...categoryDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categorÃ­a',
      error: error.message
    });
  }
});

// Eliminar categorÃ­a (admin)
app.delete('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando categorÃ­a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    await db.collection('categories').doc(categoryId).delete();

    console.log('âœ… [ADMIN] CategorÃ­a eliminada');

    res.json({
      success: true,
      message: 'CategorÃ­a eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categorÃ­a',
      error: error.message
    });
  }
});

// Reordenar categorÃ­as (admin)
app.patch('/api/admin/categories/reorder', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categories } = req.body; // Array de { id, order }
    
    console.log('ðŸ”„ [ADMIN] Reordenando categorÃ­as');

    if (!Array.isArray(categories)) {
      return res.status(400).json({
        success: false,
        message: 'Se requiere un array de categorÃ­as'
      });
    }

    const batch = db.batch();

    categories.forEach(({ id, order }) => {
      const categoryRef = db.collection('categories').doc(id);
      batch.update(categoryRef, { 
        order: parseInt(order),
        updatedAt: new Date()
      });
    });

    await batch.commit();

    console.log('âœ… [ADMIN] CategorÃ­as reordenadas:', categories.length);

    res.json({
      success: true,
      message: 'CategorÃ­as reordenadas exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error reordenando categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error reordenando categorÃ­as',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ”— SISTEMA DE COMPARTIR - Links para Posts, Recomendaciones y Listas
// ============================================================================

// ===== ENDPOINTS PÃšBLICOS PARA LINKS COMPARTIDOS =====

// Ver post compartido (pÃºblico - sin autenticaciÃ³n)
app.get('/post/:postId', async (req, res) => {
  try {
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Obtener info del autor
    let authorName = 'Usuario';
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo autor:', error);
    }

    // Obtener info de la comunidad
    let communityName = 'Munpa';
    try {
      const communityDoc = await db.collection('communities').doc(postData.communityId).get();
      if (communityDoc.exists) {
        communityName = communityDoc.data().name || 'Munpa';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo comunidad:', error);
    }

    // Generar HTML para mostrar
    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${authorName} en ${communityName} - Munpa</title>
    <meta property="og:title" content="${authorName} en ${communityName}">
    <meta property="og:description" content="${postData.content.substring(0, 200)}">
    ${postData.imageUrl ? `<meta property="og:image" content="${postData.imageUrl}">` : ''}
    <meta property="og:type" content="article">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .logo {
            font-size: 32px;
            margin-right: 12px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .community {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .author {
            font-weight: 600;
            color: #6366f1;
            margin-bottom: 16px;
        }
        .content {
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }
        .image {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .button {
            display: inline-block;
            background: #6366f1;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: background 0.2s;
        }
        .button:hover {
            background: #4f46e5;
        }
        .stats {
            color: #666;
            font-size: 14px;
            margin-top: 16px;
        }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                // Intent scheme para Android
                window.location.href = 'intent://post/${postId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                // Deep link para iOS
                window.location.href = 'munpa://post/${postId}';
                // Fallback a App Store si no tiene la app
                setTimeout(() => {
                    // Si sigue aquÃ­ despuÃ©s de 2s, no tiene la app
                    // window.location.href = 'https://apps.apple.com/app/munpa/idXXXXXX';
                }, 2000);
            } else {
                // Desktop o desconocido
                window.location.href = 'munpa://post/${postId}';
            }
        }
        
        // Intentar abrir automÃ¡ticamente al cargar
        window.onload = function() {
            // Mostrar el botÃ³n inmediatamente y hacer auto-redirect
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">ðŸ‘¶</div>
            <div class="title">Munpa</div>
        </div>
        <div class="community">ðŸ“¢ ${communityName}</div>
        <div class="author">Por ${authorName}</div>
        ${postData.imageUrl ? `<img src="${postData.imageUrl}" alt="Imagen del post" class="image">` : ''}
        <div class="content">${postData.content}</div>
        <div class="stats">
            â¤ï¸ ${postData.likeCount || 0} likes Â· ðŸ’¬ ${postData.commentCount || 0} comentarios
        </div>
        <br>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Abrir en Munpa ðŸ“±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('âŒ [SHARE] Error mostrando post:', error);
    res.status(500).send(`
      <html>
        <body style="font-family: Arial; padding: 20px; text-align: center;">
          <h2>ðŸ˜• Ups, algo saliÃ³ mal</h2>
          <p>No pudimos cargar esta publicaciÃ³n.</p>
          <a href="https://munpa.online" style="color: #6366f1;">Ir a Munpa</a>
        </body>
      </html>
    `);
  }
});

// Ver recomendaciÃ³n compartida (pÃºblico)
app.get('/recommendation/:recommendationId', async (req, res) => {
  try {
    const { recommendationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'RecomendaciÃ³n no encontrada'
      });
    }

    const recData = recommendationDoc.data();

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${recData.name || 'RecomendaciÃ³n'} - Munpa</title>
    <meta property="og:title" content="${recData.name}">
    <meta property="og:description" content="${recData.description?.substring(0, 200) || 'Lugar recomendado'}">
    ${recData.imageUrl ? `<meta property="og:image" content="${recData.imageUrl}">` : ''}
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .logo { font-size: 32px; margin-bottom: 16px; }
        .title { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 8px; }
        .category { color: #6366f1; font-size: 14px; margin-bottom: 16px; }
        .image { width: 100%; border-radius: 8px; margin-bottom: 20px; }
        .description { font-size: 16px; line-height: 1.6; color: #555; margin-bottom: 20px; }
        .info { color: #666; font-size: 14px; margin: 8px 0; }
        .button { display: inline-block; background: #6366f1; color: white; padding: 12px 24px;
                 border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 16px; }
        .button:hover { background: #4f46e5; }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://recommendation/${recommendationId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://recommendation/${recommendationId}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://recommendation/${recommendationId}';
            }
        }
        
        window.onload = function() {
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸ‘¶ Munpa</div>
        <div class="title">${recData.name || 'RecomendaciÃ³n'}</div>
        <div class="category">ðŸ“ ${recData.categoryName || 'Lugar'}</div>
        ${recData.imageUrl ? `<img src="${recData.imageUrl}" alt="${recData.name}" class="image">` : ''}
        <div class="description">${recData.description || 'Lugar recomendado en Munpa'}</div>
        ${recData.address ? `<div class="info">ðŸ“ ${recData.address}</div>` : ''}
        ${recData.phone ? `<div class="info">ðŸ“ž ${recData.phone}</div>` : ''}
        <div class="info">â­ ${recData.averageRating || 0} (${recData.totalReviews || 0} reseÃ±as)</div>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Abrir en Munpa ðŸ“±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('âŒ [SHARE] Error mostrando recomendaciÃ³n:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// Ver invitaciÃ³n para compartir hijo (pÃºblico)
app.get('/share-child/:token', async (req, res) => {
  try {
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaciÃ³n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).send(`
        <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>InvitaciÃ³n no encontrada - Munpa</title>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                     margin: 0; padding: 20px; background: #f5f5f5; display: flex; justify-content: center;
                     align-items: center; min-height: 100vh; text-align: center; }
              .container { max-width: 400px; background: white; border-radius: 12px; padding: 40px;
                           box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
              .emoji { font-size: 64px; margin-bottom: 20px; }
              h2 { color: #333; margin-bottom: 12px; }
              p { color: #666; line-height: 1.6; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="emoji">ðŸ˜•</div>
              <h2>InvitaciÃ³n no encontrada</h2>
              <p>Esta invitaciÃ³n no existe o ya expirÃ³.</p>
            </div>
          </body>
        </html>
      `);
    }

    const invitationData = invitationsSnapshot.docs[0].data();

    // Verificar si ya fue usada o expirÃ³
    const now = new Date();
    const expiresAt = invitationData.expiresAt?.toDate?.() || invitationData.expiresAt;
    const isExpired = expiresAt && now > expiresAt;
    const isUsed = invitationData.status !== 'pending';

    // Obtener info del usuario que invitÃ³
    let inviterName = 'Usuario';
    try {
      const inviterDoc = await db.collection('users').doc(invitationData.invitedBy).get();
      if (inviterDoc.exists) {
        const inviterData = inviterDoc.data();
        inviterName = inviterData.displayName || inviterData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo invitador:', error);
    }

    // Obtener info del hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    let childPhotoUrl = null;
    let childGender = null;
    if (childDoc.exists) {
      const childData = childDoc.data();
      childPhotoUrl = childData.photoUrl || null;
      childGender = childData.gender || null;
    }

    // Elegir emoji segÃºn gÃ©nero o rol
    const defaultEmoji = childGender === 'niÃ±a' ? 'ðŸ‘§' : childGender === 'niÃ±o' ? 'ðŸ‘¦' : 'ðŸ‘¶';
    const roleEmojis = {
      padre: 'ðŸ‘¨',
      madre: 'ðŸ‘©',
      cuidadora: 'ðŸ‘©â€âš•ï¸',
      familiar: 'ðŸ‘µ',
      otro: 'ðŸ‘¤'
    };
    const roleEmoji = roleEmojis[invitationData.role] || 'ðŸ‘¤';

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${inviterName} te invitÃ³ a ver el perfil de ${invitationData.childName} - Munpa</title>
    <meta property="og:title" content="${inviterName} te invitÃ³ a Munpa">
    <meta property="og:description" content="Quiere compartir el perfil de ${invitationData.childName} contigo">
    ${childPhotoUrl ? `<meta property="og:image" content="${childPhotoUrl}">` : ''}
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 400px;
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
        }
        .logo { font-size: 48px; margin-bottom: 20px; }
        .child-photo {
            width: 120px;
            height: 120px;
            border-radius: 60px;
            object-fit: cover;
            margin: 20px auto;
            border: 4px solid #667eea;
        }
        .child-emoji { font-size: 80px; margin: 20px 0; }
        .inviter {
            color: #667eea;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        .child-name {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin: 16px 0;
        }
        .role {
            display: inline-block;
            background: #f0f0f0;
            color: #666;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            margin: 12px 0;
        }
        .message {
            color: #555;
            font-size: 16px;
            line-height: 1.6;
            margin: 20px 0;
        }
        .button {
            display: block;
            width: 100%;
            background: #667eea;
            color: white;
            padding: 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 24px;
            text-decoration: none;
            box-sizing: border-box;
        }
        .button:hover {
            background: #5568d3;
        }
        .expired {
            background: #ef4444;
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
        }
        .status {
            font-size: 14px;
            color: #888;
            margin-top: 16px;
        }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://share-child/${token}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://share-child/${token}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://share-child/${token}';
            }
        }
        
        window.onload = function() {
            ${!isExpired && !isUsed ? 'setTimeout(openInApp, 100);' : ''}
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸ‘¶ Munpa</div>
        
        ${childPhotoUrl ? 
          `<img src="${childPhotoUrl}" alt="${invitationData.childName}" class="child-photo">` : 
          `<div class="child-emoji">${defaultEmoji}</div>`
        }
        
        <div class="inviter">${roleEmoji} ${inviterName}</div>
        <div class="child-name">${invitationData.childName}</div>
        <div class="role">Como ${invitationData.role}</div>
        
        <div class="message">
            Te ha invitado a ver y compartir el perfil de su ${childGender === 'niÃ±a' ? 'hija' : childGender === 'niÃ±o' ? 'hijo' : 'bebÃ©'} en Munpa.
        </div>
        
        ${isExpired ? 
          '<div class="expired">â° Esta invitaciÃ³n ha expirado</div>' : 
          isUsed ?
            '<div class="expired">âœ… Esta invitaciÃ³n ya fue utilizada</div>' :
            '<button onclick="openInApp()" class="button">Aceptar invitaciÃ³n en Munpa ðŸ“±</button>'
        }
        
        <div class="status">
            ${!isExpired && !isUsed ? 
              `VÃ¡lida hasta: ${expiresAt ? new Date(expiresAt).toLocaleDateString('es-MX', { 
                day: 'numeric', 
                month: 'long', 
                year: 'numeric' 
              }) : 'Sin lÃ­mite'}` : 
              ''
            }
        </div>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('âŒ [SHARE] Error mostrando invitaciÃ³n:', error);
    res.status(500).send(`
      <html>
        <body style="font-family: Arial; padding: 20px; text-align: center;">
          <h2>ðŸ˜• Ups, algo saliÃ³ mal</h2>
          <p>No pudimos cargar esta invitaciÃ³n.</p>
          <a href="https://munpa.online" style="color: #6366f1;">Ir a Munpa</a>
        </body>
      </html>
    `);
  }
});

// Ver producto del marketplace compartido (pÃºblico)
app.get('/marketplace/product/:productId', async (req, res) => {
  try {
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(productId).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    
    let priceText = '';
    if (productData.type === 'venta' && productData.price) {
      priceText = `<div class="price">$${productData.price.toLocaleString('es-MX')}</div>`;
    } else if (productData.type === 'donacion') {
      priceText = '<div class="price" style="color: #10b981;">Â¡Gratis!</div>';
    } else if (productData.type === 'trueque') {
      priceText = '<div class="price" style="color: #f59e0b;">Intercambio</div>';
    }

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${productData.title} - Munpa Marketplace</title>
    <meta property="og:title" content="${productData.title}">
    <meta property="og:description" content="${productData.description?.substring(0, 200) || ''}">
    ${productData.photos?.[0] ? `<meta property="og:image" content="${productData.photos[0]}">` : ''}
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0;
               padding: 20px; background: #f5f5f5; display: flex; justify-content: center; min-height: 100vh; }
        .container { max-width: 600px; background: white; border-radius: 12px; padding: 24px;
                     box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .logo { font-size: 32px; margin-bottom: 16px; }
        .title { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 8px; }
        .price { font-size: 28px; font-weight: bold; color: #6366f1; margin-bottom: 16px; }
        .image { width: 100%; border-radius: 8px; margin-bottom: 20px; }
        .description { font-size: 16px; line-height: 1.6; color: #555; margin-bottom: 20px; }
        .info { color: #666; font-size: 14px; margin: 8px 0; }
        .button { display: inline-block; background: #6366f1; color: white; padding: 12px 24px;
                 border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 16px; }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://marketplace/product/${productId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://marketplace/product/${productId}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://marketplace/product/${productId}';
            }
        }
        
        window.onload = function() {
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸ›ï¸ Munpa Marketplace</div>
        <div class="title">${productData.title}</div>
        ${priceText}
        ${productData.photos?.[0] ? `<img src="${productData.photos[0]}" alt="${productData.title}" class="image">` : ''}
        <div class="description">${productData.description || ''}</div>
        <div class="info">ðŸ“¦ ${productData.condition || 'CondiciÃ³n no especificada'}</div>
        <div class="info">ðŸ“ ${productData.location?.city || ''}, ${productData.location?.state || ''}</div>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Ver en Munpa ðŸ“±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('âŒ [SHARE] Error mostrando producto:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// ===== ENDPOINTS PARA GENERAR LINKS =====

// Compartir artÃ­culo (landing con deeplink)
app.get('/article/:articleId', async (req, res) => {
  try {
    const { articleId } = req.params;

    if (!db) {
      return res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Base de datos no disponible</h2></body></html>');
    }

    const articleDoc = await db.collection('articles').doc(articleId).get();
    if (!articleDoc.exists) {
      return res.status(404).send('<html><body style="padding:20px;text-align:center;"><h2>ArtÃ­culo no encontrado</h2></body></html>');
    }

    const articleData = articleDoc.data();
    const title = articleData.title || 'ArtÃ­culo en Munpa';
    const description = articleData.summary || stripHtml(articleData.htmlContent || '').substring(0, 200) || '';
    const imageUrl = articleData.coverImageUrl || '';

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <meta property="og:title" content="${title}">
  <meta property="og:description" content="${description}">
  ${imageUrl ? `<meta property="og:image" content="${imageUrl}">` : ''}
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 640px; margin: 0 auto; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .title { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
    .description { font-size: 15px; line-height: 1.6; color: #555; margin-bottom: 16px; }
    .button { display: inline-block; background: #6366f1; color: white; padding: 12px 20px; border-radius: 8px; text-decoration: none; font-weight: 600; }
  </style>
  <script>
    function openInApp() {
      const isAndroid = /Android/i.test(navigator.userAgent);
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (isAndroid) {
        window.location.href = 'intent://article/${articleId}#Intent;scheme=munpa;package=com.munpa.app;end';
      } else if (isIOS) {
        window.location.href = 'munpa://article/${articleId}';
        setTimeout(() => {}, 2000);
      } else {
        window.location.href = 'munpa://article/${articleId}';
      }
    }
    window.onload = function() { setTimeout(openInApp, 100); };
  </script>
</head>
<body>
  <div class="container">
    <div class="title">${title}</div>
    <div class="description">${description}</div>
    <a class="button" href="munpa://article/${articleId}">Abrir en Munpa</a>
  </div>
</body>
</html>
    `;

    res.send(html);
  } catch (error) {
    console.error('âŒ [SHARE] Error mostrando artÃ­culo:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// Compartir post de comunidad
app.get('/api/posts/:postId/share', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Obtener info del autor
    let authorName = 'Usuario';
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo autor:', error);
    }

    // Obtener info de la comunidad
    let communityName = 'Munpa';
    try {
      const communityDoc = await db.collection('communities').doc(postData.communityId).get();
      if (communityDoc.exists) {
        communityName = communityDoc.data().name || 'Munpa';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo comunidad:', error);
    }

    // Generar links
    const shareUrl = `munpa://post/${postId}`;
    const webUrl = `https://munpa.online/post/${postId}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `${authorName} en ${communityName}`,
      description: postData.content?.substring(0, 200) || 'Ver publicaciÃ³n en Munpa',
      imageUrl: postData.imageUrl || null,
      metadata: {
        postId,
        authorName,
        communityName,
        communityId: postData.communityId,
        likes: postData.likeCount || 0,
        comments: postData.commentCount || 0
      }
    };

    console.log(`âœ… [SHARE] Link generado para post: ${postId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error generando link de post:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir recomendaciÃ³n
app.get('/api/recommendations/:recommendationId/share', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la recomendaciÃ³n
    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'RecomendaciÃ³n no encontrada'
      });
    }

    const recommendationData = recommendationDoc.data();

    // Obtener info de la categorÃ­a
    let categoryName = 'Lugar';
    try {
      if (recommendationData.categoryId) {
        const categoryDoc = await db.collection('categories').doc(recommendationData.categoryId).get();
        if (categoryDoc.exists) {
          categoryName = categoryDoc.data().name || 'Lugar';
        }
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo categorÃ­a:', error);
    }

    // Generar links
    const shareUrl = `munpa://recommendation/${recommendationId}`;
    const webUrl = `https://munpa.online/recommendation/${recommendationId}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: recommendationData.name || 'RecomendaciÃ³n en Munpa',
      description: recommendationData.description?.substring(0, 200) || `${categoryName} recomendado en Munpa`,
      imageUrl: recommendationData.imageUrl || null,
      metadata: {
        recommendationId,
        categoryName,
        categoryId: recommendationData.categoryId,
        address: recommendationData.address,
        phone: recommendationData.phone,
        averageRating: recommendationData.averageRating || 0,
        totalReviews: recommendationData.totalReviews || 0,
        verified: recommendationData.verified || false
      }
    };

    console.log(`âœ… [SHARE] Link generado para recomendaciÃ³n: ${recommendationId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error generando link de recomendaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir producto del marketplace
app.get('/api/marketplace/products/:productId/share', authenticateToken, async (req, res) => {
  try {
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el producto
    const productDoc = await db.collection('marketplace_products').doc(productId).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();

    // Generar links
    const shareUrl = `munpa://marketplace/product/${productId}`;
    const webUrl = `https://munpa.online/marketplace/product/${productId}`;

    let description = productData.description?.substring(0, 200) || '';
    
    // Agregar precio si es venta
    if (productData.type === 'venta' && productData.price) {
      description = `$${productData.price.toLocaleString('es-MX')} - ${description}`;
    } else if (productData.type === 'donacion') {
      description = `Â¡Gratis! ${description}`;
    } else if (productData.type === 'trueque') {
      description = `Intercambio - ${description}`;
    }

    const shareData = {
      shareUrl,
      webUrl,
      title: productData.title || 'Producto en Munpa Marketplace',
      description,
      imageUrl: productData.photos?.[0] || null,
      metadata: {
        productId,
        categoryName: productData.categoryName,
        condition: productData.condition,
        type: productData.type,
        price: productData.price,
        location: {
          city: productData.location?.city,
          state: productData.location?.state
        },
        userName: productData.userName,
        status: productData.status
      }
    };

    console.log(`âœ… [SHARE] Link generado para producto: ${productId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error generando link de producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir lista de favoritos del marketplace
app.get('/api/marketplace/favorites/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener favoritos del usuario
    const favoritesSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .limit(10) // Primeros 10 para el preview
      .get();

    const favoriteCount = favoritesSnapshot.size;

    // Obtener info del usuario
    let userName = 'Usuario';
    try {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userName = userData.displayName || userData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo usuario:', error);
    }

    // Generar links
    const shareUrl = `munpa://marketplace/favorites/${uid}`;
    const webUrl = `https://munpa.online/marketplace/favorites/${uid}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `Favoritos de ${userName} en Munpa`,
      description: `Descubre ${favoriteCount} productos favoritos de ${userName} en Munpa Marketplace`,
      imageUrl: null, // PodrÃ­amos agregar una imagen compuesta de los favoritos
      metadata: {
        userId: uid,
        userName,
        favoriteCount
      }
    };

    console.log(`âœ… [SHARE] Link generado para lista de favoritos de: ${uid}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error generando link de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir lista de recomendaciones favoritas
app.get('/api/recommendations/favorites/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener favoritos del usuario
    const favoritesSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', uid)
      .limit(10) // Primeros 10 para el preview
      .get();

    const favoriteCount = favoritesSnapshot.size;

    // Obtener info del usuario
    let userName = 'Usuario';
    try {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userName = userData.displayName || userData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo usuario:', error);
    }

    // Generar links
    const shareUrl = `munpa://recommendations/favorites/${uid}`;
    const webUrl = `https://munpa.online/recommendations/favorites/${uid}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `Lugares favoritos de ${userName}`,
      description: `Descubre ${favoriteCount} lugares recomendados por ${userName} en Munpa`,
      imageUrl: null,
      metadata: {
        userId: uid,
        userName,
        favoriteCount
      }
    };

    console.log(`âœ… [SHARE] Link generado para favoritos de recomendaciones de: ${uid}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error generando link de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// ========== GESTIÃ“N DE RECOMENDADOS ==========

// ===== ENDPOINTS PARA LA APP (SOLO LECTURA) =====

// Obtener todos los recomendados activos (para la app)
app.get('/api/recommendations', authenticateToken, async (req, res) => {
  try {
    const { categoryId, page = 1, limit = 20, latitude, longitude, cityId, countryId, maxDistanceKm = 100 } = req.query;
    
    const pageNumber = parseInt(page);
    const limitNumber = parseInt(limit);
    
    console.log('â­ [APP] Obteniendo recomendados', categoryId ? `para categorÃ­a: ${categoryId}` : '', `(pÃ¡gina ${pageNumber}, lÃ­mite ${limitNumber})`);

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'UbicaciÃ³n no disponible. EnvÃ­a latitude/longitude o actualiza tu perfil.'
        });
      }
    }

      const cacheKey = `${req.path}?uid=${req.user.uid}&categoryId=${categoryId || ''}&page=${pageNumber}&limit=${limitNumber}&lat=${Number.isFinite(userLat) ? userLat : ''}&lng=${Number.isFinite(userLng) ? userLng : ''}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}&maxDistanceKm=${maxDistanceKm}`;
      const cached = getCachedResponse(cacheKey);
      if (cached) {
        return res.json(cached);
      }

      let query = db.collection('recommendations')
        .where('isActive', '==', true);
      if (effectiveCountryId) {
        query = query.where('countryId', '==', effectiveCountryId);
      }
      if (categoryId) {
        query = query.where('categoryId', '==', categoryId);
      }

      const snapshot = await query.get();
      const categoriesMap = await getCategoriesMap();
      const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
        const data = doc.data();
        const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          facebook: data.facebook,
          instagram: data.instagram,
          twitter: data.twitter,
          whatsapp: data.whatsapp,
          imageUrl: data.imageUrl,
          totalReviews: data.totalReviews || 0,
          averageRating: data.averageRating || 0,
          category: categoryInfo,
          ...buildLocationFields(data),
          // Badges y features
          verified: data.verified || false,
          badges: data.badges || [],
          features: data.features || {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          }
        };
      }));

      const filtered = filterRecommendationsByLocation({
        items: baseList,
        userLat: Number.isFinite(userLat) ? userLat : null,
        userLng: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm
      }).sort((a, b) => {
        const aDist = typeof a.distance === 'number' ? a.distance : Number.POSITIVE_INFINITY;
        const bDist = typeof b.distance === 'number' ? b.distance : Number.POSITIVE_INFINITY;
        return aDist - bDist;
      });

      const total = filtered.length;
      const startIndex = (pageNumber - 1) * limitNumber;
      const endIndex = startIndex + limitNumber;
      const paginated = filtered.slice(startIndex, endIndex);

      const responsePayload = {
        success: true,
        data: paginated,
        pagination: {
          total,
          page: pageNumber,
          limit: limitNumber,
          totalPages: Math.ceil(total / limitNumber),
          hasNextPage: pageNumber * limitNumber < total,
          hasPreviousPage: pageNumber > 1
        },
        meta: {
          latitude: Number.isFinite(userLat) ? userLat : null,
          longitude: Number.isFinite(userLng) ? userLng : null,
          cityId: effectiveCityId,
          countryId: effectiveCountryId,
          maxDistanceKm: Math.min(Math.max(Number(maxDistanceKm) || 100, 1), 100)
        }
      };

      setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
      return res.json(responsePayload);

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendados',
      error: error.message
    });
  }
});

// Buscar recomendados por texto (APP)
app.get('/api/recommendations/search', authenticateToken, async (req, res) => {
  try {
    const { q, categoryId, page = 1, limit = 20 } = req.query;

    if (!q || !String(q).trim()) {
      return res.status(400).json({
        success: false,
        message: 'q es requerido'
      });
    }

    const pageNumber = parseInt(page);
    const limitNumber = parseInt(limit);

    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = Number.isFinite(parseFloat(profileLocation.latitude)) ? parseFloat(profileLocation.latitude) : null;
    const userLng = Number.isFinite(parseFloat(profileLocation.longitude)) ? parseFloat(profileLocation.longitude) : null;
    const effectiveCityId = profileLocation.cityId || null;
    const effectiveCountryId = profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'UbicaciÃ³n no disponible. Actualiza tu perfil antes de buscar.'
        });
      }
    }

    const cacheKey = `${req.path}?uid=${req.user.uid}&q=${String(q).trim().toLowerCase()}&categoryId=${categoryId || ''}&page=${pageNumber}&limit=${limitNumber}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }
    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();
    const searchText = String(q).trim().toLowerCase();

    const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

      return {
        id: doc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        facebook: data.facebook,
        instagram: data.instagram,
        twitter: data.twitter,
        whatsapp: data.whatsapp,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    const textMatches = baseList.filter(item => {
      const haystack = [
        item.name,
        item.description,
        item.address
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      return haystack.includes(searchText);
    });

    const filtered = filterRecommendationsByLocation({
      items: textMatches,
      userLat: Number.isFinite(userLat) ? userLat : null,
      userLng: Number.isFinite(userLng) ? userLng : null,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: 100
    }).sort((a, b) => {
      const aDist = Number.isFinite(a.distance) ? a.distance : Number.POSITIVE_INFINITY;
      const bDist = Number.isFinite(b.distance) ? b.distance : Number.POSITIVE_INFINITY;
      return aDist - bDist;
    });

    const total = filtered.length;
    const startIndex = (pageNumber - 1) * limitNumber;
    const endIndex = startIndex + limitNumber;
    const paginated = filtered.slice(startIndex, endIndex);

    const responsePayload = {
      success: true,
      data: paginated,
      pagination: {
        total,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(total / limitNumber),
        hasNextPage: pageNumber * limitNumber < total,
        hasPreviousPage: pageNumber > 1
      },
      meta: {
        query: searchText,
        latitude: Number.isFinite(userLat) ? userLat : null,
        longitude: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm: 100
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ [APP] Error buscando recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error buscando recomendados',
      error: error.message
    });
  }
});

// ===== ENDPOINTS DE FAVORITOS (DEBEN IR ANTES DE :recommendationId) =====

// Obtener recomendaciones cercanas ordenadas por distancia (APP)
app.get('/api/recommendations/nearby', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude, radius = 10, categoryId, limit = 20, cityId, countryId } = req.query;
    
    console.log('ðŸ“ [APP] Obteniendo recomendaciones cercanas:', { latitude, longitude, radius });

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'UbicaciÃ³n no disponible. Actualiza tu perfil antes de buscar.'
      });
    }

    const maxRadius = Math.min(parseFloat(radius), 100);

    // Obtener recomendaciones activas (filtrar por categorÃ­a si se proporciona)
    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();

    // Calcular distancia para cada recomendaciÃ³n y filtrar por radio
    const recommendationsWithDistance = await Promise.all(
      snapshot.docs.map(async (doc) => {
        const data = doc.data();
        let distance = null;
        let estimatedTime = null;
        if (data.latitude && data.longitude) {
          distance = calculateDistance(
            userLat,
            userLng,
            data.latitude,
            data.longitude
          );
          estimatedTime = calculateEstimatedTime(distance);
        }

          // Obtener informaciÃ³n de la categorÃ­a
          const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          imageUrl: data.imageUrl,
          totalReviews: data.totalReviews || 0,
          averageRating: data.averageRating || 0,
          distance: typeof distance === 'number' ? Math.round(distance * 10) / 10 : null,
          estimatedTime,
          category: categoryInfo,
          ...buildLocationFields(data),
          // Badges y features
          verified: data.verified || false,
          badges: data.badges || [],
          features: data.features || {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          }
        };
      })
    );

    const baseList = recommendationsWithDistance.filter(rec => rec !== null);
    const filtered = filterRecommendationsByLocation({
      items: baseList,
      userLat,
      userLng,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: maxRadius
    }).sort((a, b) => {
      const aDist = typeof a.distance === 'number' ? a.distance : Number.POSITIVE_INFINITY;
      const bDist = typeof b.distance === 'number' ? b.distance : Number.POSITIVE_INFINITY;
      return aDist - bDist;
    });

    const validRecommendations = filtered.slice(0, parseInt(limit));

    res.json({
      success: true,
      data: validRecommendations,
      metadata: {
        userLocation: {
          latitude: userLat,
          longitude: userLng
        },
        radius: maxRadius,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        found: validRecommendations.length
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo recomendaciones cercanas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones cercanas',
      error: error.message
    });
  }
});

// Obtener top 3 recomendaciones mejor calificadas y cercanas (APP)
app.get('/api/recommendations/nearby/top', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude, radius = 10, categoryId, limit = 3, minReviews = 0, minRating = 0, cityId, countryId } = req.query;
    
    console.log('â­ðŸ“ [APP] Top recomendaciones cercanas:', { latitude, longitude, radius });

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'UbicaciÃ³n no disponible. Actualiza tu perfil antes de buscar.'
      });
    }

    const cacheKey = `${req.path}?uid=${req.user.uid}&lat=${userLat}&lng=${userLng}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}&radius=${radius}&categoryId=${categoryId || ''}&limit=${limit}&minReviews=${minReviews}&minRating=${minRating}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }
    const maxRadius = Math.min(parseFloat(radius), 100);
    const limitNumber = Math.min(parseInt(limit), 10);
    const minReviewsNumber = Math.max(parseInt(minReviews), 0);
    const minRatingNumber = Math.max(parseFloat(minRating), 0);

    if (isNaN(userLat) || isNaN(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'Latitude y longitude deben ser nÃºmeros vÃ¡lidos'
      });
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();

    const recommendationsWithDistance = await Promise.all(
      snapshot.docs.map(async (doc) => {
        const data = doc.data();
        let distance = null;
        if (data.latitude && data.longitude) {
          distance = calculateDistance(
            userLat,
            userLng,
            data.latitude,
            data.longitude
          );
        }

        const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        const totalReviews = data.totalReviews || 0;
        const averageRating = data.averageRating || 0;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          imageUrl: data.imageUrl,
          totalReviews: totalReviews,
          averageRating: averageRating,
          rating: averageRating,
          reviews: totalReviews,
          distance: typeof distance === 'number' ? Math.round(distance * 10) / 10 : null,
          category: categoryInfo,
          ...buildLocationFields(data),
          verified: data.verified || false,
          badges: data.badges || []
        };
      })
    );

    const baseList = recommendationsWithDistance.filter(rec => rec !== null);
    const locationFiltered = filterRecommendationsByLocation({
      items: baseList,
      userLat,
      userLng,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: maxRadius
    });

    const preferDistance = minReviewsNumber === 0 && minRatingNumber === 0;
    const allSorted = locationFiltered
      .sort((a, b) => {
        if (preferDistance) {
          if (a.distance !== b.distance) return a.distance - b.distance;
          if (b.averageRating !== a.averageRating) return b.averageRating - a.averageRating;
          return b.totalReviews - a.totalReviews;
        }
        if (b.averageRating !== a.averageRating) return b.averageRating - a.averageRating;
        if (a.distance !== b.distance) return a.distance - b.distance;
        return b.totalReviews - a.totalReviews;
      });

    const radiusSteps = [maxRadius];
    let usedFallback = false;
    let validRecommendations = [];

    const ratedOnly = allSorted
      .filter(rec => rec.totalReviews >= minReviewsNumber && rec.averageRating >= minRatingNumber);

    for (const stepRadius of radiusSteps) {
      const baseList = preferDistance ? allSorted : ratedOnly;
      const withinRadius = baseList.filter(rec => rec.distance <= stepRadius);
      validRecommendations = withinRadius.slice(0, limitNumber);
      if (validRecommendations.length >= limitNumber) break;
    }

    if (validRecommendations.length < limitNumber) {
      usedFallback = true;
    }

    const responsePayload = {
      success: true,
      data: validRecommendations,
      meta: {
        latitude: userLat,
        longitude: userLng,
        radius: maxRadius,
        limit: limitNumber,
        minReviews: minReviewsNumber,
        minRating: minRatingNumber,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        filledWithFallback: usedFallback
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ [APP] Error obteniendo top recomendaciones cercanas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones cercanas',
      error: error.message
    });
  }
});

// FunciÃ³n auxiliar para calcular distancia usando fÃ³rmula de Haversine
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radio de la Tierra en km
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;
  
  return distance;
}

// FunciÃ³n auxiliar para convertir grados a radianes
function toRad(degrees) {
  return degrees * (Math.PI / 180);
}

// FunciÃ³n auxiliar para calcular tiempo estimado
function calculateEstimatedTime(distanceKm) {
  const avgSpeedKmH = 40; // Velocidad promedio en ciudad (km/h)
  const timeInHours = distanceKm / avgSpeedKmH;
  const timeInMinutes = Math.round(timeInHours * 60);
  
  if (timeInMinutes < 1) {
    return "menos de 1 min";
  } else if (timeInMinutes < 60) {
    return `${timeInMinutes} min`;
  } else {
    const hours = Math.floor(timeInMinutes / 60);
    const minutes = timeInMinutes % 60;
    if (minutes === 0) {
      return `${hours} ${hours === 1 ? 'hora' : 'horas'}`;
    }
    return `${hours} h ${minutes} min`;
  }
}

// Obtener las 10 recomendaciones mÃ¡s recientes (APP)
app.get('/api/recommendations/recent', authenticateToken, async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    
    console.log('ðŸ†• [APP] Obteniendo recomendaciones recientes');

    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = Number.isFinite(parseFloat(profileLocation.latitude)) ? parseFloat(profileLocation.latitude) : null;
    const userLng = Number.isFinite(parseFloat(profileLocation.longitude)) ? parseFloat(profileLocation.longitude) : null;
    const effectiveCityId = profileLocation.cityId || null;
    const effectiveCountryId = profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'UbicaciÃ³n no disponible. Actualiza tu perfil antes de buscar.'
        });
      }
    }

    const limitNumber = Math.max(parseInt(limit), 1);
    const fetchLimit = Math.min(Math.max(limitNumber * 5, limitNumber), 100);

    const cacheKey = `${req.path}?uid=${req.user.uid}&limit=${limitNumber}&lat=${Number.isFinite(userLat) ? userLat : ''}&lng=${Number.isFinite(userLng) ? userLng : ''}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }

    // Obtener las recomendaciones mÃ¡s recientes ordenadas por createdAt
    const snapshot = await query
      .orderBy('createdAt', 'desc')
      .limit(fetchLimit)
      .get();

    const categoriesMap = await getCategoriesMap();
    const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      
      // Obtener informaciÃ³n de la categorÃ­a
      const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

      // Contar comentarios de reviews
      const reviewsSnapshot = await db.collection('recommendationReviews')
        .where('recommendationId', '==', doc.id)
        .get();

      const commentsCount = reviewsSnapshot.docs.filter(reviewDoc => {
        const reviewData = reviewDoc.data();
        return reviewData.comment && reviewData.comment.trim().length > 0;
      }).length;

      return {
        id: doc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        commentsCount: commentsCount,
        category: categoryInfo,
        ...buildLocationFields(data),
        createdAt: data.createdAt?.toDate(),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    const filtered = filterRecommendationsByLocation({
      items: baseList,
      userLat: Number.isFinite(userLat) ? userLat : null,
      userLng: Number.isFinite(userLng) ? userLng : null,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: 100
    });

    const recommendations = filtered.slice(0, limitNumber);

    const responsePayload = {
      success: true,
      data: recommendations,
      meta: {
        latitude: Number.isFinite(userLat) ? userLat : null,
        longitude: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm: 100
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
    res.json(responsePayload);

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo recomendaciones recientes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones recientes',
      error: error.message
    });
  }
});

// Obtener mis recomendados favoritos (APP)
app.get('/api/recommendations/favorites', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    
    console.log('â¤ï¸ [APP] Obteniendo favoritos del usuario:', userId);

    // Obtener IDs de favoritos del usuario
    const favoritesSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .get();

    if (favoritesSnapshot.empty) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener los recomendados completos
    const recommendationIds = favoritesSnapshot.docs.map(doc => doc.data().recommendationId);
    
    const recommendations = await Promise.all(recommendationIds.map(async (recId) => {
      const recDoc = await db.collection('recommendations').doc(recId).get();
      
      if (!recDoc.exists) return null;
      
      const data = recDoc.data();
      
      // Obtener informaciÃ³n de la categorÃ­a
      let categoryInfo = null;
      if (data.categoryId) {
        const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name,
            icon: catData.icon
          };
        }
      }

      return {
        id: recDoc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        isFavorite: true,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    // Filtrar nulls (recomendados que ya no existen)
    const validRecommendations = recommendations.filter(rec => rec !== null);

    res.json({
      success: true,
      data: validRecommendations
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo favoritos',
      error: error.message
    });
  }
});

// Verificar si un recomendado es favorito (APP)
app.get('/api/recommendations/:recommendationId/favorite', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('â¤ï¸ [APP] Verificando si es favorito:', recommendationId);

    const favoriteSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    res.json({
      success: true,
      isFavorite: !favoriteSnapshot.empty
    });

  } catch (error) {
    console.error('âŒ [APP] Error verificando favorito:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando favorito',
      error: error.message
    });
  }
});

// Agregar/quitar recomendado de favoritos (toggle) (APP)
app.post('/api/recommendations/:recommendationId/favorite', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('â¤ï¸ [APP] Toggle favorito para recomendado:', recommendationId);

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si ya es favorito
    const favoriteSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (favoriteSnapshot.empty) {
      // Agregar a favoritos
      await db.collection('recommendationFavorites').add({
        userId,
        recommendationId,
        createdAt: new Date()
      });

      console.log('âœ… [APP] Agregado a favoritos');

      res.json({
        success: true,
        message: 'Agregado a favoritos',
        isFavorite: true
      });
    } else {
      // Quitar de favoritos
      await favoriteSnapshot.docs[0].ref.delete();

      console.log('âœ… [APP] Eliminado de favoritos');

      res.json({
        success: true,
        message: 'Eliminado de favoritos',
        isFavorite: false
      });
    }

  } catch (error) {
    console.error('âŒ [APP] Error con favorito:', error);
    res.status(500).json({
      success: false,
      message: 'Error al marcar como favorito',
      error: error.message
    });
  }
});

// ===== ENDPOINTS DE WISHLIST (LISTA DE DESEOS) =====

// Agregar a wishlist (APP)
app.post('/api/recommendations/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { recommendationId, notes, priority = 'medium' } = req.body;

    console.log('ðŸ’ [APP] Agregando a wishlist:', recommendationId);

    // Validaciones
    if (!recommendationId) {
      return res.status(400).json({
        success: false,
        message: 'El recommendationId es requerido'
      });
    }

    if (priority && !['high', 'medium', 'low'].includes(priority)) {
      return res.status(400).json({
        success: false,
        message: 'La prioridad debe ser: high, medium o low'
      });
    }

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si ya estÃ¡ en la wishlist
    const existingWishlist = await db.collection('recommendationWishlist')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (!existingWishlist.empty) {
      return res.status(400).json({
        success: false,
        message: 'Este recomendado ya estÃ¡ en tu lista de deseos'
      });
    }

    // Agregar a wishlist
    const wishlistData = {
      userId,
      recommendationId,
      notes: notes || '',
      priority: priority || 'medium',
      addedAt: new Date(),
      createdAt: new Date()
    };

    const wishlistRef = await db.collection('recommendationWishlist').add(wishlistData);

    console.log('âœ… [APP] Agregado a wishlist:', wishlistRef.id);

    res.json({
      success: true,
      message: 'Agregado a tu lista de deseos',
      data: {
        id: wishlistRef.id,
        ...wishlistData
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error agregando a wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando a lista de deseos',
      error: error.message
    });
  }
});

// Obtener mi wishlist (APP)
app.get('/api/recommendations/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { priority } = req.query;

    console.log('ðŸ’ [APP] Obteniendo wishlist del usuario:', userId);

    // Query base
    let query = db.collection('recommendationWishlist')
      .where('userId', '==', userId);

    // Filtrar por prioridad si se especifica
    if (priority) {
      if (!['high', 'medium', 'low'].includes(priority)) {
        return res.status(400).json({
          success: false,
          message: 'La prioridad debe ser: high, medium o low'
        });
      }
      query = query.where('priority', '==', priority);
    }

    const wishlistSnapshot = await query.get();

    if (wishlistSnapshot.empty) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener los recomendados completos
    const wishlistItems = await Promise.all(wishlistSnapshot.docs.map(async (doc) => {
      const wishlistData = doc.data();
      const recDoc = await db.collection('recommendations').doc(wishlistData.recommendationId).get();

      if (!recDoc.exists) return null;

      const recData = recDoc.data();

      // Solo incluir recomendados activos
      if (!recData.isActive) return null;

      // Obtener informaciÃ³n de la categorÃ­a
      let categoryInfo = null;
      if (recData.categoryId) {
        const categoryDoc = await db.collection('categories').doc(recData.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name,
            icon: catData.icon,
            imageUrl: catData.imageUrl
          };
        }
      }

      return {
        // Datos del recomendado
        id: recDoc.id,
        name: recData.name,
        description: recData.description,
        address: recData.address,
        latitude: recData.latitude,
        longitude: recData.longitude,
        phone: recData.phone,
        email: recData.email,
        website: recData.website,
        facebook: recData.facebook,
        instagram: recData.instagram,
        twitter: recData.twitter,
        whatsapp: recData.whatsapp,
        imageUrl: recData.imageUrl,
        totalReviews: recData.totalReviews || 0,
        averageRating: recData.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(recData),
        verified: recData.verified || false,
        badges: recData.badges || [],
        features: recData.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        },
        // Datos de la wishlist
        wishlistId: doc.id,
        addedAt: wishlistData.addedAt?.toDate(),
        notes: wishlistData.notes || '',
        priority: wishlistData.priority || 'medium'
      };
    }));

    // Filtrar nulls (recomendados que ya no existen o no estÃ¡n activos)
    const validItems = wishlistItems.filter(item => item !== null);

    // Ordenar por prioridad (high > medium > low) y luego por fecha
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    validItems.sort((a, b) => {
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return (b.addedAt?.getTime() || 0) - (a.addedAt?.getTime() || 0);
    });

    res.json({
      success: true,
      data: validItems,
      metadata: {
        total: validItems.length,
        byPriority: {
          high: validItems.filter(i => i.priority === 'high').length,
          medium: validItems.filter(i => i.priority === 'medium').length,
          low: validItems.filter(i => i.priority === 'low').length
        }
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo lista de deseos',
      error: error.message
    });
  }
});

// Actualizar item de wishlist (APP)
app.put('/api/recommendations/wishlist/:wishlistId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { wishlistId } = req.params;
    const { notes, priority } = req.body;

    console.log('âœï¸ [APP] Actualizando wishlist item:', wishlistId);

    // Validaciones
    if (priority && !['high', 'medium', 'low'].includes(priority)) {
      return res.status(400).json({
        success: false,
        message: 'La prioridad debe ser: high, medium o low'
      });
    }

    const wishlistRef = db.collection('recommendationWishlist').doc(wishlistId);
    const wishlistDoc = await wishlistRef.get();

    if (!wishlistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Item de wishlist no encontrado'
      });
    }

    const wishlistData = wishlistDoc.data();

    // Verificar que el usuario es el dueÃ±o
    if (wishlistData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para modificar este item'
      });
    }

    // Actualizar
    const updateData = {
      updatedAt: new Date()
    };

    if (notes !== undefined) updateData.notes = notes;
    if (priority !== undefined) updateData.priority = priority;

    await wishlistRef.update(updateData);

    console.log('âœ… [APP] Wishlist item actualizado');

    res.json({
      success: true,
      message: 'Item actualizado exitosamente',
      data: {
        id: wishlistId,
        ...wishlistData,
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error actualizando wishlist item:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando item de wishlist',
      error: error.message
    });
  }
});

// Eliminar de wishlist (APP)
app.delete('/api/recommendations/wishlist/:wishlistId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { wishlistId } = req.params;

    console.log('ðŸ—‘ï¸ [APP] Eliminando de wishlist:', wishlistId);

    const wishlistRef = db.collection('recommendationWishlist').doc(wishlistId);
    const wishlistDoc = await wishlistRef.get();

    if (!wishlistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Item de wishlist no encontrado'
      });
    }

    const wishlistData = wishlistDoc.data();

    // Verificar que el usuario es el dueÃ±o
    if (wishlistData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar este item'
      });
    }

    await wishlistRef.delete();

    console.log('âœ… [APP] Eliminado de wishlist');

    res.json({
      success: true,
      message: 'Eliminado de tu lista de deseos'
    });

  } catch (error) {
    console.error('âŒ [APP] Error eliminando de wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando de lista de deseos',
      error: error.message
    });
  }
});

// Verificar si un recomendado estÃ¡ en wishlist (APP)
app.get('/api/recommendations/:recommendationId/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { recommendationId } = req.params;

    console.log('ðŸ’ [APP] Verificando si estÃ¡ en wishlist:', recommendationId);

    const wishlistSnapshot = await db.collection('recommendationWishlist')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (wishlistSnapshot.empty) {
      return res.json({
        success: true,
        data: {
          inWishlist: false
        }
      });
    }

    const wishlistDoc = wishlistSnapshot.docs[0];
    const wishlistData = wishlistDoc.data();

    res.json({
      success: true,
      data: {
        inWishlist: true,
        wishlistId: wishlistDoc.id,
        addedAt: wishlistData.addedAt?.toDate(),
        notes: wishlistData.notes || '',
        priority: wishlistData.priority || 'medium'
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error verificando wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando lista de deseos',
      error: error.message
    });
  }
});

// Obtener un recomendado especÃ­fico (para la app)
app.get('/api/recommendations/:recommendationId', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('â­ [APP] Obteniendo recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    const data = recDoc.data();

    if (!data.isActive) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no disponible'
      });
    }

    // Obtener informaciÃ³n de la categorÃ­a
    let categoryInfo = null;
    if (data.categoryId) {
      const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
      if (categoryDoc.exists) {
        const catData = categoryDoc.data();
        categoryInfo = {
          id: categoryDoc.id,
          name: catData.name,
          icon: catData.icon,
          imageUrl: catData.imageUrl
        };
      }
    }

    res.json({
      success: true,
      data: {
        id: recDoc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        facebook: data.facebook,
        instagram: data.instagram,
        twitter: data.twitter,
        whatsapp: data.whatsapp,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendado',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN (CRUD COMPLETO) =====

// Obtener todos los recomendados (admin)
app.get('/api/admin/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', categoryId } = req.query;
    
    console.log('â­ [ADMIN] Obteniendo recomendados');

    let query = db.collection('recommendations');

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();

    let recommendations = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      
      // Obtener informaciÃ³n de la categorÃ­a
      let categoryInfo = null;
      if (data.categoryId) {
        const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name
          };
        }
      }

      return {
        id: doc.id,
        ...data,
        category: categoryInfo,
        createdAt: data.createdAt?.toDate(),
        updatedAt: data.updatedAt?.toDate()
      };
    }));

    // Filtrar por bÃºsqueda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      recommendations = recommendations.filter(rec => 
        rec.name?.toLowerCase().includes(searchLower) ||
        rec.description?.toLowerCase().includes(searchLower) ||
        rec.address?.toLowerCase().includes(searchLower)
      );
    }

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedRecommendations = recommendations.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedRecommendations,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: recommendations.length,
        totalPages: Math.ceil(recommendations.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendados',
      error: error.message
    });
  }
});

// Obtener un recomendado especÃ­fico (admin)
app.get('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('â­ [ADMIN] Obteniendo recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    const data = recDoc.data();

    // Obtener informaciÃ³n de la categorÃ­a
    let categoryInfo = null;
    if (data.categoryId) {
      const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
      if (categoryDoc.exists) {
        const catData = categoryDoc.data();
        categoryInfo = {
          id: categoryDoc.id,
          name: catData.name,
          imageUrl: catData.imageUrl
        };
      }
    }

    res.json({
      success: true,
      data: {
        id: recDoc.id,
        ...data,
        category: categoryInfo,
        createdAt: data.createdAt?.toDate(),
        updatedAt: data.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendado',
      error: error.message
    });
  }
});

// Crear nuevo recomendado (admin)
app.post('/api/admin/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      isActive = true,
      countryId,
      cityId,
      // Badges y features
      verified = false,
      badges = [],
      features = {}
    } = req.body;
    
    console.log('âž• [ADMIN] Creando nuevo recomendado:', name);
    console.log('ðŸ“‹ [DEBUG] verified recibido:', verified, 'tipo:', typeof verified);

    // Validaciones
    if (!name || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido'
      });
    }

    if (!categoryId) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a es requerida'
      });
    }

    // Verificar que la categorÃ­a existe
    const categoryDoc = await db.collection('categories').doc(categoryId).get();
    if (!categoryDoc.exists) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a seleccionada no existe'
      });
    }

    // Procesar features con valores por defecto
    const processedFeatures = {
      hasChangingTable: features.hasChangingTable === true,
      hasNursingRoom: features.hasNursingRoom === true,
      hasParking: features.hasParking === true,
      isStrollerAccessible: features.isStrollerAccessible === true,
      acceptsEmergencies: features.acceptsEmergencies === true,
      is24Hours: features.is24Hours === true
    };

    // Generar badges automÃ¡ticamente basados en features
    const autoBadges = [];
    if (processedFeatures.hasChangingTable) autoBadges.push('changing_table');
    if (processedFeatures.hasNursingRoom) autoBadges.push('nursing_room');
    if (processedFeatures.hasParking) autoBadges.push('parking');
    if (processedFeatures.isStrollerAccessible) autoBadges.push('stroller_accessible');
    if (processedFeatures.acceptsEmergencies) autoBadges.push('emergency_24_7');
    if (processedFeatures.is24Hours) autoBadges.push('24_hours');

    // Badge "baby_friendly" si tiene al menos 3 features
    const featuresCount = Object.values(processedFeatures).filter(v => v === true).length;
    if (featuresCount >= 3) {
      autoBadges.push('baby_friendly');
    }

    // Combinar badges manuales con auto-generados (sin duplicados)
    const allBadges = Array.isArray(badges) ? badges : [];
    const finalBadges = [...new Set([...allBadges, ...autoBadges])];

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({
        success: false,
        message: err.message
      });
    }

    const recommendationData = {
      categoryId,
      name: name.trim(),
      description: description ? description.trim() : '',
      address: address ? address.trim() : '',
      latitude: latitude ? parseFloat(latitude) : null,
      longitude: longitude ? parseFloat(longitude) : null,
      phone: phone ? phone.trim() : '',
      email: email ? email.trim() : '',
      website: website ? website.trim() : '',
      facebook: facebook ? facebook.trim() : '',
      instagram: instagram ? instagram.trim() : '',
      twitter: twitter ? twitter.trim() : '',
      whatsapp: whatsapp ? whatsapp.trim() : '',
      imageUrl: imageUrl || null,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      isActive: isActive === true || isActive === 'true',
      // Badges y features
      verified: verified === true || verified === 'true' || verified === '1' || verified === 1,
      badges: finalBadges,
      features: processedFeatures,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    console.log('ðŸ“‹ [DEBUG] recommendationData.verified final:', recommendationData.verified);

    const recRef = await db.collection('recommendations').add(recommendationData);

    console.log('âœ… [ADMIN] Recomendado creado:', recRef.id);

    res.json({
      success: true,
      message: 'Recomendado creado exitosamente',
      data: {
        id: recRef.id,
        ...recommendationData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando recomendado',
      error: error.message
    });
  }
});

// Actualizar recomendado (admin)
app.put('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      isActive,
      countryId,
      cityId,
      // Badges y features
      verified,
      badges,
      features
    } = req.body;
    
    console.log('âœï¸ [ADMIN] Actualizando recomendado:', recommendationId);

    const recRef = db.collection('recommendations').doc(recommendationId);
    const recDoc = await recRef.get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Si se cambia la categorÃ­a, verificar que existe
    if (categoryId !== undefined) {
      const categoryDoc = await db.collection('categories').doc(categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'La categorÃ­a seleccionada no existe'
        });
      }
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (categoryId !== undefined) updateData.categoryId = categoryId;
    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (address !== undefined) updateData.address = address.trim();
    if (latitude !== undefined) updateData.latitude = latitude ? parseFloat(latitude) : null;
    if (longitude !== undefined) updateData.longitude = longitude ? parseFloat(longitude) : null;
    if (phone !== undefined) updateData.phone = phone.trim();
    if (email !== undefined) updateData.email = email.trim();
    if (website !== undefined) updateData.website = website.trim();
    if (facebook !== undefined) updateData.facebook = facebook.trim();
    if (instagram !== undefined) updateData.instagram = instagram.trim();
    if (twitter !== undefined) updateData.twitter = twitter.trim();
    if (whatsapp !== undefined) updateData.whatsapp = whatsapp.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isActive !== undefined) updateData.isActive = isActive === true || isActive === 'true';

    const hasLocationUpdate = Object.prototype.hasOwnProperty.call(req.body, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body, 'cityId');
    if (hasLocationUpdate) {
      const normalizedCountryId = countryId ? String(countryId).trim() : null;
      const normalizedCityId = cityId ? String(cityId).trim() : null;
      try {
        const locationData = await resolveCountryCity(normalizedCountryId, normalizedCityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    // Actualizar badges y features
    if (verified !== undefined) {
      console.log('ðŸ“‹ [DEBUG UPDATE] verified recibido:', verified, 'tipo:', typeof verified);
      updateData.verified = verified === true || verified === 'true' || verified === '1' || verified === 1;
      console.log('ðŸ“‹ [DEBUG UPDATE] verified final:', updateData.verified);
    }

    if (features !== undefined) {
      // Procesar features con valores por defecto
      const processedFeatures = {
        hasChangingTable: features.hasChangingTable === true,
        hasNursingRoom: features.hasNursingRoom === true,
        hasParking: features.hasParking === true,
        isStrollerAccessible: features.isStrollerAccessible === true,
        acceptsEmergencies: features.acceptsEmergencies === true,
        is24Hours: features.is24Hours === true
      };

      // Generar badges automÃ¡ticamente basados en features
      const autoBadges = [];
      if (processedFeatures.hasChangingTable) autoBadges.push('changing_table');
      if (processedFeatures.hasNursingRoom) autoBadges.push('nursing_room');
      if (processedFeatures.hasParking) autoBadges.push('parking');
      if (processedFeatures.isStrollerAccessible) autoBadges.push('stroller_accessible');
      if (processedFeatures.acceptsEmergencies) autoBadges.push('emergency_24_7');
      if (processedFeatures.is24Hours) autoBadges.push('24_hours');

      // Badge "baby_friendly" si tiene al menos 3 features
      const featuresCount = Object.values(processedFeatures).filter(v => v === true).length;
      if (featuresCount >= 3) {
        autoBadges.push('baby_friendly');
      }

      // Combinar badges manuales con auto-generados (sin duplicados)
      const manualBadges = Array.isArray(badges) ? badges : (recDoc.data().badges || []);
      const finalBadges = [...new Set([...manualBadges, ...autoBadges])];

      updateData.features = processedFeatures;
      updateData.badges = finalBadges;
    } else if (badges !== undefined) {
      // Solo se actualizan badges manualmente sin features
      updateData.badges = Array.isArray(badges) ? badges : [];
    }

    await recRef.update(updateData);

    console.log('âœ… [ADMIN] Recomendado actualizado');

    res.json({
      success: true,
      message: 'Recomendado actualizado exitosamente',
      data: {
        id: recommendationId,
        ...recDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando recomendado',
      error: error.message
    });
  }
});

// MigraciÃ³n: Agregar campos verified, badges y features a recomendados existentes (admin)
app.post('/api/admin/recommendations/migrate-badges', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ”„ [ADMIN] Iniciando migraciÃ³n de badges...');

    const snapshot = await db.collection('recommendations').get();
    
    let updated = 0;
    let skipped = 0;
    const updates = [];

    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Solo actualizar si no tiene los nuevos campos
      if (data.verified === undefined || data.badges === undefined || data.features === undefined) {
        const updateData = {};
        
        // Agregar verified si no existe
        if (data.verified === undefined) {
          updateData.verified = false;
        }
        
        // Agregar badges si no existe
        if (data.badges === undefined) {
          updateData.badges = [];
        }
        
        // Agregar features si no existe
        if (data.features === undefined) {
          updateData.features = {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          };
        }
        
        if (Object.keys(updateData).length > 0) {
          updates.push(
            db.collection('recommendations').doc(doc.id).update(updateData)
          );
          updated++;
        }
      } else {
        skipped++;
      }
    }

    // Ejecutar todas las actualizaciones en paralelo
    if (updates.length > 0) {
      await Promise.all(updates);
    }

    console.log(`âœ… [ADMIN] MigraciÃ³n completada: ${updated} actualizados, ${skipped} omitidos`);

    res.json({
      success: true,
      message: 'MigraciÃ³n completada exitosamente',
      data: {
        total: snapshot.size,
        updated,
        skipped
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error en migraciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error ejecutando migraciÃ³n',
      error: error.message
    });
  }
});

// Eliminar recomendado (admin)
app.delete('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    await db.collection('recommendations').doc(recommendationId).delete();

    console.log('âœ… [ADMIN] Recomendado eliminado');

    res.json({
      success: true,
      message: 'Recomendado eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando recomendado',
      error: error.message
    });
  }
});

// ========== REVIEWS DE RECOMENDADOS ==========

// ===== ENDPOINTS PARA LA APP =====

// Obtener reviews de un recomendado (APP)
app.get('/api/recommendations/:recommendationId/reviews', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('â­ [APP] Obteniendo reviews para recomendado:', recommendationId);

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Obtener reviews
    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    const userId = req.user?.uid; // Usuario actual para saber si marcÃ³ como Ãºtil

    let reviews = await Promise.all(reviewsSnapshot.docs.map(async (doc) => {
      const reviewData = doc.data();
      
      // Obtener informaciÃ³n del usuario
      let userInfo = null;
      if (reviewData.userId) {
        const userDoc = await db.collection('users').doc(reviewData.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            id: userDoc.id,
            displayName: userData.displayName || 'Usuario',
            photoURL: userData.photoURL || null
          };
        }
      }

      // Verificar si el usuario actual marcÃ³ como Ãºtil
      const helpfulBy = reviewData.helpfulBy || [];
      const isHelpfulByMe = userId ? helpfulBy.includes(userId) : false;

      return {
        id: doc.id,
        userId: reviewData.userId,
        userName: userInfo?.displayName || 'Usuario',
        userAvatar: userInfo?.photoURL || null,
        rating: reviewData.rating,
        comment: reviewData.comment,
        // Nuevos campos
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        isHelpfulByMe,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      };
    }));

    // Ordenar por fecha (mÃ¡s recientes primero)
    reviews.sort((a, b) => {
      const dateA = a.createdAt || new Date(0);
      const dateB = b.createdAt || new Date(0);
      return dateB - dateA;
    });

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedReviews = reviews.slice(startIndex, endIndex);

    // Calcular estadÃ­sticas
    const totalReviews = reviews.length;
    const averageRating = totalReviews > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews 
      : 0;

    res.json({
      success: true,
      data: paginatedReviews,
      stats: {
        totalReviews,
        averageRating: Math.round(averageRating * 10) / 10 // Redondear a 1 decimal
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReviews,
        totalPages: Math.ceil(totalReviews / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reviews',
      error: error.message
    });
  }
});

// Crear o actualizar review de un recomendado (APP)
app.post('/api/recommendations/:recommendationId/reviews', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { rating, comment, photos = [], childAge, visitedWith } = req.body;
    const userId = req.user.uid;
    
    console.log('â­ [APP] Creando/actualizando review para recomendado:', recommendationId);

    // Validaciones
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({
        success: false,
        message: 'La calificaciÃ³n debe ser entre 1 y 5 estrellas'
      });
    }

    // Validar visitedWith si se proporciona
    const validVisitedWith = ['Solo', 'Pareja', 'Familia', 'Amigos'];
    if (visitedWith && !validVisitedWith.includes(visitedWith)) {
      return res.status(400).json({
        success: false,
        message: `visitedWith debe ser uno de: ${validVisitedWith.join(', ')}`
      });
    }

    // Validar fotos (mÃ¡ximo 5)
    if (photos && photos.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'MÃ¡ximo 5 fotos por review'
      });
    }

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si el usuario ya tiene una review para este recomendado
    const existingReviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    let reviewRef;
    let isNew = true;

    if (!existingReviewSnapshot.empty) {
      // Actualizar review existente
      reviewRef = existingReviewSnapshot.docs[0].ref;
      isNew = false;
      
      const updateData = {
        rating: parseInt(rating),
        comment: comment ? comment.trim() : '',
        updatedAt: new Date()
      };

      // Actualizar campos opcionales si se proporcionan
      if (photos !== undefined) updateData.photos = Array.isArray(photos) ? photos : [];
      if (childAge !== undefined) updateData.childAge = childAge ? childAge.trim() : '';
      if (visitedWith !== undefined) updateData.visitedWith = visitedWith || '';

      await reviewRef.update(updateData);

      console.log('âœ… [APP] Review actualizada');
    } else {
      // Crear nueva review
      const reviewData = {
        recommendationId,
        userId,
        rating: parseInt(rating),
        comment: comment ? comment.trim() : '',
        photos: Array.isArray(photos) ? photos : [],
        childAge: childAge ? childAge.trim() : '',
        visitedWith: visitedWith || '',
        helpfulCount: 0,
        helpfulBy: [], // Array de userIds que marcaron como Ãºtil
        createdAt: new Date(),
        updatedAt: new Date()
      };

      reviewRef = await db.collection('recommendationReviews').add(reviewData);

      console.log('âœ… [APP] Review creada');
    }

    // Recalcular estadÃ­sticas del recomendado
    await updateRecommendationStats(recommendationId);

    // Obtener la review actualizada con info del usuario
    const reviewDoc = await reviewRef.get();
    const reviewData = reviewDoc.data();
    
    const userDoc = await db.collection('users').doc(userId).get();
    const userData = userDoc.data();

    res.json({
      success: true,
      message: isNew ? 'Review creada exitosamente' : 'Review actualizada exitosamente',
      data: {
        id: reviewDoc.id,
        userId,
        userName: userData.displayName || 'Usuario',
        userAvatar: userData.photoURL || null,
        rating: reviewData.rating,
        comment: reviewData.comment,
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error creando/actualizando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando review',
      error: error.message
    });
  }
});

// Subir fotos para reviews (APP) - Una sola foto
app.post('/api/recommendations/:recommendationId/reviews/upload-photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;

    console.log('ðŸ“¸ [APP] Subiendo foto de review para:', recommendationId);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna foto'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `review-${recommendationId}-${userId}-${timestamp}-${file.originalname}`;
    
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`reviews/${recommendationId}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype,
        metadata: {
          uploadedBy: userId,
          recommendationId: recommendationId
        }
      }
    });

    blobStream.on('error', (error) => {
      console.error('âŒ [APP] Error subiendo foto:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo foto',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const photoUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        console.log('âœ… [APP] Foto subida:', photoUrl);

        res.json({
          success: true,
          message: 'Foto subida exitosamente',
          data: {
            photoUrl
          }
        });
      } catch (error) {
        console.error('âŒ [APP] Error haciendo pÃºblica la foto:', error);
        res.status(500).json({
          success: false,
          message: 'Error procesando foto',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('âŒ [APP] Error en upload de foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});

// Subir mÃºltiples fotos para reviews (APP) - Hasta 5 fotos
app.post('/api/recommendations/:recommendationId/reviews/upload-photos', authenticateToken, upload.array('photos', 5), async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;

    console.log('ðŸ“¸ [APP] Subiendo fotos de review (mÃºltiples) para:', recommendationId);

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionaron fotos'
      });
    }

    if (req.files.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'MÃ¡ximo 5 fotos por vez'
      });
    }

    const bucket = admin.storage().bucket();
    const uploadPromises = req.files.map((file) => {
      return new Promise((resolve, reject) => {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(7);
        const fileName = `review-${recommendationId}-${userId}-${timestamp}-${random}-${file.originalname}`;
        
        const blob = bucket.file(`reviews/${recommendationId}/${fileName}`);
        
        const blobStream = blob.createWriteStream({
          metadata: {
            contentType: file.mimetype,
            metadata: {
              uploadedBy: userId,
              recommendationId: recommendationId
            }
          }
        });

        blobStream.on('error', (error) => {
          reject(error);
        });

        blobStream.on('finish', async () => {
          try {
            await blob.makePublic();
            const photoUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
            resolve(photoUrl);
          } catch (error) {
            reject(error);
          }
        });

        blobStream.end(file.buffer);
      });
    });

    const photoUrls = await Promise.all(uploadPromises);

    console.log('âœ… [APP] Fotos subidas:', photoUrls.length);

    res.json({
      success: true,
      message: `${photoUrls.length} foto(s) subida(s) exitosamente`,
      data: {
        photoUrls
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error subiendo fotos:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo fotos',
      error: error.message
    });
  }
});

// Marcar/desmarcar review como Ãºtil (APP)
app.post('/api/recommendations/:recommendationId/reviews/:reviewId/helpful', authenticateToken, async (req, res) => {
  try {
    const { recommendationId, reviewId } = req.params;
    const userId = req.user.uid;

    console.log('ðŸ‘ [APP] Toggle Ãºtil en review:', reviewId);

    const reviewRef = db.collection('recommendationReviews').doc(reviewId);
    const reviewDoc = await reviewRef.get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    const reviewData = reviewDoc.data();
    const helpfulBy = reviewData.helpfulBy || [];

    let isHelpful;
    let newHelpfulBy;

    if (helpfulBy.includes(userId)) {
      // Ya marcado, quitar
      newHelpfulBy = helpfulBy.filter(id => id !== userId);
      isHelpful = false;
    } else {
      // No marcado, agregar
      newHelpfulBy = [...helpfulBy, userId];
      isHelpful = true;
    }

    await reviewRef.update({
      helpfulBy: newHelpfulBy,
      helpfulCount: newHelpfulBy.length
    });

    console.log(`âœ… [APP] Review marcada como ${isHelpful ? 'Ãºtil' : 'no Ãºtil'}`);

    res.json({
      success: true,
      isHelpful,
      helpfulCount: newHelpfulBy.length
    });

  } catch (error) {
    console.error('âŒ [APP] Error marcando review como Ãºtil:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando review',
      error: error.message
    });
  }
});

// Verificar si el usuario marcÃ³ una review como Ãºtil (APP)
app.get('/api/recommendations/:recommendationId/reviews/:reviewId/helpful', authenticateToken, async (req, res) => {
  try {
    const { reviewId } = req.params;
    const userId = req.user.uid;

    console.log('â“ [APP] Verificando Ãºtil en review:', reviewId);

    const reviewDoc = await db.collection('recommendationReviews').doc(reviewId).get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    const reviewData = reviewDoc.data();
    const helpfulBy = reviewData.helpfulBy || [];
    const isHelpful = helpfulBy.includes(userId);

    res.json({
      success: true,
      data: {
        isHelpful
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error verificando Ãºtil:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando review',
      error: error.message
    });
  }
});

// Obtener la review del usuario actual para un recomendado (APP)
app.get('/api/recommendations/:recommendationId/reviews/my-review', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('â­ [APP] Obteniendo mi review para recomendado:', recommendationId);

    const reviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    if (reviewSnapshot.empty) {
      return res.json({
        success: true,
        data: null
      });
    }

    const reviewDoc = reviewSnapshot.docs[0];
    const reviewData = reviewDoc.data();

    res.json({
      success: true,
      data: {
        id: reviewDoc.id,
        rating: reviewData.rating,
        comment: reviewData.comment,
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [APP] Error obteniendo mi review:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo review',
      error: error.message
    });
  }
});

// Eliminar review propia (APP)
app.delete('/api/recommendations/:recommendationId/reviews/my-review', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('ðŸ—‘ï¸ [APP] Eliminando mi review para recomendado:', recommendationId);

    const reviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    if (reviewSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'No tienes una review para este recomendado'
      });
    }

    await reviewSnapshot.docs[0].ref.delete();

    // Recalcular estadÃ­sticas del recomendado
    await updateRecommendationStats(recommendationId);

    console.log('âœ… [APP] Review eliminada');

    res.json({
      success: true,
      message: 'Review eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [APP] Error eliminando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando review',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN =====

// Obtener todas las reviews de un recomendado (ADMIN)
app.get('/api/admin/recommendations/:recommendationId/reviews', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('â­ [ADMIN] Obteniendo reviews para recomendado:', recommendationId);

    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    let reviews = await Promise.all(reviewsSnapshot.docs.map(async (doc) => {
      const reviewData = doc.data();
      
      // Obtener informaciÃ³n del usuario
      let userInfo = null;
      if (reviewData.userId) {
        const userDoc = await db.collection('users').doc(reviewData.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            id: userDoc.id,
            displayName: userData.displayName,
            email: userData.email,
            photoURL: userData.photoURL
          };
        }
      }

      return {
        id: doc.id,
        recommendationId: reviewData.recommendationId,
        rating: reviewData.rating,
        comment: reviewData.comment,
        user: userInfo,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      };
    }));

    // Ordenar por fecha
    reviews.sort((a, b) => (b.createdAt || new Date(0)) - (a.createdAt || new Date(0)));

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedReviews = reviews.slice(startIndex, endIndex);

    // EstadÃ­sticas
    const totalReviews = reviews.length;
    const averageRating = totalReviews > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews 
      : 0;

    res.json({
      success: true,
      data: paginatedReviews,
      stats: {
        totalReviews,
        averageRating: Math.round(averageRating * 10) / 10
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReviews,
        totalPages: Math.ceil(totalReviews / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reviews',
      error: error.message
    });
  }
});

// Eliminar una review (ADMIN)
app.delete('/api/admin/recommendations/:recommendationId/reviews/:reviewId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId, reviewId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando review:', reviewId);

    const reviewDoc = await db.collection('recommendationReviews').doc(reviewId).get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    await db.collection('recommendationReviews').doc(reviewId).delete();

    // Recalcular estadÃ­sticas del recomendado
    await updateRecommendationStats(recommendationId);

    console.log('âœ… [ADMIN] Review eliminada');

    res.json({
      success: true,
      message: 'Review eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando review',
      error: error.message
    });
  }
});

// MigraciÃ³n: Agregar nuevos campos a reviews existentes (ADMIN)
app.post('/api/admin/reviews/migrate-fields', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ”„ [ADMIN] Iniciando migraciÃ³n de reviews...');

    const snapshot = await db.collection('recommendationReviews').get();
    
    let updated = 0;
    let skipped = 0;
    const updates = [];

    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Solo actualizar si no tiene los nuevos campos
      if (data.photos === undefined || data.helpfulCount === undefined || data.helpfulBy === undefined) {
        const updateData = {};
        
        // Agregar photos si no existe
        if (data.photos === undefined) {
          updateData.photos = [];
        }
        
        // Agregar childAge si no existe
        if (data.childAge === undefined) {
          updateData.childAge = '';
        }
        
        // Agregar visitedWith si no existe
        if (data.visitedWith === undefined) {
          updateData.visitedWith = '';
        }
        
        // Agregar helpfulCount si no existe
        if (data.helpfulCount === undefined) {
          updateData.helpfulCount = 0;
        }
        
        // Agregar helpfulBy si no existe
        if (data.helpfulBy === undefined) {
          updateData.helpfulBy = [];
        }
        
        if (Object.keys(updateData).length > 0) {
          updates.push(
            db.collection('recommendationReviews').doc(doc.id).update(updateData)
          );
          updated++;
        }
      } else {
        skipped++;
      }
    }

    // Ejecutar todas las actualizaciones en paralelo
    if (updates.length > 0) {
      await Promise.all(updates);
    }

    console.log(`âœ… [ADMIN] MigraciÃ³n completada: ${updated} reviews actualizadas, ${skipped} omitidas`);

    res.json({
      success: true,
      message: 'MigraciÃ³n de reviews completada exitosamente',
      data: {
        total: snapshot.size,
        updated,
        skipped
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error en migraciÃ³n de reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error ejecutando migraciÃ³n',
      error: error.message
    });
  }
});

// FunciÃ³n auxiliar para recalcular estadÃ­sticas de un recomendado
async function updateRecommendationStats(recommendationId) {
  try {
    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    const totalReviews = reviewsSnapshot.size;
    let averageRating = 0;

    if (totalReviews > 0) {
      const totalRating = reviewsSnapshot.docs.reduce((sum, doc) => {
        return sum + (doc.data().rating || 0);
      }, 0);
      averageRating = totalRating / totalReviews;
    }

    // Actualizar el recomendado con las estadÃ­sticas
    await db.collection('recommendations').doc(recommendationId).update({
      totalReviews,
      averageRating: Math.round(averageRating * 10) / 10,
      updatedAt: new Date()
    });

    console.log('âœ… EstadÃ­sticas actualizadas para recomendado:', recommendationId);
  } catch (error) {
    console.error('âŒ Error actualizando estadÃ­sticas:', error);
  }
}

// ========== GESTIÃ“N DE LISTAS ==========

// Obtener todas las listas
app.get('/api/admin/lists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('ðŸ“‹ [ADMIN] Obteniendo listas');

    const snapshot = await db.collection('lists')
      .orderBy('createdAt', 'desc')
      .get();
    
    // Obtener informaciÃ³n de los usuarios dueÃ±os de las listas
    const listsWithOwners = await Promise.all(snapshot.docs.map(async (doc) => {
      const listData = doc.data();
      let ownerInfo = null;

      // Buscar el dueÃ±o usando userId o creatorId (compatibilidad con ambos formatos)
      const ownerId = listData.userId || listData.creatorId;

      if (ownerId) {
        try {
          const userDoc = await db.collection('users').doc(ownerId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            ownerInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario sin nombre',
              email: userData.email || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${ownerId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...listData,
        owner: ownerInfo,
        createdAt: listData.createdAt?.toDate(),
        updatedAt: listData.updatedAt?.toDate()
      };
    }));

    // Filtrar por bÃºsqueda si existe
    let lists = listsWithOwners;
    if (search) {
      const searchLower = search.toLowerCase();
      lists = listsWithOwners.filter(list => 
        list.title?.toLowerCase().includes(searchLower) ||
        list.description?.toLowerCase().includes(searchLower) ||
        list.owner?.displayName?.toLowerCase().includes(searchLower) ||
        list.owner?.email?.toLowerCase().includes(searchLower)
      );
    }

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedLists = lists.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedLists,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: lists.length,
        totalPages: Math.ceil(lists.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo listas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas',
      error: error.message
    });
  }
});

// Obtener detalle de una lista especÃ­fica
app.get('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('ðŸ“‹ [ADMIN] Obteniendo detalle de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    let ownerInfo = null;

    // Obtener informaciÃ³n del dueÃ±o (compatibilidad con userId y creatorId)
    const ownerId = listData.userId || listData.creatorId;

    if (ownerId) {
      try {
        const userDoc = await db.collection('users').doc(ownerId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          ownerInfo = {
            id: userDoc.id,
            displayName: userData.displayName || 'Usuario sin nombre',
            email: userData.email || null,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.error(`Error obteniendo usuario ${ownerId}:`, error);
      }
    }

    res.json({
      success: true,
      data: {
        id: listDoc.id,
        ...listData,
        owner: ownerInfo,
        createdAt: listData.createdAt?.toDate(),
        updatedAt: listData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalle de lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de lista',
      error: error.message
    });
  }
});

// Crear nueva lista
app.post('/api/admin/lists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, description, items = [], isPublic = true, imageUrl } = req.body;
    
    console.log('âž• [ADMIN] Creando nueva lista:', title);

    if (!title) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ­tulo de la lista es requerido'
      });
    }

    // Procesar items con estructura completa
    const processedItems = items.map((item, index) => ({
      id: item.id || `item_${Date.now()}_${index}`,
      text: item.text ? item.text.trim() : '',
      imageUrl: item.imageUrl || null,
      priority: item.priority || 'medium',
      details: item.details || '',
      brand: item.brand || '',
      store: item.store || '',
      approximatePrice: item.approximatePrice || null,
      completed: item.completed || false,
      createdAt: item.createdAt || new Date()
    }));

    const listData = {
      title: title.trim(),
      description: description ? description.trim() : '',
      imageUrl: imageUrl || null,
      items: processedItems,
      isPublic,
      userId: req.user.uid,
      creatorId: req.user.uid, // Agregar tambiÃ©n creatorId para compatibilidad
      completedItems: processedItems.filter(item => item.completed).length,
      totalItems: processedItems.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const listRef = await db.collection('lists').add(listData);

    console.log('âœ… [ADMIN] Lista creada con', processedItems.length, 'items');

    res.json({
      success: true,
      message: 'Lista creada exitosamente',
      data: {
        id: listRef.id,
        ...listData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando lista',
      error: error.message
    });
  }
});

// Editar lista
app.put('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    const { title, description, items, isPublic, imageUrl } = req.body;
    
    console.log('âœï¸ [ADMIN] Editando lista:', listId);

    const listRef = db.collection('lists').doc(listId);
    const listDoc = await listRef.get();

    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const oldListData = listDoc.data();
    const updateData = {
      updatedAt: new Date()
    };

    if (title !== undefined) updateData.title = title.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isPublic !== undefined) updateData.isPublic = isPublic;
    
    // Si se estÃ¡n actualizando los items, procesarlos con estructura completa
    if (items !== undefined) {
      const oldItems = oldListData.items || [];
      const itemIdMapping = {}; // Mapeo de itemId viejo -> itemId nuevo
      
      const processedItems = items.map((item, index) => {
        // Si el item ya tiene un ID, conservarlo sin cambios
        if (item.id) {
          return {
            id: item.id, // Mantener el ID existente
            text: item.text ? item.text.trim() : '',
            imageUrl: item.imageUrl || null,
            priority: item.priority || 'medium',
            details: item.details || '',
            brand: item.brand || '',
            store: item.store || '',
            approximatePrice: item.approximatePrice || null,
            completed: item.completed || false,
            createdAt: item.createdAt || new Date()
          };
        }
        
        // Si no tiene ID, intentar encontrar el item anterior por texto
        const newItemId = `item_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
        
        if (item.text) {
          const oldItem = oldItems.find(old => 
            old.text && old.text.toLowerCase().trim() === item.text.toLowerCase().trim()
          );
          
          if (oldItem && oldItem.id) {
            // Usar el ID del item anterior si se encuentra por texto
            console.log(`ðŸ”— [ADMIN] Reutilizando itemId existente: ${oldItem.id} para "${item.text}"`);
            return {
              id: oldItem.id, // Reutilizar ID existente
              text: item.text.trim(),
              imageUrl: item.imageUrl || null,
              priority: item.priority || 'medium',
              details: item.details || '',
              brand: item.brand || '',
              store: item.store || '',
              approximatePrice: item.approximatePrice || null,
              completed: item.completed || false,
              createdAt: item.createdAt || oldItem.createdAt || new Date()
            };
          }
        }
        
        // Generar nuevo ID solo si es un item completamente nuevo
        console.log(`âœ¨ [ADMIN] Generando nuevo itemId: ${newItemId} para "${item.text}"`);
        return {
          id: newItemId,
          text: item.text ? item.text.trim() : '',
          imageUrl: item.imageUrl || null,
          priority: item.priority || 'medium',
          details: item.details || '',
          brand: item.brand || '',
          store: item.store || '',
          approximatePrice: item.approximatePrice || null,
          completed: item.completed || false,
          createdAt: item.createdAt || new Date()
        };
      });
      
      updateData.items = processedItems;
      updateData.completedItems = processedItems.filter(item => item.completed).length;
      updateData.totalItems = processedItems.length;
      
      console.log('âœ… [ADMIN] Items procesados:', processedItems.length);
      
      // Actualizar itemId en comentarios y ratings si hay mapeos
      if (Object.keys(itemIdMapping).length > 0) {
        console.log('ðŸ”„ [ADMIN] Actualizando itemIds en comentarios y ratings...');
        
        // Actualizar comentarios
        const commentsSnapshot = await db.collection('listComments')
          .where('listId', '==', listId)
          .get();
        
        const commentUpdates = [];
        commentsSnapshot.forEach(doc => {
          const oldItemId = doc.data().itemId;
          if (itemIdMapping[oldItemId]) {
            commentUpdates.push(
              doc.ref.update({ itemId: itemIdMapping[oldItemId] })
            );
            console.log(`  âœ“ Comentario ${doc.id}: ${oldItemId} -> ${itemIdMapping[oldItemId]}`);
          }
        });
        
        // Actualizar ratings
        const ratingsSnapshot = await db.collection('itemRatings')
          .where('listId', '==', listId)
          .get();
        
        const ratingUpdates = [];
        ratingsSnapshot.forEach(doc => {
          const oldItemId = doc.data().itemId;
          if (itemIdMapping[oldItemId]) {
            ratingUpdates.push(
              doc.ref.update({ itemId: itemIdMapping[oldItemId] })
            );
            console.log(`  âœ“ Rating ${doc.id}: ${oldItemId} -> ${itemIdMapping[oldItemId]}`);
          }
        });
        
        // Ejecutar todas las actualizaciones
        await Promise.all([...commentUpdates, ...ratingUpdates]);
        console.log(`âœ… [ADMIN] Actualizados ${commentUpdates.length} comentarios y ${ratingUpdates.length} ratings`);
      }
    }

    await listRef.update(updateData);

    res.json({
      success: true,
      message: 'Lista actualizada exitosamente',
      data: {
        id: listId,
        ...listDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error editando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando lista',
      error: error.message
    });
  }
});

// Endpoint para sincronizar itemIds en comentarios y ratings con los items actuales de la lista
app.post('/api/admin/lists/:listId/sync-item-ids', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('ðŸ”„ [ADMIN] Sincronizando itemIds para lista:', listId);

    // Obtener la lista
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    const currentItems = listData.items || [];
    
    if (currentItems.length === 0) {
      return res.json({
        success: true,
        message: 'La lista no tiene items',
        data: {
          commentsUpdated: 0,
          ratingsUpdated: 0
        }
      });
    }

    // Crear mapeo de texto -> itemId actual
    const textToIdMap = {};
    currentItems.forEach(item => {
      if (item.text && item.id) {
        const normalizedText = item.text.toLowerCase().trim();
        textToIdMap[normalizedText] = item.id;
      }
    });

    console.log('ðŸ“‹ [ADMIN] Items encontrados:', currentItems.length);
    console.log('ðŸ—ºï¸ [ADMIN] Mapeo de texto a ID:', Object.keys(textToIdMap).length);

    // Obtener todos los comentarios de esta lista
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .get();

    // Obtener todos los ratings de esta lista
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();

    console.log('ðŸ’¬ [ADMIN] Comentarios encontrados:', commentsSnapshot.size);
    console.log('â­ [ADMIN] Ratings encontrados:', ratingsSnapshot.size);

    const commentUpdates = [];
    const ratingUpdates = [];
    let commentsUpdated = 0;
    let ratingsUpdated = 0;

    // Actualizar comentarios
    for (const doc of commentsSnapshot.docs) {
      const commentData = doc.data();
      const currentItemId = commentData.itemId;
      
      // Buscar el item actual por su ID antiguo
      const matchingItem = currentItems.find(item => {
        // Intentar match por texto
        if (commentData.itemId && item.text) {
          // Buscar el item por itemId en el texto normalizado
          const normalizedText = item.text.toLowerCase().trim();
          return textToIdMap[normalizedText] && item.id !== currentItemId;
        }
        return false;
      });

      // Si encontramos un item que coincide por texto pero tiene diferente ID
      if (matchingItem && matchingItem.id !== currentItemId) {
        commentUpdates.push(
          doc.ref.update({ itemId: matchingItem.id })
            .then(() => {
              console.log(`  âœ“ Comentario ${doc.id}: ${currentItemId} -> ${matchingItem.id}`);
              commentsUpdated++;
            })
        );
      }
    }

    // Actualizar ratings
    for (const doc of ratingsSnapshot.docs) {
      const ratingData = doc.data();
      const currentItemId = ratingData.itemId;
      
      // Buscar el item actual
      const matchingItem = currentItems.find(item => {
        if (ratingData.itemId && item.text) {
          const normalizedText = item.text.toLowerCase().trim();
          return textToIdMap[normalizedText] && item.id !== currentItemId;
        }
        return false;
      });

      if (matchingItem && matchingItem.id !== currentItemId) {
        ratingUpdates.push(
          doc.ref.update({ itemId: matchingItem.id })
            .then(() => {
              console.log(`  âœ“ Rating ${doc.id}: ${currentItemId} -> ${matchingItem.id}`);
              ratingsUpdated++;
            })
        );
      }
    }

    // Ejecutar todas las actualizaciones
    await Promise.all([...commentUpdates, ...ratingUpdates]);

    console.log(`âœ… [ADMIN] SincronizaciÃ³n completada: ${commentsUpdated} comentarios, ${ratingsUpdated} ratings`);

    res.json({
      success: true,
      message: 'ItemIds sincronizados exitosamente',
      data: {
        totalItems: currentItems.length,
        totalComments: commentsSnapshot.size,
        totalRatings: ratingsSnapshot.size,
        commentsUpdated,
        ratingsUpdated
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error sincronizando itemIds:', error);
    res.status(500).json({
      success: false,
      message: 'Error sincronizando itemIds',
      error: error.message
    });
  }
});

// Endpoint para sincronizar TODAS las listas (migraciÃ³n masiva)
app.post('/api/admin/lists/sync-all-item-ids', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ”„ [ADMIN] Sincronizando itemIds para TODAS las listas...');

    // Obtener todas las listas
    const listsSnapshot = await db.collection('lists').get();
    
    console.log('ðŸ“‹ [ADMIN] Total listas:', listsSnapshot.size);

    const results = [];
    
    for (const listDoc of listsSnapshot.docs) {
      const listId = listDoc.id;
      const listData = listDoc.data();
      const currentItems = listData.items || [];
      
      if (currentItems.length === 0) continue;

      // Crear mapeo de texto -> itemId actual
      const textToIdMap = {};
      currentItems.forEach(item => {
        if (item.text && item.id) {
          const normalizedText = item.text.toLowerCase().trim();
          textToIdMap[normalizedText] = item.id;
        }
      });

      // Obtener comentarios y ratings de esta lista
      const [commentsSnapshot, ratingsSnapshot] = await Promise.all([
        db.collection('listComments').where('listId', '==', listId).get(),
        db.collection('itemRatings').where('listId', '==', listId).get()
      ]);

      let commentsUpdated = 0;
      let ratingsUpdated = 0;
      const updates = [];

      // Procesar comentarios
      commentsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId) {
          // Buscar item por texto del comentario (necesitarÃ­amos el texto del item)
          const matchingItem = currentItems.find(item => item.id === data.itemId);
          if (!matchingItem && currentItems.length > 0) {
            // Si no coincide, intentar encontrar por Ã­ndice o primer item
            const firstItem = currentItems[0];
            if (firstItem && firstItem.id !== data.itemId) {
              updates.push(
                doc.ref.update({ itemId: firstItem.id }).then(() => commentsUpdated++)
              );
            }
          }
        }
      });

      // Procesar ratings
      ratingsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId) {
          const matchingItem = currentItems.find(item => item.id === data.itemId);
          if (!matchingItem && currentItems.length > 0) {
            const firstItem = currentItems[0];
            if (firstItem && firstItem.id !== data.itemId) {
              updates.push(
                doc.ref.update({ itemId: firstItem.id }).then(() => ratingsUpdated++)
              );
            }
          }
        }
      });

      await Promise.all(updates);

      if (commentsUpdated > 0 || ratingsUpdated > 0) {
        results.push({
          listId,
          listTitle: listData.title,
          commentsUpdated,
          ratingsUpdated
        });
        console.log(`  âœ“ Lista "${listData.title}": ${commentsUpdated} comentarios, ${ratingsUpdated} ratings actualizados`);
      }
    }

    console.log(`âœ… [ADMIN] SincronizaciÃ³n masiva completada: ${results.length} listas procesadas`);

    res.json({
      success: true,
      message: 'SincronizaciÃ³n masiva completada',
      data: {
        totalLists: listsSnapshot.size,
        listsUpdated: results.length,
        details: results
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error en sincronizaciÃ³n masiva:', error);
    res.status(500).json({
      success: false,
      message: 'Error en sincronizaciÃ³n masiva',
      error: error.message
    });
  }
});

// Eliminar lista
app.delete('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    await db.collection('lists').doc(listId).delete();

    res.json({
      success: true,
      message: 'Lista eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando lista',
      error: error.message
    });
  }
});

// Obtener calificaciones de una lista (items)
app.get('/api/admin/lists/:listId/ratings', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('â­ [ADMIN] Obteniendo calificaciones de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    // Obtener todas las calificaciones de items de esta lista
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();

    const ratings = await Promise.all(ratingsSnapshot.docs.map(async (doc) => {
      const ratingData = doc.data();
      let userInfo = null;

      // Obtener informaciÃ³n del usuario que calificÃ³
      if (ratingData.userId) {
        try {
          const userDoc = await db.collection('users').doc(ratingData.userId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario',
              email: userData.email || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${ratingData.userId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...ratingData,
        user: userInfo,
        createdAt: ratingData.createdAt?.toDate()
      };
    }));

    // Calcular estadÃ­sticas por item
    const itemStats = {};
    ratings.forEach(rating => {
      if (!itemStats[rating.itemId]) {
        itemStats[rating.itemId] = {
          itemId: rating.itemId,
          totalRatings: 0,
          sumRatings: 0,
          averageRating: 0
        };
      }
      itemStats[rating.itemId].totalRatings++;
      itemStats[rating.itemId].sumRatings += rating.rating;
    });

    // Calcular promedios
    Object.keys(itemStats).forEach(itemId => {
      const stats = itemStats[itemId];
      stats.averageRating = parseFloat((stats.sumRatings / stats.totalRatings).toFixed(1));
    });

    res.json({
      success: true,
      data: {
        ratings: ratings,
        stats: Object.values(itemStats),
        totalRatings: ratings.length
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo calificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones',
      error: error.message
    });
  }
});

// Obtener comentarios de una lista (items)
app.get('/api/admin/lists/:listId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('ðŸ’¬ [ADMIN] Obteniendo comentarios de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    // Obtener todos los comentarios de items de esta lista
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .orderBy('createdAt', 'desc')
      .get();

    const allComments = await Promise.all(commentsSnapshot.docs.map(async (doc) => {
      const commentData = doc.data();
      let userInfo = null;

      // Obtener informaciÃ³n del usuario que comentÃ³
      if (commentData.userId) {
        try {
          const userDoc = await db.collection('users').doc(commentData.userId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario',
              email: userData.email || null,
              photoURL: userData.photoURL || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${commentData.userId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...commentData,
        user: userInfo,
        createdAt: commentData.createdAt?.toDate()
      };
    }));

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = allComments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: allComments.length,
        totalPages: Math.ceil(allComments.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Eliminar calificaciÃ³n
app.delete('/api/admin/lists/:listId/ratings/:ratingId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { ratingId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando calificaciÃ³n:', ratingId);

    await db.collection('itemRatings').doc(ratingId).delete();

    res.json({
      success: true,
      message: 'CalificaciÃ³n eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando calificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando calificaciÃ³n',
      error: error.message
    });
  }
});

// Eliminar comentario
app.delete('/api/admin/lists/:listId/comments/:commentId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { commentId } = req.params;
    
    console.log('ðŸ—‘ï¸ [ADMIN] Eliminando comentario:', commentId);

    await db.collection('listComments').doc(commentId).delete();

    res.json({
      success: true,
      message: 'Comentario eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comentario',
      error: error.message
    });
  }
});

// Obtener calificaciones de un item especÃ­fico
app.get('/api/admin/lists/:listId/items/:itemId/ratings', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId, itemId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('â­ [ADMIN] Obteniendo ratings del item:', itemId, 'en lista:', listId);

    // Primero, obtener todos los ratings de la lista para debug
    const allRatingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();
    
    console.log('ðŸ“Š [ADMIN] Total ratings en la lista:', allRatingsSnapshot.size);
    if (allRatingsSnapshot.size > 0) {
      console.log('ðŸ” [ADMIN] Ejemplo de itemIds encontrados:', 
        allRatingsSnapshot.docs.slice(0, 3).map(doc => doc.data().itemId)
      );
    }

    // Obtener todas las calificaciones del item
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    console.log('âœ… [ADMIN] Ratings encontrados para itemId', itemId, ':', ratingsSnapshot.size);

    const ratings = [];
    for (const doc of ratingsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaciÃ³n del usuario
      let userInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('âš ï¸ [ADMIN] Error obteniendo info del usuario:', data.userId);
      }

      ratings.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        user: userInfo,
        rating: data.rating,
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (mÃ¡s recientes primero)
    ratings.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // Calcular estadÃ­sticas
    const totalRatings = ratings.length;
    const averageRating = totalRatings > 0 
      ? (ratings.reduce((sum, r) => sum + r.rating, 0) / totalRatings).toFixed(2)
      : 0;

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedRatings = ratings.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedRatings,
      stats: {
        totalRatings,
        averageRating: parseFloat(averageRating),
        distribution: {
          5: ratings.filter(r => r.rating === 5).length,
          4: ratings.filter(r => r.rating === 4).length,
          3: ratings.filter(r => r.rating === 3).length,
          2: ratings.filter(r => r.rating === 2).length,
          1: ratings.filter(r => r.rating === 1).length
        }
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalRatings,
        totalPages: Math.ceil(totalRatings / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo ratings del item:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones del item',
      error: error.message
    });
  }
});

// Obtener comentarios de un item especÃ­fico
app.get('/api/admin/lists/:listId/items/:itemId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    let { itemId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    // Decodificar el itemId por si viene con URL encoding
    itemId = decodeURIComponent(itemId);
    
    console.log('ðŸ’¬ [ADMIN] Obteniendo comentarios del item');
    console.log('   - ItemId recibido:', itemId);
    console.log('   - ItemId length:', itemId.length);
    console.log('   - ListId:', listId);

    // Primero, obtener todos los comentarios de la lista para debug
    const allCommentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .get();
    
    console.log('ðŸ“Š [ADMIN] Total comentarios en la lista:', allCommentsSnapshot.size);
    
    if (allCommentsSnapshot.size > 0) {
      const exampleItemIds = allCommentsSnapshot.docs.slice(0, 5).map(doc => {
        const itemId = doc.data().itemId;
        return {
          id: itemId,
          length: itemId?.length,
          type: typeof itemId
        };
      });
      console.log('ðŸ” [ADMIN] Ejemplos de itemIds en Firestore:', JSON.stringify(exampleItemIds, null, 2));
    }

    // Obtener todos los comentarios del item
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    console.log('âœ… [ADMIN] Comentarios encontrados para itemId exacto:', commentsSnapshot.size);
    
    // Si no se encontraron, intentar buscar con comparaciÃ³n flexible
    let allComments = [];
    if (commentsSnapshot.size === 0 && allCommentsSnapshot.size > 0) {
      console.log('âš ï¸ [ADMIN] No se encontrÃ³ match exacto, buscando similares...');
      allCommentsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId && data.itemId.toString() === itemId.toString()) {
          allComments.push({ id: doc.id, data });
          console.log('âœ… [ADMIN] Match encontrado con conversiÃ³n a string');
        }
      });
    }

    // Usar los comentarios encontrados (exactos o flexibles)
    const docsToProcess = commentsSnapshot.size > 0 
      ? commentsSnapshot.docs 
      : allComments.map(c => ({ id: c.id, data: () => c.data }));

    const comments = [];
    for (const doc of docsToProcess) {
      const data = typeof doc.data === 'function' ? doc.data() : doc.data;
      
      // Obtener informaciÃ³n del usuario con foto
      let userInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            displayName: userData.displayName || data.userName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('âš ï¸ [ADMIN] Error obteniendo info del usuario:', data.userId);
        userInfo = {
          displayName: data.userName || 'Usuario',
          email: null,
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        user: userInfo,
        content: data.content,
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (mÃ¡s recientes primero)
    comments.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // PaginaciÃ³n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = comments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: comments.length,
        totalPages: Math.ceil(comments.length / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo comentarios del item:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios del item',
      error: error.message
    });
  }
});

// ==========================================
// ðŸ“¸ SUBIDA DE IMÃGENES GENERAL
// ==========================================

// Endpoint general para subir imÃ¡genes (usuarios autenticados)
app.post('/api/upload/image', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'general' } = req.body; // tipo: list, item, community, profile, etc.

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna imagen'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `${type}-${uid}-${timestamp}-${file.originalname}`;
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`images/${type}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype
      }
    });

    blobStream.on('error', (error) => {
      console.error('Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error al subir la imagen',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const publicUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        res.json({
          success: true,
          message: 'Imagen subida exitosamente',
          imageUrl: publicUrl
        });
      } catch (error) {
        console.error('Error haciendo la imagen pÃºblica:', error);
        res.status(500).json({
          success: false,
          message: 'Error al hacer pÃºblica la imagen',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Endpoint para subir imÃ¡genes desde el admin dashboard
app.post('/api/admin/upload/image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'general' } = req.body; // tipo: list, item, community, profile, etc.

    console.log('ðŸ“¤ [ADMIN] Subiendo imagen, tipo:', type);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna imagen'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `${type}-admin-${uid}-${timestamp}-${file.originalname}`;
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`images/${type}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype
      }
    });

    blobStream.on('error', (error) => {
      console.error('âŒ [ADMIN] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error al subir la imagen',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const publicUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        console.log('âœ… [ADMIN] Imagen subida exitosamente:', publicUrl);
        
        res.json({
          success: true,
          message: 'Imagen subida exitosamente',
          imageUrl: publicUrl
        });
      } catch (error) {
        console.error('âŒ [ADMIN] Error haciendo la imagen pÃºblica:', error);
        res.status(500).json({
          success: false,
          message: 'Error al hacer pÃºblica la imagen',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('âŒ [ADMIN] Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// ==========================================
// ðŸ“¸ FOTO DE PERFIL DEL USUARIO
// ==========================================

// Endpoint para subir/actualizar foto de perfil del usuario
app.post('/api/auth/profile/photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { uid } = req.user;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna foto'
      });
    }

    console.log('ðŸ“¸ [PROFILE-PHOTO] Subiendo foto de perfil para usuario:', uid);
    console.log('ðŸ“¸ [PROFILE-PHOTO] Archivo:', req.file.originalname, req.file.size, 'bytes');

    // Subir a Firebase Storage
    const bucket = admin.storage().bucket();
    const fileName = `profile-photos/${uid}/${Date.now()}_${req.file.originalname}`;
    const file = bucket.file(fileName);

    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
        metadata: {
          firebaseStorageDownloadTokens: uid
        }
      }
    });

    // Hacer el archivo pÃºblico y obtener la URL
    await file.makePublic();
    const photoURL = `https://storage.googleapis.com/${bucket.name}/${fileName}`;

    console.log('âœ… [PROFILE-PHOTO] Foto subida:', photoURL);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: photoURL
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: photoURL,
      updatedAt: new Date()
    });

    console.log('âœ… [PROFILE-PHOTO] Perfil actualizado en Auth y Firestore');

    res.json({
      success: true,
      message: 'Foto de perfil actualizada exitosamente',
      data: {
        photoURL: photoURL
      }
    });

  } catch (error) {
    console.error('âŒ [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al subir la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint para actualizar foto de perfil con URL externa (Google, Apple, etc.)
app.put('/api/auth/profile/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { photoURL } = req.body;

    if (!photoURL) {
      return res.status(400).json({
        success: false,
        message: 'URL de la foto es requerida'
      });
    }

    console.log('ðŸ“¸ [PROFILE-PHOTO] Actualizando foto de perfil para usuario:', uid);
    console.log('ðŸ“¸ [PROFILE-PHOTO] Nueva URL:', photoURL);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: photoURL
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: photoURL,
      updatedAt: new Date()
    });

    console.log('âœ… [PROFILE-PHOTO] Foto de perfil actualizada');

    res.json({
      success: true,
      message: 'Foto de perfil actualizada exitosamente',
      data: {
        photoURL: photoURL
      }
    });

  } catch (error) {
    console.error('âŒ [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint para eliminar foto de perfil
app.delete('/api/auth/profile/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    console.log('ðŸ—‘ï¸ [PROFILE-PHOTO] Eliminando foto de perfil para usuario:', uid);

    // Obtener la foto actual
    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();
    const currentPhotoURL = userData?.photoURL;

    // Si la foto estÃ¡ en Firebase Storage, eliminarla
    if (currentPhotoURL && currentPhotoURL.includes('storage.googleapis.com')) {
      try {
        const bucket = admin.storage().bucket();
        // Extraer el nombre del archivo de la URL
        const filePathMatch = currentPhotoURL.match(/profile-photos\/.+/);
        if (filePathMatch) {
          const filePath = decodeURIComponent(filePathMatch[0]);
          const file = bucket.file(filePath);
          await file.delete();
          console.log('âœ… [PROFILE-PHOTO] Archivo eliminado de Storage:', filePath);
        }
      } catch (storageError) {
        console.log('âš ï¸ [PROFILE-PHOTO] Error al eliminar de Storage (continuando):', storageError.message);
      }
    }

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: null
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: null,
      updatedAt: new Date()
    });

    console.log('âœ… [PROFILE-PHOTO] Foto de perfil eliminada');

    res.json({
      success: true,
      message: 'Foto de perfil eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint protegido - Perfil del usuario
app.get('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const userRecord = await auth.getUser(uid);
    
    let userData = {
      uid: userRecord.uid,
      email: userRecord.email,
      displayName: userRecord.displayName,
      emailVerified: userRecord.emailVerified,
      createdAt: userRecord.metadata.creationTime,
      lastSignIn: userRecord.metadata.lastSignInTime,
      gender: null, // M o F
      childrenCount: 0,
      isPregnant: false,
      gestationWeeks: null
    };

    // Obtener datos adicionales de Firestore
    if (db) {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const firestoreData = userDoc.data();
        
        // Calcular semanas de gestaciÃ³n actuales si estÃ¡ embarazada
        let currentGestationWeeks = firestoreData.gestationWeeks || null;
        let daysSinceRegistration = null;
        
        if (firestoreData.isPregnant && firestoreData.gestationWeeks && firestoreData.createdAt) {
          const now = new Date();
          const createdDate = new Date(firestoreData.createdAt);
          const diffTime = now - createdDate;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          const diffWeeks = Math.floor(diffDays / 7);
          const calculatedWeeks = firestoreData.gestationWeeks + diffWeeks;
          
          // Aplicar lÃ­mites
          if (calculatedWeeks > 42) {
            currentGestationWeeks = 40; // TÃ©rmino completo
          } else if (calculatedWeeks < 4) {
            currentGestationWeeks = 4; // MÃ­nimo
          } else {
            currentGestationWeeks = calculatedWeeks;
          }
          
          daysSinceRegistration = diffDays;
          
          console.log(`ðŸ“Š [PROFILE GESTATION] Usuario: ${firestoreData.gestationWeeks} semanas + ${diffWeeks} semanas = ${currentGestationWeeks} semanas (${diffDays} dÃ­as desde registro)`);
        }
        
        userData = { 
          ...userData, 
          gender: firestoreData.gender || null,
          childrenCount: firestoreData.childrenCount || 0,
          isPregnant: firestoreData.isPregnant || false,
          gestationWeeks: firestoreData.gestationWeeks || null, // Semanas registradas originales
          currentGestationWeeks: currentGestationWeeks, // Semanas calculadas automÃ¡ticamente
          daysSinceRegistration: daysSinceRegistration, // DÃ­as desde el registro
          isActive: firestoreData.isActive || true,
          updatedAt: firestoreData.updatedAt,
          latitude: firestoreData.latitude ?? null,
          longitude: firestoreData.longitude ?? null,
          countryId: firestoreData.countryId || null,
          countryName: firestoreData.countryName || null,
          cityId: firestoreData.cityId || null,
          cityName: firestoreData.cityName || null,
          // âœ¨ NUEVO: Perfil profesional si existe
          professionalProfile: firestoreData.professionalProfile || null
        };
      }
    }

    res.json({
      success: true,
      data: userData
    });

  } catch (error) {
    console.error('Error al obtener perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener perfil del usuario',
      error: error.message
    });
  }
});

// Endpoint para actualizar perfil
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { displayName, email, gender, childrenCount, isPregnant, gestationWeeks } = req.body;

    const updateData = {};
    if (displayName) updateData.displayName = displayName;
    if (email) updateData.email = email;
    if (gender) updateData.gender = gender;
    if (childrenCount !== undefined) updateData.childrenCount = childrenCount;
    if (isPregnant !== undefined) updateData.isPregnant = isPregnant;
    if (gestationWeeks !== undefined) updateData.gestationWeeks = gestationWeeks;

    // Validar gestaciÃ³n solo para mujeres
    if (gender === 'F' && isPregnant && (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42)) {
      return res.status(400).json({
        success: false,
        message: 'Para mujeres embarazadas, las semanas de gestaciÃ³n deben estar entre 1 y 42'
      });
    }

    // Limpiar campos de gestaciÃ³n si no estÃ¡ embarazada o es hombre
    if (gender === 'M' || !isPregnant) {
      updateData.isPregnant = false;
      updateData.gestationWeeks = null;
    }

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, updateData);

    // Calcular el nÃºmero real de hijos de la base de datos
    let actualChildrenCount = 0;
    if (db) {
      const childrenSnapshot = await db.collection('children')
        .where('parentId', '==', uid)
        .get();
      
      actualChildrenCount = childrenSnapshot.size;
      console.log('ðŸ“Š [PROFILE] NÃºmero real de hijos en BD:', actualChildrenCount);
    }

    // Actualizar childrenCount con el valor real
    updateData.childrenCount = actualChildrenCount;

    // Actualizar en Firestore
    if (db) {
      await db.collection('users').doc(uid).update({
        ...updateData,
        updatedAt: new Date()
      });
    }

    res.json({
      success: true,
      message: 'Perfil actualizado exitosamente',
      data: { uid, ...updateData }
    });

  } catch (error) {
    console.error('Error al actualizar perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar perfil',
      error: error.message
    });
  }
});

// Actualizar ubicaciÃ³n del usuario (app)
app.put('/api/auth/location', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { latitude, longitude, countryId, cityId } = req.body || {};

    if (latitude === undefined && longitude === undefined && countryId === undefined && cityId === undefined) {
      return res.status(400).json({
        success: false,
        message: 'Debes enviar latitude/longitude o countryId/cityId'
      });
    }

    const updateData = {};
    if (latitude !== undefined) {
      const parsedLat = parseFloat(latitude);
      if (Number.isNaN(parsedLat)) {
        return res.status(400).json({ success: false, message: 'latitude invÃ¡lida' });
      }
      updateData.latitude = parsedLat;
    }
    if (longitude !== undefined) {
      const parsedLng = parseFloat(longitude);
      if (Number.isNaN(parsedLng)) {
        return res.status(400).json({ success: false, message: 'longitude invÃ¡lida' });
      }
      updateData.longitude = parsedLng;
    }

    const hasLocationIds = Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId');
    if (hasLocationIds) {
      const isBlankLocation = (value) => value === null || value === undefined || String(value).trim() === '';
      const hasNoLocationValues = isBlankLocation(countryId) && isBlankLocation(cityId);
      if (hasNoLocationValues) {
        const defaultLocation = await getDefaultUserLocation();
        updateData.countryId = defaultLocation.countryId;
        updateData.countryName = defaultLocation.countryName;
        updateData.cityId = defaultLocation.cityId;
        updateData.cityName = defaultLocation.cityName;
      } else {
      try {
        const locationData = await resolveCountryCity(countryId, cityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
      }
    }

    if (db) {
      await db.collection('users').doc(uid).set({
        ...updateData,
        updatedAt: new Date()
      }, { merge: true });
    }

    res.json({
      success: true,
      message: 'UbicaciÃ³n actualizada',
      data: { uid, ...updateData }
    });
  } catch (error) {
    console.error('âŒ [PROFILE] Error actualizando ubicaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando ubicaciÃ³n',
      error: error.message
    });
  }
});

// Endpoint para cambiar contraseÃ±a
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { newPassword } = req.body;

    if (!newPassword || newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'La nueva contraseÃ±a debe tener al menos 6 caracteres'
      });
    }

    // Actualizar contraseÃ±a en Firebase Auth
    await auth.updateUser(uid, { password: newPassword });

    res.json({
      success: true,
      message: 'ContraseÃ±a actualizada exitosamente'
    });

  } catch (error) {
    console.error('Error al cambiar contraseÃ±a:', error);
    res.status(500).json({
      success: false,
      message: 'Error al cambiar contraseÃ±a',
      error: error.message
    });
  }
});

// Endpoint para eliminar cuenta
app.delete('/api/auth/account', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Eliminar de Firestore
    if (db) {
      await db.collection('users').doc(uid).delete();
    }

    // Eliminar de Firebase Auth
    await auth.deleteUser(uid);

    res.json({
      success: true,
      message: 'Cuenta eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error al eliminar cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar cuenta',
      error: error.message
    });
  }
});

// Ruta para solicitar restablecimiento de contraseÃ±a
app.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: 'Email es requerido'
      });
    }

    // Verificar que Firebase Auth estÃ© disponible
    if (!auth) {
      console.error('âŒ [FORGOT-PASSWORD] Firebase Auth no estÃ¡ disponible');
      return res.status(500).json({
        success: false,
        message: 'Servicio de autenticaciÃ³n no disponible'
      });
    }

    console.log('ðŸ”‘ [FORGOT-PASSWORD] Solicitando restablecimiento para:', email);

    // Verificar si el usuario existe
    try {
      const userRecord = await auth.getUserByEmail(email);
      console.log('âœ… [FORGOT-PASSWORD] Usuario encontrado:', userRecord.uid);
    } catch (userError) {
      if (userError.code === 'auth/user-not-found') {
        return res.status(404).json({
          success: false,
          message: 'No se encontrÃ³ una cuenta con este email'
        });
      }
      throw userError;
    }

    // Firebase enviarÃ¡ automÃ¡ticamente el email usando sus plantillas configuradas
    // Nota: Debes configurar las plantillas en Firebase Console > Authentication > Templates
    await admin.auth().generatePasswordResetLink(email);
    
    console.log('âœ… [FORGOT-PASSWORD] Email de restablecimiento enviado a:', email);
    
    res.json({
      success: true,
      message: 'Se ha enviado un email con instrucciones para restablecer tu contraseÃ±a. Revisa tu bandeja de entrada y spam.'
    });

  } catch (error) {
    console.error('âŒ [FORGOT-PASSWORD] Error:', error);
    
    if (error.code === 'auth/user-not-found') {
      return res.status(404).json({
        success: false,
        message: 'No se encontrÃ³ una cuenta con este email'
      });
    }

    if (error.code === 'auth/unauthorized-continue-uri') {
      return res.status(400).json({
        success: false,
        message: 'URL de redirecciÃ³n no autorizada. Contacta al administrador.'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al procesar la solicitud de restablecimiento',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Ruta para confirmar restablecimiento de contraseÃ±a
app.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { oobCode, newPassword } = req.body;

    if (!oobCode || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'CÃ³digo de restablecimiento y nueva contraseÃ±a son requeridos'
      });
    }

    // Verificar que Firebase Auth estÃ© disponible
    if (!auth) {
      console.error('âŒ [RESET-PASSWORD] Firebase Auth no estÃ¡ disponible');
      return res.status(500).json({
        success: false,
        message: 'Servicio de autenticaciÃ³n no disponible'
      });
    }

    console.log('ðŸ”‘ [RESET-PASSWORD] Procesando restablecimiento...');

    // Verificar el cÃ³digo y cambiar la contraseÃ±a
    const email = await auth.verifyPasswordResetCode(oobCode);
    await auth.confirmPasswordReset(oobCode, newPassword);

    console.log('âœ… [RESET-PASSWORD] ContraseÃ±a actualizada para:', email);

    res.json({
      success: true,
      message: 'ContraseÃ±a actualizada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [RESET-PASSWORD] Error:', error);
    
    if (error.code === 'auth/invalid-action-code') {
      return res.status(400).json({
        success: false,
        message: 'CÃ³digo de restablecimiento invÃ¡lido o expirado'
      });
    }

    if (error.code === 'auth/weak-password') {
      return res.status(400).json({
        success: false,
        message: 'La contraseÃ±a debe tener al menos 6 caracteres'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al restablecer la contraseÃ±a',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Endpoint para obtener hijos del usuario
app.get('/api/auth/children', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener hijos propios (como padre principal)
    const ownChildrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    // Obtener hijos compartidos (donde el usuario estÃ¡ en sharedWith)
    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const children = [];
    const childIds = new Set(); // Para evitar duplicados

    // Procesar hijos propios
    ownChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...childData,
          isShared: false, // Este es hijo propio
          // InformaciÃ³n calculada automÃ¡ticamente
          currentAgeInMonths: currentInfo.currentAgeInMonths,
          currentGestationWeeks: currentInfo.currentGestationWeeks,
          registeredAgeInMonths: currentInfo.registeredAgeInMonths,
          registeredGestationWeeks: currentInfo.registeredGestationWeeks,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Procesar hijos compartidos
    sharedChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...childData,
          isShared: true, // Este es hijo compartido
          // InformaciÃ³n calculada automÃ¡ticamente
          currentAgeInMonths: currentInfo.currentAgeInMonths,
          currentGestationWeeks: currentInfo.currentGestationWeeks,
          registeredAgeInMonths: currentInfo.registeredAgeInMonths,
          registeredGestationWeeks: currentInfo.registeredGestationWeeks,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Ordenar por createdAt desc
    children.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || a.createdAt || new Date(0);
      const dateB = b.createdAt?.toDate?.() || b.createdAt || new Date(0);
      return dateB - dateA;
    });

    res.json({
      success: true,
      data: children
    });

  } catch (error) {
    console.error('Error al obtener hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener hijos',
      error: error.message
    });
  }
});

// DEBUG: Endpoint para verificar hijos compartidos
app.get('/api/auth/children/debug', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Obtener hijos propios
    const ownChildren = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    // Obtener hijos compartidos
    const sharedChildren = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    // Obtener todos los hijos para ver el array sharedWith
    const allChildrenSnapshot = await db.collection('children').get();
    const allChildrenWithSharedInfo = allChildrenSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      parentId: doc.data().parentId,
      sharedWith: doc.data().sharedWith || []
    }));

    res.json({
      success: true,
      data: {
        currentUserId: uid,
        ownChildrenCount: ownChildren.size,
        ownChildren: ownChildren.docs.map(doc => ({
          id: doc.id,
          name: doc.data().name,
          parentId: doc.data().parentId,
          sharedWith: doc.data().sharedWith || []
        })),
        sharedChildrenCount: sharedChildren.size,
        sharedChildren: sharedChildren.docs.map(doc => ({
          id: doc.id,
          name: doc.data().name,
          parentId: doc.data().parentId,
          sharedWith: doc.data().sharedWith || []
        })),
        allChildren: allChildrenWithSharedInfo.filter(c => 
          c.parentId === uid || c.sharedWith.includes(uid)
        )
      }
    });

  } catch (error) {
    console.error('âŒ [DEBUG] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en debug',
      error: error.message
    });
  }
});

// Endpoint para agregar un hijo
app.post('/api/auth/children', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento (para bebÃ©s nacidos)
      dueDate,          // Nuevo: fecha esperada de parto (para bebÃ©s no nacidos)
      isUnborn, 
      photoUrl,
      // Legacy (para compatibilidad con apps antiguas)
      ageInMonths, 
      gestationWeeks 
    } = req.body;

    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Nombre es requerido'
      });
    }

    // Validar que si es un bebÃ© no nacido, tenga fecha de parto o semanas de gestaciÃ³n (legacy)
    if (isUnborn) {
      if (!dueDate && (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42)) {
      return res.status(400).json({
        success: false,
          message: 'Para bebÃ©s no nacidos, la fecha esperada de parto es requerida (o semanas de gestaciÃ³n entre 1 y 42)'
        });
      }
      
      // Validar que la fecha de parto sea futura (con un margen de 2 semanas para casos de parto tardÃ­o)
      if (dueDate) {
        const due = new Date(dueDate);
        const now = new Date();
        const twoWeeksAgo = new Date(now.getTime() - (14 * 24 * 60 * 60 * 1000));
        
        if (due < twoWeeksAgo) {
      return res.status(400).json({
        success: false,
            message: 'La fecha esperada de parto debe ser futura o reciente (mÃ¡ximo 2 semanas en el pasado)'
          });
        }
      }
    }

    // Validar que si es un bebÃ© nacido, tenga fecha de nacimiento o edad en meses (legacy)
    if (!isUnborn) {
      if (!birthDate && (ageInMonths === undefined || ageInMonths < 0)) {
        return res.status(400).json({
          success: false,
          message: 'Para bebÃ©s nacidos, la fecha de nacimiento es requerida (o edad en meses mayor o igual a 0)'
        });
      }
      
      // Validar que la fecha de nacimiento sea pasada y no muy lejana
      if (birthDate) {
        const birth = new Date(birthDate);
        const now = new Date();
        const maxYearsBack = 18; // MÃ¡ximo 18 aÃ±os
        const minDate = new Date(now.getFullYear() - maxYearsBack, now.getMonth(), now.getDate());
        
        if (birth > now) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento debe ser en el pasado'
          });
        }
        
        if (birth < minDate) {
          return res.status(400).json({
            success: false,
            message: `La fecha de nacimiento no puede ser mayor a ${maxYearsBack} aÃ±os atrÃ¡s`
          });
        }
      }
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const childData = {
      parentId: uid,
      name: name.trim(),
      isUnborn: isUnborn || false,
      photoUrl: photoUrl || null,
      createdAt: now,
      updatedAt: now
    };

    // Usar el nuevo sistema basado en fechas
    if (isUnborn) {
      if (dueDate) {
        childData.dueDate = new Date(dueDate); // Nuevo sistema
        childData.gestationWeeks = null;
      } else {
        // Fallback a sistema legacy
        childData.gestationWeeks = parseInt(gestationWeeks);
        childData.dueDate = null;
        childData.registeredAt = now; // Solo para sistema legacy
      }
      childData.birthDate = null;
      childData.ageInMonths = null;
    } else {
      if (birthDate) {
        childData.birthDate = new Date(birthDate); // Nuevo sistema
        childData.ageInMonths = null;
      } else {
        // Fallback a sistema legacy
        childData.ageInMonths = parseInt(ageInMonths);
        childData.birthDate = null;
        childData.registeredAt = now; // Solo para sistema legacy
      }
      childData.dueDate = null;
      childData.gestationWeeks = null;
    }

    const childRef = await db.collection('children').add(childData);
    
    // Calcular informaciÃ³n actual del hijo
    const childDoc = await childRef.get();
    const childWithInfo = getChildCurrentInfo({ id: childRef.id, ...childDoc.data() });
    
    // Calcular el nÃºmero real de hijos despuÃ©s de agregar
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('ðŸ“Š [CHILDREN] NÃºmero real de hijos despuÃ©s de agregar:', actualChildrenCount);
    
    // Actualizar contador de hijos en el perfil con el valor real
    const userRef = db.collection('users').doc(uid);
    await userRef.update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    // ðŸ“§ Enviar email segÃºn el nÃºmero de hijos
    try {
      const userDoc = await userRef.get();
      const userData = userDoc.data();
      
      if (userData && userData.email) {
        // Calcular edad del hijo para el email
        let childAge = '';
        if (!isUnborn && birthDate) {
          const birth = new Date(birthDate);
          const now = new Date();
          const months = Math.floor((now - birth) / (1000 * 60 * 60 * 24 * 30.44));
          const years = Math.floor(months / 12);
          const remainingMonths = months % 12;
          
          if (years > 0) {
            childAge = `${years} ${years === 1 ? 'aÃ±o' : 'aÃ±os'}`;
            if (remainingMonths > 0) {
              childAge += ` y ${remainingMonths} ${remainingMonths === 1 ? 'mes' : 'meses'}`;
            }
          } else {
            childAge = `${months} ${months === 1 ? 'mes' : 'meses'}`;
          }
        } else if (isUnborn) {
          childAge = 'por nacer';
        } else if (ageInMonths !== undefined) {
          childAge = `${ageInMonths} ${ageInMonths === 1 ? 'mes' : 'meses'}`;
        }
        
        if (actualChildrenCount === 1) {
          // ðŸ“§ Primer hijo
          console.log(`ðŸ“§ [EMAIL] Enviando email de primer hijo a ${userData.email}`);
          const { sendFirstChildEmail } = require('./services/emailService');
          sendFirstChildEmail(
            userData.displayName || userData.name || 'MamÃ¡',
            userData.email,
            name.trim(),
            childAge
          ).catch(err => console.error('âŒ [EMAIL] Error enviando email de primer hijo:', err));
          
        } else if (actualChildrenCount > 1) {
          // ðŸ“§ Hijo adicional (2do, 3ro, etc)
          console.log(`ðŸ“§ [EMAIL] Enviando email de hijo adicional a ${userData.email}`);
          const { sendAdditionalChildEmail } = require('./services/emailService');
          sendAdditionalChildEmail(
            userData.displayName || userData.name || 'MamÃ¡',
            userData.email,
            name.trim(),
            childAge,
            actualChildrenCount
          ).catch(err => console.error('âŒ [EMAIL] Error enviando email de hijo adicional:', err));
        }
        
        // ðŸ“§ Si es un bebÃ© por nacer (embarazo), enviar email de felicitaciÃ³n
        if (isUnborn && dueDate) {
          console.log(`ðŸ“§ [EMAIL] Enviando email de embarazo a ${userData.email}`);
          const { sendPregnancyEmail } = require('./services/emailService');
          sendPregnancyEmail(
            userData.displayName || userData.name || 'MamÃ¡',
            userData.email,
            name.trim(),
            dueDate
          ).catch(err => console.error('âŒ [EMAIL] Error enviando email de embarazo:', err));
        }
      }
    } catch (emailError) {
      console.error('âŒ [EMAIL] Error al enviar emails:', emailError);
      // No fallar la request si el email falla
    }

    res.json({
      success: true,
      message: 'Hijo agregado exitosamente',
      data: childWithInfo
    });

  } catch (error) {
    console.error('Error al agregar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al agregar hijo',
      error: error.message
    });
  }
});

// Endpoint para actualizar un hijo
app.put('/api/auth/children/:childId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento
      dueDate,          // Nuevo: fecha esperada de parto
      isUnborn, 
      photoUrl,
      // Legacy
      ageInMonths, 
      gestationWeeks 
    } = req.body;

    if (!name && !birthDate && !dueDate && ageInMonths === undefined && 
        isUnborn === undefined && gestationWeeks === undefined && !photoUrl) {
      return res.status(400).json({
        success: false,
        message: 'Al menos un campo debe ser proporcionado'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    if (childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    const currentData = childDoc.data();
    const updateData = {
      updatedAt: new Date()
    };
    
    // Actualizar nombre si se proporciona
    if (name) updateData.name = name.trim();
    
    // Actualizar foto si se proporciona
    if (photoUrl !== undefined) {
    if (photoUrl && !isValidUrl(photoUrl)) {
      return res.status(400).json({
        success: false,
        message: 'URL de foto invÃ¡lida'
      });
      }
      updateData.photoUrl = photoUrl;
    }
    
    // Actualizar estado de embarazo si se proporciona
    if (isUnborn !== undefined) {
      updateData.isUnborn = isUnborn;
    }

    // Determinar el estado final de isUnborn
    const finalIsUnborn = isUnborn !== undefined ? isUnborn : currentData.isUnborn;

    // Manejar actualizaciÃ³n de fechas/edades segÃºn el estado
    if (finalIsUnborn) {
      // Es un bebÃ© no nacido
      if (dueDate) {
        // Validar fecha de parto
        const due = new Date(dueDate);
        if (isNaN(due.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha esperada de parto es invÃ¡lida'
          });
        }
        const now = new Date();
        const twoWeeksAgo = new Date(now.getTime() - (14 * 24 * 60 * 60 * 1000));
        
        if (due < twoWeeksAgo) {
          return res.status(400).json({
            success: false,
            message: 'La fecha esperada de parto debe ser futura o reciente (mÃ¡ximo 2 semanas en el pasado)'
          });
        }
        
        updateData.dueDate = due;
        updateData.gestationWeeks = null;
        updateData.birthDate = null;
      updateData.ageInMonths = null;
      } else if (gestationWeeks !== undefined) {
        // Legacy: usar semanas de gestaciÃ³n
        const parsedGestationWeeks = parseInt(gestationWeeks);
        if (Number.isNaN(parsedGestationWeeks) || parsedGestationWeeks < 1 || parsedGestationWeeks > 42) {
          return res.status(400).json({
            success: false,
            message: 'Las semanas de gestaciÃ³n deben estar entre 1 y 42'
          });
        }
        updateData.gestationWeeks = parsedGestationWeeks;
        updateData.dueDate = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
        updateData.registeredAt = new Date();
      }
    } else {
      // Es un bebÃ© nacido
      if (birthDate) {
        // Validar fecha de nacimiento
        const birth = new Date(birthDate);
        if (isNaN(birth.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento es invÃ¡lida'
          });
        }
        const now = new Date();
        const maxYearsBack = 18;
        const minDate = new Date(now.getFullYear() - maxYearsBack, now.getMonth(), now.getDate());
        
        if (birth > now) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento debe ser en el pasado'
          });
        }
        
        if (birth < minDate) {
          return res.status(400).json({
            success: false,
            message: `La fecha de nacimiento no puede ser mayor a ${maxYearsBack} aÃ±os atrÃ¡s`
          });
        }
        
        updateData.birthDate = birth;
        updateData.ageInMonths = null;
        updateData.dueDate = null;
      updateData.gestationWeeks = null;
      } else if (ageInMonths !== undefined) {
        // Legacy: usar edad en meses
        const parsedAgeInMonths = parseInt(ageInMonths);
        if (Number.isNaN(parsedAgeInMonths) || parsedAgeInMonths < 0) {
          return res.status(400).json({
            success: false,
            message: 'La edad en meses debe ser mayor o igual a 0'
          });
        }
        updateData.ageInMonths = parsedAgeInMonths;
        updateData.birthDate = null;
        updateData.dueDate = null;
        updateData.gestationWeeks = null;
        updateData.registeredAt = new Date();
      }
    }

    await db.collection('children').doc(childId).update(updateData);

    // Obtener el hijo actualizado con informaciÃ³n calculada
    const updatedChildDoc = await db.collection('children').doc(childId).get();
    const updatedChild = getChildCurrentInfo({ id: childId, ...updatedChildDoc.data() });

    res.json({
      success: true,
      message: 'Hijo actualizado exitosamente',
      data: updatedChild
    });

  } catch (error) {
    console.error('Error al actualizar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar hijo',
      error: error.message
    });
  }
});

// Endpoint para subir foto de hijo usando Firebase Storage
app.post('/api/auth/children/upload-photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.body;

    if (!childId) {
      return res.status(400).json({
        success: false,
        message: 'ID del hijo es requerido'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ningÃºn archivo'
      });
    }

    // Verificar que Firebase Admin estÃ© inicializado
    if (!admin) {
      console.error('âŒ [STORAGE] Firebase Admin no estÃ¡ inicializado');
      return res.status(500).json({
        success: false,
        message: 'Error interno del servidor: Firebase no configurado'
      });
    }

    // Verificar que Firebase Storage estÃ© disponible
    try {
      const bucket = admin.storage().bucket();
      console.log('âœ… [STORAGE] Firebase Storage disponible');
      console.log('ðŸ“¦ [STORAGE] Bucket:', bucket.name);
    } catch (storageError) {
      console.error('âŒ [STORAGE] Error accediendo a Firebase Storage:', storageError);
      return res.status(500).json({
        success: false,
        message: 'Error interno del servidor: Storage no disponible',
        error: storageError.message
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    // Subir archivo a Firebase Storage usando buffer de memoria
    console.log('ðŸ” [STORAGE] Verificando admin:', admin ? 'âœ… Inicializado' : 'âŒ Null');
    console.log('ðŸ” [STORAGE] Verificando admin.storage:', admin.storage ? 'âœ… Disponible' : 'âŒ No disponible');
    console.log('ðŸ” [STORAGE] Project ID:', process.env.FIREBASE_PROJECT_ID);
    
    const bucket = admin.storage().bucket();
    console.log('ðŸ“¦ [STORAGE] Bucket obtenido:', bucket.name);
    
    const fileName = `children/${childId}/photo-${Date.now()}-${Math.round(Math.random() * 1E9)}${path.extname(req.file.originalname)}`;
    
    console.log('ðŸ“¤ [STORAGE] Subiendo archivo a Firebase Storage:', fileName);

    // Usar el buffer de memoria directamente
    const file = bucket.file(fileName);
    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
        metadata: {
          uploadedBy: uid,
          childId: childId,
          originalName: req.file.originalname
        }
      }
    });

    // Hacer el archivo pÃºblico
    await file.makePublic();

    // Obtener URL pÃºblica
    const photoUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
    
    console.log('âœ… [STORAGE] Archivo subido exitosamente:', photoUrl);

    // Actualizar el hijo con la nueva foto
    await db.collection('children').doc(childId).update({
      photoUrl: photoUrl,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Foto subida exitosamente',
      data: {
        photoUrl: photoUrl,
        fileName: fileName
      }
    });

  } catch (error) {
    console.error('Error subiendo foto a Firebase Storage:', error);
    
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});



// Endpoint para sincronizar childrenCount
app.post('/api/auth/children/sync-count', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Contar hijos reales en la base de datos
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('ðŸ“Š [SYNC] Sincronizando childrenCount:', actualChildrenCount);

    // Actualizar el perfil con el nÃºmero real
    await db.collection('users').doc(uid).update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'ChildrenCount sincronizado correctamente',
      data: {
        childrenCount: actualChildrenCount
      }
    });

  } catch (error) {
    console.error('Error sincronizando childrenCount:', error);
    res.status(500).json({
      success: false,
      message: 'Error sincronizando childrenCount',
      error: error.message
    });
  }
});

// Endpoint para calcular edad en meses desde fecha de nacimiento
app.post('/api/auth/children/calculate-age', authenticateToken, async (req, res) => {
  try {
    const { birthDate } = req.body;

    if (!birthDate) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de nacimiento es requerida'
      });
    }

    const ageInMonths = calculateAgeFromBirthDate(birthDate);
    const birth = new Date(birthDate);
    const today = new Date();
    const ageInDays = Math.max(0, Math.floor((today - birth) / (1000 * 60 * 60 * 24)));
    
    const years = Math.floor(ageInMonths / 12);
    const months = ageInMonths % 12;

    res.json({
      success: true,
      data: {
        ageInMonths: ageInMonths,
        ageInDays: ageInDays,
        ageInYears: years,
        monthsRemainder: months,
        formattedAge: years > 0 
          ? `${years} aÃ±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
          : `${months} mes${months > 1 ? 'es' : ''}`
      }
    });

  } catch (error) {
    console.error('Error calculando edad:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando edad',
      error: error.message
    });
  }
});

// Endpoint helper para calcular fecha de parto desde semanas de gestaciÃ³n
app.post('/api/auth/children/calculate-due-date', authenticateToken, async (req, res) => {
  try {
    const { gestationWeeks } = req.body;

    if (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 45) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaciÃ³n deben estar entre 1 y 45'
      });
    }

    const today = new Date();
    const weeksRemaining = 40 - gestationWeeks; // Embarazo completo son 40 semanas
    const daysRemaining = weeksRemaining * 7;
    
    const dueDate = new Date(today.getTime() + (daysRemaining * 24 * 60 * 60 * 1000));

    res.json({
      success: true,
      data: {
        dueDate: dueDate.toISOString().split('T')[0], // Formato YYYY-MM-DD
        currentWeeks: gestationWeeks,
        weeksRemaining: Math.max(0, weeksRemaining),
        daysRemaining: Math.max(0, daysRemaining),
        isOverdue: gestationWeeks >= 40
      }
    });
  } catch (error) {
    console.error('Error calculando fecha de parto:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando fecha de parto',
      error: error.message
    });
  }
});

// Endpoint helper para calcular semanas de gestaciÃ³n desde fecha de parto
app.post('/api/auth/children/calculate-gestation-weeks', authenticateToken, async (req, res) => {
  try {
    const { dueDate } = req.body;

    if (!dueDate) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de parto es requerida'
      });
    }

    const gestationInfo = calculateGestationFromDueDate(dueDate);

    res.json({
      success: true,
      data: {
        currentWeeks: gestationInfo.weeks,
        daysUntilDue: gestationInfo.daysUntilDue,
        isOverdue: gestationInfo.isOverdue,
        dueDateFormatted: new Date(dueDate).toLocaleDateString('es-ES', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        })
      }
    });
  } catch (error) {
    console.error('Error calculando semanas de gestaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando semanas de gestaciÃ³n',
      error: error.message
    });
  }
});

// Endpoint para eliminar foto de hijo de Firebase Storage
app.delete('/api/auth/children/:childId/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    // Si hay una foto existente, eliminarla de Firebase Storage
    if (childData.photoUrl) {
      try {
        const bucket = admin.storage().bucket();
        
        // Extraer el nombre del archivo de la URL
        const urlParts = childData.photoUrl.split('/');
        const fileName = urlParts.slice(-2).join('/'); // children/childId/filename
        
        console.log('ðŸ—‘ï¸ [STORAGE] Eliminando archivo de Firebase Storage:', fileName);
        
        await bucket.file(fileName).delete();
        console.log('âœ… [STORAGE] Archivo eliminado exitosamente');
      } catch (storageError) {
        console.error('âš ï¸ [STORAGE] Error eliminando archivo de Storage (continuando):', storageError);
        // Continuar aunque falle la eliminaciÃ³n del archivo
      }
    }

    // Actualizar el hijo eliminando la foto
    await db.collection('children').doc(childId).update({
      photoUrl: null,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Foto eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando foto',
      error: error.message
    });
  }
});

// Endpoint para eliminar un hijo
app.delete('/api/auth/children/:childId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    if (childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar este hijo'
      });
    }

    await db.collection('children').doc(childId).delete();

    // Calcular el nÃºmero real de hijos despuÃ©s de eliminar
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('ðŸ“Š [CHILDREN] NÃºmero real de hijos despuÃ©s de eliminar:', actualChildrenCount);
    
    // Actualizar contador de hijos en el perfil con el valor real
    const userRef = db.collection('users').doc(uid);
    await userRef.update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Hijo eliminado exitosamente'
    });

  } catch (error) {
    console.error('Error al eliminar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar hijo',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ¤ SISTEMA DE COMPARTIR HIJOS
// ============================================================================

// Generar link de invitaciÃ³n para compartir un hijo
app.post('/api/auth/children/:childId/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { role = 'otro', expiresInDays = 7 } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe y pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid && !childData.sharedWith?.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para compartir este hijo'
      });
    }

    // Validar rol
    const validRoles = ['padre', 'madre', 'cuidadora', 'familiar', 'otro'];
    if (!validRoles.includes(role)) {
      return res.status(400).json({
        success: false,
        message: 'Rol invÃ¡lido. Debe ser: padre, madre, cuidadora, familiar u otro'
      });
    }

    // Generar token Ãºnico
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');

    // Calcular fecha de expiraciÃ³n
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + parseInt(expiresInDays));

    // Guardar invitaciÃ³n
    const invitationData = {
      token,
      childId,
      childName: childData.name,
      invitedBy: uid,
      role,
      status: 'pending',
      createdAt: new Date(),
      expiresAt
    };

    await db.collection('childInvitations').add(invitationData);

    console.log(`âœ… [SHARE] InvitaciÃ³n creada para hijo ${childId} por ${uid}`);

    // Generar link
    const invitationLink = `munpa://share-child/${token}`;

    res.json({
      success: true,
      message: 'InvitaciÃ³n creada exitosamente',
      data: {
        token,
        invitationLink,
        expiresAt: expiresAt.toISOString(),
        childName: childData.name,
        role
      }
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error creando invitaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando invitaciÃ³n',
      error: error.message
    });
  }
});

// Ver invitaciones pendientes del usuario
app.get('/api/auth/children/invitations', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener invitaciones pendientes (no es necesario que sean especÃ­ficas del usuario, 
    // cualquiera con el link puede aceptar)
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('status', '==', 'pending')
      .where('expiresAt', '>', new Date())
      .get();

    const invitations = [];
    for (const doc of invitationsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener info del usuario que invitÃ³
      let inviterName = 'Usuario';
      try {
        const inviterDoc = await db.collection('users').doc(data.invitedBy).get();
        if (inviterDoc.exists) {
          const inviterData = inviterDoc.data();
          inviterName = inviterData.displayName || inviterData.name || 'Usuario';
        }
      } catch (error) {
        console.warn('âš ï¸ [SHARE] Error obteniendo info del invitador:', error);
      }

      invitations.push({
        id: doc.id,
        token: data.token,
        childName: data.childName,
        invitedBy: data.invitedBy,
        inviterName,
        role: data.role,
        status: data.status,
        createdAt: data.createdAt,
        expiresAt: data.expiresAt
      });
    }

    res.json({
      success: true,
      data: invitations
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error obteniendo invitaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo invitaciones',
      error: error.message
    });
  }
});

// Aceptar invitaciÃ³n (desde el link)
app.post('/api/auth/children/invitations/:token/accept', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaciÃ³n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'InvitaciÃ³n no encontrada'
      });
    }

    const invitationDoc = invitationsSnapshot.docs[0];
    const invitationData = invitationDoc.data();

    // Validar que no estÃ© expirada
    if (invitationData.expiresAt.toDate() < new Date()) {
      return res.status(400).json({
        success: false,
        message: 'Esta invitaciÃ³n ha expirado'
      });
    }

    // Validar que no estÃ© ya aceptada o rechazada
    if (invitationData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `Esta invitaciÃ³n ya fue ${invitationData.status === 'accepted' ? 'aceptada' : 'rechazada'}`
      });
    }

    // Validar que no sea el mismo usuario que creÃ³ la invitaciÃ³n
    if (invitationData.invitedBy === uid) {
      return res.status(400).json({
        success: false,
        message: 'No puedes aceptar tu propia invitaciÃ³n'
      });
    }

    // Obtener el hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'El hijo ya no existe'
      });
    }

    const childData = childDoc.data();

    // Verificar que el usuario no tenga ya acceso
    if (childData.parentId === uid || childData.sharedWith?.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya tienes acceso a este hijo'
      });
    }

    // Agregar al usuario a la lista de compartidos
    await db.collection('children').doc(invitationData.childId).update({
      sharedWith: admin.firestore.FieldValue.arrayUnion(uid),
      updatedAt: new Date()
    });

    // Actualizar invitaciÃ³n
    await invitationDoc.ref.update({
      status: 'accepted',
      acceptedBy: uid,
      acceptedAt: new Date()
    });

    // Obtener info del usuario para logging
    const userDoc = await db.collection('users').doc(uid).get();
    const userName = userDoc.exists ? (userDoc.data().displayName || userDoc.data().name || 'Usuario') : 'Usuario';

    console.log(`âœ… [SHARE] ${userName} (${uid}) aceptÃ³ invitaciÃ³n para hijo ${invitationData.childId}`);

    res.json({
      success: true,
      message: 'InvitaciÃ³n aceptada exitosamente',
      data: {
        childId: invitationData.childId,
        childName: invitationData.childName,
        role: invitationData.role
      }
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error aceptando invitaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error aceptando invitaciÃ³n',
      error: error.message
    });
  }
});

// Rechazar invitaciÃ³n
app.post('/api/auth/children/invitations/:token/reject', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaciÃ³n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'InvitaciÃ³n no encontrada'
      });
    }

    const invitationDoc = invitationsSnapshot.docs[0];
    const invitationData = invitationDoc.data();

    // Validar que estÃ© pendiente
    if (invitationData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `Esta invitaciÃ³n ya fue ${invitationData.status === 'accepted' ? 'aceptada' : 'rechazada'}`
      });
    }

    // Actualizar invitaciÃ³n
    await invitationDoc.ref.update({
      status: 'rejected',
      rejectedBy: uid,
      rejectedAt: new Date()
    });

    console.log(`âœ… [SHARE] Usuario ${uid} rechazÃ³ invitaciÃ³n para hijo ${invitationData.childId}`);

    res.json({
      success: true,
      message: 'InvitaciÃ³n rechazada'
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error rechazando invitaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando invitaciÃ³n',
      error: error.message
    });
  }
});

// Ver con quiÃ©n se comparte un hijo
app.get('/api/auth/children/:childId/shared-with', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe y el usuario tiene acceso
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid && !childData.sharedWith?.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver esta informaciÃ³n'
      });
    }

    // Obtener lista de usuarios con quienes se comparte
    const sharedWithUsers = childData.sharedWith || [];
    const usersInfo = [];

    // Agregar el padre/madre principal
    try {
      const parentDoc = await db.collection('users').doc(childData.parentId).get();
      if (parentDoc.exists) {
        const parentData = parentDoc.data();
        usersInfo.push({
          userId: childData.parentId,
          name: parentData.displayName || parentData.name || 'Usuario',
          photoUrl: parentData.photoUrl || null,
          role: 'principal',
          isPrincipal: true
        });
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo info del padre:', error);
    }

    // Agregar los usuarios compartidos
    for (const userId of sharedWithUsers) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          
          // Buscar el rol en las invitaciones aceptadas
          let role = 'otro';
          const invitationSnapshot = await db.collection('childInvitations')
            .where('childId', '==', childId)
            .where('acceptedBy', '==', userId)
            .where('status', '==', 'accepted')
            .limit(1)
            .get();
          
          if (!invitationSnapshot.empty) {
            role = invitationSnapshot.docs[0].data().role;
          }

          usersInfo.push({
            userId,
            name: userData.displayName || userData.name || 'Usuario',
            photoUrl: userData.photoUrl || null,
            role,
            isPrincipal: false
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [SHARE] Error obteniendo info del usuario ${userId}:`, error);
      }
    }

    res.json({
      success: true,
      data: usersInfo
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error obteniendo usuarios compartidos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo usuarios compartidos',
      error: error.message
    });
  }
});

// Dejar de compartir con un usuario
app.delete('/api/auth/children/:childId/shared-with/:userId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, userId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();

    // Solo el padre principal puede dejar de compartir
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el padre/madre principal puede dejar de compartir'
      });
    }

    // No puede eliminar al padre principal
    if (userId === childData.parentId) {
      return res.status(400).json({
        success: false,
        message: 'No puedes eliminar al padre/madre principal'
      });
    }

    // Remover usuario de la lista
    await db.collection('children').doc(childId).update({
      sharedWith: admin.firestore.FieldValue.arrayRemove(userId),
      updatedAt: new Date()
    });

    console.log(`âœ… [SHARE] Se dejÃ³ de compartir hijo ${childId} con usuario ${userId}`);

    res.json({
      success: true,
      message: 'Se dejÃ³ de compartir exitosamente'
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error dejando de compartir:', error);
    res.status(500).json({
      success: false,
      message: 'Error dejando de compartir',
      error: error.message
    });
  }
});

// Verificar invitaciÃ³n por token (para mostrar info antes de aceptar/rechazar)
app.get('/api/auth/children/invitations/:token', authenticateToken, async (req, res) => {
  try {
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaciÃ³n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'InvitaciÃ³n no encontrada'
      });
    }

    const invitationData = invitationsSnapshot.docs[0].data();

    // Obtener info del usuario que invitÃ³
    let inviterName = 'Usuario';
    let inviterPhoto = null;
    try {
      const inviterDoc = await db.collection('users').doc(invitationData.invitedBy).get();
      if (inviterDoc.exists) {
        const inviterData = inviterDoc.data();
        inviterName = inviterData.displayName || inviterData.name || 'Usuario';
        inviterPhoto = inviterData.photoUrl || null;
      }
    } catch (error) {
      console.warn('âš ï¸ [SHARE] Error obteniendo info del invitador:', error);
    }

    // Obtener info del hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    let childPhotoUrl = null;
    if (childDoc.exists) {
      childPhotoUrl = childDoc.data().photoUrl || null;
    }

    res.json({
      success: true,
      data: {
        token,
        childName: invitationData.childName,
        childPhotoUrl,
        inviterName,
        inviterPhoto,
        role: invitationData.role,
        status: invitationData.status,
        createdAt: invitationData.createdAt,
        expiresAt: invitationData.expiresAt,
        isExpired: invitationData.expiresAt.toDate() < new Date()
      }
    });

  } catch (error) {
    console.error('âŒ [SHARE] Error obteniendo invitaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo invitaciÃ³n',
      error: error.message
    });
  }
});

// Endpoint para verificar token
app.get('/api/auth/verify-token', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Obtener informaciÃ³n del usuario
    const userRecord = await auth.getUser(uid);

    res.json({
      success: true,
      message: 'Token vÃ¡lido',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        emailVerified: userRecord.emailVerified
      }
    });

  } catch (error) {
    console.error('Error al verificar token:', error);
    res.status(401).json({
      success: false,
      message: 'Token invÃ¡lido',
      error: error.message
    });
  }
});

// Endpoint para agregar conocimiento a la base de datos
app.post('/api/doula/knowledge', authenticateToken, async (req, res) => {
  try {
    const { text, metadata } = req.body;

    if (!text || text.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El texto es requerido'
      });
    }

    const success = await saveKnowledge(text, metadata);
    
    if (success) {
      res.json({
        success: true,
        message: 'Conocimiento agregado correctamente'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al agregar conocimiento'
      });
    }

  } catch (error) {
    console.error('âŒ Error agregando conocimiento:', error);
    res.status(500).json({
      success: false,
      message: 'Error al agregar conocimiento',
      error: error.message
    });
  }
});

// Endpoint para aprendizaje validado (POST /learn)
app.post('/api/doula/learn', authenticateToken, async (req, res) => {
  try {
    const { 
      text, 
      metadata, 
      validation = {
        approved: false,
        approvedBy: null,
        approvedAt: null,
        checklist: {
          sourceVerified: false,
          medicalAccuracy: false,
          toneAppropriate: false,
          contentRelevant: false
        }
      }
    } = req.body;

    if (!text || text.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El texto es requerido'
      });
    }

    // Validar que el checklist estÃ© completo
    const checklist = validation.checklist;
    const isFullyValidated = Object.values(checklist).every(item => item === true);

    if (!isFullyValidated) {
      return res.status(400).json({
        success: false,
        message: 'El conocimiento debe pasar todas las validaciones del checklist',
        checklist: checklist
      });
    }

    // Agregar metadatos de validaciÃ³n
    const validatedMetadata = {
      ...metadata,
      validation: {
        ...validation,
        approved: true,
        approvedAt: new Date(),
        approvedBy: req.user.uid
      },
      version: metadata.version || '1.0',
      createdAt: new Date(),
      isActive: true
    };

    const success = await saveKnowledge(text, validatedMetadata);
    
    if (success) {
      res.json({
        success: true,
        message: 'Conocimiento validado y agregado correctamente',
        data: {
          text: text.substring(0, 100) + '...',
          metadata: validatedMetadata
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al agregar conocimiento validado'
      });
    }

  } catch (error) {
    console.error('âŒ Error en aprendizaje validado:', error);
    res.status(500).json({
      success: false,
      message: 'Error en aprendizaje validado',
      error: error.message
    });
  }
});

// Endpoint para guardar feedback del usuario
app.post('/api/doula/feedback', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { conversationId, feedback, details } = req.body;

    if (!feedback || !['positive', 'negative'].includes(feedback)) {
      return res.status(400).json({
        success: false,
        message: 'Feedback debe ser "positive" o "negative"'
      });
    }

    const feedbackData = {
      userId: uid,
      conversationId: conversationId,
      feedback: feedback,
      details: details || {},
      timestamp: new Date(),
      processed: false
    };

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('user_feedback').add(feedbackData);
    
    console.log('ðŸ’¾ [FEEDBACK] Feedback guardado:', feedback);
    
    // Si es feedback positivo, considerar guardar como Q&A validado
    if (feedback === 'positive' && details && details.question && details.answer) {
      const qaData = {
        question: details.question,
        answer: details.answer,
        tags: details.tags || [],
        qualityScore: 0.9,
        createdAt: new Date(),
        isActive: true,
        usageCount: 0,
        source: 'user_feedback',
        validatedBy: uid
      };
      
      await db.collection('validated_qa').add(qaData);
      console.log('âœ… [QA] Q&A validado guardado desde feedback');
    }
    
    res.json({
      success: true,
      message: 'Feedback guardado correctamente'
    });

  } catch (error) {
    console.error('âŒ Error guardando feedback:', error);
    res.status(500).json({
      success: false,
      message: 'Error al guardar feedback',
      error: error.message
    });
  }
});

// Endpoint para actualizar memoria del usuario
app.put('/api/doula/memory', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { notes, preferences } = req.body;

    const memoryData = {
      notes: notes || [],
      preferences: preferences || {}
    };

    const success = await saveUserMemory(uid, memoryData);
    
    if (success) {
      res.json({
        success: true,
        message: 'Memoria actualizada correctamente'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al actualizar memoria'
      });
    }

  } catch (error) {
    console.error('âŒ Error actualizando memoria:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar memoria',
      error: error.message
    });
  }
});

// Endpoint para borrar memoria del usuario
app.delete('/api/doula/memory', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('user_memory').doc(uid).delete();
    
    console.log('ðŸ—‘ï¸ [MEMORY] Memoria borrada para usuario:', uid);
    
    res.json({
      success: true,
      message: 'Memoria borrada correctamente'
    });

  } catch (error) {
    console.error('âŒ Error borrando memoria:', error);
    res.status(500).json({
      success: false,
      message: 'Error al borrar memoria',
      error: error.message
    });
  }
});

// Endpoint para tests automÃ¡ticos de calidad
app.post('/api/doula/quality-test', authenticateToken, async (req, res) => {
  try {
    const testQuestions = [
      {
        question: "Â¿QuÃ© ejercicios puedo hacer durante el embarazo?",
        expectedCategory: "embarazo",
        expectedKeywords: ["caminar", "yoga", "nataciÃ³n", "seguro"]
      },
      {
        question: "Â¿CÃ³mo puedo prepararme para la lactancia?",
        expectedCategory: "lactancia",
        expectedKeywords: ["contacto", "agarre", "demanda", "beneficios"]
      },
      {
        question: "Â¿CuÃ¡les son los sÃ­ntomas del primer trimestre?",
        expectedCategory: "embarazo",
        expectedKeywords: ["nÃ¡useas", "fatiga", "senos", "hormonas"]
      },
      {
        question: "Â¿Puedes ayudarme con programaciÃ³n en JavaScript?",
        expectedCategory: "off_topic",
        expectedResponse: "especializada en acompaÃ±amiento durante el embarazo"
      }
    ];

    const results = [];
    let totalScore = 0;

    for (const test of testQuestions) {
      try {
        // Simular llamada al chat
        const response = await generateDoulaResponse(test.question, '', '', 'TestUser');
        
        let score = 0;
        let feedback = '';

        if (test.expectedCategory === 'off_topic') {
          // Verificar que redirija correctamente
          if (response.includes(test.expectedResponse)) {
            score = 1;
            feedback = 'âœ… RedirecciÃ³n correcta para tema fuera del Ã¡mbito';
          } else {
            feedback = 'âŒ No redirigiÃ³ correctamente tema fuera del Ã¡mbito';
          }
        } else {
          // Verificar palabras clave esperadas
          const keywordMatches = test.expectedKeywords.filter(keyword => 
            response.toLowerCase().includes(keyword.toLowerCase())
          );
          
          score = keywordMatches.length / test.expectedKeywords.length;
          feedback = `âœ… EncontrÃ³ ${keywordMatches.length}/${test.expectedKeywords.length} palabras clave`;
        }

        results.push({
          question: test.question,
          expectedCategory: test.expectedCategory,
          score: score,
          feedback: feedback,
          response: response.substring(0, 200) + '...'
        });

        totalScore += score;

      } catch (error) {
        results.push({
          question: test.question,
          expectedCategory: test.expectedCategory,
          score: 0,
          feedback: 'âŒ Error en test',
          error: error.message
        });
      }
    }

    const averageScore = totalScore / testQuestions.length;
    const qualityStatus = averageScore >= 0.8 ? 'EXCELENTE' : averageScore >= 0.6 ? 'BUENO' : 'NEEDS_IMPROVEMENT';

    res.json({
      success: true,
      data: {
        testDate: new Date(),
        totalTests: testQuestions.length,
        averageScore: averageScore,
        qualityStatus: qualityStatus,
        results: results
      }
    });

  } catch (error) {
    console.error('âŒ Error en test de calidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error en test de calidad',
      error: error.message
    });
  }
});

// Endpoint para obtener informaciÃ³n de desarrollo infantil por edad
app.post('/api/children/development-info', authenticateToken, async (req, res) => {
  try {
    const { childId, name } = req.body;
    const userId = req.user.uid;

    let child = null;
    let currentAgeInMonths = null;
    let currentGestationWeeks = null;
    let isUnborn = false;

    // Si se proporciona childId, buscar el hijo en la base de datos
    if (childId) {
      const childDoc = await db.collection('children').doc(childId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      
      child = childDoc.data();
      
      // Verificar que el hijo pertenece al usuario
      if (child.parentId !== userId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }

      // Calcular edad actual basada en fecha de registro
      const childInfo = getChildCurrentInfo(child);
      currentAgeInMonths = childInfo.currentAgeInMonths;
      currentGestationWeeks = childInfo.currentGestationWeeks;
      isUnborn = child.isUnborn;
      
      console.log(`ðŸ“Š [DEVELOPMENT] ${child.name}: ${isUnborn ? currentGestationWeeks + ' semanas' : currentAgeInMonths + ' meses'} (calculado desde ${childInfo.registeredAgeInMonths || childInfo.registeredGestationWeeks})`);
    } else if (name) {
      // Modo de compatibilidad: usar nombre y parÃ¡metros manuales
      const { ageInMonths, isUnborn: manualIsUnborn, gestationWeeks } = req.body;
      
      if (!name.trim()) {
        return res.status(400).json({
          success: false,
          message: 'El nombre del niÃ±o es requerido'
        });
      }

      if (manualIsUnborn && !gestationWeeks) {
        return res.status(400).json({
          success: false,
          message: 'Para niÃ±os por nacer, las semanas de gestaciÃ³n son requeridas'
        });
      }

      if (!manualIsUnborn && !ageInMonths && ageInMonths !== 0) {
        return res.status(400).json({
          success: false,
          message: 'Para niÃ±os nacidos, la edad en meses es requerida'
        });
      }

      currentAgeInMonths = manualIsUnborn ? null : ageInMonths;
      currentGestationWeeks = manualIsUnborn ? gestationWeeks : null;
      isUnborn = manualIsUnborn;
      
      console.log(`ðŸ“Š [DEVELOPMENT] ${name}: ${isUnborn ? currentGestationWeeks + ' semanas' : currentAgeInMonths + ' meses'} (manual)`);
    } else {
      return res.status(400).json({
        success: false,
        message: 'Se requiere childId o nombre del niÃ±o'
      });
    }

    // Crear clave Ãºnica para el historial
    const childKey = child ? `${child.id}_${isUnborn ? 'unborn' : 'born'}` : `${name.trim()}_${isUnborn ? 'unborn' : 'born'}`;
    const previousResponses = await getPreviousDevelopmentResponses(userId, childKey);

    // Obtener informaciÃ³n variada desde OpenAI
    let developmentInfo = [];
    if (isUnborn) {
      developmentInfo = await getUnbornDevelopmentInfoFromAI(currentGestationWeeks, previousResponses, child ? child.name : name.trim());
    } else {
      developmentInfo = await getChildDevelopmentInfoFromAI(currentAgeInMonths, previousResponses, child ? child.name : name.trim());
    }

    // Guardar esta respuesta para futuras consultas
    await saveDevelopmentResponse(userId, childKey, {
      childName: child ? child.name : name.trim(),
      childId: child ? child.id : null,
      ageInMonths: currentAgeInMonths,
      gestationWeeks: currentGestationWeeks,
      isUnborn: isUnborn,
      developmentInfo: developmentInfo,
      timestamp: new Date()
    });

    res.json({
      success: true,
      data: {
        childName: child ? child.name : name.trim(),
        childId: child ? child.id : null,
        ageInMonths: currentAgeInMonths,
        gestationWeeks: currentGestationWeeks,
        isUnborn: isUnborn,
        developmentInfo: developmentInfo,
        timestamp: new Date(),
        responseCount: previousResponses.length + 1,
        isNewInfo: previousResponses.length === 0,
        calculatedAge: true,
        // InformaciÃ³n detallada de edades
        registeredAge: child ? (child.isUnborn ? childInfo.registeredGestationWeeks : childInfo.registeredAgeInMonths) : null,
        currentAge: child ? (child.isUnborn ? childInfo.currentGestationWeeks : childInfo.currentAgeInMonths) : null,
        daysSinceCreation: child ? childInfo.daysSinceCreation : null,
        // InformaciÃ³n adicional para bebÃ©s por nacer
        isOverdue: child ? childInfo.isOverdue : false,
        // InformaciÃ³n de cÃ¡lculo
        calculationInfo: child ? {
          registeredWeeks: child.isUnborn ? childInfo.registeredGestationWeeks : null,
          registeredMonths: child.isUnborn ? null : childInfo.registeredAgeInMonths,
          currentWeeks: child.isUnborn ? childInfo.currentGestationWeeks : null,
          currentMonths: child.isUnborn ? null : childInfo.currentAgeInMonths,
          daysSinceCreation: childInfo.daysSinceCreation
        } : null
      }
    });

  } catch (error) {
    console.error('âŒ Error obteniendo informaciÃ³n de desarrollo:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaciÃ³n de desarrollo',
      error: error.message
    });
  }
});

// GuÃ­a diaria para bebÃ© o embarazo (con OpenAI)
app.post('/api/guide/today', authenticateToken, async (req, res) => {
  try {
    const { birthDate, gestationWeeks, ageWeeks, name, isPregnant = false, childId } = req.body;

    let weeks = null;
    let months = null;
    let ageBreakdown = null;
    let pregnant = Boolean(isPregnant);
    let resolvedChildId = childId || null;

    if (!resolvedChildId && name && db) {
      const trimmedName = String(name).trim();
      const ownSnapshot = await db.collection('children')
        .where('parentId', '==', req.user.uid)
        .where('name', '==', trimmedName)
        .limit(1)
        .get();
      if (!ownSnapshot.empty) {
        resolvedChildId = ownSnapshot.docs[0].id;
      } else {
        const sharedSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', req.user.uid)
          .where('name', '==', trimmedName)
          .limit(1)
          .get();
        if (!sharedSnapshot.empty) {
          resolvedChildId = sharedSnapshot.docs[0].id;
        }
      }
    }

    if (resolvedChildId) {
      const childDoc = await db.collection('children').doc(resolvedChildId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      const childData = childDoc.data();
      const isOwner = childData.parentId === req.user.uid;
      const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(req.user.uid);
      if (!isOwner && !isShared) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }
      pregnant = Boolean(childData.isUnborn);
      weeks = getWeeksFromChildData(childData);
      months = getMonthsFromChildData(childData);
      if (!pregnant && childData.birthDate) {
        ageBreakdown = calculateAgeBreakdownFromBirthDate(childData.birthDate);
      }
    } else if (gestationWeeks || isPregnant) {
      weeks = parseInt(gestationWeeks, 10);
      pregnant = true;
    } else if (ageWeeks || ageWeeks === 0) {
      weeks = parseInt(ageWeeks, 10);
    } else if (birthDate) {
      weeks = calculateWeeksFromBirthDate(birthDate);
      months = calculateMonthsFromBirthDate(birthDate);
      ageBreakdown = calculateAgeBreakdownFromBirthDate(birthDate);
    }

    if (pregnant) {
      if (!weeks || weeks < 1 || weeks > 45) {
        return res.status(400).json({
          success: false,
          message: 'Para embarazo debes enviar gestationWeeks (1-45) o childId'
        });
      }
    } else {
      if ((!weeks || weeks < 1 || weeks > 60) && (months === null || months < 0)) {
        return res.status(400).json({
          success: false,
          message: 'Debes enviar birthDate o ageWeeks (1-60) o childId'
        });
      }
    }

    let unit = 'week';
    let value = weeks;
    if (!pregnant) {
      const isUnderOneMonth = weeks !== null && weeks < 4;
      if (!isUnderOneMonth) {
        unit = 'month';
        if (months !== null) {
          value = Math.max(1, months);
        } else if (weeks !== null) {
          value = Math.max(1, Math.floor(weeks / 4.3));
        }
      }
    }

    const cacheKey = `/api/guide/today?childId=${resolvedChildId || 'none'}&unit=${unit}&value=${value}&pregnant=${Boolean(pregnant)}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const guide = await getDailyGuideFromAI({
      unit,
      value,
      name: name && String(name).trim() ? String(name).trim() : null,
      isPregnant: pregnant
    });

    let title = guide.title;
    let ageLabel = null;
    if (!pregnant && ageBreakdown && ageBreakdown.totalMonths >= 12) {
      const parts = [];
      if (ageBreakdown.years > 0) {
        parts.push(`${ageBreakdown.years} aÃ±o${ageBreakdown.years === 1 ? '' : 's'}`);
      }
      if (ageBreakdown.months > 0) {
        parts.push(`${ageBreakdown.months} mes${ageBreakdown.months === 1 ? '' : 'es'}`);
      }
      ageLabel = parts.length > 0 ? parts.join(' ') : `${ageBreakdown.totalMonths} meses`;
      const titleSuffix = title && String(title).includes(':')
        ? String(title).split(':').slice(1).join(':').trim()
        : String(title || '');
      title = `${ageLabel}: ${titleSuffix || 'El descubrimiento'}`;
    }

    const responsePayload = {
      success: true,
      data: {
        title,
        subtitle: guide.subtitle,
        description: guide.description,
        tip: guide.tip,
        unit,
        value,
        ageLabel,
        ageYears: ageBreakdown ? ageBreakdown.years : null,
        ageMonths: ageBreakdown ? ageBreakdown.months : null,
        ageTotalMonths: ageBreakdown ? ageBreakdown.totalMonths : null,
        isPregnant: pregnant,
        source: guide.source
      }
    };

    setCachedResponse(cacheKey, responsePayload, 2 * 60 * 60 * 1000);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ Error obteniendo guÃ­a diaria:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo guÃ­a diaria',
      error: error.message
    });
  }
});

// Preguntas frecuentes para mamas (FAQ) con cache 24h
app.post('/api/faq/moms', authenticateToken, async (req, res) => {
  try {
    const { childId, isPregnant = false } = req.body;
    const userId = req.user.uid;

    let childName = null;
    let pregnant = Boolean(isPregnant);
    let ageLabel = null;

    if (childId) {
      const childDoc = await db.collection('children').doc(childId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      const childData = childDoc.data();
      
      // Verificar si el usuario es el padre o tiene acceso compartido
      const isParent = childData.parentId === userId;
      const hasSharedAccess = childData.sharedWith && 
        Array.isArray(childData.sharedWith) && 
        childData.sharedWith.includes(userId);
      
      if (!isParent && !hasSharedAccess) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }
      
      childName = childData.name || null;
      pregnant = Boolean(childData.isUnborn);
      if (!pregnant) {
        const weeks = getWeeksFromChildData(childData);
        const months = getMonthsFromChildData(childData);
        const isUnderOneMonth = weeks !== null && weeks < 4;
        if (isUnderOneMonth) {
          ageLabel = `Semana ${weeks}`;
        } else if (months !== null) {
          ageLabel = `Mes ${Math.max(1, months)}`;
        }
      } else {
        const weeks = getWeeksFromChildData(childData);
        if (weeks) ageLabel = `Semana ${weeks}`;
      }
    }

    const cacheKey = `/api/faq/moms?childId=${childId || 'none'}&pregnant=${pregnant}&age=${ageLabel || 'na'}&user=${userId}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const result = await getMomsFaqFromAI({ childName, isPregnant: pregnant, ageLabel });
    const responsePayload = {
      success: true,
      data: {
        questions: result.items,
        source: result.source
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ Error obteniendo FAQ mamÃ¡s:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo FAQ',
      error: error.message
    });
  }
});

// Endpoint para obtener informaciÃ³n del embarazo por semanas con imagen
app.post('/api/pregnancy/week-info', authenticateToken, async (req, res) => {
  try {
    const { gestationWeeks, name, includeImage = true } = req.body;

    const parsedWeeks = parseInt(gestationWeeks, 10);
    if (!parsedWeeks || parsedWeeks < 1 || parsedWeeks > 45) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaciÃ³n deben estar entre 1 y 45'
      });
    }

    const babyName = name && name.trim() ? name.trim() : 'tu bebÃ©';

    const infoResult = await getPregnancyWeekInfoFromAI(parsedWeeks, babyName);

    let imageUrl = null;
    let imageWarning = null;
    if (includeImage) {
      const imageResult = await generatePregnancyImageUrlFromAI(parsedWeeks);
      imageUrl = imageResult?.url || null;
      imageWarning = imageResult?.warning || null;
    }

    res.json({
      success: true,
      data: {
        gestationWeeks: parsedWeeks,
        babyName: babyName,
        importantInfo: infoResult.items,
        infoSource: infoResult.source,
        image: imageUrl ? {
          url: imageUrl
        } : null,
        imageSource: imageUrl ? 'openai' : 'none',
        imageWarning: imageWarning,
        timestamp: new Date()
      }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo info de embarazo por semana:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaciÃ³n del embarazo',
      error: error.message
    });
  }
});

// FunciÃ³n para calcular edad en meses desde fecha de nacimiento
const calculateAgeFromBirthDate = (birthDate) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let birth;
  if (birthDate && typeof birthDate === 'object' && birthDate._seconds) {
    birth = new Date(birthDate._seconds * 1000);
  } else {
    birth = new Date(birthDate);
  }
  
  // Calcular aÃ±os y meses
  let years = now.getFullYear() - birth.getFullYear();
  let months = now.getMonth() - birth.getMonth();
  
  // Ajustar si el dÃ­a actual es menor que el dÃ­a de nacimiento
  if (now.getDate() < birth.getDate()) {
    months--;
  }
  
  // Si los meses son negativos, ajustar aÃ±os y meses
  if (months < 0) {
    years--;
    months += 12;
  }
  
  const totalMonths = Math.max(0, years * 12 + months);
  
  console.log(`ðŸ“Š [AGE CALCULATION] Nacimiento: ${birth.toLocaleDateString()} â†’ Edad actual: ${totalMonths} meses (${years} aÃ±os, ${months} meses)`);
  
  return totalMonths;
};

const calculateAgeBreakdownFromBirthDate = (birthDate) => {
  const now = new Date();
  let birth;
  if (birthDate && typeof birthDate === 'object' && birthDate._seconds) {
    birth = new Date(birthDate._seconds * 1000);
  } else {
    birth = new Date(birthDate);
  }
  let years = now.getFullYear() - birth.getFullYear();
  let months = now.getMonth() - birth.getMonth();
  if (now.getDate() < birth.getDate()) {
    months--;
  }
  if (months < 0) {
    years--;
    months += 12;
  }
  const totalMonths = Math.max(0, years * 12 + months);
  return { years: Math.max(0, years), months: Math.max(0, months), totalMonths };
};

// FunciÃ³n para calcular edad actual basada en fecha de creaciÃ³n (LEGACY - para compatibilidad con datos antiguos)
const calculateCurrentAge = (registeredAge, createdAt) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let createdDate;
  if (createdAt && typeof createdAt === 'object' && createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(createdAt);
  }
  
  const diffTime = now - createdDate;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  // Calcular meses completos transcurridos
  const diffMonths = Math.floor(diffDays / 30.44); // Promedio de dÃ­as por mes
  
  // Calcular edad actual sumando los meses transcurridos
  const currentAge = Math.max(0, registeredAge + diffMonths);
  
  console.log(`ðŸ“Š [AGE CALCULATION LEGACY] ${registeredAge} meses + ${diffMonths} meses = ${currentAge} meses (${diffDays} dÃ­as desde creaciÃ³n)`);
  
  return currentAge;
};

// FunciÃ³n para calcular semanas de gestaciÃ³n desde fecha esperada de parto
const calculateGestationFromDueDate = (dueDate) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let due;
  if (dueDate && typeof dueDate === 'object' && dueDate._seconds) {
    due = new Date(dueDate._seconds * 1000);
  } else {
    due = new Date(dueDate);
  }
  
  // Un embarazo completo son 40 semanas (280 dÃ­as)
  // Calculamos cuÃ¡ntos dÃ­as faltan hasta la fecha de parto
  const diffTime = due - now;
  const daysUntilDue = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  // Calcular semanas de gestaciÃ³n actual
  // Si faltan X dÃ­as, la gestaciÃ³n actual es (280 - X) / 7
  const currentWeeks = Math.floor((280 - daysUntilDue) / 7);
  
  // Limitar a un rango realista (4-45 semanas, permitiendo un poco de margen para partos tardÃ­os)
  const finalWeeks = Math.max(4, Math.min(45, currentWeeks));
  
  console.log(`ðŸ“Š [GESTATION CALCULATION] Fecha de parto: ${due.toLocaleDateString()} â†’ Semanas actuales: ${finalWeeks} (faltan ${daysUntilDue} dÃ­as)`);
  
  return {
    weeks: finalWeeks,
    isOverdue: currentWeeks >= 40,
    daysUntilDue: daysUntilDue
  };
};

// FunciÃ³n para calcular semanas de gestaciÃ³n actual basada en fecha de creaciÃ³n (LEGACY - para compatibilidad)
const calculateCurrentGestationWeeks = (registeredWeeks, createdAt) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let createdDate;
  if (createdAt && typeof createdAt === 'object' && createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(createdAt);
  }
  
  const diffTime = now - createdDate;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const diffWeeks = Math.floor(diffDays / 7);
  
  // Calcular semanas actuales sumando las semanas transcurridas
  const currentWeeks = registeredWeeks + diffWeeks;
  
  // Limitar a un rango realista (4-42 semanas)
  const finalWeeks = Math.max(4, Math.min(42, currentWeeks));
  
  console.log(`ðŸ“Š [GESTATION CALCULATION LEGACY] ${registeredWeeks} semanas + ${diffWeeks} semanas = ${finalWeeks} semanas (${diffDays} dÃ­as desde creaciÃ³n)`);
  
  return finalWeeks;
};

// FunciÃ³n para obtener informaciÃ³n actualizada de un hijo
const getChildCurrentInfo = (child) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore para daysSinceCreation
  let createdDate;
  if (child.createdAt && typeof child.createdAt === 'object' && child.createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(child.createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(child.createdAt);
  }
  
  const daysSinceCreation = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));
  
  if (child.isUnborn) {
    // Si tiene dueDate (nuevo sistema), usar eso
    if (child.dueDate) {
      const gestationInfo = calculateGestationFromDueDate(child.dueDate);
      
      return {
        ...child,
        currentGestationWeeks: gestationInfo.weeks,
        currentAgeInMonths: null,
        registeredGestationWeeks: null, // Ya no aplica con el nuevo sistema
        daysSinceCreation: daysSinceCreation,
        isOverdue: gestationInfo.isOverdue,
        daysUntilDue: gestationInfo.daysUntilDue
      };
    } 
    // Fallback a sistema antiguo (legacy)
    else if (child.gestationWeeks) {
    const currentGestationWeeks = calculateCurrentGestationWeeks(child.gestationWeeks, child.createdAt);
    
    return {
      ...child,
      currentGestationWeeks: currentGestationWeeks,
      currentAgeInMonths: null,
      registeredGestationWeeks: child.gestationWeeks,
      daysSinceCreation: daysSinceCreation,
      isOverdue: currentGestationWeeks >= 40
    };
    }
  } else {
    // Si tiene birthDate (nuevo sistema), usar eso
    if (child.birthDate) {
      const currentAgeInMonths = calculateAgeFromBirthDate(child.birthDate);
      
      return {
        ...child,
        currentAgeInMonths: currentAgeInMonths,
        currentGestationWeeks: null,
        registeredAgeInMonths: null, // Ya no aplica con el nuevo sistema
        daysSinceCreation: daysSinceCreation
      };
    }
    // Fallback a sistema antiguo (legacy)
    else if (child.ageInMonths !== undefined && child.ageInMonths !== null) {
    const currentAgeInMonths = calculateCurrentAge(child.ageInMonths, child.createdAt);
    
    return {
      ...child,
      currentAgeInMonths: currentAgeInMonths,
      currentGestationWeeks: null,
      registeredAgeInMonths: child.ageInMonths,
      daysSinceCreation: daysSinceCreation
    };
  }
  }
  
  // Si no hay datos vÃ¡lidos, retornar el child original con valores por defecto
  return {
    ...child,
    currentAgeInMonths: 0,
    currentGestationWeeks: null,
    daysSinceCreation: daysSinceCreation
  };
};

// FunciÃ³n para obtener respuestas previas de desarrollo
const getPreviousDevelopmentResponses = async (userId, childKey) => {
  try {
    const response = await db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses')
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();

    return response.docs.map(doc => doc.data());
  } catch (error) {
    console.error('Error obteniendo respuestas previas:', error);
    return [];
  }
};

// FunciÃ³n para guardar respuesta de desarrollo
const saveDevelopmentResponse = async (userId, childKey, responseData) => {
  try {
    await db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses')
      .add({
        ...responseData,
        savedAt: new Date()
      });
  } catch (error) {
    console.error('Error guardando respuesta:', error);
  }
};

// FunciÃ³n para validar que las respuestas no se repitan
const validateResponseUniqueness = (newBullets, previousResponses, maxAttempts = 3) => {
  if (previousResponses.length === 0) {
    return { isValid: true, bullets: newBullets };
  }

  // Extraer todos los bullets previos
  const allPreviousBullets = previousResponses.flatMap(resp => resp.developmentInfo);
  
  // FunciÃ³n para calcular similitud entre dos bullets
  const calculateSimilarity = (bullet1, bullet2) => {
    const words1 = bullet1.toLowerCase().split(/\s+/);
    const words2 = bullet2.toLowerCase().split(/\s+/);
    const commonWords = words1.filter(word => words2.includes(word));
    return commonWords.length / Math.max(words1.length, words2.length);
  };

  // Verificar si hay repeticiones significativas
  let hasRepetition = false;
  for (const newBullet of newBullets) {
    for (const prevBullet of allPreviousBullets) {
      const similarity = calculateSimilarity(newBullet, prevBullet);
      if (similarity > 0.6) { // Si mÃ¡s del 60% de las palabras son iguales
        hasRepetition = true;
        console.log(`âš ï¸ Detected repetition: "${newBullet.substring(0, 50)}..." similar to "${prevBullet.substring(0, 50)}..." (${(similarity * 100).toFixed(1)}%)`);
        break;
      }
    }
    if (hasRepetition) break;
  }

  return { isValid: !hasRepetition, bullets: newBullets };
};

// FunciÃ³n para obtener informaciÃ³n del embarazo por semanas desde OpenAI
const getPregnancyWeekInfoFromAI = async (gestationWeeks, babyName) => {
  if (!openai) {
    return {
      items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
      source: 'fallback'
    };
  }

  try {
    const systemPrompt = `Eres una doula experta especializada en desarrollo fetal. Debes entregar informaciÃ³n clara y Ãºtil para madres sobre el embarazo por semanas.

IMPORTANTE:
- Proporciona EXACTAMENTE 4 bullets
- Cada bullet debe ser concreto y prÃ¡ctico
- Usa emojis al inicio de cada bullet
- MantÃ©n un tono cÃ¡lido y profesional
- No incluyas diagnÃ³stico ni consejo mÃ©dico personalizado

FORMATO REQUERIDO:
1. ðŸ‘¶ **TÃ­tulo**: Texto...
2. ðŸ§  **TÃ­tulo**: Texto...
3. ðŸ«¶ **TÃ­tulo**: Texto...
4. âš ï¸ **TÃ­tulo**: Texto...`;

    const userPrompt = `Dame 4 bullets de informaciÃ³n importante sobre el embarazo en la semana ${gestationWeeks} para ${babyName}.`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      max_tokens: 500,
      temperature: 0.7
    });

    const content = response.choices[0].message.content || '';
    const items = content
      .split('\n')
      .filter(line => line.trim().match(/^\d+\.\s*/))
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(Boolean)
      .slice(0, 4);

    if (items.length < 3) {
      return {
        items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
        source: 'fallback'
      };
    }

    return { items, source: 'openai' };
  } catch (error) {
    console.error('âŒ Error OpenAI embarazo por semanas:', error.message);
    return {
      items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
      source: 'fallback'
    };
  }
};

const getDailyGuideFallback = ({ unit, value, name, isPregnant }) => {
  const safeName = name || (isPregnant ? 'tu bebÃ©' : 'tu bebÃ©');
  const label = unit === 'month' ? `Mes ${value}` : `Semana ${value}`;
  const title = `${label}: El descubrimiento`;
  const subtitle = isPregnant
    ? `En la ${label.toLowerCase()}, el desarrollo continÃºa a buen ritmo.`
    : `En la ${label.toLowerCase()}, ${safeName} sigue descubriendo el mundo.`;
  const description = isPregnant
    ? `Tu cuerpo y tu bebÃ© atraviesan cambios importantes. MantÃ©n una rutina suave y escucha tu energÃ­a.`
    : `Texturas, sonidos y movimientos nuevos estimulan el desarrollo. El juego guiado corto marca la diferencia.`;
  const tip = isPregnant
    ? 'Dedica unos minutos a descansar y respirar profundo.'
    : 'Crea un ambiente calmado antes de dormir y evita estÃ­mulos fuertes.';
  return { title, subtitle, description, tip, source: 'fallback' };
};

const extractJsonFromText = (text) => {
  const match = text.match(/\{[\s\S]*\}/);
  if (!match) return null;
  try {
    return JSON.parse(match[0]);
  } catch (_) {
    return null;
  }
};

const getDailyGuideFromAI = async ({ unit, value, name, isPregnant }) => {
  if (!openai) {
    return getDailyGuideFallback({ unit, value, name, isPregnant });
  }

  try {
    const systemPrompt = `Eres una doula experta. Genera una guÃ­a breve y cÃ¡lida en espaÃ±ol.
Responde SOLO con JSON vÃ¡lido con estas claves: title, subtitle, description, tip.
Requisitos:
- title debe empezar con "Semana X:" o "Mes X:" segÃºn corresponda
- subtitle: 1 oraciÃ³n
- description: 1-2 oraciones
- tip: mÃ¡ximo 20 palabras
- Sin emojis ni markdown`;

    const label = unit === 'month' ? `Mes ${value}` : `Semana ${value}`;
    const context = isPregnant
      ? `Embarazo en ${label.toLowerCase()}.`
      : `BebÃ© nacido con ${label.toLowerCase()} de vida.`;
    const displayName = name ? `Nombre: ${name}.` : '';

    const userPrompt = `Crea la guÃ­a de hoy. ${context} ${displayName}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      max_tokens: 250,
      temperature: 0.7
    });

    const content = response.choices?.[0]?.message?.content || '';
    const parsed = extractJsonFromText(content);
    if (!parsed || !parsed.title || !parsed.subtitle || !parsed.description || !parsed.tip) {
      return getDailyGuideFallback({ unit, value, name, isPregnant });
    }
    const expectedPrefix = unit === 'month' ? `Mes ${value}:` : `Semana ${value}:`;
    if (!String(parsed.title || '').startsWith(expectedPrefix)) {
      return getDailyGuideFallback({ unit, value, name, isPregnant });
    }
    return { ...parsed, source: 'openai' };
  } catch (error) {
    console.error('âŒ Error OpenAI guÃ­a diaria:', error.message);
    return getDailyGuideFallback({ unit, value, name, isPregnant });
  }
};

const getMomsFaqFallback = (childName) => {
  const name = childName || 'mi bebÃ©';
  return [
    `Â¿Es normal que ${name} cambie sus horarios de sueÃ±o semana a semana?`,
    `Â¿CuÃ¡ntas siestas deberÃ­a hacer ${name} segÃºn su edad?`,
    `Â¿QuÃ© seÃ±ales indican que ${name} ya tiene sueÃ±o?`,
    `Â¿CÃ³mo puedo crear una rutina tranquila antes de dormir?`
  ];
};

const getMomsFaqFromAI = async ({ childName, isPregnant, ageLabel }) => {
  if (!openai) {
    return { items: getMomsFaqFallback(childName), source: 'fallback' };
  }

  try {
    const systemPrompt = `Eres una doula experta. Genera EXACTAMENTE 4 preguntas frecuentes en espaÃ±ol para madres.
Requisitos:
- Deben ser preguntas cortas y claras
- Sin emojis ni markdown
- En una sola lÃ­nea cada pregunta`;

    const context = isPregnant
      ? `Contexto: embarazo. ${ageLabel ? `Edad: ${ageLabel}.` : ''}`
      : `Contexto: bebÃ© nacido. Nombre: ${childName || 'mi bebÃ©'}. ${ageLabel ? `Edad: ${ageLabel}.` : ''}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Crea 4 preguntas frecuentes. ${context}` }
      ],
      max_tokens: 200,
      temperature: 0.7
    });

    const content = response.choices?.[0]?.message?.content || '';
    const items = content
      .split('\n')
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(Boolean)
      .slice(0, 4);

    if (items.length < 4) {
      return { items: getMomsFaqFallback(childName), source: 'fallback' };
    }

    return { items, source: 'openai' };
  } catch (error) {
    console.error('âŒ Error OpenAI FAQ mamÃ¡s:', error.message);
    return { items: getMomsFaqFallback(childName), source: 'fallback' };
  }
};

// Subir imagen base64 a Firebase Storage y devolver URL pÃºblica
const uploadPregnancyImageBase64 = async (base64Data, filePath) => {
  const bucket = admin.storage().bucket();
  const buffer = Buffer.from(base64Data, 'base64');
  const file = bucket.file(filePath);

  await file.save(buffer, {
    metadata: {
      contentType: 'image/png'
    }
  });
  await file.makePublic();

  return `https://storage.googleapis.com/${bucket.name}/${file.name}`;
};

// FunciÃ³n para generar imagen del embarazo por semanas con OpenAI (URL pÃºblica)
const generatePregnancyImageUrlFromAI = async (gestationWeeks) => {
  if (!openai) {
    return { url: null, warning: 'openai_not_configured' };
  }

  try {
    const prompt = `IlustraciÃ³n mÃ©dica educativa, estilo suave y minimalista, de un feto en el Ãºtero a las ${gestationWeeks} semanas de gestaciÃ³n. 
No realista, sin sangre, sin desnudez explÃ­cita, fondo claro, colores suaves, enfoque en el desarrollo general.`;

    const response = await openai.images.generate({
      model: process.env.OPENAI_IMAGE_MODEL || 'gpt-image-1',
      prompt: prompt,
      size: '1024x1024'
    });

    const base64Image = response.data?.[0]?.b64_json || null;
    if (base64Image) {
      const filePath = `pregnancy/weeks/${gestationWeeks}/week-${gestationWeeks}-${Date.now()}.png`;
      const url = await uploadPregnancyImageBase64(base64Image, filePath);
      return { url, warning: null };
    }

    const imageUrl = response.data?.[0]?.url || null;
    return { url: imageUrl, warning: imageUrl ? null : 'openai_image_empty' };
  } catch (error) {
    const message = error?.message || '';
    if (message.includes('organization must be verified')) {
      console.warn('âš ï¸ OpenAI requiere verificaciÃ³n de organizaciÃ³n para imÃ¡genes.');
      return { url: null, warning: 'openai_org_verification_required' };
    }
    if (message.includes('does not have access to model')) {
      console.warn('âš ï¸ OpenAI: el proyecto no tiene acceso al modelo de imÃ¡genes.');
      return { url: null, warning: 'openai_model_not_allowed' };
    }
    console.error('âŒ Error generando imagen de embarazo:', message);
    return { url: null, warning: 'openai_image_error' };
  }
};

// Fallback para informaciÃ³n del embarazo por semanas
const getPregnancyWeekInfoFallback = (gestationWeeks, babyName) => {
  if (gestationWeeks <= 12) {
    return [
      `ðŸ‘¶ **FormaciÃ³n temprana**: ${babyName} estÃ¡ formando Ã³rganos principales y estructuras bÃ¡sicas.`,
      "ðŸ§¬ **Desarrollo clave**: Se fortalecen el cerebro y el sistema nervioso central.",
      "ðŸŽ **NutriciÃ³n**: Prioriza Ã¡cido fÃ³lico, hierro y una hidrataciÃ³n constante.",
      "âš ï¸ **Cuidados**: Evita alcohol, tabaco y medicamentos sin indicaciÃ³n mÃ©dica."
    ];
  }
  if (gestationWeeks <= 24) {
    return [
      `ðŸ‘¶ **Movimientos**: ${babyName} ya realiza movimientos mÃ¡s perceptibles.`,
      "ðŸ‘‚ **Sentidos**: Responde a sonidos y a la voz de la madre.",
      "ðŸ“ **Crecimiento**: Aumenta peso y tamaÃ±o rÃ¡pidamente.",
      "ðŸ«¶ **VÃ­nculo**: Hablarle y tocar el abdomen ayuda a conectar."
    ];
  }
  if (gestationWeeks <= 36) {
    return [
      "ðŸ« **Pulmones**: Se preparan para respirar fuera del Ãºtero.",
      "ðŸ§  **MaduraciÃ³n**: El cerebro continÃºa desarrollÃ¡ndose aceleradamente.",
      "ðŸ’¤ **SueÃ±o**: Presenta ciclos de sueÃ±o mÃ¡s definidos.",
      "ðŸ¥ **PreparaciÃ³n**: Considera plan de parto y controles prenatales."
    ];
  }

  return [
    "ðŸ‘¶ **PosiciÃ³n**: El bebÃ© suele colocarse cabeza abajo.",
    "ðŸ§  **Ãšltimos ajustes**: MaduraciÃ³n final de Ã³rganos y reflejos.",
    "ðŸ§³ **PreparaciÃ³n**: Ten lista tu bolsa para el parto.",
    "âš ï¸ **SeÃ±ales**: Consulta ante contracciones regulares o pÃ©rdida de lÃ­quido."
  ];
};

// FunciÃ³n para obtener informaciÃ³n de desarrollo de bebÃ©s por nacer desde OpenAI
const getUnbornDevelopmentInfoFromAI = async (gestationWeeks, previousResponses, childName) => {
  try {
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      attempts++;
      console.log(`ðŸ¤– [OPENAI] Intento ${attempts}/${maxAttempts} para ${childName} (${gestationWeeks} semanas)`);

      // Crear contexto de respuestas previas
      const previousContext = previousResponses.length > 0 
        ? `\n\nInformaciÃ³n ya proporcionada anteriormente:\n${previousResponses.slice(0, 3).map((resp, index) => 
            `${index + 1}. ${resp.developmentInfo.join('\n   ')}`
          ).join('\n')}`
        : '';

      const systemPrompt = `Eres una doula experta especializada en desarrollo fetal. Tu tarea es proporcionar informaciÃ³n relevante y variada sobre el desarrollo del bebÃ© durante el embarazo.

IMPORTANTE:
- Proporciona EXACTAMENTE 3 bullets de informaciÃ³n
- Cada bullet debe ser COMPLETAMENTE DIFERENTE a la informaciÃ³n previa
- Evita repetir conceptos, temas o informaciÃ³n ya proporcionada
- Usa emojis relevantes al inicio de cada bullet
- MantÃ©n un tono cÃ¡lido y profesional
- Incluye el nombre del bebÃ© cuando sea apropiado
- Si es la consulta #${previousResponses.length + 1}, enfÃ³cate en aspectos NO mencionados anteriormente

FORMATO REQUERIDO:
1. ðŸ«€ **TÃ­tulo del primer aspecto**: DescripciÃ³n detallada...
2. ðŸ§¬ **TÃ­tulo del segundo aspecto**: DescripciÃ³n detallada...
3. âš ï¸ **TÃ­tulo del tercer aspecto**: DescripciÃ³n detallada...

CONTEXTO ACTUAL:
- BebÃ©: ${childName}
- Semanas de gestaciÃ³n: ${gestationWeeks}
- Consulta #${previousResponses.length + 1}${previousContext}

${previousResponses.length > 0 ? 'IMPORTANTE: NO repitas ningÃºn concepto, tema o informaciÃ³n de las consultas anteriores. Busca aspectos completamente nuevos.' : 'Si es la primera consulta, proporciona informaciÃ³n fundamental.'}`;

      const userPrompt = `Proporciona 3 bullets de informaciÃ³n ÃšNICA sobre el desarrollo fetal de ${childName} a las ${gestationWeeks} semanas de gestaciÃ³n.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: 500,
        temperature: 0.8 + (attempts * 0.1), // Aumentar temperatura en cada intento
        presence_penalty: 0.8 + (attempts * 0.1), // Aumentar penalty en cada intento
        frequency_penalty: 0.9 + (attempts * 0.05)
      });

      const content = response.choices[0].message.content;
      
      // Extraer los 3 bullets del contenido
      const bullets = content.split('\n')
        .filter(line => line.trim().match(/^\d+\.\s*[ðŸ«€ðŸ§¬âš ï¸ðŸ‘¶ðŸ‘‚ðŸ“ðŸŽµðŸ«ðŸ‘ï¸ðŸ’ªðŸ§ ðŸ’¤ðŸŽðŸŽ¯ðŸ“¦â°ðŸ¤±ðŸ¥ðŸ‘¶]/))
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .slice(0, 3);

      // Si no se pudieron extraer bullets, usar fallback
      if (bullets.length < 3) {
        console.log('âš ï¸ No se pudieron extraer bullets de OpenAI, usando fallback');
        return getUnbornDevelopmentInfoFallback(gestationWeeks);
      }

      // Validar que no haya repeticiones
      const validation = validateResponseUniqueness(bullets, previousResponses);
      
      if (validation.isValid) {
        console.log(`âœ… [OPENAI] Respuesta vÃ¡lida obtenida en intento ${attempts}`);
        return validation.bullets;
      } else {
        console.log(`âš ï¸ [OPENAI] Respuesta con repeticiones detectada, reintentando...`);
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar antes del siguiente intento
        }
      }
    }

    // Si se agotaron los intentos, usar fallback
    console.log(`âš ï¸ [OPENAI] Se agotaron los intentos, usando fallback`);
    return getUnbornDevelopmentInfoFallback(gestationWeeks);

  } catch (error) {
    console.error('âŒ Error obteniendo informaciÃ³n de OpenAI:', error);
    // Fallback a informaciÃ³n predefinida
    return getUnbornDevelopmentInfoFallback(gestationWeeks);
  }
};

// FunciÃ³n para obtener informaciÃ³n de desarrollo de niÃ±os nacidos desde OpenAI
const getChildDevelopmentInfoFromAI = async (ageInMonths, previousResponses, childName) => {
  try {
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      attempts++;
      console.log(`ðŸ¤– [OPENAI] Intento ${attempts}/${maxAttempts} para ${childName} (${ageInMonths} meses)`);

      // Crear contexto de respuestas previas
      const previousContext = previousResponses.length > 0 
        ? `\n\nInformaciÃ³n ya proporcionada anteriormente:\n${previousResponses.slice(0, 3).map((resp, index) => 
            `${index + 1}. ${resp.developmentInfo.join('\n   ')}`
          ).join('\n')}`
        : '';

      const systemPrompt = `Eres una doula experta especializada en desarrollo infantil. Tu tarea es proporcionar informaciÃ³n relevante y variada sobre el desarrollo del niÃ±o.

IMPORTANTE:
- Proporciona EXACTAMENTE 3 bullets de informaciÃ³n
- Cada bullet debe ser COMPLETAMENTE DIFERENTE a la informaciÃ³n previa
- Evita repetir conceptos, temas o informaciÃ³n ya proporcionada
- Usa emojis relevantes al inicio de cada bullet
- MantÃ©n un tono cÃ¡lido y profesional
- Incluye el nombre del niÃ±o cuando sea apropiado
- Si es la consulta #${previousResponses.length + 1}, enfÃ³cate en aspectos NO mencionados anteriormente

FORMATO REQUERIDO:
1. ðŸ‘€ **TÃ­tulo del primer aspecto**: DescripciÃ³n detallada...
2. ðŸ˜Š **TÃ­tulo del segundo aspecto**: DescripciÃ³n detallada...
3. ðŸ’ª **TÃ­tulo del tercer aspecto**: DescripciÃ³n detallada...

CONTEXTO ACTUAL:
- NiÃ±o: ${childName}
- Edad: ${ageInMonths} meses
- Consulta #${previousResponses.length + 1}${previousContext}

${previousResponses.length > 0 ? 'IMPORTANTE: NO repitas ningÃºn concepto, tema o informaciÃ³n de las consultas anteriores. Busca aspectos completamente nuevos.' : 'Si es la primera consulta, proporciona informaciÃ³n fundamental.'}`;

      const userPrompt = `Proporciona 3 bullets de informaciÃ³n ÃšNICA sobre el desarrollo de ${childName} a los ${ageInMonths} meses de edad.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: 500,
        temperature: 0.8 + (attempts * 0.1), // Aumentar temperatura en cada intento
        presence_penalty: 0.8 + (attempts * 0.1), // Aumentar penalty en cada intento
        frequency_penalty: 0.9 + (attempts * 0.05)
      });

      const content = response.choices[0].message.content;
      
      // Extraer los 3 bullets del contenido
      const bullets = content.split('\n')
        .filter(line => line.trim().match(/^\d+\.\s*[ðŸ‘€ðŸ˜ŠðŸ’ªðŸ¤±ðŸ¦·ðŸ”„ðŸŽ¤ðŸ‘ðŸª‘ðŸ¤ðŸ—£ï¸ðŸš¶ðŸ‘‹ðŸ½ï¸ðŸƒðŸŽ¯ðŸŽµðŸ§©ðŸŽ­ðŸ“šðŸŽ¨ðŸ¤ðŸ§®ðŸƒâ€â™‚ï¸ðŸ“–ðŸ”¢ðŸŽ¯ðŸŽ“ðŸƒâ€â™‚ï¸ðŸ§ ðŸ“šðŸŽ¨ðŸ‘¥]/))
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .slice(0, 3);

      // Si no se pudieron extraer bullets, usar fallback
      if (bullets.length < 3) {
        console.log('âš ï¸ No se pudieron extraer bullets de OpenAI, usando fallback');
        return getChildDevelopmentInfoFallback(ageInMonths);
      }

      // Validar que no haya repeticiones
      const validation = validateResponseUniqueness(bullets, previousResponses);
      
      if (validation.isValid) {
        console.log(`âœ… [OPENAI] Respuesta vÃ¡lida obtenida en intento ${attempts}`);
        return validation.bullets;
      } else {
        console.log(`âš ï¸ [OPENAI] Respuesta con repeticiones detectada, reintentando...`);
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar antes del siguiente intento
        }
      }
    }

    // Si se agotaron los intentos, usar fallback
    console.log(`âš ï¸ [OPENAI] Se agotaron los intentos, usando fallback`);
    return getChildDevelopmentInfoFallback(ageInMonths);

  } catch (error) {
    console.error('âŒ Error obteniendo informaciÃ³n de OpenAI:', error);
    // Fallback a informaciÃ³n predefinida
    return getChildDevelopmentInfoFallback(ageInMonths);
  }
};

// FunciÃ³n de fallback para informaciÃ³n de bebÃ©s por nacer
const getUnbornDevelopmentInfoFallback = (gestationWeeks) => {
  if (gestationWeeks <= 12) {
    return [
      "ðŸ«€ **Desarrollo del corazÃ³n**: El corazÃ³n de tu bebÃ© ya late y se estÃ¡n formando los principales Ã³rganos. Es un perÃ­odo crÃ­tico de desarrollo.",
      "ðŸ§¬ **FormaciÃ³n de Ã³rganos**: Se estÃ¡n desarrollando el cerebro, hÃ­gado, riÃ±ones y otros Ã³rganos vitales. La nutriciÃ³n materna es fundamental.",
      "âš ï¸ **Cuidados especiales**: Evita alcohol, tabaco y medicamentos sin prescripciÃ³n mÃ©dica. Descansa lo suficiente y mantÃ©n una dieta equilibrada."
    ];
  } else if (gestationWeeks <= 24) {
    return [
      "ðŸ‘¶ **Movimientos fetales**: Tu bebÃ© ya se mueve y puedes sentir sus pataditas. Los movimientos son una seÃ±al de bienestar.",
      "ðŸ‘‚ **Desarrollo sensorial**: Ya puede oÃ­r sonidos y responde a tu voz. Hablarle y cantarle fortalece el vÃ­nculo.",
      "ðŸ“ **Crecimiento acelerado**: Tu bebÃ© crece rÃ¡pidamente. MantÃ©n una buena nutriciÃ³n y control prenatal regular."
    ];
  } else if (gestationWeeks <= 36) {
    return [
      "ðŸ« **MaduraciÃ³n pulmonar**: Los pulmones se estÃ¡n preparando para respirar. El bebÃ© practica movimientos respiratorios.",
      "ðŸ‘ï¸ **Desarrollo visual**: Los ojos se abren y puede distinguir entre luz y oscuridad. Responde a estÃ­mulos luminosos.",
      "ðŸ’ª **PosiciÃ³n de parto**: El bebÃ© se estÃ¡ posicionando para el nacimiento. Los movimientos pueden ser mÃ¡s limitados."
    ];
  } else {
    return [
      "ðŸŽ¯ **Listo para nacer**: Tu bebÃ© estÃ¡ completamente desarrollado y listo para el nacimiento en cualquier momento.",
      "ðŸ“¦ **PosiciÃ³n final**: Probablemente estÃ© en posiciÃ³n cefÃ¡lica (cabeza abajo) preparÃ¡ndose para el parto.",
      "â° **Signos de parto**: Presta atenciÃ³n a contracciones regulares, rotura de aguas o pÃ©rdida del tapÃ³n mucoso."
    ];
  }
};

// FunciÃ³n de fallback para informaciÃ³n de niÃ±os nacidos
const getChildDevelopmentInfoFallback = (ageInMonths) => {
  if (ageInMonths <= 3) {
    return [
      "ðŸ‘€ **Desarrollo visual**: Tu bebÃ© puede seguir objetos con la mirada y reconoce tu rostro. El contacto visual es fundamental.",
      "ðŸ˜Š **Primeras sonrisas**: Aparecen las sonrisas sociales y el bebÃ© responde a tu voz y caricias.",
      "ðŸ’ª **Control de cabeza**: Comienza a sostener la cabeza cuando estÃ¡ boca abajo. El tiempo boca abajo es importante."
    ];
  } else if (ageInMonths <= 6) {
    return [
      "ðŸ¤± **AlimentaciÃ³n complementaria**: EstÃ¡ listo para comenzar con papillas. Introduce alimentos uno por uno.",
      "ðŸ¦· **Primeros dientes**: Pueden aparecer los primeros dientes. Ofrece mordedores frÃ­os para aliviar las molestias.",
      "ðŸ”„ **Volteo**: Aprende a darse la vuelta de boca arriba a boca abajo y viceversa. Supervisa siempre."
    ];
  } else if (ageInMonths <= 9) {
    return [
      "ðŸª‘ **Sentarse solo**: Ya puede sentarse sin apoyo y mantenerse estable. El equilibrio mejora dÃ­a a dÃ­a.",
      "ðŸ¤ **Pinza fina**: Desarrolla la capacidad de agarrar objetos pequeÃ±os entre el pulgar y el Ã­ndice.",
      "ðŸ—£ï¸ **Balbuceo**: Produce sonidos como 'mamÃ¡', 'papÃ¡'. Responde a su nombre y entiende palabras simples."
    ];
  } else if (ageInMonths <= 12) {
    return [
      "ðŸš¶ **Primeros pasos**: Puede dar sus primeros pasos sosteniÃ©ndose de muebles o de tu mano. Cada bebÃ© tiene su ritmo.",
      "ðŸ‘‹ **Gestos comunicativos**: Hace gestos como saludar, seÃ±alar y aplaudir. La comunicaciÃ³n no verbal se desarrolla.",
      "ðŸ½ï¸ **AlimentaciÃ³n independiente**: Quiere comer solo y explorar texturas. Ofrece alimentos seguros y variados."
    ];
  } else if (ageInMonths <= 18) {
    return [
      "ðŸƒ **Caminar estable**: Ya camina con seguridad y puede subir escaleras gateando. Supervisa en todo momento.",
      "ðŸ—£ï¸ **Primeras palabras**: Dice entre 5-20 palabras y entiende muchas mÃ¡s. Lee cuentos y habla constantemente.",
      "ðŸŽ¯ **Juego simbÃ³lico**: Comienza a imitar acciones como hablar por telÃ©fono o dar de comer a muÃ±ecos."
    ];
  } else if (ageInMonths <= 24) {
    return [
      "ðŸ’¬ **ExplosiÃ³n del lenguaje**: Aprende nuevas palabras cada dÃ­a y forma frases de 2-3 palabras.",
      "ðŸŽ¨ **Creatividad**: Disfruta pintar, dibujar y crear. Ofrece materiales seguros para expresarse.",
      "ðŸ‘¥ **SocializaciÃ³n**: Muestra interÃ©s por otros niÃ±os aunque aÃºn juega en paralelo. Las citas de juego son beneficiosas."
    ];
  } else if (ageInMonths <= 36) {
    return [
      "ðŸ§© **Pensamiento lÃ³gico**: Resuelve rompecabezas simples y entiende conceptos como grande/pequeÃ±o, arriba/abajo.",
      "ðŸŽ­ **Juego de roles**: Imita roles como ser mamÃ¡, papÃ¡, doctor. El juego imaginativo se desarrolla.",
      "ðŸŽµ **Habilidades musicales**: Disfruta cantar, bailar y hacer mÃºsica. La mÃºsica estimula el desarrollo cerebral."
    ];
  } else if (ageInMonths <= 48) {
    return [
      "ðŸ“š **PreparaciÃ³n escolar**: Desarrolla habilidades pre-lectura como reconocer letras y contar.",
      "ðŸŽ¨ **ExpresiÃ³n artÃ­stica**: Crea dibujos mÃ¡s detallados y puede representar personas y objetos.",
      "ðŸ¤ **CooperaciÃ³n**: Aprende a compartir, esperar turnos y seguir reglas simples en grupo."
    ];
  } else if (ageInMonths <= 60) {
    return [
      "ðŸ“– **Lectura emergente**: Reconoce algunas palabras escritas y puede 'leer' cuentos conocidos.",
      "ðŸ”¢ **Conceptos matemÃ¡ticos**: Cuenta hasta 10, reconoce nÃºmeros y entiende conceptos bÃ¡sicos de cantidad.",
      "ðŸŽ¯ **Independencia**: Se viste solo, usa el baÃ±o independientemente y ayuda en tareas simples."
    ];
  } else {
    return [
      "ðŸŽ“ **Desarrollo escolar**: EstÃ¡ listo para el aprendizaje formal. Las habilidades sociales y acadÃ©micas se desarrollan.",
      "ðŸƒâ€â™‚ï¸ **Actividad fÃ­sica**: Disfruta deportes y actividades fÃ­sicas. El ejercicio regular es importante.",
      "ðŸ§  **Pensamiento abstracto**: Comienza a entender conceptos mÃ¡s complejos y puede resolver problemas simples."
    ];
  }
};

// FunciÃ³n para obtener informaciÃ³n de desarrollo de bebÃ©s por nacer
const getUnbornDevelopmentInfo = (gestationWeeks) => {
  if (gestationWeeks <= 12) {
    return [
      "ðŸ«€ **Desarrollo del corazÃ³n**: El corazÃ³n de tu bebÃ© ya late y se estÃ¡n formando los principales Ã³rganos. Es un perÃ­odo crÃ­tico de desarrollo.",
      "ðŸ§¬ **FormaciÃ³n de Ã³rganos**: Se estÃ¡n desarrollando el cerebro, hÃ­gado, riÃ±ones y otros Ã³rganos vitales. La nutriciÃ³n materna es fundamental.",
      "âš ï¸ **Cuidados especiales**: Evita alcohol, tabaco y medicamentos sin prescripciÃ³n mÃ©dica. Descansa lo suficiente y mantÃ©n una dieta equilibrada."
    ];
  } else if (gestationWeeks <= 24) {
    return [
      "ðŸ‘¶ **Movimientos fetales**: Tu bebÃ© ya se mueve y puedes sentir sus pataditas. Los movimientos son una seÃ±al de bienestar.",
      "ðŸ‘‚ **Desarrollo sensorial**: Ya puede oÃ­r sonidos y responde a tu voz. Hablarle y cantarle fortalece el vÃ­nculo.",
      "ðŸ“ **Crecimiento acelerado**: Tu bebÃ© crece rÃ¡pidamente. MantÃ©n una buena nutriciÃ³n y control prenatal regular."
    ];
  } else if (gestationWeeks <= 36) {
    return [
      "ðŸ« **MaduraciÃ³n pulmonar**: Los pulmones se estÃ¡n preparando para respirar. El bebÃ© practica movimientos respiratorios.",
      "ðŸ‘ï¸ **Desarrollo visual**: Los ojos se abren y puede distinguir entre luz y oscuridad. Responde a estÃ­mulos luminosos.",
      "ðŸ’ª **PosiciÃ³n de parto**: El bebÃ© se estÃ¡ posicionando para el nacimiento. Los movimientos pueden ser mÃ¡s limitados."
    ];
  } else {
    return [
      "ðŸŽ¯ **Listo para nacer**: Tu bebÃ© estÃ¡ completamente desarrollado y listo para el nacimiento en cualquier momento.",
      "ðŸ“¦ **PosiciÃ³n final**: Probablemente estÃ© en posiciÃ³n cefÃ¡lica (cabeza abajo) preparÃ¡ndose para el parto.",
      "â° **Signos de parto**: Presta atenciÃ³n a contracciones regulares, rotura de aguas o pÃ©rdida del tapÃ³n mucoso."
    ];
  }
};



// FunciÃ³n para obtener informaciÃ³n de desarrollo de niÃ±os nacidos
const getChildDevelopmentInfo = (ageInMonths) => {
  if (ageInMonths <= 3) {
    return [
      "ðŸ‘€ **Desarrollo visual**: Tu bebÃ© puede seguir objetos con la mirada y reconoce tu rostro. El contacto visual es fundamental.",
      "ðŸ˜Š **Primeras sonrisas**: Aparecen las sonrisas sociales y el bebÃ© responde a tu voz y caricias.",
      "ðŸ’ª **Control de cabeza**: Comienza a sostener la cabeza cuando estÃ¡ boca abajo. El tiempo boca abajo es importante."
    ];
  } else if (ageInMonths <= 6) {
    return [
      "ðŸ¤± **AlimentaciÃ³n complementaria**: EstÃ¡ listo para comenzar con papillas. Introduce alimentos uno por uno.",
      "ðŸ¦· **Primeros dientes**: Pueden aparecer los primeros dientes. Ofrece mordedores frÃ­os para aliviar las molestias.",
      "ðŸ”„ **Volteo**: Aprende a darse la vuelta de boca arriba a boca abajo y viceversa. Supervisa siempre."
    ];
  } else if (ageInMonths <= 9) {
    return [
      "ðŸª‘ **Sentarse solo**: Ya puede sentarse sin apoyo y mantenerse estable. El equilibrio mejora dÃ­a a dÃ­a.",
      "ðŸ¤ **Pinza fina**: Desarrolla la capacidad de agarrar objetos pequeÃ±os entre el pulgar y el Ã­ndice.",
      "ðŸ—£ï¸ **Balbuceo**: Produce sonidos como 'mamÃ¡', 'papÃ¡'. Responde a su nombre y entiende palabras simples."
    ];
  } else if (ageInMonths <= 12) {
    return [
      "ðŸš¶ **Primeros pasos**: Puede dar sus primeros pasos sosteniÃ©ndose de muebles o de tu mano. Cada bebÃ© tiene su ritmo.",
      "ðŸ‘‹ **Gestos comunicativos**: Hace gestos como saludar, seÃ±alar y aplaudir. La comunicaciÃ³n no verbal se desarrolla.",
      "ðŸ½ï¸ **AlimentaciÃ³n independiente**: Quiere comer solo y explorar texturas. Ofrece alimentos seguros y variados."
    ];
  } else if (ageInMonths <= 18) {
    return [
      "ðŸƒ **Caminar estable**: Ya camina con seguridad y puede subir escaleras gateando. Supervisa en todo momento.",
      "ðŸ—£ï¸ **Primeras palabras**: Dice entre 5-20 palabras y entiende muchas mÃ¡s. Lee cuentos y habla constantemente.",
      "ðŸŽ¯ **Juego simbÃ³lico**: Comienza a imitar acciones como hablar por telÃ©fono o dar de comer a muÃ±ecos."
    ];
  } else if (ageInMonths <= 24) {
    return [
      "ðŸ’¬ **ExplosiÃ³n del lenguaje**: Aprende nuevas palabras cada dÃ­a y forma frases de 2-3 palabras.",
      "ðŸŽ¨ **Creatividad**: Disfruta pintar, dibujar y crear. Ofrece materiales seguros para expresarse.",
      "ðŸ‘¥ **SocializaciÃ³n**: Muestra interÃ©s por otros niÃ±os aunque aÃºn juega en paralelo. Las citas de juego son beneficiosas."
    ];
  } else if (ageInMonths <= 36) {
    return [
      "ðŸ§© **Pensamiento lÃ³gico**: Resuelve rompecabezas simples y entiende conceptos como grande/pequeÃ±o, arriba/abajo.",
      "ðŸŽ­ **Juego de roles**: Imita roles como ser mamÃ¡, papÃ¡, doctor. El juego imaginativo se desarrolla.",
      "ðŸŽµ **Habilidades musicales**: Disfruta cantar, bailar y hacer mÃºsica. La mÃºsica estimula el desarrollo cerebral."
    ];
  } else if (ageInMonths <= 48) {
    return [
      "ðŸ“š **PreparaciÃ³n escolar**: Desarrolla habilidades pre-lectura como reconocer letras y contar.",
      "ðŸŽ¨ **ExpresiÃ³n artÃ­stica**: Crea dibujos mÃ¡s detallados y puede representar personas y objetos.",
      "ðŸ¤ **CooperaciÃ³n**: Aprende a compartir, esperar turnos y seguir reglas simples en grupo."
    ];
  } else if (ageInMonths <= 60) {
    return [
      "ðŸ“– **Lectura emergente**: Reconoce algunas palabras escritas y puede 'leer' cuentos conocidos.",
      "ðŸ”¢ **Conceptos matemÃ¡ticos**: Cuenta hasta 10, reconoce nÃºmeros y entiende conceptos bÃ¡sicos de cantidad.",
      "ðŸŽ¯ **Independencia**: Se viste solo, usa el baÃ±o independientemente y ayuda en tareas simples."
    ];
  } else {
    return [
      "ðŸŽ“ **Desarrollo escolar**: EstÃ¡ listo para el aprendizaje formal. Las habilidades sociales y acadÃ©micas se desarrollan.",
      "ðŸƒâ€â™‚ï¸ **Actividad fÃ­sica**: Disfruta deportes y actividades fÃ­sicas. El ejercicio regular es importante.",
      "ðŸ§  **Pensamiento abstracto**: Comienza a entender conceptos mÃ¡s complejos y puede resolver problemas simples."
    ];
  }
};

// Endpoint para obtener informaciÃ³n actualizada de hijos
app.get('/api/auth/children/current-info', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener hijos propios
    const ownChildrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    // Obtener hijos compartidos
    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const children = [];
    const childIds = new Set();

    // Procesar hijos propios
    ownChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...currentInfo,
          isShared: false,
          // InformaciÃ³n adicional calculada
          createdDate: childData.createdAt,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Procesar hijos compartidos
    sharedChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...currentInfo,
          isShared: true,
          // InformaciÃ³n adicional calculada
          createdDate: childData.createdAt,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    res.json({
      success: true,
      data: {
        children: children,
        totalChildren: children.length,
        timestamp: new Date()
      }
    });

  } catch (error) {
    console.error('âŒ Error obteniendo informaciÃ³n actualizada de hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaciÃ³n de hijos',
      error: error.message
    });
  }
});

// Endpoint para limpiar historial de respuestas de desarrollo
app.delete('/api/children/development-history', authenticateToken, async (req, res) => {
  try {
    const { childName, ageInMonths, isUnborn = false } = req.body;
    const userId = req.user.uid;

    if (!childName || !childName.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre del niÃ±o es requerido'
      });
    }

    const childKey = `${childName.trim()}_${isUnborn ? 'unborn' : ageInMonths}months`;

    // Obtener todas las respuestas para este niÃ±o
    const responsesRef = db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses');

    const responses = await responsesRef.get();

    // Eliminar todas las respuestas
    const batch = db.batch();
    responses.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    res.json({
      success: true,
      message: 'Historial de respuestas eliminado',
      data: {
        childName: childName.trim(),
        deletedCount: responses.docs.length
      }
    });

  } catch (error) {
    console.error('âŒ Error eliminando historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando historial',
      error: error.message
    });
  }
});
// Endpoint para obtener tips personalizados de los hijos
app.post('/api/children/tips', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { tipType = 'general', childId } = req.body; // general, alimentacion, desarrollo, salud, etc.
    
    console.log('ðŸ’¡ [TIPS] Solicitud de tip:', { tipType, childId, userId: uid });

    // Verificar si ya se dio un tip recientemente para evitar repeticiÃ³n
    let recentTips = [];
    let latestTipData = null;
    const forceRefresh = req.query?.force === 'true' || req.headers['x-force-refresh'] === 'true';
    const cacheTtlMinutes = 60;
    try {
      const recentTipsSnapshot = await db.collection('userTips')
        .where('userId', '==', uid)
        .where('tipType', '==', tipType)
        .orderBy('createdAt', 'desc')
        .limit(5)
        .get();
      
      recentTipsSnapshot.forEach(doc => {
        recentTips.push(doc.data().tip);
      });
      if (!recentTipsSnapshot.empty) {
        latestTipData = recentTipsSnapshot.docs[0].data();
      }
    } catch (indexError) {
      console.log('âš ï¸ Ãndice no disponible aÃºn, continuando sin verificaciÃ³n de duplicados:', indexError.message);
      // Continuar sin verificaciÃ³n de duplicados hasta que se cree el Ã­ndice
      recentTips = [];
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener informaciÃ³n actualizada de los hijos
    let children = [];
    
    if (childId) {
      // Si se proporciona childId, solo obtener ese hijo especÃ­fico
      console.log('ðŸ” [TIPS] Obteniendo informaciÃ³n del hijo especÃ­fico:', childId);
      
      const childDoc = await db.collection('children').doc(childId).get();
      
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      
      const childData = childDoc.data();
      
      // Verificar que el hijo pertenece al usuario
      if (childData.parentId !== uid) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permiso para acceder a este hijo'
        });
      }
      
      const currentInfo = getChildCurrentInfo(childData);
      children.push({
        id: childDoc.id,
        name: childData.name,
        ageInMonths: childData.ageInMonths,
        currentAgeInMonths: currentInfo.currentAgeInMonths,
        isUnborn: childData.isUnborn,
        gestationWeeks: childData.gestationWeeks,
        currentGestationWeeks: currentInfo.currentGestationWeeks,
        daysSinceCreation: currentInfo.daysSinceCreation
      });
      
      console.log('âœ… [TIPS] Hijo especÃ­fico obtenido:', children[0]);
    } else {
      // Si no se proporciona childId, obtener todos los hijos
      console.log('ðŸ” [TIPS] Obteniendo todos los hijos del usuario');
      
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    if (childrenSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'No tienes hijos registrados'
      });
    }

    childrenSnapshot.forEach(doc => {
      const childData = doc.data();
      const currentInfo = getChildCurrentInfo(childData);
      children.push({
        id: doc.id,
        name: childData.name,
        ageInMonths: childData.ageInMonths,
        currentAgeInMonths: currentInfo.currentAgeInMonths,
        isUnborn: childData.isUnborn,
        gestationWeeks: childData.gestationWeeks,
        currentGestationWeeks: currentInfo.currentGestationWeeks,
        daysSinceCreation: currentInfo.daysSinceCreation
      });
    });
      
      console.log('âœ… [TIPS] Todos los hijos obtenidos:', children.length);
    }

    // Obtener perfil del usuario para verificar si estÃ¡ embarazada
    let isPregnant = false;
    let currentGestationWeeks = 0;
    
    try {
      const userProfileSnapshot = await db.collection('users').doc(uid).get();
      if (userProfileSnapshot.exists) {
        const userProfile = userProfileSnapshot.data();
        isPregnant = userProfile.isPregnant || false;
        currentGestationWeeks = userProfile.gestationWeeks || 0;
        console.log('ðŸ‘¤ [PROFILE] Perfil del usuario:', { isPregnant, currentGestationWeeks });
      }
    } catch (profileError) {
      console.log('âš ï¸ [PROFILE] Error obteniendo perfil del usuario:', profileError.message);
      // Continuar con valores por defecto
    }

    // âš¡ Devolver tip cacheado si es reciente (evita OpenAI)
    if (!forceRefresh && latestTipData?.createdAt) {
      const createdAt = latestTipData.createdAt.toDate ? latestTipData.createdAt.toDate() : new Date(latestTipData.createdAt);
      const ageMinutes = Math.floor((Date.now() - createdAt.getTime()) / 60000);
      const childMatch = !childId || !latestTipData.childIds || latestTipData.childIds.includes(childId);
      if (ageMinutes <= cacheTtlMinutes && childMatch) {
        console.log(`âš¡ [TIPS] Usando cache (${ageMinutes} min)`);
        return res.json({
          success: true,
          data: {
            tips: [latestTipData.tip],
            children: children.map(child => ({
              id: child.id,
              name: child.name,
              currentAge: child.isUnborn ? `${child.currentGestationWeeks} semanas` : `${child.currentAgeInMonths} meses`,
              isUnborn: child.isUnborn
            })),
            tipType: tipType,
            timestamp: createdAt,
            cached: true
          }
        });
      }
    }

    // Crear contexto para OpenAI
    const childrenContext = children.map(child => {
      if (child.isUnborn) {
        return `${child.name}: Por nacer, ${child.currentGestationWeeks} semanas de gestaciÃ³n`;
      } else {
        const years = Math.floor(child.currentAgeInMonths / 12);
        const months = child.currentAgeInMonths % 12;
        const ageText = years > 0 
          ? `${years} aÃ±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
          : `${months} mes${months > 1 ? 'es' : ''}`;
        return `${child.name}: ${ageText} de edad`;
      }
    }).join(', ');

    console.log('ðŸ‘¶ [CHILDREN] Contexto de hijos:', childrenContext);
    console.log('ðŸ¤° [PREGNANCY] Estado de embarazo:', { isPregnant, currentGestationWeeks });

    // Generar tips usando OpenAI - UN TIP POR CADA HIJO
    let tips = [];
    if (openai) {
      try {
        // Si hay tips especÃ­ficos de hijos, generar uno por cada hijo
        const shouldGeneratePerChild = !['maternidad', 'crianza', 'embarazo'].includes(tipType);
        
        const prompt = shouldGeneratePerChild 
          ? `Eres una doula experta llamada "Douli". Necesito que generes tips personalizados para cada hijo.

INFORMACIÃ“N DE LOS HIJOS:
${children.map((child, index) => {
  if (child.isUnborn) {
    return `${index + 1}. ${child.name}: Por nacer, ${child.currentGestationWeeks} semanas de gestaciÃ³n`;
  } else {
    const years = Math.floor(child.currentAgeInMonths / 12);
    const months = child.currentAgeInMonths % 12;
    const ageText = years > 0 
      ? `${years} aÃ±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
      : `${months} mes${months > 1 ? 'es' : ''}`;
    return `${index + 1}. ${child.name}: ${ageText} de edad`;
  }
}).join('\n')}

TIPO DE TIP SOLICITADO: ${tipType}

TIPS RECIENTES (NO REPITAS ESTOS):
${recentTips.length > 0 ? recentTips.map(tip => `- ${tip}`).join('\n') : 'Ninguno'}

INSTRUCCIONES ESTRICTAS:
- Genera EXACTAMENTE ${children.length} tip${children.length > 1 ? 's' : ''} (uno para cada hijo listado arriba)
- USA EXACTAMENTE el nombre que aparece arriba (NO inventes nombres)
- DEBES mencionar el nombre EXACTO del hijo en cada tip
- Formato OBLIGATORIO: emoji + NOMBRE EXACTO DEL HIJO + consejo
- En espaÃ±ol
- Relacionado con el tipo "${tipType}"
- NO REPITAS ningÃºn tip de la lista de "TIPS RECIENTES"
- Cada tip en una lÃ­nea separada

âš ï¸ MUY IMPORTANTE - USAR NOMBRES EXACTOS:
${children.map((child, index) => `- Hijo ${index + 1}: DEBES usar "${child.name}" (NO uses otro nombre)`).join('\n')}

CONTEXTO POR EDAD:
- Si el hijo es bebÃ© (0-12 meses), enfÃ³cate en desarrollo temprano
- Si el hijo es niÃ±o pequeÃ±o (1-3 aÃ±os), enfÃ³cate en autonomÃ­a y lenguaje  
- Si el hijo es por nacer, enfÃ³cate en preparaciÃ³n

EJEMPLO CORRECTO de formato:
${children.length > 0 ? `ðŸŽ¨ ${children[0].name}: [consejo personalizado para ${children[0].name}]` : ''}

Genera ${children.length} tip${children.length > 1 ? 's' : ''} ahora usando los NOMBRES EXACTOS listados arriba:`
          : `Eres una doula experta llamada "Douli". Necesito que generes SOLO 1 tip general de ${tipType}.

ESTADO DE EMBARAZO:
${isPregnant ? `Actualmente embarazada de ${currentGestationWeeks} semanas` : 'No estÃ¡ embarazada actualmente'}

TIPS RECIENTES (NO REPITAS ESTOS):
${recentTips.length > 0 ? recentTips.map(tip => `- ${tip}`).join('\n') : 'Ninguno'}

INSTRUCCIONES:
- Genera SOLO 1 tip general de ${tipType}
- Formato: emoji + texto corto
- En espaÃ±ol
- NO especÃ­fico de ningÃºn hijo en particular
- NO REPITAS ningÃºn tip de la lista de "TIPS RECIENTES"
${tipType === 'embarazo' && isPregnant ? `\n- EspecÃ­fico para ${currentGestationWeeks} semanas de embarazo` : ''}

Genera el tip ahora:`;

        const completion = await openai.chat.completions.create({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: "Eres una doula experta y compasiva que da consejos prÃ¡cticos y Ãºtiles para padres."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: shouldGeneratePerChild ? 150 * children.length : 300, // MÃ¡s tokens si hay mÃºltiples hijos
          temperature: 0.7
        });

        const response = completion.choices[0].message.content;
        tips = response.split('\n').filter(tip => tip.trim().length > 0);

      } catch (openaiError) {
        console.error('âŒ Error con OpenAI:', openaiError.message);
        // Fallback con tips predefinidos
        tips = generateFallbackTips(children, tipType);
      }
    } else {
      // Fallback si OpenAI no estÃ¡ disponible
      tips = generateFallbackTips(children, tipType);
    }

    // Almacenar el tip generado para evitar repeticiones futuras
    if (tips.length > 0) {
      console.log('ðŸ” [STORAGE] Intentando almacenar tip:', {
        userId: uid,
        tipType: tipType,
        tip: tips[0],
        childrenContext: childrenContext,
        isPregnant: isPregnant,
        currentGestationWeeks: currentGestationWeeks
      });
      
      try {
        const tipData = {
          userId: uid,
          tipType: tipType,
          tip: tips[0],
          childrenContext: childrenContext,
          childIds: children.map(child => child.id),
          isPregnant: isPregnant,
          currentGestationWeeks: currentGestationWeeks,
          createdAt: new Date(),
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // Expira en 30 dÃ­as
        };
        
        console.log('ðŸ“ [STORAGE] Datos del tip a almacenar:', tipData);
        
        const docRef = await db.collection('userTips').add(tipData);
        console.log('âœ… [STORAGE] Tip almacenado exitosamente. Document ID:', docRef.id);
        console.log('âœ… [STORAGE] Tip almacenado para usuario:', uid, 'tipo:', tipType);
      } catch (storageError) {
        console.error('âŒ [STORAGE] Error almacenando tip:', storageError);
        console.error('âŒ [STORAGE] Error completo:', JSON.stringify(storageError, null, 2));
        // Continuar aunque falle el almacenamiento
      }
    } else {
      console.log('âš ï¸ [STORAGE] No hay tips para almacenar');
    }

    res.json({
      success: true,
      data: {
        tips: tips.slice(0, 1), // Solo 1 tip
        children: children.map(child => ({
          id: child.id,
          name: child.name,
          currentAge: child.isUnborn ? `${child.currentGestationWeeks} semanas` : `${child.currentAgeInMonths} meses`,
          isUnborn: child.isUnborn
        })),
        tipType: tipType,
        timestamp: new Date()
      }
    });

  } catch (error) {
    console.error('âŒ Error obteniendo tips:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo tips',
      error: error.message
    });
  }
});

// ===== SISTEMA DE COMUNIDADES =====

// Endpoint para subir foto de comunidad
app.post('/api/communities/upload-photo', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se ha subido ninguna imagen. AsegÃºrate de usar el campo "image"'
      });
    }

    // Validar tipo de archivo
    const allowedTypes = [
      'image/jpeg',
      'image/jpg',
      'image/png',
      'image/gif',
      'image/webp',
      'image/heic',
      'image/heif'
    ];
    if (!allowedTypes.includes(req.file.mimetype)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de archivo no permitido. Solo se permiten: JPEG, JPG, PNG, GIF, WEBP, HEIC, HEIF'
      });
    }

    // Validar tamaÃ±o (mÃ¡ximo 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB en bytes
    if (req.file.size > maxSize) {
      return res.status(400).json({
        success: false,
        message: 'La imagen es demasiado grande. MÃ¡ximo 5MB permitido'
      });
    }

    let imageUrl = null;
    
    try {
      const bucket = admin.storage().bucket();
      const fileName = `communities/photos/${Date.now()}-${req.file.originalname}`;
      const file = bucket.file(fileName);
      
      console.log('ðŸ“¤ [UPLOAD] Subiendo imagen:', {
        originalName: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        fileName: fileName
      });

      await file.save(req.file.buffer, {
        metadata: {
          contentType: req.file.mimetype
        }
      });

      // Hacer la imagen pÃºblica
      await file.makePublic();
      imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      
      console.log('âœ… [UPLOAD] Imagen subida exitosamente:', imageUrl);

      // Guardar registro de la imagen en Firestore (opcional, para tracking)
      await db.collection('communityPhotos').add({
        userId: uid,
        fileName: fileName,
        originalName: req.file.originalname,
        imageUrl: imageUrl,
        fileSize: req.file.size,
        mimetype: req.file.mimetype,
        uploadedAt: new Date()
      });

      res.json({
        success: true,
        message: 'Imagen subida exitosamente',
        data: {
          photoUrl: imageUrl,
          fileName: fileName,
          originalName: req.file.originalname,
          fileSize: req.file.size,
          mimetype: req.file.mimetype
        }
      });

    } catch (uploadError) {
      console.error('âŒ [UPLOAD] Error subiendo imagen:', uploadError);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: uploadError.message
      });
    }

  } catch (error) {
    console.error('âŒ [UPLOAD] Error general:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Endpoint para crear una comunidad
app.post('/api/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { name, keywords, description, imageUrl, isPublic = true } = req.body;

    console.log('ðŸ—ï¸ [COMMUNITIES] Datos recibidos:', {
      name, keywords, description, imageUrl, isPublic
    });

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar campos obligatorios
    if (!name || !keywords || !description) {
      return res.status(400).json({
        success: false,
        message: 'Nombre, palabras clave y descripciÃ³n son obligatorios'
      });
    }

    // Verificar si ya existe una comunidad con ese nombre
    const existingCommunity = await db.collection('communities')
      .where('name', '==', name.trim())
      .get();

    if (!existingCommunity.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una comunidad con ese nombre'
      });
    }

    // Usar la URL de imagen recibida directamente
    console.log('ðŸ–¼ï¸ [COMMUNITIES] URL de imagen recibida:', imageUrl);

    // Crear la comunidad
    const communityData = {
      name: name.trim(),
      keywords: keywords.split(',').map(k => k.trim()).filter(k => k),
      description: description.trim(),
      imageUrl: imageUrl || null, // Asegurar que no sea undefined
      isPublic: isPublic === 'true' || isPublic === true,
      creatorId: uid,
      members: [uid], // El creador es el primer miembro
      memberCount: 1,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const communityRef = await db.collection('communities').add(communityData);
    
    console.log('âœ… [COMMUNITY] Comunidad creada exitosamente:', communityRef.id);

    res.json({
      success: true,
      message: 'Comunidad creada exitosamente',
      data: {
        id: communityRef.id,
        ...communityData
      }
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error creando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comunidad',
      error: error.message
    });
  }
});

// Endpoint para buscar en todas las comunidades (pÃºblicas y privadas) incluyendo las del usuario
app.get('/api/communities/search', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { query, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ©rmino de bÃºsqueda es obligatorio'
      });
    }

    const searchTerm = query.trim().toLowerCase();
    const searchLimit = Math.min(parseInt(limit), 50); // MÃ¡ximo 50 resultados

    // Obtener TODAS las comunidades (incluyendo las del usuario)
    let communitiesSnapshot;
    try {
      // Intentar con ordenamiento - obtener TODAS las comunidades
      communitiesSnapshot = await db.collection('communities')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [COMMUNITIES SEARCH] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      communitiesSnapshot = await db.collection('communities').get();
    }

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Buscar en nombre, palabras clave y descripciÃ³n
      const nameMatch = data.name.toLowerCase().includes(searchTerm);
      const keywordsMatch = data.keywords && data.keywords.some(keyword => 
        keyword.toLowerCase().includes(searchTerm)
      );
      const descriptionMatch = data.description.toLowerCase().includes(searchTerm);
      
      if (nameMatch || keywordsMatch || descriptionMatch) {
        const isCreator = data.creatorId === uid;
        const isMember = data.members && data.members.includes(uid);
        const isPublicResolved = data.isPublic !== undefined ? data.isPublic : (data.isPrivate ? false : true);
        const isPrivateResolved = data.isPrivate !== undefined ? data.isPrivate : !isPublicResolved;
        
        communities.push({
          id: doc.id,
          name: data.name,
          keywords: data.keywords,
          description: data.description,
          imageUrl: data.imageUrl,
          isPublic: isPublicResolved,
          isPrivate: isPrivateResolved,
          memberCount: data.memberCount || 0,
          isCreator: isCreator,
          isMember: isMember,
          canJoin: !isMember && isPublicResolved, // Solo si no es miembro y es pÃºblica
          joinType: !isMember ? (isPublicResolved ? 'direct' : 'request') : null, // Tipo de uniÃ³n si no es miembro
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          // Campos de relevancia para el ranking
          relevanceScore: calculateRelevanceScore(data, searchTerm)
        });
      }
    });

    // Ordenar por relevancia (exacto > parcial > fecha)
    communities.sort((a, b) => {
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Si tienen la misma relevancia, ordenar por fecha de creaciÃ³n
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Limitar resultados
    const limitedResults = communities.slice(0, searchLimit);

    res.json({
      success: true,
      message: 'BÃºsqueda completada exitosamente',
      data: {
        results: limitedResults,
        totalFound: communities.length,
        searchTerm: searchTerm,
        limit: searchLimit
      }
    });

  } catch (error) {
    console.error('âŒ [COMMUNITIES] Error en bÃºsqueda:', error);
    res.status(500).json({
      success: false,
      message: 'Error en la bÃºsqueda',
      error: error.message
    });
  }
});

// Endpoint para obtener todas las comunidades (pÃºblicas y privadas)
app.get('/api/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let communitiesSnapshot;
    try {
      // Intentar con ordenamiento - obtener TODAS las comunidades excepto las del usuario
      communitiesSnapshot = await db.collection('communities')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [COMMUNITIES] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento y filtrar en memoria
      communitiesSnapshot = await db.collection('communities').get();
    }

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      const isPublicResolved = data.isPublic !== undefined ? data.isPublic : (data.isPrivate ? false : true);
      const isPrivateResolved = data.isPrivate !== undefined ? data.isPrivate : !isPublicResolved;
      
      const creatorId = data.creatorId || data.createdBy || null;
      const isMember = data.members && data.members.includes(uid);
      
      communities.push({
        id: doc.id,
        name: data.name,
        keywords: data.keywords,
        description: data.description,
        imageUrl: data.imageUrl,
        isPublic: isPublicResolved,
        isPrivate: isPrivateResolved,
        memberCount: data.memberCount || 0,
        isMember: isMember,
        isCreator: creatorId === uid,
        canJoin: isPublicResolved && !isMember, // Solo si no es miembro y es pÃºblica
        joinType: isPublicResolved ? 'direct' : 'request', // Tipo de uniÃ³n permitida
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      data: communities
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error obteniendo comunidades:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades',
      error: error.message
    });
  }
});

// Endpoint para unirse a una comunidad
app.post('/api/communities/:communityId/join', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();

    // Verificar si ya es miembro
    if (communityData.members && communityData.members.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya eres miembro de esta comunidad'
      });
    }

    // Si es pÃºblica, unirse directamente
    if (communityData.isPublic) {
      await communityRef.update({
        members: admin.firestore.FieldValue.arrayUnion(uid),
        memberCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      console.log('âœ… [COMMUNITY] Usuario se uniÃ³ directamente a comunidad pÃºblica:', uid, communityId);

      res.json({
        success: true,
        message: 'Te has unido a la comunidad exitosamente'
      });
    } else {
      // Si es privada, crear solicitud de uniÃ³n
      // Verificar que no haya una solicitud pendiente
      let existingRequest;
      try {
        // Intentar con ordenamiento - requiere Ã­ndice compuesto
        existingRequest = await db.collection('joinRequests')
          .where('communityId', '==', communityId)
          .where('userId', '==', uid)
          .where('status', '==', 'pending')
          .get();
      } catch (indexError) {
        console.log('âš ï¸ [JOIN CHECK] Ãndice no disponible, verificando sin ordenamiento:', indexError.message);
        // Fallback: verificar sin ordenamiento
        existingRequest = await db.collection('joinRequests')
          .where('communityId', '==', communityId)
          .where('userId', '==', uid)
          .where('status', '==', 'pending')
          .get();
      }

      if (!existingRequest.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya tienes una solicitud pendiente para esta comunidad'
        });
      }

      const requestData = {
        userId: uid,
        communityId: communityId,
        userName: req.user.displayName || 'Usuario',
        status: 'pending', // pending, approved, rejected
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const joinRequestRef = await db.collection('joinRequests').add(requestData);
      
      console.log('âœ… [COMMUNITY] Solicitud de uniÃ³n creada:', uid, communityId);

      res.json({
        success: true,
        message: 'Solicitud de uniÃ³n enviada. Espera la aprobaciÃ³n del administrador.',
        data: {
          communityId,
          requestId: joinRequestRef.id,
          status: 'pending'
        }
      });
    }

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error uniÃ©ndose a comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error uniÃ©ndose a comunidad',
      error: error.message
    });
  }
});

// Endpoint para salir de una comunidad
app.post('/api/communities/:communityId/leave', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    console.log('ðŸšª [COMMUNITY] Usuario intentando salir de comunidad:', uid, communityId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();

    // Verificar si el usuario es el creador de la comunidad
    if (communityData.userId === uid) {
      return res.status(400).json({
        success: false,
        message: 'No puedes salir de una comunidad que creaste. Debes eliminarla o transferir la propiedad primero.'
      });
    }

    // Verificar si es miembro
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No eres miembro de esta comunidad'
      });
    }

    // Remover al usuario de la lista de miembros
    await communityRef.update({
      members: admin.firestore.FieldValue.arrayRemove(uid),
      memberCount: admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log('âœ… [COMMUNITY] Usuario saliÃ³ de la comunidad:', uid, communityId);

    res.json({
      success: true,
      message: 'Has salido de la comunidad exitosamente'
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error saliendo de comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error saliendo de comunidad',
      error: error.message
    });
  }
});

// Endpoint para obtener solicitudes pendientes de una comunidad (solo para el owner)
app.get('/api/communities/:communityId/join-requests', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe y el usuario es el owner
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (communityData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador de la comunidad puede ver las solicitudes'
      });
    }

    // Obtener solicitudes pendientes
    let requestsSnapshot;
    try {
      // Intentar con ordenamiento - requiere Ã­ndice compuesto
      requestsSnapshot = await db.collection('joinRequests')
        .where('communityId', '==', communityId)
        .where('status', '==', 'pending')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [JOIN REQUESTS] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      requestsSnapshot = await db.collection('joinRequests')
        .where('communityId', '==', communityId)
        .where('status', '==', 'pending')
        .get();
    }

    const requests = [];
    for (const doc of requestsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaciÃ³n completa del usuario
      let userProfile = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          userProfile = userDoc.data();
        }
      } catch (userError) {
        console.log('âš ï¸ [JOIN REQUESTS] Error obteniendo perfil de usuario:', data.userId, userError.message);
      }
      
      requests.push({
        id: doc.id,
        userId: data.userId,
        userName: userProfile?.displayName || data.userName || 'Usuario',
        userPhoto: userProfile?.photoURL || null,
        userEmail: userProfile?.email || null,
        communityId: data.communityId,
        status: data.status,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        requestDate: data.createdAt // Fecha de la solicitud
      });
    }

    res.json({
      success: true,
      message: 'Solicitudes obtenidas exitosamente',
      data: requests
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error obteniendo solicitudes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo solicitudes',
      error: error.message
    });
  }
});

// Endpoint para aprobar/rechazar solicitudes de uniÃ³n (solo para el owner)
app.put('/api/communities/:communityId/join-requests/:requestId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId, requestId } = req.params;
    const { action } = req.body; // 'approve' o 'reject'

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!action || !['approve', 'reject'].includes(action)) {
      return res.status(400).json({
        success: false,
        message: 'AcciÃ³n debe ser "approve" o "reject"'
      });
    }

    // Verificar que la comunidad existe y el usuario es el owner
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (communityData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador de la comunidad puede aprobar/rechazar solicitudes'
      });
    }

    // Obtener la solicitud
    const requestDoc = await db.collection('joinRequests').doc(requestId).get();
    if (!requestDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Solicitud no encontrada'
      });
    }

    const requestData = requestDoc.data();
    if (requestData.communityId !== communityId) {
      return res.status(400).json({
        success: false,
        message: 'La solicitud no pertenece a esta comunidad'
      });
    }

    if (requestData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'La solicitud ya no estÃ¡ pendiente'
      });
    }

    const batch = db.batch();

    if (action === 'approve') {
      // Aprobar solicitud: agregar usuario a la comunidad
      const communityRef = db.collection('communities').doc(communityId);
      batch.update(communityRef, {
        members: admin.firestore.FieldValue.arrayUnion(requestData.userId),
        memberCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      // Actualizar estado de la solicitud
      const requestRef = db.collection('joinRequests').doc(requestId);
      batch.update(requestRef, {
        status: 'approved',
        updatedAt: new Date()
      });

      await batch.commit();

      console.log('âœ… [COMMUNITY] Solicitud aprobada:', requestId, communityId);

      res.json({
        success: true,
        message: 'Solicitud aprobada. El usuario se ha unido a la comunidad.',
        data: {
          requestId,
          status: 'approved',
          userId: requestData.userId
        }
      });
    } else {
      // Rechazar solicitud
      const requestRef = db.collection('joinRequests').doc(requestId);
      batch.update(requestRef, {
        status: 'rejected',
        updatedAt: new Date()
      });

      await batch.commit();

      console.log('âœ… [COMMUNITY] Solicitud rechazada:', requestId, communityId);

      res.json({
        success: true,
        message: 'Solicitud rechazada',
        data: {
          requestId,
          status: 'rejected',
          userId: requestData.userId
        }
      });
    }

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error procesando solicitud:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando solicitud',
      error: error.message
    });
  }
});

// Endpoint para obtener solicitudes del usuario
app.get('/api/user/join-requests', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las solicitudes del usuario
    let requestsSnapshot;
    try {
      // Intentar con ordenamiento - requiere Ã­ndice compuesto
      requestsSnapshot = await db.collection('joinRequests')
        .where('userId', '==', uid)
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [USER REQUESTS] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      requestsSnapshot = await db.collection('joinRequests')
        .where('userId', '==', uid)
        .get();
    }

    const requests = [];
    for (const doc of requestsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaciÃ³n de la comunidad
      const communityDoc = await db.collection('communities').doc(data.communityId).get();
      if (communityDoc.exists) {
        const communityData = communityDoc.data();
        requests.push({
          id: doc.id,
          communityId: data.communityId,
          communityName: communityData.name,
          communityImage: communityData.imageUrl,
          status: data.status,
          createdAt: data.createdAt,
          updatedAt: data.updatedAt
        });
      }
    }

    res.json({
      success: true,
      message: 'Solicitudes obtenidas exitosamente',
      data: requests
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error obteniendo solicitudes del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo solicitudes',
      error: error.message
    });
  }
});

// Endpoint para buscar en las comunidades del usuario
app.get('/api/user/communities/search', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { query, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ©rmino de bÃºsqueda es obligatorio'
      });
    }

    const searchTerm = query.trim().toLowerCase();
    const searchLimit = Math.min(parseInt(limit), 50); // MÃ¡ximo 50 resultados

    // Obtener todas las comunidades del usuario
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', uid)
      .get();

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Buscar en nombre, palabras clave y descripciÃ³n
      const nameMatch = data.name.toLowerCase().includes(searchTerm);
      const keywordsMatch = data.keywords && data.keywords.some(keyword => 
        keyword.toLowerCase().includes(searchTerm)
      );
      const descriptionMatch = data.description.toLowerCase().includes(searchTerm);
      
      if (nameMatch || keywordsMatch || descriptionMatch) {
        communities.push({
          id: doc.id,
          name: data.name,
          keywords: data.keywords,
          description: data.description,
          imageUrl: data.imageUrl,
          isPublic: data.isPublic,
          memberCount: data.memberCount || 0,
          isCreator: data.creatorId === uid,
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          // Campos de relevancia para el ranking
          relevanceScore: calculateRelevanceScore(data, searchTerm)
        });
      }
    });

    // Ordenar por relevancia (exacto > parcial > fecha)
    communities.sort((a, b) => {
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Si tienen la misma relevancia, ordenar por fecha de creaciÃ³n
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Limitar resultados
    const limitedResults = communities.slice(0, searchLimit);

    res.json({
      success: true,
      message: 'BÃºsqueda completada exitosamente',
      data: {
        results: limitedResults,
        totalFound: communities.length,
        searchTerm: searchTerm,
        limit: searchLimit
      }
    });

  } catch (error) {
    console.error('âŒ [COMMUNITIES] Error en bÃºsqueda:', error);
    res.status(500).json({
      success: false,
      message: 'Error en la bÃºsqueda',
      error: error.message
    });
  }
});

// FunciÃ³n para calcular puntuaciÃ³n de relevancia
function calculateRelevanceScore(community, searchTerm) {
  let score = 0;
  const term = searchTerm.toLowerCase();
  
  // BÃºsqueda exacta en nombre (mÃ¡xima puntuaciÃ³n)
  if (community.name.toLowerCase() === term) {
    score += 100;
  }
  // BÃºsqueda parcial en nombre
  else if (community.name.toLowerCase().includes(term)) {
    score += 50;
  }
  
  // BÃºsqueda en palabras clave
  if (community.keywords) {
    community.keywords.forEach(keyword => {
      if (keyword.toLowerCase() === term) {
        score += 30;
      } else if (keyword.toLowerCase().includes(term)) {
        score += 15;
      }
    });
  }
  
  // BÃºsqueda en descripciÃ³n
  if (community.description.toLowerCase().includes(term)) {
    score += 10;
  }
  
  return score;
}

// Endpoint para obtener comunidades del usuario
app.get('/api/user/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener comunidades donde el usuario es miembro
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', uid)
      .get();

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      communities.push({
        id: doc.id,
        name: data.name,
        keywords: data.keywords,
        description: data.description,
        imageUrl: data.imageUrl,
        isPublic: data.isPublic,
        memberCount: data.memberCount || 0,
        isCreator: data.creatorId === uid,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      data: communities
    });

  } catch (error) {
    console.error('âŒ [COMMUNITY] Error obteniendo comunidades del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades del usuario',
      error: error.message
    });
  }
});

// ===== SISTEMA DE LISTAS =====

// Endpoint para crear una lista
app.post('/api/lists', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { title, description, isPublic = false, items = [] } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar campos obligatorios
    if (!title || title.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ­tulo de la lista es obligatorio'
      });
    }

    // Crear la lista
    const listData = {
      title: title.trim(),
      description: description ? description.trim() : '',
      imageUrl: req.body.imageUrl || null, // URL de imagen de la lista
      isPublic: isPublic === 'true' || isPublic === true,
      creatorId: uid,
      items: items.map((item, index) => ({
        id: `item_${Date.now()}_${index}`,
        text: item.text ? item.text.trim() : '',
        imageUrl: item.imageUrl || null, // URL de imagen del item
        priority: item.priority || 'medium', // low, medium, high
        details: item.details || '', // Detalles adicionales
        brand: item.brand || '', // Marca
        store: item.store || '', // Tienda
        approximatePrice: item.approximatePrice || null, // Precio aproximado
        completed: false,
        createdAt: new Date()
      })),
      completedItems: 0,
      totalItems: items.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const listRef = await db.collection('lists').add(listData);
    
    console.log('âœ… [LISTS] Lista creada exitosamente:', listRef.id);

    res.json({
      success: true,
      message: 'Lista creada exitosamente',
      data: {
        id: listRef.id,
        ...listData
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error creando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando lista',
      error: error.message
    });
  }
});

// Endpoint para obtener las listas del usuario
app.get('/api/user/lists', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'all', includeItems = 'false' } = req.query; // 'all', 'public', 'private'

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('lists').where('creatorId', '==', uid);
    
    // Filtrar por tipo si se especifica
    if (type === 'public') {
      query = query.where('isPublic', '==', true);
    } else if (type === 'private') {
      query = query.where('isPublic', '==', false);
    }

    const listsSnapshot = await query.orderBy('updatedAt', 'desc').get();

    const shouldIncludeItems = includeItems === 'true';
    const lists = [];
    
    listsSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Por defecto, solo devolver primeros 5 items como preview
      let itemsPreview = [];
      if (shouldIncludeItems && data.items && data.items.length > 0) {
        itemsPreview = data.items.slice(0, 5);
      }
      
      lists.push({
        id: doc.id,
        title: data.title,
        description: data.description,
        imageUrl: data.imageUrl || null,
        isPublic: data.isPublic,
        isOwner: data.creatorId === uid,
        items: itemsPreview, // Solo preview de items
        hasMoreItems: data.items && data.items.length > 5,
        completedItems: data.completedItems || 0,
        totalItems: data.totalItems || 0,
        stars: data.stars || 0,
        comments: data.comments || 0,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      message: 'Listas obtenidas exitosamente',
      data: lists
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error obteniendo listas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas',
      error: error.message
    });
  }
});

// Endpoint para obtener listas pÃºblicas
app.get('/api/lists/public', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { limit = 20, offset = 0 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const listsSnapshot = await db.collection('lists')
      .where('isPublic', '==', true)
      .orderBy('stars', 'desc')
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit))
      .offset(parseInt(offset))
      .get();

    const lists = [];
    listsSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Solo incluir preview de primeros 5 items
      const itemsPreview = data.items && data.items.length > 0 ? data.items.slice(0, 5) : [];
      
      lists.push({
        id: doc.id,
        title: data.title,
        description: data.description,
        imageUrl: data.imageUrl || null,
        creatorId: data.creatorId,
        isOwner: data.creatorId === uid,
        items: itemsPreview, // Solo preview
        hasMoreItems: data.items && data.items.length > 5,
        completedItems: data.completedItems || 0,
        totalItems: data.totalItems || 0,
        stars: data.stars || 0,
        comments: data.comments || 0,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      message: 'Listas pÃºblicas obtenidas exitosamente',
      data: lists
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error obteniendo listas pÃºblicas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas pÃºblicas',
      error: error.message
    });
  }
});

// Endpoint para actualizar una lista
app.put('/api/lists/:listId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { title, description, isPublic } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede editar la lista'
      });
    }

    // Actualizar la lista
    const updateData = {
      updatedAt: new Date()
    };

    if (title !== undefined) updateData.title = title.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (req.body.imageUrl !== undefined) updateData.imageUrl = req.body.imageUrl || null;
    if (isPublic !== undefined) updateData.isPublic = isPublic === 'true' || isPublic === true;

    await db.collection('lists').doc(listId).update(updateData);

    console.log('âœ… [LISTS] Lista actualizada exitosamente:', listId);

    res.json({
      success: true,
      message: 'Lista actualizada exitosamente',
      data: { listId, ...updateData }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error actualizando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando lista',
      error: error.message
    });
  }
});

// Endpoint para agregar un item a una lista
app.post('/api/lists/:listId/items', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { text } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!text || text.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El texto del item es obligatorio'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede agregar items a la lista'
      });
    }

    // Crear el nuevo item
    const newItem = {
      id: `item_${Date.now()}_${Math.random()}`,
      text: text.trim(),
      imageUrl: req.body.imageUrl || null,
      priority: req.body.priority || 'medium',
      details: req.body.details || '',
      brand: req.body.brand || '',
      store: req.body.store || '',
      approximatePrice: req.body.approximatePrice || null,
      completed: false,
      createdAt: new Date()
    };

    // Actualizar la lista
    const updatedItems = [...(listData.items || []), newItem];
    
    await db.collection('lists').doc(listId).update({
      items: updatedItems,
      totalItems: updatedItems.length,
      updatedAt: new Date()
    });

    console.log('âœ… [LISTS] Item agregado exitosamente:', newItem.id);

    res.json({
      success: true,
      message: 'Item agregado exitosamente',
      data: newItem
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error agregando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando item',
      error: error.message
    });
  }
});

// Endpoint para marcar/desmarcar un item como completado
app.put('/api/lists/:listId/items/:itemId/toggle', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede modificar items de la lista'
      });
    }

    // Encontrar y actualizar el item
    const items = listData.items || [];
    const itemIndex = items.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Toggle del estado completado
    items[itemIndex].completed = !items[itemIndex].completed;
    
    // Contar items completados
    const completedItems = items.filter(item => item.completed).length;

    // Actualizar la lista
    await db.collection('lists').doc(listId).update({
      items: items,
      completedItems: completedItems,
      updatedAt: new Date()
    });

    console.log('âœ… [LISTS] Item actualizado exitosamente:', itemId);

    res.json({
      success: true,
      message: 'Item actualizado exitosamente',
      data: {
        itemId: itemId,
        completed: items[itemIndex].completed,
        completedItems: completedItems
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error actualizando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando item',
      error: error.message
    });
  }
});

// Endpoint para eliminar un item de una lista
app.delete('/api/lists/:listId/items/:itemId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede eliminar items de la lista'
      });
    }

    // Encontrar y eliminar el item
    const items = listData.items || [];
    const filteredItems = items.filter(item => item.id !== itemId);
    
    if (filteredItems.length === items.length) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Contar items completados
    const completedItems = filteredItems.filter(item => item.completed).length;

    // Actualizar la lista
    await db.collection('lists').doc(listId).update({
      items: filteredItems,
      totalItems: filteredItems.length,
      completedItems: completedItems,
      updatedAt: new Date()
    });

    console.log('âœ… [LISTS] Item eliminado exitosamente:', itemId);

    res.json({
      success: true,
      message: 'Item eliminado exitosamente',
      data: { itemId }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error eliminando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando item',
      error: error.message
    });
  }
});

// Endpoint para calificar un item de lista pÃºblica
app.post('/api/lists/:listId/items/:itemId/rate', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;
    const { rating } = req.body; // rating del 1 al 5

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar rating
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({
        success: false,
        message: 'El rating debe ser un nÃºmero del 1 al 5'
      });
    }

    // Verificar que la lista existe y es pÃºblica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden calificar items de listas pÃºblicas'
      });
    }

    // Verificar que el item existe
    const item = listData.items.find(item => item.id === itemId);
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Verificar si el usuario ya calificÃ³ este item
    const existingRating = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .where('userId', '==', uid)
      .get();

    let ratingData;
    if (existingRating.empty) {
      // Crear nueva calificaciÃ³n
      ratingData = {
        listId: listId,
        itemId: itemId,
        userId: uid,
        rating: parseInt(rating),
        createdAt: new Date(),
        updatedAt: new Date()
      };
      await db.collection('itemRatings').add(ratingData);
    } else {
      // Actualizar calificaciÃ³n existente
      const ratingDoc = existingRating.docs[0];
      ratingData = {
        ...ratingDoc.data(),
        rating: parseInt(rating),
        updatedAt: new Date()
      };
      await db.collection('itemRatings').doc(ratingDoc.id).update({
        rating: parseInt(rating),
        updatedAt: new Date()
      });
    }

    // Calcular promedio de calificaciones para este item
    const allRatings = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    let totalRating = 0;
    let ratingCount = 0;
    allRatings.forEach(doc => {
      totalRating += doc.data().rating;
      ratingCount++;
    });

    const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

    console.log('âœ… [LISTS] Item calificado exitosamente:', itemId, 'Rating:', rating);

    res.json({
      success: true,
      message: 'Item calificado exitosamente',
      data: {
        listId: listId,
        itemId: itemId,
        rating: parseInt(rating),
        averageRating: parseFloat(averageRating),
        totalRatings: ratingCount,
        isNewRating: existingRating.empty
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error calificando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error calificando item',
      error: error.message
    });
  }
});

// Endpoint para obtener calificaciones de un item
app.get('/api/lists/:listId/items/:itemId/ratings', async (req, res) => {
  try {
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es pÃºblica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden ver calificaciones de items de listas pÃºblicas'
      });
    }

    // Obtener todas las calificaciones del item
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    let totalRating = 0;
    let ratingCount = 0;
    const ratings = [];

    ratingsSnapshot.forEach(doc => {
      const data = doc.data();
      totalRating += data.rating;
      ratingCount++;
      ratings.push({
        id: doc.id,
        userId: data.userId,
        rating: data.rating,
        createdAt: data.createdAt
      });
    });

    const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

    res.json({
      success: true,
      message: 'Calificaciones obtenidas exitosamente',
      data: {
        itemId: itemId,
        averageRating: parseFloat(averageRating),
        totalRatings: ratingCount,
        ratings: ratings
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error obteniendo calificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones',
      error: error.message
    });
  }
});

// Endpoint para dar/quitar estrella a una lista pÃºblica
app.post('/api/lists/:listId/star', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es pÃºblica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden calificar listas pÃºblicas'
      });
    }

    // Verificar si el usuario ya dio estrella
    const existingStar = await db.collection('listStars')
      .where('listId', '==', listId)
      .where('userId', '==', uid)
      .get();

    let newStarsCount = listData.stars || 0;

    if (existingStar.empty) {
      // Agregar estrella
      await db.collection('listStars').add({
        listId: listId,
        userId: uid,
        createdAt: new Date()
      });
      newStarsCount += 1;
    } else {
      // Quitar estrella
      await db.collection('listStars').doc(existingStar.docs[0].id).delete();
      newStarsCount = Math.max(0, newStarsCount - 1);
    }

    // Actualizar contador de estrellas en la lista
    await db.collection('lists').doc(listId).update({
      stars: newStarsCount,
      updatedAt: new Date()
    });

    console.log('âœ… [LISTS] Estrella actualizada:', listId, newStarsCount);

    res.json({
      success: true,
      message: 'Estrella actualizada exitosamente',
      data: {
        listId: listId,
        stars: newStarsCount,
        hasStarred: existingStar.empty
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error actualizando estrella:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estrella',
      error: error.message
    });
  }
});

// Endpoint para comentar en un item de lista pÃºblica
app.post('/api/lists/:listId/items/:itemId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;
    const { content } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del comentario es obligatorio'
      });
    }

    // Verificar que la lista existe y es pÃºblica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden comentar listas pÃºblicas'
      });
    }

    // Verificar que el item existe
    const item = listData.items.find(item => item.id === itemId);
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Crear el comentario
    const commentData = {
      listId: listId,
      itemId: itemId,
      userId: uid,
      userName: req.user.displayName || 'Usuario',
      content: content.trim(),
      createdAt: new Date()
    };

    const commentRef = await db.collection('listComments').add(commentData);

    // Actualizar contador de comentarios en la lista
    const newCommentsCount = (listData.comments || 0) + 1;
    await db.collection('lists').doc(listId).update({
      comments: newCommentsCount,
      updatedAt: new Date()
    });

    console.log('âœ… [LISTS] Comentario agregado exitosamente:', commentRef.id);

    res.json({
      success: true,
      message: 'Comentario agregado exitosamente',
      data: {
        id: commentRef.id,
        ...commentData,
        commentsCount: newCommentsCount
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error agregando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando comentario',
      error: error.message
    });
  }
});

// Endpoint para obtener comentarios de un item de lista pÃºblica
app.get('/api/lists/:listId/items/:itemId/comments', async (req, res) => {
  try {
    const { listId, itemId } = req.params;
    const { limit = 20, offset = 0 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es pÃºblica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden ver comentarios de listas pÃºblicas'
      });
    }

    // Obtener comentarios del item
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit))
      .offset(parseInt(offset))
      .get();

    const comments = [];
    
    // Obtener informaciÃ³n de perfil para cada comentario
    for (const doc of commentsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaciÃ³n del perfil del usuario
      let userProfile = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userProfile = {
            displayName: userData.displayName || data.userName || 'Usuario',
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('âš ï¸ [LISTS] Error obteniendo perfil del usuario:', data.userId, error.message);
        // Usar datos del comentario como fallback
        userProfile = {
          displayName: data.userName || 'Usuario',
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        userName: userProfile.displayName,
        userPhoto: userProfile.photoURL,
        content: data.content,
        createdAt: data.createdAt
      });
    }

    res.json({
      success: true,
      message: 'Comentarios obtenidos exitosamente',
      data: comments
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Endpoint para obtener detalles de una lista pÃºblica con informaciÃ³n de interacciÃ³n del usuario
app.get('/api/lists/:listId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { page = 1, limit = 20, includeStats = 'true' } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la lista
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();

    // Verificar si el usuario puede ver la lista
    if (!listData.isPublic && listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver esta lista'
      });
    }

    // Obtener informaciÃ³n de interacciÃ³n del usuario (solo para listas pÃºblicas)
    let hasStarred = false;
    if (listData.isPublic) {
      const userStar = await db.collection('listStars')
        .where('listId', '==', listId)
        .where('userId', '==', uid)
        .get();
      hasStarred = !userStar.empty;
    }

    // Paginar items
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;

    const allItems = listData.items || [];
    const paginatedItems = allItems.slice(startIndex, endIndex);
    const shouldIncludeStats = includeStats === 'true';

    // Obtener calificaciones y comentarios para cada item (solo los paginados)
    let itemsWithStats = [];
    if (paginatedItems.length > 0 && shouldIncludeStats) {
      itemsWithStats = await Promise.all(
        paginatedItems.map(async (item) => {
          // Si el item no tiene ID, retornar sin stats
          if (!item.id) {
            console.warn('âš ï¸ [LISTS] Item sin ID encontrado:', item);
            return {
              ...item,
              averageRating: 0,
              totalRatings: 0,
              commentCount: 0
            };
          }

          // Obtener calificaciones del item
          const ratingsSnapshot = await db.collection('itemRatings')
            .where('listId', '==', listId)
            .where('itemId', '==', item.id)
            .get();

          let totalRating = 0;
          let ratingCount = 0;
          ratingsSnapshot.forEach(doc => {
            totalRating += doc.data().rating;
            ratingCount++;
          });
          const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

          // Obtener comentarios del item
          const commentsSnapshot = await db.collection('listComments')
            .where('listId', '==', listId)
            .where('itemId', '==', item.id)
            .get();

          const commentCount = commentsSnapshot.size;

          return {
            ...item,
            averageRating: parseFloat(averageRating),
            totalRatings: ratingCount,
            commentCount: commentCount
          };
        })
      );
    } else {
      itemsWithStats = paginatedItems;
    }

    const totalPages = Math.ceil(allItems.length / limitNum);
    const hasMore = pageNum < totalPages;

    console.log(`ðŸ“‹ [LISTS] Lista ${listId}: pÃ¡gina ${pageNum} de ${totalPages} (${paginatedItems.length}/${allItems.length} items)`);

    res.json({
      success: true,
      message: 'Lista obtenida exitosamente',
      data: {
        id: listDoc.id,
        title: listData.title,
        description: listData.description,
        imageUrl: listData.imageUrl || null,
        isPublic: listData.isPublic,
        creatorId: listData.creatorId,
        isOwner: listData.creatorId === uid,
        items: itemsWithStats,
        completedItems: listData.completedItems || 0,
        totalItems: listData.totalItems || 0,
        stars: listData.stars || 0,
        comments: listData.comments || 0,
        hasStarred: hasStarred,
        isCreator: listData.creatorId === uid,
        createdAt: listData.createdAt,
        updatedAt: listData.updatedAt
      },
      pagination: {
        currentPage: pageNum,
        totalPages: totalPages,
        itemsPerPage: limitNum,
        totalItems: allItems.length,
        hasMore: hasMore
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error obteniendo lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo lista',
      error: error.message
    });
  }
});

// Endpoint para copiar una lista pÃºblica
app.post('/api/lists/:listId/copy', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la lista original
    const originalListDoc = await db.collection('lists').doc(listId).get();
    if (!originalListDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const originalData = originalListDoc.data();
    
    // Verificar que la lista sea pÃºblica
    if (!originalData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden copiar listas pÃºblicas'
      });
    }

    // Crear la copia
    const copiedListData = {
      title: `${originalData.title} (Copia)`,
      description: originalData.description,
      imageUrl: originalData.imageUrl, // Copiar imagen de la lista original
      isPublic: false, // La copia es privada por defecto
      creatorId: uid,
      originalListId: listId, // Referencia a la lista original
      items: originalData.items.map(item => ({
        ...item,
        id: `item_${Date.now()}_${Math.random()}`,
        completed: false, // Resetear estado de completado
        createdAt: new Date()
      })),
      completedItems: 0,
      totalItems: originalData.items.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const copiedListRef = await db.collection('lists').add(copiedListData);
    
    console.log('âœ… [LISTS] Lista copiada exitosamente:', copiedListRef.id);

    res.json({
      success: true,
      message: 'Lista copiada exitosamente',
      data: {
        id: copiedListRef.id,
        ...copiedListData
      }
    });

  } catch (error) {
    console.error('âŒ [LISTS] Error copiando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error copiando lista',
      error: error.message
    });
  }
});

// ===== SISTEMA DE PUBLICACIONES EN COMUNIDADES =====

// Endpoint para crear una publicaciÃ³n en una comunidad (recibe URL de imagen)
app.post('/api/communities/:communityId/posts', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;
    const { content, imageUrl, attachedLists = [], postType = 'normal', eventData } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para publicar'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido de la publicaciÃ³n es obligatorio'
      });
    }

    // Validar que la URL de imagen sea vÃ¡lida si se proporciona
    if (imageUrl && !imageUrl.startsWith('http')) {
      return res.status(400).json({
        success: false,
        message: 'La URL de la imagen debe ser vÃ¡lida'
      });
    }

    // NUEVO: Validar datos de evento si postType es "event"
    let validatedEventData = null;
    if (postType === 'event') {
      if (!eventData) {
        return res.status(400).json({
          success: false,
          message: 'Los datos del evento son requeridos para posts tipo evento'
        });
      }

      // Validar campos requeridos del evento
      if (!eventData.title || eventData.title.trim().length === 0) {
        return res.status(400).json({
          success: false,
          message: 'El tÃ­tulo del evento es obligatorio'
        });
      }

      if (!eventData.eventDate) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento es obligatoria'
        });
      }

      // Validar que la fecha del evento sea futura
      const eventDate = new Date(eventData.eventDate);
      if (isNaN(eventDate.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento no es vÃ¡lida'
        });
      }

      if (eventDate < new Date()) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento debe ser futura'
        });
      }

      // Validar eventEndDate si existe
      let eventEndDate = null;
      if (eventData.eventEndDate) {
        eventEndDate = new Date(eventData.eventEndDate);
        if (isNaN(eventEndDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de finalizaciÃ³n del evento no es vÃ¡lida'
          });
        }
        if (eventEndDate < eventDate) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de finalizaciÃ³n debe ser posterior a la fecha de inicio'
          });
        }
      }

      // Validar maxAttendees si existe
      if (eventData.maxAttendees !== undefined && eventData.maxAttendees !== null) {
        const maxAttendees = parseInt(eventData.maxAttendees);
        if (isNaN(maxAttendees) || maxAttendees < 1) {
          return res.status(400).json({
            success: false,
            message: 'El nÃºmero mÃ¡ximo de asistentes debe ser mayor a 0'
          });
        }
      }

      // Construir objeto eventData validado
      validatedEventData = {
        title: eventData.title.trim(),
        description: eventData.description ? eventData.description.trim() : '',
        eventDate: admin.firestore.Timestamp.fromDate(eventDate),
        status: 'upcoming',
        attendees: [],
        attendeeCount: 0,
        waitlist: [],  // NUEVO: Lista de espera
        waitlistCount: 0,  // NUEVO: Contador de lista de espera
        checkedInAttendees: [],  // NUEVO: Asistentes que hicieron check-in
        checkedInCount: 0,  // NUEVO: Contador de check-ins
        requiresConfirmation: eventData.requiresConfirmation === true,
        reminderSent: false,
        reminderSentAt: null
      };

      // Agregar campos opcionales
      if (eventEndDate) {
        validatedEventData.eventEndDate = admin.firestore.Timestamp.fromDate(eventEndDate);
      }

      if (eventData.maxAttendees !== undefined && eventData.maxAttendees !== null) {
        validatedEventData.maxAttendees = parseInt(eventData.maxAttendees);
      }

      if (eventData.location) {
        validatedEventData.location = {
          name: eventData.location.name || '',
          address: eventData.location.address || '',
          latitude: eventData.location.latitude || null,
          longitude: eventData.location.longitude || null
        };
      }

      if (validatedEventData.requiresConfirmation) {
        validatedEventData.pendingAttendees = [];
      }

      console.log('âœ… [EVENT] Datos del evento validados:', validatedEventData.title);
    }

    // Validar y verificar que las listas existen y pertenecen al usuario o son pÃºblicas
    const validatedLists = [];
    if (attachedLists && Array.isArray(attachedLists) && attachedLists.length > 0) {
      console.log(`ðŸ“‹ [POST] Validando ${attachedLists.length} listas adjuntas`);
      
      for (const listId of attachedLists) {
        try {
          const listDoc = await db.collection('lists').doc(listId).get();
          
          if (!listDoc.exists) {
            console.warn(`âš ï¸ [POST] Lista no encontrada: ${listId}`);
            continue;
          }

          const listData = listDoc.data();
          
          // Verificar que la lista sea del usuario o sea pÃºblica
          if (listData.creatorId === uid || listData.isPublic) {
            validatedLists.push({
              id: listId,
              title: listData.title,
              description: listData.description || '',
              imageUrl: listData.imageUrl || null,
              isPublic: listData.isPublic,
              totalItems: listData.totalItems || 0,
              completedItems: listData.completedItems || 0
            });
            console.log(`âœ… [POST] Lista validada: ${listData.title}`);
          } else {
            console.warn(`âš ï¸ [POST] Lista ${listId} no es del usuario ni es pÃºblica`);
          }
        } catch (error) {
          console.error(`âŒ [POST] Error validando lista ${listId}:`, error.message);
        }
      }
    }

    // Crear la publicaciÃ³n
    const postData = {
      communityId: communityId,
      authorId: uid,
      content: content.trim(),
      postType: postType,  // "normal" o "event"
      isPinned: false,
      likes: [],
      likeCount: 0,
      commentCount: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Solo agregar imageUrl si existe y no es undefined
    if (imageUrl) {
      postData.imageUrl = imageUrl;
    }

    // Agregar datos del evento si es tipo "event"
    if (postType === 'event' && validatedEventData) {
      postData.eventData = validatedEventData;
      console.log(`ðŸ“… [EVENT] Creando evento: ${validatedEventData.title}`);
    }

    // Agregar listas adjuntas si hay
    if (validatedLists.length > 0) {
      postData.attachedLists = validatedLists;
      console.log(`ðŸ“‹ [POST] ${validatedLists.length} listas adjuntadas al post`);
    }

    const postRef = await db.collection('posts').add(postData);
    
    if (postType === 'event') {
      console.log('âœ… [EVENT] Evento creado exitosamente:', postRef.id);
    } else {
      console.log('âœ… [POST] PublicaciÃ³n creada exitosamente:', postRef.id);
    }

    // Enviar notificaciones push a todos los miembros de la comunidad (excepto al autor)
    try {
      const authorDoc = await db.collection('users').doc(uid).get();
      const authorData = authorDoc.exists ? authorDoc.data() : {};
      const authorName = authorData.displayName || authorData.name || 'Un miembro';
      const communityName = communityData.name || 'la comunidad';

      // Obtener tokens de todos los miembros excepto el autor
      const membersToNotify = communityData.members.filter(memberId => memberId !== uid);
      
      if (membersToNotify.length > 0) {
        console.log(`ðŸ“¤ [COMMUNITY] Enviando notificaciÃ³n de nueva publicaciÃ³n a ${membersToNotify.length} miembros`);
        
        const tokensPromises = membersToNotify.map(async (memberId) => {
          try {
            const memberDoc = await db.collection('users').doc(memberId).get();
            if (memberDoc.exists) {
              const memberData = memberDoc.data();
              return { userId: memberId, tokens: memberData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`âš ï¸ [COMMUNITY] Error obteniendo tokens del miembro ${memberId}:`, error.message);
          }
          return { userId: memberId, tokens: [] };
        });
        
        const usersWithTokens = await Promise.all(tokensPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);
        
        if (allTokens.length > 0) {
          const isEvent = postType === 'event';
          const notification = {
            title: isEvent 
              ? `ðŸ“… ${authorName} creÃ³ un evento en ${communityName}`
              : `ðŸ“¢ ${authorName} publicÃ³ en ${communityName}`,
            body: isEvent && validatedEventData
              ? validatedEventData.title
              : (content.trim().length > 100 ? content.trim().substring(0, 100) + '...' : content.trim())
          };

          const notificationData = {
            type: isEvent ? 'community_event' : 'community_post',
            postId: postRef.id,
            communityId: communityId,
            communityName: communityName,
            authorId: uid,
            authorName: authorName,
            screen: 'CommunityPostScreen'
          };

          const pushResult = await sendPushNotification(allTokens, notification, notificationData);
          console.log(`âœ… [COMMUNITY] Notificaciones enviadas: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

          // Guardar notificaciones en Firestore para cada usuario
          const batch = db.batch();
          usersWithTokens.forEach(userWithTokens => {
            if (userWithTokens.tokens.length > 0) {
              const notifRef = db.collection('notifications').doc();
              batch.set(notifRef, {
                userId: userWithTokens.userId,
                type: isEvent ? 'community_event' : 'community_post',
                title: notification.title,
                body: notification.body,
                data: notificationData,
                read: false,
                createdAt: admin.firestore.Timestamp.fromDate(new Date())
              });
            }
          });
          await batch.commit();
          console.log(`âœ… [COMMUNITY] ${membersToNotify.length} notificaciones guardadas en Firestore`);
        } else {
          console.log('âš ï¸ [COMMUNITY] NingÃºn miembro tiene tokens FCM registrados');
        }
      }
    } catch (notificationError) {
      console.error('âŒ [COMMUNITY] Error enviando notificaciones de nueva publicaciÃ³n:', notificationError);
      // No fallar la creaciÃ³n de la publicaciÃ³n si falla la notificaciÃ³n
    }

    res.json({
      success: true,
      message: postType === 'event' ? 'Evento creado exitosamente' : 'PublicaciÃ³n creada exitosamente',
      data: {
        id: postRef.id,
        ...postData
      }
    });

  } catch (error) {
    console.error('âŒ [POST] Error creando publicaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando publicaciÃ³n',
      error: error.message
    });
  }
});

// ===== ENDPOINTS PARA EVENTOS =====

// Confirmar asistencia a un evento
app.post('/api/posts/:postId/attend', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para asistir al evento'
      });
    }

    const eventData = postData.eventData;

    // Verificar que el evento no estÃ¡ cancelado
    if (eventData.status === 'cancelled') {
      return res.status(400).json({
        success: false,
        message: 'Este evento ha sido cancelado'
      });
    }

    // Verificar que el evento no ha pasado
    const eventDate = eventData.eventDate.toDate();
    if (eventDate < new Date()) {
      return res.status(400).json({
        success: false,
        message: 'Este evento ya pasÃ³'
      });
    }

    // Verificar que el usuario no estÃ© ya en la lista
    const attendees = eventData.attendees || [];
    if (attendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya confirmaste tu asistencia a este evento'
      });
    }

    // Verificar si hay cupo disponible
    const isEventFull = eventData.maxAttendees && attendees.length >= eventData.maxAttendees;
    
    if (isEventFull) {
      // Si el evento estÃ¡ lleno, agregar a lista de espera
      const waitlist = eventData.waitlist || [];
      
      // Verificar que no estÃ© ya en la lista de espera
      if (waitlist.includes(uid)) {
        return res.status(400).json({
          success: false,
          message: 'Ya estÃ¡s en la lista de espera para este evento'
        });
      }

      await db.collection('posts').doc(postId).update({
        'eventData.waitlist': admin.firestore.FieldValue.arrayUnion(uid),
        'eventData.waitlistCount': admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      console.log(`ðŸ“‹ [EVENT] Usuario ${uid} agregado a lista de espera del evento ${postId}`);

      // Notificar al usuario que fue agregado a lista de espera
      try {
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const userTokens = userData.fcmTokens || [];

          if (userTokens.length > 0) {
            const notification = {
              title: `ðŸ“‹ Agregado a lista de espera`,
              body: `Te agregamos a la lista de espera de "${eventData.title}". Te notificaremos si se libera un cupo.`
            };

            const notificationData = {
              type: 'event_waitlist_added',
              postId: postId,
              screen: 'CommunityPostScreen'
            };

            await sendPushNotification(userTokens, notification, notificationData);
          }
        }
      } catch (notificationError) {
        console.error('âŒ [EVENT] Error enviando notificaciÃ³n de lista de espera:', notificationError);
      }

      return res.json({
        success: true,
        message: 'Agregado a lista de espera. Te notificaremos si se libera un cupo.',
        data: {
          postId: postId,
          attendeeCount: attendees.length,
          waitlistCount: waitlist.length + 1,
          userInWaitlist: true,
          userAttending: false
        }
      });
    }

    // Agregar al usuario a la lista de asistentes
    await db.collection('posts').doc(postId).update({
      'eventData.attendees': admin.firestore.FieldValue.arrayUnion(uid),
      'eventData.attendeeCount': admin.firestore.FieldValue.increment(1),
      updatedAt: new Date()
    });

    console.log(`âœ… [EVENT] Usuario ${uid} confirmÃ³ asistencia al evento ${postId}`);

    // ðŸ“§ Enviar email de confirmaciÃ³n al asistente
    try {
      const { sendEventConfirmation } = require('./services/emailService');
      const attendeeDoc = await db.collection('users').doc(uid).get();
      const attendeeData = attendeeDoc.exists ? attendeeDoc.data() : {};
      
      if (attendeeData && attendeeData.email) {
        console.log(`ðŸ“§ [EMAIL] Enviando confirmaciÃ³n de evento a ${attendeeData.email}`);
        sendEventConfirmation(
          attendeeData.displayName || attendeeData.name || 'MamÃ¡',
          attendeeData.email,
          {
            id: postId,
            title: eventData.title,
            description: postData.content,
            eventDate: eventData.eventDate,
            location: eventData.location || { name: 'Por definir', address: '' },
            checkInCode: eventData.checkInCode || null
          }
        ).catch(err => console.error('âŒ [EMAIL] Error enviando confirmaciÃ³n:', err));
      }
    } catch (emailError) {
      console.error('âŒ [EMAIL] Error al enviar confirmaciÃ³n de evento:', emailError);
      // No fallar la request si el email falla
    }

    // Enviar notificaciÃ³n al organizador
    try {
      const organizerDoc = await db.collection('users').doc(postData.authorId).get();
      if (organizerDoc.exists) {
        const organizerData = organizerDoc.data();
        const organizerTokens = organizerData.fcmTokens || [];

        if (organizerTokens.length > 0) {
          const attendeeDoc = await db.collection('users').doc(uid).get();
          const attendeeData = attendeeDoc.exists ? attendeeDoc.data() : {};
          const attendeeName = attendeeData.displayName || attendeeData.name || 'Un usuario';

          const notification = {
            title: `ðŸ“… Nueva confirmaciÃ³n para tu evento`,
            body: `${attendeeName} confirmÃ³ asistencia a "${eventData.title}"`
          };

          const notificationData = {
            type: 'event_attendance_confirmed',
            postId: postId,
            attendeeId: uid,
            screen: 'CommunityPostScreen'
          };

          await sendPushNotification(organizerTokens, notification, notificationData);
          console.log(`âœ… [EVENT] NotificaciÃ³n enviada al organizador`);
        }
      }
    } catch (notificationError) {
      console.error('âŒ [EVENT] Error enviando notificaciÃ³n al organizador:', notificationError);
    }

    res.json({
      success: true,
      message: 'Asistencia confirmada exitosamente',
      data: {
        postId: postId,
        attendeeCount: attendees.length + 1,
        userAttending: true
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error confirmando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error confirmando asistencia',
      error: error.message
    });
  }
});

// Cancelar asistencia a un evento
app.delete('/api/posts/:postId/attend', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    const eventData = postData.eventData;
    const attendees = eventData.attendees || [];

    // Verificar que el usuario estÃ¡ en la lista
    if (!attendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No has confirmado asistencia a este evento'
      });
    }

    // Remover al usuario de la lista de asistentes
    await db.collection('posts').doc(postId).update({
      'eventData.attendees': admin.firestore.FieldValue.arrayRemove(uid),
      'eventData.attendeeCount': admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log(`âœ… [EVENT] Usuario ${uid} cancelÃ³ asistencia al evento ${postId}`);

    // Promover al primero de la lista de espera si hay cupo y hay gente esperando
    try {
      const waitlist = eventData.waitlist || [];
      if (waitlist.length > 0) {
        const nextUserId = waitlist[0];
        
        // Obtener el documento actualizado
        const updatedPostDoc = await db.collection('posts').doc(postId).get();
        const updatedEventData = updatedPostDoc.data().eventData;
        const currentAttendees = updatedEventData.attendees || [];
        
        // Verificar que hay cupo disponible
        if (!updatedEventData.maxAttendees || currentAttendees.length < updatedEventData.maxAttendees) {
          // Mover de lista de espera a asistentes
          await db.collection('posts').doc(postId).update({
            'eventData.waitlist': admin.firestore.FieldValue.arrayRemove(nextUserId),
            'eventData.waitlistCount': admin.firestore.FieldValue.increment(-1),
            'eventData.attendees': admin.firestore.FieldValue.arrayUnion(nextUserId),
            'eventData.attendeeCount': admin.firestore.FieldValue.increment(1)
          });

          console.log(`âœ… [EVENT] Usuario ${nextUserId} promovido de lista de espera a asistente`);

          // Notificar al usuario promovido
          const nextUserDoc = await db.collection('users').doc(nextUserId).get();
          if (nextUserDoc.exists) {
            const nextUserData = nextUserDoc.data();
            const nextUserTokens = nextUserData.fcmTokens || [];

            if (nextUserTokens.length > 0) {
              const notification = {
                title: `ðŸŽ‰ Â¡Tienes un cupo disponible!`,
                body: `Se liberÃ³ un cupo para "${eventData.title}". Â¡Ya estÃ¡s confirmado!`
              };

              const notificationData = {
                type: 'event_waitlist_promoted',
                postId: postId,
                screen: 'CommunityPostScreen'
              };

              await sendPushNotification(nextUserTokens, notification, notificationData);
              console.log(`âœ… [EVENT] NotificaciÃ³n de promociÃ³n enviada a ${nextUserId}`);
            }
          }
        }
      }
    } catch (waitlistError) {
      console.error('âŒ [EVENT] Error procesando lista de espera:', waitlistError);
      // No fallar la cancelaciÃ³n si falla la promociÃ³n de lista de espera
    }

    res.json({
      success: true,
      message: 'Asistencia cancelada exitosamente',
      data: {
        postId: postId,
        attendeeCount: attendees.length - 1,
        userAttending: false
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error cancelando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando asistencia',
      error: error.message
    });
  }
});

// Generar cÃ³digo QR para check-in del evento (solo organizador)
app.get('/api/posts/:postId/qr-code', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Verificar que el usuario es el organizador
    if (postData.authorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el organizador puede generar el cÃ³digo QR del evento'
      });
    }

    const eventData = postData.eventData;

    // Generar o recuperar el cÃ³digo Ãºnico del evento
    let checkInCode = eventData.checkInCode;
    if (!checkInCode) {
      // Generar un cÃ³digo Ãºnico de 8 caracteres
      checkInCode = Math.random().toString(36).substring(2, 10).toUpperCase();
      
      // Guardar el cÃ³digo en el evento
      await db.collection('posts').doc(postId).update({
        'eventData.checkInCode': checkInCode,
        updatedAt: new Date()
      });

      console.log(`âœ… [EVENT] CÃ³digo de check-in generado para evento ${postId}: ${checkInCode}`);
    }

    // Crear la URL de check-in
    const checkInUrl = `https://mumpa.app/event/${postId}/checkin?code=${checkInCode}`;

    res.json({
      success: true,
      data: {
        postId: postId,
        eventTitle: eventData.title,
        checkInCode: checkInCode,
        checkInUrl: checkInUrl,
        // El frontend puede usar esta URL para generar el QR
        qrData: checkInUrl
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error generando cÃ³digo QR:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando cÃ³digo QR',
      error: error.message
    });
  }
});

// Hacer check-in en el evento (escanear QR o ingresar cÃ³digo)
app.post('/api/posts/:postId/checkin', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { code } = req.body;

    if (!code) {
      return res.status(400).json({
        success: false,
        message: 'El cÃ³digo de check-in es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    const eventData = postData.eventData;

    // Verificar que el usuario estÃ¡ en la lista de asistentes
    const attendees = eventData.attendees || [];
    if (!attendees.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes confirmar tu asistencia antes de hacer check-in'
      });
    }

    // Verificar el cÃ³digo
    if (eventData.checkInCode !== code.toUpperCase()) {
      return res.status(400).json({
        success: false,
        message: 'CÃ³digo de check-in invÃ¡lido'
      });
    }

    // Verificar si ya hizo check-in
    const checkedInAttendees = eventData.checkedInAttendees || [];
    if (checkedInAttendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya hiciste check-in en este evento'
      });
    }

    // Registrar check-in
    await db.collection('posts').doc(postId).update({
      'eventData.checkedInAttendees': admin.firestore.FieldValue.arrayUnion(uid),
      'eventData.checkedInCount': admin.firestore.FieldValue.increment(1),
      [`eventData.checkInTimes.${uid}`]: new Date(),
      updatedAt: new Date()
    });

    console.log(`âœ… [EVENT] Usuario ${uid} hizo check-in en evento ${postId}`);

    // Notificar al organizador
    try {
      if (postData.authorId !== uid) {
        const organizerDoc = await db.collection('users').doc(postData.authorId).get();
        if (organizerDoc.exists) {
          const organizerData = organizerDoc.data();
          const organizerTokens = organizerData.fcmTokens || [];

          if (organizerTokens.length > 0) {
            const userDoc = await db.collection('users').doc(uid).get();
            const userData = userDoc.exists ? userDoc.data() : {};
            const userName = userData.displayName || userData.name || 'Un usuario';

            const notification = {
              title: `âœ… Check-in registrado`,
              body: `${userName} hizo check-in en "${eventData.title}"`
            };

            const notificationData = {
              type: 'event_checkin',
              postId: postId,
              attendeeId: uid,
              screen: 'CommunityPostScreen'
            };

            await sendPushNotification(organizerTokens, notification, notificationData);
          }
        }
      }
    } catch (notificationError) {
      console.error('âŒ [EVENT] Error enviando notificaciÃ³n de check-in:', notificationError);
    }

    res.json({
      success: true,
      message: 'Check-in realizado exitosamente',
      data: {
        postId: postId,
        checkedInCount: checkedInAttendees.length + 1,
        userCheckedIn: true,
        checkInTime: new Date()
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error haciendo check-in:', error);
    res.status(500).json({
      success: false,
      message: 'Error haciendo check-in',
      error: error.message
    });
  }
});

// Exportar evento a Google Calendar (.ics)
app.get('/api/posts/:postId/calendar', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para exportar el evento'
      });
    }

    const eventData = postData.eventData;

    // Convertir fecha de Firestore a formato de fecha
    const eventDate = eventData.eventDate.toDate();
    const eventEndDate = eventData.eventEndDate 
      ? eventData.eventEndDate.toDate() 
      : new Date(eventDate.getTime() + 2 * 60 * 60 * 1000); // +2 horas por defecto

    // FunciÃ³n auxiliar para formatear fecha en formato iCalendar
    const formatICalDate = (date) => {
      return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    };

    // Construir ubicaciÃ³n
    let locationText = '';
    if (eventData.location) {
      const parts = [];
      if (eventData.location.name) parts.push(eventData.location.name);
      if (eventData.location.address) parts.push(eventData.location.address);
      locationText = parts.join(', ');
    }

    // Construir descripciÃ³n
    let description = postData.content || '';
    if (eventData.description) {
      description += '\\n\\n' + eventData.description;
    }
    if (eventData.maxAttendees) {
      description += `\\n\\nCupo limitado: ${eventData.maxAttendees} personas`;
    }

    // Generar archivo .ics
    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Munpa//Event Calendar//ES
CALSCALE:GREGORIAN
METHOD:PUBLISH
BEGIN:VEVENT
UID:munpa-event-${postId}@munpa.app
DTSTAMP:${formatICalDate(new Date())}
DTSTART:${formatICalDate(eventDate)}
DTEND:${formatICalDate(eventEndDate)}
SUMMARY:${eventData.title}
DESCRIPTION:${description.replace(/\n/g, '\\n')}
LOCATION:${locationText}
STATUS:CONFIRMED
SEQUENCE:0
BEGIN:VALARM
TRIGGER:-PT24H
ACTION:DISPLAY
DESCRIPTION:Recordatorio: ${eventData.title} maÃ±ana
END:VALARM
END:VEVENT
END:VCALENDAR`;

    // Enviar como archivo descargable
    res.setHeader('Content-Type', 'text/calendar; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="evento-${postId}.ics"`);
    res.send(icsContent);

    console.log(`âœ… [EVENT] Archivo .ics generado para evento ${postId}`);

  } catch (error) {
    console.error('âŒ [EVENT] Error generando archivo de calendario:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando archivo de calendario',
      error: error.message
    });
  }
});

// Obtener enlace para agregar a Google Calendar
app.get('/api/posts/:postId/calendar/google', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    const eventData = postData.eventData;

    // Convertir fecha de Firestore a formato de fecha
    const eventDate = eventData.eventDate.toDate();
    const eventEndDate = eventData.eventEndDate 
      ? eventData.eventEndDate.toDate() 
      : new Date(eventDate.getTime() + 2 * 60 * 60 * 1000);

    // Formatear fechas para Google Calendar (YYYYMMDDTHHmmssZ)
    const formatGoogleDate = (date) => {
      return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    };

    // Construir ubicaciÃ³n
    let location = '';
    if (eventData.location) {
      const parts = [];
      if (eventData.location.name) parts.push(eventData.location.name);
      if (eventData.location.address) parts.push(eventData.location.address);
      location = parts.join(', ');
    }

    // Construir descripciÃ³n
    let details = postData.content || '';
    if (eventData.description) {
      details += '\n\n' + eventData.description;
    }

    // Crear URL de Google Calendar
    const googleCalendarUrl = new URL('https://calendar.google.com/calendar/render');
    googleCalendarUrl.searchParams.append('action', 'TEMPLATE');
    googleCalendarUrl.searchParams.append('text', eventData.title);
    googleCalendarUrl.searchParams.append('dates', `${formatGoogleDate(eventDate)}/${formatGoogleDate(eventEndDate)}`);
    googleCalendarUrl.searchParams.append('details', details);
    googleCalendarUrl.searchParams.append('location', location);
    googleCalendarUrl.searchParams.append('sf', 'true');
    googleCalendarUrl.searchParams.append('output', 'xml');

    res.json({
      success: true,
      data: {
        googleCalendarUrl: googleCalendarUrl.toString(),
        eventTitle: eventData.title,
        eventDate: eventDate,
        eventEndDate: eventEndDate
      }
    });

    console.log(`âœ… [EVENT] URL de Google Calendar generada para evento ${postId}`);

  } catch (error) {
    console.error('âŒ [EVENT] Error generando URL de Google Calendar:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando URL de Google Calendar',
      error: error.message
    });
  }
});

// Obtener banners activos (banners normales + eventos marcados como banner)
app.get('/api/banners', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { section } = req.query; // 'home', 'communities', 'marketplace', etc.

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    let allBanners = [];

    // 1. OBTENER BANNERS NORMALES (de la colecciÃ³n banners)
    try {
      let bannersQuery = db.collection('banners')
        .where('isActive', '==', true);
      
      // Filtrar por secciÃ³n si se especifica
      if (section) {
        bannersQuery = bannersQuery.where('section', '==', section);
      }

      const bannersSnapshot = await bannersQuery.get();

      for (const doc of bannersSnapshot.docs) {
        const banner = doc.data();
        
        // Verificar fechas de programaciÃ³n
        const startDate = banner.startDate ? banner.startDate.toDate() : null;
        const endDate = banner.endDate ? banner.endDate.toDate() : null;
        
        // Solo mostrar si estÃ¡ dentro del rango de fechas
        const isInDateRange = (!startDate || startDate <= now) && (!endDate || endDate >= now);
        
        if (isInDateRange) {
          allBanners.push({
            id: doc.id,
            ...banner, // â¬…ï¸ INCLUIR TODOS LOS CAMPOS DEL BANNER
            type: 'banner', // Tipo de banner
            isEvent: false, // Indica que NO es un evento
            
            // Asegurar que estos campos existan (por compatibilidad)
            order: banner.order || 999,
            duration: banner.duration || 5,
            section: banner.section || 'home',
            views: banner.views || 0,
            clicks: banner.clicks || 0
          });
        }
      }
    } catch (error) {
      console.warn('âš ï¸ [BANNER] Error obteniendo banners normales:', error.message);
    }

    // 2. OBTENER EVENTOS MARCADOS COMO BANNER
    try {
      // Obtener comunidades del usuario
      const communitiesSnapshot = await db.collection('communities')
        .where('members', 'array-contains', uid)
        .get();

      const userCommunityIds = communitiesSnapshot.docs.map(doc => doc.id);

      if (userCommunityIds.length > 0) {
        // Firestore no permite "in" con mÃ¡s de 10 elementos
        const chunkSize = 10;
        for (let i = 0; i < userCommunityIds.length; i += chunkSize) {
          const chunk = userCommunityIds.slice(i, i + chunkSize);
          
          const eventsSnapshot = await db.collection('posts')
            .where('postType', '==', 'event')
            .where('communityId', 'in', chunk)
            .where('eventData.isBanner', '==', true)
            .get();

          for (const doc of eventsSnapshot.docs) {
            const eventPost = doc.data();
            
            if (!eventPost.eventData) continue;
            
            const eventDate = eventPost.eventData.eventDate.toDate();
            const isCancelled = eventPost.eventData.status === 'cancelled';
            
            // Verificar visibilidad del evento
            const eventSection = eventPost.eventData.bannerSection || 'home';
            const publishedAt = eventPost.eventData.bannerPublishedAt 
              ? eventPost.eventData.bannerPublishedAt.toDate() 
              : eventPost.createdAt.toDate();
            
            // Filtrar por secciÃ³n si se especifica
            if (section && eventSection !== section) continue;
            
            // Mostrar desde que se publica hasta la hora del evento
            const shouldShow = publishedAt <= now && eventDate >= now && !isCancelled;
            
            if (shouldShow) {
              // Obtener nombre de comunidad
              let communityName = 'Comunidad';
              try {
                const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
                if (communityDoc.exists) {
                  communityName = communityDoc.data().name || 'Comunidad';
                }
              } catch (error) {
                console.warn(`âš ï¸ [BANNER] Error obteniendo comunidad:`, error.message);
              }

              // Obtener nombre del autor
              let authorName = 'Usuario';
              try {
                const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
                if (authorDoc.exists) {
                  authorName = authorDoc.data().displayName || 'Usuario';
                }
              } catch (error) {
                console.warn(`âš ï¸ [BANNER] Error obteniendo autor:`, error.message);
              }

              allBanners.push({
                id: doc.id,
                type: 'event', // â¬…ï¸ NUEVO: tipo de banner
                isEvent: true,  // â¬…ï¸ NUEVO: indica que ES un evento
                
                title: eventPost.eventData.title,
                description: eventPost.eventData.description || '',
                imageUrl: eventPost.imageUrl || null,
                link: `/communities/${eventPost.communityId}/events/${doc.id}`, // Link al evento
                
                // Datos especÃ­ficos del evento
                eventDate: eventPost.eventData.eventDate,
                eventEndDate: eventPost.eventData.eventEndDate || null,
                location: eventPost.eventData.location || null,
                communityId: eventPost.communityId,
                communityName,
                authorId: eventPost.authorId,
                authorName,
                attendeeCount: eventPost.eventData.attendeeCount || 0,
                maxAttendees: eventPost.eventData.maxAttendees || null,
                isUserAttending: (eventPost.eventData.attendees || []).includes(uid),
                
                // ConfiguraciÃ³n del banner
                order: eventPost.eventData.bannerOrder || 1,
                duration: eventPost.eventData.bannerDuration || 5,
                section: eventSection,
                
                startDate: eventPost.eventData.bannerPublishedAt || eventPost.createdAt,
                endDate: eventPost.eventData.eventDate, // El evento es el lÃ­mite
                
                likeCount: eventPost.likeCount || 0,
                commentCount: eventPost.commentCount || 0,
                createdAt: eventPost.createdAt,
                bannerUpdatedAt: eventPost.eventData.bannerUpdatedAt || null
              });
            }
          }
        }
      }
    } catch (error) {
      console.warn('âš ï¸ [BANNER] Error obteniendo eventos banner:', error.message);
    }

    // 3. ORDENAR TODOS LOS BANNERS
    allBanners.sort((a, b) => {
      // Primero por orden
      if (a.order !== b.order) {
        return a.order - b.order;
      }
      
      // Si tienen el mismo orden, eventos van antes (por fecha)
      if (a.isEvent && !b.isEvent) {
        return -1;
      }
      if (!a.isEvent && b.isEvent) {
        return 1;
      }
      
      // Si ambos son eventos, ordenar por fecha del evento (mÃ¡s prÃ³ximo primero)
      if (a.isEvent && b.isEvent) {
        const dateA = a.eventDate.toDate();
        const dateB = b.eventDate.toDate();
        return dateA - dateB;
      }
      
      // Si ambos son banners normales, mantener orden actual
      return 0;
    });

    console.log(`âœ… [BANNER] ${allBanners.length} banners encontrados para usuario ${uid}${section ? ` (secciÃ³n: ${section})` : ''}`);
    console.log(`   - Banners normales: ${allBanners.filter(b => !b.isEvent).length}`);
    console.log(`   - Eventos: ${allBanners.filter(b => b.isEvent).length}`);

    res.json({
      success: true,
      data: allBanners
    });

  } catch (error) {
    console.error('âŒ [BANNER] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// Salir de la lista de espera
app.delete('/api/posts/:postId/waitlist', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    const eventData = postData.eventData;
    const waitlist = eventData.waitlist || [];

    // Verificar que el usuario estÃ¡ en la lista de espera
    if (!waitlist.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No estÃ¡s en la lista de espera de este evento'
      });
    }

    // Remover de lista de espera
    await db.collection('posts').doc(postId).update({
      'eventData.waitlist': admin.firestore.FieldValue.arrayRemove(uid),
      'eventData.waitlistCount': admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log(`âœ… [EVENT] Usuario ${uid} saliÃ³ de la lista de espera del evento ${postId}`);

    res.json({
      success: true,
      message: 'Saliste de la lista de espera exitosamente',
      data: {
        postId: postId,
        waitlistCount: waitlist.length - 1,
        userInWaitlist: false
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error saliendo de lista de espera:', error);
    res.status(500).json({
      success: false,
      message: 'Error saliendo de lista de espera',
      error: error.message
    });
  }
});

// ============== ELIMINAR POST/EVENTO (Usuario debe ser el autor) ==============
app.delete('/api/posts/:postId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    console.log(`ðŸ—‘ï¸ [POST] Usuario ${uid} intenta eliminar post ${postId}`);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que el usuario es el autor del post
    if (postData.authorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar esta publicaciÃ³n'
      });
    }

    // Eliminar el post
    await db.collection('posts').doc(postId).delete();

    console.log(`âœ… [POST] Post ${postId} eliminado exitosamente por ${uid}`);

    // Decrementar el contador de posts de la comunidad (si tiene communityId)
    if (postData.communityId) {
      try {
        await db.collection('communities').doc(postData.communityId).update({
          postCount: admin.firestore.FieldValue.increment(-1),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        console.log(`âœ… [POST] Contador de posts de comunidad ${postData.communityId} actualizado`);
      } catch (communityError) {
        console.error('âš ï¸ [POST] Error actualizando contador de comunidad:', communityError.message);
        // No fallar la peticiÃ³n si esto falla
      }
    }

    res.json({
      success: true,
      message: 'PublicaciÃ³n eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [POST] Error eliminando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando publicaciÃ³n',
      error: error.message
    });
  }
});

// Obtener lista de asistentes de un evento
app.get('/api/posts/:postId/attendees', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver los asistentes'
      });
    }

    const eventData = postData.eventData;
    const attendeeIds = eventData.attendees || [];

    // Obtener informaciÃ³n de los asistentes
    const attendees = [];
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const attendeeData = attendeeDoc.data();
          attendees.push({
            userId: attendeeId,
            userName: attendeeData.displayName || attendeeData.name || 'Usuario',
            userPhoto: attendeeData.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [EVENT] Error obteniendo datos del asistente ${attendeeId}:`, error.message);
      }
    }

    // Calcular cupos disponibles
    const maxAttendees = eventData.maxAttendees || null;
    const spotsAvailable = maxAttendees ? Math.max(0, maxAttendees - attendees.length) : null;

    res.json({
      success: true,
      data: {
        attendees,
        attendeeCount: attendees.length,
        maxAttendees,
        spotsAvailable,
        eventTitle: eventData.title,
        eventDate: eventData.eventDate,
        eventStatus: eventData.status
      }
    });

  } catch (error) {
    console.error('âŒ [EVENT] Error obteniendo asistentes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo asistentes',
      error: error.message
    });
  }
});

// Obtener solo eventos de una comunidad
app.get('/api/communities/:communityId/events', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;
    const { filter = 'upcoming', page = 1, limit = 10 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver los eventos'
      });
    }

    // Obtener eventos
    let postsSnapshot;
    try {
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .where('postType', '==', 'event')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [EVENTS] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .where('postType', '==', 'event')
        .get();
    }

    let events = [];
    const now = new Date();

    for (const doc of postsSnapshot.docs) {
      const eventPost = doc.data();
      
      if (!eventPost.eventData) continue;

      const eventDate = eventPost.eventData.eventDate.toDate();
      
      // Filtrar segÃºn el parÃ¡metro filter
      if (filter === 'upcoming' && eventDate < now) continue;
      if (filter === 'past' && eventDate >= now) continue;
      if (eventPost.eventData.status === 'cancelled' && filter !== 'all') continue;

      // Obtener datos del autor
      let authorData = { displayName: 'Usuario Desconocido', photoUrl: null };
      try {
        const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
        if (authorDoc.exists) {
          const data = authorDoc.data();
          authorData = {
            displayName: data.displayName || data.name || 'Usuario',
            photoUrl: data.photoUrl || null
          };
        }
      } catch (error) {
        console.warn(`âš ï¸ [EVENTS] Error obteniendo autor ${eventPost.authorId}:`, error.message);
      }

      // Verificar si el usuario estÃ¡ asistiendo
      const attendees = eventPost.eventData.attendees || [];
      const userAttending = attendees.includes(uid);

      events.push({
        id: doc.id,
        postType: eventPost.postType,
        content: eventPost.content,
        imageUrl: eventPost.imageUrl || null,
        eventData: {
          title: eventPost.eventData.title,
          description: eventPost.eventData.description || '',
          eventDate: eventPost.eventData.eventDate,
          eventEndDate: eventPost.eventData.eventEndDate || null,
          location: eventPost.eventData.location || null,
          attendeeCount: eventPost.eventData.attendeeCount || 0,
          maxAttendees: eventPost.eventData.maxAttendees || null,
          status: eventPost.eventData.status
        },
        author: {
          id: eventPost.authorId,
          name: authorData.displayName,
          photo: authorData.photoUrl
        },
        userAttending,
        likes: eventPost.likes || [],
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0,
        createdAt: eventPost.createdAt
      });
    }

    // Ordenar eventos por fecha del evento
    events.sort((a, b) => {
      const dateA = a.eventData.eventDate.toDate();
      const dateB = b.eventData.eventDate.toDate();
      return filter === 'past' ? dateB - dateA : dateA - dateB;
    });

    // PaginaciÃ³n
    const total = events.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedEvents = events.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedEvents,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [EVENTS] Error obteniendo eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo eventos',
      error: error.message
    });
  }
});

// Editar post o evento (solo el autor)
app.put('/api/posts/:postId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { content, imageUrl, eventData } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que el usuario es el autor
    if (postData.authorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el autor puede editar esta publicaciÃ³n'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    // Actualizar contenido si se proporciona
    if (content !== undefined) {
      if (!content || content.trim().length === 0) {
        return res.status(400).json({
          success: false,
          message: 'El contenido no puede estar vacÃ­o'
        });
      }
      updateData.content = content.trim();
    }

    // Actualizar imagen si se proporciona
    if (imageUrl !== undefined) {
      if (imageUrl && !imageUrl.startsWith('http')) {
        return res.status(400).json({
          success: false,
          message: 'La URL de la imagen debe ser vÃ¡lida'
        });
      }
      updateData.imageUrl = imageUrl || null;
    }

    // Si es un evento, actualizar datos del evento
    if (postData.postType === 'event' && eventData) {
      const currentEventData = postData.eventData || {};

      // Actualizar tÃ­tulo del evento
      if (eventData.title !== undefined) {
        if (!eventData.title || eventData.title.trim().length === 0) {
          return res.status(400).json({
            success: false,
            message: 'El tÃ­tulo del evento es obligatorio'
          });
        }
        updateData['eventData.title'] = eventData.title.trim();
      }

      // Actualizar descripciÃ³n
      if (eventData.description !== undefined) {
        updateData['eventData.description'] = eventData.description.trim();
      }

      // Actualizar fecha del evento
      if (eventData.eventDate !== undefined) {
        const newEventDate = new Date(eventData.eventDate);
        if (isNaN(newEventDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha del evento no es vÃ¡lida'
          });
        }
        if (newEventDate < new Date()) {
          return res.status(400).json({
            success: false,
            message: 'La fecha del evento debe ser futura'
          });
        }
        updateData['eventData.eventDate'] = admin.firestore.Timestamp.fromDate(newEventDate);
        
        // Si se cambiÃ³ la fecha, notificar a los asistentes
        const oldEventDate = currentEventData.eventDate?.toDate();
        if (oldEventDate && oldEventDate.getTime() !== newEventDate.getTime()) {
          updateData['eventData.dateChanged'] = true;
        }
      }

      // Actualizar fecha de finalizaciÃ³n
      if (eventData.eventEndDate !== undefined) {
        if (eventData.eventEndDate) {
          const newEventEndDate = new Date(eventData.eventEndDate);
          if (isNaN(newEventEndDate.getTime())) {
            return res.status(400).json({
              success: false,
              message: 'La fecha de finalizaciÃ³n no es vÃ¡lida'
            });
          }
          updateData['eventData.eventEndDate'] = admin.firestore.Timestamp.fromDate(newEventEndDate);
        } else {
          updateData['eventData.eventEndDate'] = null;
        }
      }

      // Actualizar ubicaciÃ³n
      if (eventData.location !== undefined) {
        updateData['eventData.location'] = {
          name: eventData.location.name || '',
          address: eventData.location.address || '',
          latitude: eventData.location.latitude || null,
          longitude: eventData.location.longitude || null
        };
      }

      // Actualizar mÃ¡ximo de asistentes
      if (eventData.maxAttendees !== undefined) {
        const maxAttendees = eventData.maxAttendees ? parseInt(eventData.maxAttendees) : null;
        if (maxAttendees !== null && (isNaN(maxAttendees) || maxAttendees < 1)) {
          return res.status(400).json({
            success: false,
            message: 'El nÃºmero mÃ¡ximo de asistentes debe ser mayor a 0'
          });
        }
        updateData['eventData.maxAttendees'] = maxAttendees;
      }

      // Actualizar estado del evento
      if (eventData.status !== undefined) {
        const validStatuses = ['upcoming', 'ongoing', 'completed', 'cancelled'];
        if (!validStatuses.includes(eventData.status)) {
          return res.status(400).json({
            success: false,
            message: 'Estado del evento invÃ¡lido'
          });
        }
        updateData['eventData.status'] = eventData.status;

        // Si se cancela, notificar a los asistentes
        if (eventData.status === 'cancelled' && currentEventData.status !== 'cancelled') {
          updateData['eventData.cancelledAt'] = new Date();
          
          // Notificar a los asistentes sobre la cancelaciÃ³n
          try {
            const attendees = currentEventData.attendees || [];
            if (attendees.length > 0) {
              const attendeePromises = attendees.map(async (attendeeId) => {
                try {
                  const attendeeDoc = await db.collection('users').doc(attendeeId).get();
                  if (attendeeDoc.exists) {
                    const attendeeData = attendeeDoc.data();
                    return { userId: attendeeId, tokens: attendeeData.fcmTokens || [] };
                  }
                } catch (error) {
                  console.warn(`âš ï¸ [EVENT] Error obteniendo tokens del asistente ${attendeeId}:`, error.message);
                }
                return { userId: attendeeId, tokens: [] };
              });

              const usersWithTokens = await Promise.all(attendeePromises);
              const allTokens = usersWithTokens.flatMap(u => u.tokens);

              if (allTokens.length > 0) {
                const notification = {
                  title: 'âŒ Evento cancelado',
                  body: `El evento "${currentEventData.title}" ha sido cancelado`
                };

                const notificationData = {
                  type: 'event_cancelled',
                  postId: postId,
                  screen: 'CommunityPostScreen'
                };

                await sendPushNotification(allTokens, notification, notificationData);
                console.log(`âœ… [EVENT] Notificaciones de cancelaciÃ³n enviadas a ${attendees.length} asistentes`);
              }
            }
          } catch (notificationError) {
            console.error('âŒ [EVENT] Error enviando notificaciones de cancelaciÃ³n:', notificationError);
          }
        }
      }

      console.log('âœ… [EVENT] Actualizando evento:', postId);
    }

    // Aplicar actualizaciones
    await db.collection('posts').doc(postId).update(updateData);

    console.log(`âœ… [POST] Post ${postId} actualizado exitosamente`);

    res.json({
      success: true,
      message: postData.postType === 'event' ? 'Evento actualizado exitosamente' : 'PublicaciÃ³n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ [POST] Error actualizando publicaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando publicaciÃ³n',
      error: error.message
    });
  }
});

// Endpoint para obtener publicaciones de una comunidad
app.get('/api/communities/:communityId/posts', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver las publicaciones'
      });
    }

    // Obtener publicaciones ordenadas por fecha
    let postsSnapshot;
    try {
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [POSTS] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .get();
    }

    const posts = [];
    for (const doc of postsSnapshot.docs) {
      const postData = doc.data();
      
      // Obtener informaciÃ³n del autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(postData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (error) {
        console.log('âš ï¸ [POST] Error obteniendo nombre del autor:', error.message);
      }

      posts.push({
        id: doc.id,
        content: postData.content,
        imageUrl: postData.imageUrl,
        authorId: postData.authorId,
        authorName: authorName,
        postType: postData.postType || 'normal',  // NUEVO: tipo de post
        eventData: postData.eventData || null,     // NUEVO: datos del evento si existe
        attachedLists: postData.attachedLists || [], // Listas adjuntas
        isPinned: postData.isPinned || false, // Post fijado
        likes: postData.likes || [],
        likeCount: postData.likeCount || 0,
        commentCount: postData.commentCount || 0,
        isLiked: postData.likes && postData.likes.includes(uid),
        createdAt: postData.createdAt,
        updatedAt: postData.updatedAt
      });
    }

    // Ordenar: posts fijados primero, luego por fecha
    posts.sort((a, b) => {
      // Si uno estÃ¡ pinneado y el otro no, el pinneado va primero
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      
      // Si ambos tienen el mismo estado de pin, ordenar por fecha
      const dateA = a.createdAt?.toDate?.() || a.createdAt;
      const dateB = b.createdAt?.toDate?.() || b.createdAt;
      return dateB - dateA;
    });

    console.log(`ðŸ“Œ [POSTS] ${posts.filter(p => p.isPinned).length} posts fijados de ${posts.length} totales`);

    res.json({
      success: true,
      data: posts
    });

  } catch (error) {
    console.error('âŒ [POST] Error obteniendo publicaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo publicaciones',
      error: error.message
    });
  }
});

// Obtener top 3 posts con mÃ¡s likes (APP)
app.get('/api/communities/posts/top', authenticateToken, async (req, res) => {
  try {
    const cacheKey = buildCacheKey(req);
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const { limit = 3 } = req.query;
    const limitNumber = Math.min(parseInt(limit), 10);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener posts recientes (para evitar escanear todo)
    const snapshot = await db.collection('posts')
      .orderBy('createdAt', 'desc')
      .limit(200)
      .get();

    const communityIds = new Set();
    const posts = [];
    for (const doc of snapshot.docs) {
      const postData = doc.data();
      if (postData.communityId) {
        communityIds.add(postData.communityId);
      }

      // Obtener nombre de autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(postData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (_) {}

      posts.push({
        id: doc.id,
        content: postData.content,
        imageUrl: postData.imageUrl,
        authorId: postData.authorId,
        authorName: authorName,
        communityId: postData.communityId,
        postType: postData.postType || 'normal',  // NUEVO: tipo de post
        eventData: postData.eventData || null,     // NUEVO: datos del evento si existe
        likeCount: postData.likeCount || 0,
        commentCount: postData.commentCount || 0,
        createdAt: postData.createdAt
      });
    }

    const communityMap = new Map();
    if (communityIds.size > 0) {
      const communitySnapshot = await db.collection('communities')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(communityIds).slice(0, 10))
        .get();
      communitySnapshot.forEach(doc => {
        const data = doc.data();
        communityMap.set(doc.id, {
          id: doc.id,
          name: data.name || null
        });
      });
    }

    const topPosts = posts
      .sort((a, b) => {
        if (b.likeCount !== a.likeCount) return b.likeCount - a.likeCount;
        const dateA = a.createdAt?.toDate?.() || a.createdAt;
        const dateB = b.createdAt?.toDate?.() || b.createdAt;
        return dateB - dateA;
      })
      .slice(0, limitNumber)
      .map(post => ({
        ...post,
        communityName: post.communityId ? communityMap.get(post.communityId)?.name || null : null
      }));

    const responsePayload = {
      success: true,
      data: topPosts
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ [POSTS] Error obteniendo top posts:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo top posts',
      error: error.message
    });
  }
});

// Obtener un post/evento especÃ­fico por ID
app.get('/api/posts/:postId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver esta publicaciÃ³n'
      });
    }

    // Obtener informaciÃ³n del autor
    let authorName = 'Usuario';
    let authorPhotoUrl = null;
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
        authorPhotoUrl = authorData.photoUrl || null;
      }
    } catch (error) {
      console.warn('âš ï¸ [POST] Error obteniendo autor:', error.message);
    }

    // Construir respuesta base
    const response = {
      id: postId,
      content: postData.content,
      imageUrl: postData.imageUrl || null,
      authorId: postData.authorId,
      authorName: authorName,
      authorPhotoUrl: authorPhotoUrl,
      communityId: postData.communityId,
      communityName: communityData.name,
      postType: postData.postType || 'normal',
      attachedLists: postData.attachedLists || [],
      isPinned: postData.isPinned || false,
      likes: postData.likes || [],
      likeCount: postData.likeCount || 0,
      commentCount: postData.commentCount || 0,
      isLiked: postData.likes && postData.likes.includes(uid),
      createdAt: postData.createdAt,
      updatedAt: postData.updatedAt
    };

    // Si es un evento, agregar datos del evento
    if (postData.postType === 'event' && postData.eventData) {
      response.eventData = {
        title: postData.eventData.title,
        description: postData.eventData.description || '',
        eventDate: postData.eventData.eventDate,
        eventEndDate: postData.eventData.eventEndDate || null,
        location: postData.eventData.location || null,
        status: postData.eventData.status,
        maxAttendees: postData.eventData.maxAttendees || null,
        requiresConfirmation: postData.eventData.requiresConfirmation || false,
        
        // InformaciÃ³n de asistencia
        attendees: postData.eventData.attendees || [],
        attendeeCount: postData.eventData.attendeeCount || 0,
        waitlist: postData.eventData.waitlist || [],
        waitlistCount: postData.eventData.waitlistCount || 0,
        
        // Check-in
        checkInCode: postData.eventData.checkInCode || null,
        checkedInAttendees: postData.eventData.checkedInAttendees || [],
        checkedInCount: postData.eventData.checkedInCount || 0,
        
        // Estado del usuario
        isUserAttending: (postData.eventData.attendees || []).includes(uid),
        isUserInWaitlist: (postData.eventData.waitlist || []).includes(uid),
        isUserCheckedIn: (postData.eventData.checkedInAttendees || []).includes(uid),
        isUserOrganizer: postData.authorId === uid,
        
        // Banner
        isBanner: postData.eventData.isBanner || false
      };
    }

    console.log(`âœ… [POST] Post ${postId} obtenido por usuario ${uid}`);

    res.json({
      success: true,
      data: response
    });

  } catch (error) {
    console.error('âŒ [POST] Error obteniendo post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo publicaciÃ³n',
      error: error.message
    });
  }
});

// Endpoint para dar like a una publicaciÃ³n
app.post('/api/posts/:postId/like', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    const postData = postDoc.data();
    const isLiked = postData.likes && postData.likes.includes(uid);

    if (isLiked) {
      // Quitar like
      await postRef.update({
        likes: admin.firestore.FieldValue.arrayRemove(uid),
        likeCount: admin.firestore.FieldValue.increment(-1),
        updatedAt: new Date()
      });
      
      console.log('âœ… [POST] Like removido:', uid, postId);
      
      res.json({
        success: true,
        message: 'Like removido',
        data: { liked: false }
      });
    } else {
      // Agregar like
      await postRef.update({
        likes: admin.firestore.FieldValue.arrayUnion(uid),
        likeCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });
      
      console.log('âœ… [POST] Like agregado:', uid, postId);
      
      res.json({
        success: true,
        message: 'Like agregado',
        data: { liked: true }
      });
    }

  } catch (error) {
    console.error('âŒ [POST] Error manejando like:', error);
    res.status(500).json({
      success: false,
      message: 'Error manejando like',
      error: error.message
    });
  }
});

// Endpoint para comentar en una publicaciÃ³n
app.post('/api/posts/:postId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { content } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del comentario es obligatorio'
      });
    }

    // Verificar que la publicaciÃ³n existe
    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'PublicaciÃ³n no encontrada'
      });
    }

    // Crear el comentario
    const commentData = {
      postId: postId,
      authorId: uid,
      content: content.trim(),
      likes: [],
      likeCount: 0,
      createdAt: new Date()
    };

    const commentRef = await db.collection('comments').add(commentData);

    // Incrementar contador de comentarios en la publicaciÃ³n
    await postRef.update({
      commentCount: admin.firestore.FieldValue.increment(1),
      updatedAt: new Date()
    });

    console.log('âœ… [COMMENT] Comentario creado exitosamente:', commentRef.id);

    // Enviar notificaciÃ³n push al autor de la publicaciÃ³n (si no es Ã©l mismo)
    try {
      const postData = postDoc.data();
      const postAuthorId = postData.authorId;

      if (postAuthorId && postAuthorId !== uid) {
        console.log(`ðŸ“¤ [COMMENT] Enviando notificaciÃ³n al autor de la publicaciÃ³n: ${postAuthorId}`);

        // Obtener informaciÃ³n del comentarista
        const commenterDoc = await db.collection('users').doc(uid).get();
        const commenterData = commenterDoc.exists ? commenterDoc.data() : {};
        const commenterName = commenterData.displayName || commenterData.name || 'Alguien';

        // Obtener tokens del autor de la publicaciÃ³n
        const postAuthorDoc = await db.collection('users').doc(postAuthorId).get();
        if (postAuthorDoc.exists) {
          const postAuthorData = postAuthorDoc.data();
          const authorTokens = postAuthorData.fcmTokens || [];

          if (authorTokens.length > 0) {
            const notification = {
              title: `ðŸ’¬ ${commenterName} comentÃ³ tu publicaciÃ³n`,
              body: content.trim().length > 100 ? content.trim().substring(0, 100) + '...' : content.trim()
            };

            const notificationData = {
              type: 'post_comment',
              postId: postId,
              commentId: commentRef.id,
              commenterId: uid,
              commenterName: commenterName,
              screen: 'PostDetailScreen'
            };

            const pushResult = await sendPushNotification(authorTokens, notification, notificationData);
            console.log(`âœ… [COMMENT] NotificaciÃ³n enviada: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

            // Guardar notificaciÃ³n en Firestore
            await db.collection('notifications').add({
              userId: postAuthorId,
              type: 'post_comment',
              title: notification.title,
              body: notification.body,
              data: notificationData,
              read: false,
              createdAt: admin.firestore.Timestamp.fromDate(new Date())
            });

            console.log('âœ… [COMMENT] NotificaciÃ³n guardada en Firestore');
          } else {
            console.log('âš ï¸ [COMMENT] El autor de la publicaciÃ³n no tiene tokens FCM registrados');
          }
        } else {
          console.log(`âš ï¸ [COMMENT] Autor de la publicaciÃ³n ${postAuthorId} no encontrado`);
        }
      } else {
        console.log('â„¹ï¸ [COMMENT] No se envÃ­a notificaciÃ³n: el autor comentÃ³ su propia publicaciÃ³n');
      }
    } catch (notificationError) {
      console.error('âŒ [COMMENT] Error enviando notificaciÃ³n de comentario:', notificationError);
      // No fallar la creaciÃ³n del comentario si falla la notificaciÃ³n
    }

    res.json({
      success: true,
      message: 'Comentario creado exitosamente',
      data: {
        id: commentRef.id,
        ...commentData
      }
    });

  } catch (error) {
    console.error('âŒ [COMMENT] Error creando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comentario',
      error: error.message
    });
  }
});

// Endpoint para obtener comentarios de una publicaciÃ³n
app.get('/api/posts/:postId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener comentarios ordenados por fecha
    let commentsSnapshot;
    try {
      commentsSnapshot = await db.collection('comments')
        .where('postId', '==', postId)
        .orderBy('createdAt', 'asc')
        .get();
    } catch (indexError) {
      console.log('âš ï¸ [COMMENTS] Ãndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      commentsSnapshot = await db.collection('comments')
        .where('postId', '==', postId)
        .get();
    }

    const comments = [];
    for (const doc of commentsSnapshot.docs) {
      const commentData = doc.data();
      
      // Obtener nombre del autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(commentData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (error) {
        console.log('âš ï¸ [COMMENT] Error obteniendo nombre del autor:', error.message);
      }

      comments.push({
        id: doc.id,
        content: commentData.content,
        authorId: commentData.authorId,
        authorName: authorName,
        likes: commentData.likes || [],
        likeCount: commentData.likeCount || 0,
        isLiked: commentData.likes && commentData.likes.includes(uid),
        createdAt: commentData.createdAt
      });
    }

    res.json({
      success: true,
      data: comments
    });

  } catch (error) {
    console.error('âŒ [COMMENT] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Endpoint para dar like a un comentario
app.post('/api/comments/:commentId/like', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { commentId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const commentRef = db.collection('comments').doc(commentId);
    const commentDoc = await commentRef.get();

    if (!commentDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    const commentData = commentDoc.data();
    const isLiked = commentData.likes && commentData.likes.includes(uid);

    if (isLiked) {
      // Quitar like
      await commentRef.update({
        likes: admin.firestore.FieldValue.arrayRemove(uid),
        likeCount: admin.firestore.FieldValue.increment(-1),
        updatedAt: new Date()
      });
      
      console.log('âœ… [COMMENT] Like removido del comentario:', uid, commentId);
      
      res.json({
        success: true,
        message: 'Like removido del comentario',
        data: { liked: false }
      });
    } else {
      // Agregar like
      await commentRef.update({
        likes: admin.firestore.FieldValue.arrayUnion(uid),
        likeCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });
      
      console.log('âœ… [COMMENT] Like agregado al comentario:', uid, commentId);
      
      res.json({
        success: true,
        message: 'Like agregado al comentario',
        data: { liked: true }
      });
    }

  } catch (error) {
    console.error('âŒ [COMMENT] Error manejando like del comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error manejando like del comentario',
      error: error.message
    });
  }
});

// Endpoint de prueba para verificar almacenamiento de tips
app.post('/api/children/test-storage', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Intentar crear un documento de prueba
    const testData = {
      userId: uid,
      tipType: 'test',
      tip: 'Este es un tip de prueba para verificar el almacenamiento',
      childrenContext: 'Test context',
      isPregnant: false,
      currentGestationWeeks: 0,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    };

    console.log('ðŸ§ª [TEST] Intentando crear documento de prueba:', testData);

    const docRef = await db.collection('userTips').add(testData);
    
    console.log('âœ… [TEST] Documento de prueba creado exitosamente. ID:', docRef.id);

    // Verificar que se puede leer
    const readDoc = await db.collection('userTips').doc(docRef.id).get();
    
    if (readDoc.exists) {
      console.log('âœ… [TEST] Documento leÃ­do exitosamente:', readDoc.data());
      
      // Limpiar el documento de prueba
      await db.collection('userTips').doc(docRef.id).delete();
      console.log('ðŸ§¹ [TEST] Documento de prueba eliminado');
      
      res.json({
        success: true,
        message: 'Prueba de almacenamiento exitosa',
        data: {
          created: true,
          read: true,
          deleted: true,
          documentId: docRef.id
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error: El documento no se puede leer despuÃ©s de crearlo'
      });
    }

  } catch (error) {
    console.error('âŒ [TEST] Error en prueba de almacenamiento:', error);
    res.status(500).json({
      success: false,
      message: 'Error en prueba de almacenamiento',
      error: error.message
    });
  }
});

// Endpoint para limpiar tips antiguos (opcional, para mantenimiento)
app.post('/api/children/cleanup-tips', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Eliminar tips expirados (mÃ¡s de 30 dÃ­as)
    const expiredDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const expiredTipsSnapshot = await db.collection('userTips')
      .where('userId', '==', uid)
      .where('expiresAt', '<', expiredDate)
      .get();

    let deletedCount = 0;
    const batch = db.batch();
    
    expiredTipsSnapshot.forEach(doc => {
      batch.delete(doc.ref);
      deletedCount++;
    });

    if (deletedCount > 0) {
      await batch.commit();
      console.log(`ðŸ§¹ Limpieza de tips: ${deletedCount} tips expirados eliminados para usuario ${uid}`);
    }

    res.json({
      success: true,
      message: `Limpieza completada. ${deletedCount} tips expirados eliminados.`
    });

  } catch (error) {
    console.error('âŒ Error en limpieza de tips:', error);
    res.status(500).json({
      success: false,
      message: 'Error en limpieza de tips'
    });
  }
});

// FunciÃ³n para generar tips de fallback (solo para hijos)
function generateFallbackTips(children, tipType) {
  // Rotar entre los hijos para dar variedad - usar timestamp + tipType para mÃ¡s variedad
  const now = Date.now();
  const timeAndType = now + tipType.length + tipType.charCodeAt(0);
  
  const childIndex = Math.floor((timeAndType / 30000) % children.length); // Cambia cada 30 segundos + variaciÃ³n por tipo
  const selectedChild = children[childIndex];
  let tip = '';
  
  if (tipType === 'general' || tipType === 'desarrollo') {
    if (selectedChild.isUnborn) {
      if (selectedChild.currentGestationWeeks >= 40) {
        tip = `ðŸ¤° Â¡${selectedChild.name} estÃ¡ listo para nacer! MantÃ©n la calma y confÃ­a en tu cuerpo.`;
      } else if (selectedChild.currentGestationWeeks >= 37) {
        tip = `ðŸ‘¶ ${selectedChild.name} ya no es prematuro desde las 37 semanas. Â¡EstÃ¡s en la recta final!`;
      } else if (selectedChild.currentGestationWeeks >= 28) {
        tip = `ðŸ’• ${selectedChild.name} ya puede soÃ±ar y reconocer tu voz. Habla con Ã©l/ella todos los dÃ­as.`;
      } else {
        tip = `ðŸŒŸ ${selectedChild.name} estÃ¡ creciendo bien en tu vientre. MantÃ©n una alimentaciÃ³n saludable.`;
      }
    } else {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `ðŸ¼ La leche materna es el mejor alimento para ${selectedChild.name}. Amamanta a demanda.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ðŸ¥„ Introduce alimentos sÃ³lidos gradualmente a ${selectedChild.name}. Un alimento nuevo cada 3-4 dÃ­as.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ðŸš¶ ${selectedChild.name} estÃ¡ explorando el mundo. MantÃ©n tu casa segura para niÃ±os.`;
      } else if (selectedChild.currentAgeInMonths <= 36) {
        tip = `ðŸŽ¨ Fomenta la creatividad de ${selectedChild.name} con dibujos, manualidades y juegos imaginativos.`;
      } else {
        tip = `ðŸ“š Lee cuentos con ${selectedChild.name}. Es una excelente manera de fortalecer el vÃ­nculo.`;
      }
    }
  } else if (tipType === 'alimentacion') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `ðŸ¤± Amamanta exclusivamente a ${selectedChild.name} hasta los 6 meses. No necesita agua ni otros alimentos.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ðŸ¥‘ Introduce frutas y verduras de colores variados a ${selectedChild.name} para una nutriciÃ³n completa.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ðŸ¥› Ofrece a ${selectedChild.name} 3 comidas principales y 2-3 refrigerios saludables al dÃ­a.`;
      } else {
        tip = `ðŸŽ Incluye en la dieta de ${selectedChild.name} proteÃ­nas magras, granos enteros y muchas frutas y verduras.`;
      }
    } else {
      tip = `ðŸ¤° Para ${selectedChild.name}, mantÃ©n una alimentaciÃ³n rica en Ã¡cido fÃ³lico, hierro y calcio durante el embarazo.`;
    }
  } else if (tipType === 'salud') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ðŸ’‰ MantÃ©n al dÃ­a el calendario de vacunaciÃ³n de ${selectedChild.name}. Es fundamental para su salud.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ðŸ¦· Cepilla los dientes de ${selectedChild.name} 2 veces al dÃ­a con pasta dental con flÃºor.`;
      } else {
        tip = `ðŸƒ Fomenta en ${selectedChild.name} al menos 1 hora de actividad fÃ­sica diaria para un desarrollo saludable.`;
      }
    } else {
      tip = `ðŸ¥ Asiste a todas las citas prenatales para monitorear el desarrollo saludable de ${selectedChild.name}.`;
    }
  } else if (tipType === 'sueÃ±o') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `ðŸ˜´ ${selectedChild.name} necesita 14-17 horas de sueÃ±o total al dÃ­a. Respeta sus ritmos naturales.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ðŸŒ™ Establece una rutina de sueÃ±o consistente para ${selectedChild.name}: baÃ±o, cuento y cuna a la misma hora.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ðŸ›ï¸ ${selectedChild.name} necesita 11-14 horas de sueÃ±o, incluyendo 1-2 siestas durante el dÃ­a.`;
      } else {
        tip = `ðŸ’¤ ${selectedChild.name} necesita 10-13 horas de sueÃ±o. MantÃ©n horarios regulares para un descanso Ã³ptimo.`;
      }
    } else {
      tip = `ðŸ˜´ Descansa bien durante el embarazo. Tu descanso tambiÃ©n beneficia el desarrollo de ${selectedChild.name}.`;
    }
  } else if (tipType === 'actividades') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `ðŸŽµ Canta canciones y haz movimientos rÃ­tmicos con ${selectedChild.name}. Estimula su desarrollo auditivo y motor.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ðŸ§¸ Juega a esconder objetos con ${selectedChild.name}. Desarrolla su memoria y comprensiÃ³n de permanencia.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ðŸ—ï¸ Construye torres con bloques junto a ${selectedChild.name}. Mejora su coordinaciÃ³n y pensamiento espacial.`;
      } else {
        tip = `ðŸŽ­ Juega a disfrazarse con ${selectedChild.name}. Fomenta la imaginaciÃ³n y la expresiÃ³n creativa.`;
      }
    } else {
      tip = `ðŸ’• Habla, canta y acaricia tu vientre. ${selectedChild.name} puede sentir tu amor desde el Ãºtero.`;
    }
  }

  // Si no hay tip especÃ­fico, generar uno general personalizado
  if (!tip) {
    tip = `ðŸ’• ${selectedChild.name} es Ãºnico. ConfÃ­a en tu instinto maternal/paternal para criarlo.`;
  }

  return [tip]; // Retornar solo 1 tip
}

// Endpoint para actualizar el nombre del usuario
app.put('/api/auth/update-name', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { displayName } = req.body;

    if (!displayName || displayName.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Servicios no disponibles'
      });
    }

    console.log('ðŸ“ Actualizando nombre del usuario:', uid, 'Nuevo nombre:', displayName);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      displayName: displayName.trim()
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      displayName: displayName.trim(),
      updatedAt: new Date()
    });

    console.log('âœ… Nombre actualizado correctamente');

    res.json({
      success: true,
      message: 'Nombre actualizado correctamente',
      data: {
        displayName: displayName.trim()
      }
    });

  } catch (error) {
    console.error('âŒ Error actualizando nombre:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar el nombre',
      error: error.message
    });
  }
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
  console.error('Error no manejado:', err);
  res.status(500).json({
    success: false,
    message: 'Error interno del servidor',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Algo saliÃ³ mal'
  });
});

// ==========================================
// ðŸ“‹ ENDPOINTS DE PERFIL COMPLETO DE HIJOS
// ==========================================

// ==========================================
// 1. VACUNAS
// ==========================================

const buildVaccineSchedulePayload = ({ countryId, countryName, name, items, isActive = true }) => ({
  countryId,
  countryName,
  name,
  isActive,
  items: Array.isArray(items) ? items : [],
  updatedAt: new Date(),
  createdAt: new Date()
});

const mapScheduleItemToVaccine = (item, birthDate) => {
  const ageMonths = Number.isFinite(item.ageMonths) ? item.ageMonths : null;
  const ageWeeks = Number.isFinite(item.ageWeeks) ? item.ageWeeks : null;
  const scheduledDate = ageMonths !== null
    ? addMonthsToDate(birthDate, ageMonths)
    : addWeeksToDate(birthDate, ageWeeks);

  if (!scheduledDate) return null;

  return {
    name: item.name,
    scheduledDate,
    appliedDate: null,
    status: 'pending',
    location: '',
    batch: '',
    notes: item.notes || '',
    source: 'schedule',
    scheduleItemId: item.id || null,
    ageMonths,
    ageWeeks,
    createdAt: new Date(),
    updatedAt: new Date()
  };
};

// Listar calendarios de vacunas disponibles
app.get('/api/vaccines/schedules', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('vaccine_schedules')
      .where('isActive', '==', true)
      .orderBy('countryName', 'asc')
      .get();
    const schedules = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: schedules });
  } catch (error) {
    console.error('âŒ Error listando calendarios de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error listando calendarios', error: error.message });
  }
});

// Obtener calendario por paÃ­s
app.get('/api/vaccines/schedules/country/:countryId', authenticateToken, async (req, res) => {
  try {
    const { countryId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('vaccine_schedules')
      .where('countryId', '==', countryId)
      .where('isActive', '==', true)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Calendario no encontrado' });
    }
    const doc = snapshot.docs[0];
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('âŒ Error obteniendo calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo calendario', error: error.message });
  }
});

// Admin: crear calendario de vacunas
app.post('/api/admin/vaccines/schedules', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId, name, items } = req.body || {};
    if (!countryId || !name) {
      return res.status(400).json({ success: false, message: 'countryId y name son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const countryDoc = await db.collection('countries').doc(countryId).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      return res.status(400).json({ success: false, message: 'PaÃ­s no encontrado o inactivo' });
    }
    const payload = buildVaccineSchedulePayload({
      countryId,
      countryName: countryDoc.data().name,
      name,
      items,
      isActive: true
    });
    const ref = await db.collection('vaccine_schedules').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ Error creando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error creando calendario', error: error.message });
  }
});

// Admin: listar calendarios de vacunas
app.get('/api/admin/vaccines/schedules', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { isActive } = req.query || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('vaccine_schedules');
    if (isActive !== undefined) {
      query = query.where('isActive', '==', String(isActive) === 'true');
    }
    const snapshot = await query.orderBy('countryName', 'asc').get();
    const schedules = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: schedules });
  } catch (error) {
    console.error('âŒ Error listando calendarios de vacunas (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando calendarios', error: error.message });
  }
});

// Admin: actualizar calendario de vacunas
app.put('/api/admin/vaccines/schedules/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, items, isActive } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = {
      updatedAt: new Date()
    };
    if (name !== undefined) updateData.name = name;
    if (items !== undefined) updateData.items = Array.isArray(items) ? items : [];
    if (isActive !== undefined) updateData.isActive = Boolean(isActive);
    await db.collection('vaccine_schedules').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ Error actualizando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error actualizando calendario', error: error.message });
  }
});

// Admin: eliminar calendario de vacunas
app.delete('/api/admin/vaccines/schedules/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('vaccine_schedules').doc(id).delete();
    res.json({ success: true, message: 'Calendario eliminado' });
  } catch (error) {
    console.error('âŒ Error eliminando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error eliminando calendario', error: error.message });
  }
});

// Asignar calendario de vacunas a un hijo
app.post('/api/children/:childId/vaccines/assign-schedule', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { countryId } = req.body || {};

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const childRef = db.collection('children').doc(childId);
    const childDoc = await childRef.get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({ success: false, message: 'No tienes permiso para acceder a este hijo' });
    }

    const childData = childDoc.data();
    const birthDate = parseDateSafe(childData.birthDate);
    if (!birthDate) {
      return res.status(400).json({ success: false, message: 'El hijo no tiene birthDate vÃ¡lida' });
    }

    const existingVaccines = await childRef.collection('vaccines').limit(1).get();
    if (!existingVaccines.empty) {
      return res.status(400).json({ success: false, message: 'El hijo ya tiene vacunas registradas' });
    }

    const scheduleSnapshot = await db.collection('vaccine_schedules')
      .where('countryId', '==', countryId)
      .where('isActive', '==', true)
      .limit(1)
      .get();
    if (scheduleSnapshot.empty) {
      return res.status(404).json({ success: false, message: 'Calendario de vacunas no encontrado' });
    }

    const scheduleDoc = scheduleSnapshot.docs[0];
    const scheduleData = scheduleDoc.data();
    const items = Array.isArray(scheduleData.items) ? scheduleData.items : [];
    if (items.length === 0) {
      return res.status(400).json({ success: false, message: 'El calendario no tiene vacunas' });
    }

    const batch = db.batch();
    const vaccinesToCreate = [];
    items.forEach(item => {
      if (!item || !item.name) return;
      const vaccinePayload = mapScheduleItemToVaccine(item, birthDate);
      if (!vaccinePayload) return;
      const docRef = childRef.collection('vaccines').doc();
      batch.set(docRef, {
        ...vaccinePayload,
        scheduleId: scheduleDoc.id,
        scheduleName: scheduleData.name || '',
        countryId: scheduleData.countryId,
        countryName: scheduleData.countryName || ''
      });
      vaccinesToCreate.push({ id: docRef.id, ...vaccinePayload });
    });

    const countryDoc = await db.collection('countries').doc(countryId).get();
    const countryName = countryDoc.exists ? countryDoc.data().name : scheduleData.countryName || '';

    batch.update(childRef, stripUndefined({
      vaccinationCountryId: countryId,
      vaccinationCountryName: countryName || '',
      vaccinationScheduleId: scheduleDoc.id,
      vaccinationScheduleName: scheduleData.name || '',
      vaccinationAssignedAt: new Date(),
      updatedAt: new Date()
    }));

    await batch.commit();

    res.json({
      success: true,
      message: 'Calendario asignado correctamente',
      data: vaccinesToCreate
    });
  } catch (error) {
    console.error('âŒ Error asignando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error asignando calendario', error: error.message });
  }
});

// Obtener vacunas de un hijo
app.get('/api/children/:childId/vaccines', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const vaccinesSnapshot = await db.collection('children').doc(childId)
      .collection('vaccines')
      .orderBy('scheduledDate', 'asc')
      .get();

    const vaccines = [];
    vaccinesSnapshot.forEach(doc => {
      vaccines.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: vaccines,
      needsVaccinationCountry: vaccines.length === 0 && !childDoc.data().vaccinationCountryId
    });

  } catch (error) {
    console.error('âŒ Error obteniendo vacunas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo vacunas',
      error: error.message
    });
  }
});

// Agregar/actualizar vacuna
app.post('/api/children/:childId/vaccines', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name, 
      scheduledDate, 
      appliedDate, 
      status, // 'pending', 'applied', 'skipped'
      location,
      batch,
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const vaccineData = {
      name,
      scheduledDate: new Date(scheduledDate),
      appliedDate: appliedDate ? new Date(appliedDate) : null,
      status: status || 'pending',
      location: location || '',
      batch: batch || '',
      notes: notes || '',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const vaccineRef = await db.collection('children').doc(childId)
      .collection('vaccines')
      .add(vaccineData);

    res.json({
      success: true,
      message: 'Vacuna registrada exitosamente',
      data: {
        id: vaccineRef.id,
        ...vaccineData
      }
    });

  } catch (error) {
    console.error('âŒ Error registrando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando vacuna',
      error: error.message
    });
  }
});

// ==========================================
// 2. CITAS MÃ‰DICAS
// ==========================================

// Obtener citas mÃ©dicas
app.get('/api/children/:childId/appointments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const appointmentsSnapshot = await db.collection('children').doc(childId)
      .collection('appointments')
      .orderBy('date', 'desc')
      .get();

    const appointments = [];
    appointmentsSnapshot.forEach(doc => {
      appointments.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: appointments
    });

  } catch (error) {
    console.error('âŒ Error obteniendo citas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo citas',
      error: error.message
    });
  }
});

// Agregar cita mÃ©dica
app.post('/api/children/:childId/appointments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'checkup', 'specialist', 'emergency', 'vaccine'
      date,
      doctor,
      location,
      reason,
      notes,
      status // 'scheduled', 'completed', 'cancelled'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const appointmentData = {
      type: type || 'checkup',
      date: new Date(date),
      doctor: doctor || '',
      location: location || '',
      reason: reason || '',
      notes: notes || '',
      status: status || 'scheduled',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const appointmentRef = await db.collection('children').doc(childId)
      .collection('appointments')
      .add(appointmentData);

    res.json({
      success: true,
      message: 'Cita registrada exitosamente',
      data: {
        id: appointmentRef.id,
        ...appointmentData
      }
    });

  } catch (error) {
    console.error('âŒ Error registrando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando cita',
      error: error.message
    });
  }
});

// ==========================================
// 3. MEDICAMENTOS
// ==========================================

// Obtener medicamentos
app.get('/api/children/:childId/medications', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const medicationsSnapshot = await db.collection('children').doc(childId)
      .collection('medications')
      .orderBy('startDate', 'desc')
      .get();

    const medications = [];
    medicationsSnapshot.forEach(doc => {
      medications.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: medications
    });

  } catch (error) {
    console.error('âŒ Error obteniendo medicamentos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo medicamentos',
      error: error.message
    });
  }
});

// Agregar medicamento
app.post('/api/children/:childId/medications', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name,
      dosage,
      frequency,
      startDate,
      endDate,
      reason,
      prescribedBy,
      notes,
      status // 'active', 'completed', 'discontinued'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const medicationData = {
      name,
      dosage,
      frequency,
      startDate: new Date(startDate),
      endDate: endDate ? new Date(endDate) : null,
      reason: reason || '',
      prescribedBy: prescribedBy || '',
      notes: notes || '',
      status: status || 'active',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const medicationRef = await db.collection('children').doc(childId)
      .collection('medications')
      .add(medicationData);

    res.json({
      success: true,
      message: 'Medicamento registrado exitosamente',
      data: {
        id: medicationRef.id,
        ...medicationData
      }
    });

  } catch (error) {
    console.error('âŒ Error registrando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando medicamento',
      error: error.message
    });
  }
});

// ==========================================
// 4. ALERGIAS (actualizar hijo con campo allergies)
// ==========================================

// Actualizar alergias del hijo
app.put('/api/children/:childId/allergies', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { allergies } = req.body; // array de strings

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId).update({
      allergies: allergies || [],
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Alergias actualizadas exitosamente',
      data: {
        allergies
      }
    });

  } catch (error) {
    console.error('âŒ Error actualizando alergias:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando alergias',
      error: error.message
    });
  }
});

// ==========================================
// 5. HISTORIAL MÃ‰DICO
// ==========================================

// Obtener historial mÃ©dico
app.get('/api/children/:childId/medical-history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const historySnapshot = await db.collection('children').doc(childId)
      .collection('medical_history')
      .orderBy('date', 'desc')
      .get();

    const history = [];
    historySnapshot.forEach(doc => {
      history.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: history
    });

  } catch (error) {
    console.error('âŒ Error obteniendo historial mÃ©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial mÃ©dico',
      error: error.message
    });
  }
});

// Agregar entrada al historial mÃ©dico
app.post('/api/children/:childId/medical-history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'diagnosis', 'treatment', 'surgery', 'hospitalization', 'other'
      date,
      title,
      description,
      doctor,
      location,
      attachments // URLs de documentos/imÃ¡genes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const historyData = {
      type: type || 'other',
      date: new Date(date),
      title,
      description: description || '',
      doctor: doctor || '',
      location: location || '',
      attachments: attachments || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const historyRef = await db.collection('children').doc(childId)
      .collection('medical_history')
      .add(historyData);

    res.json({
      success: true,
      message: 'Historial mÃ©dico actualizado exitosamente',
      data: {
        id: historyRef.id,
        ...historyData
      }
    });

  } catch (error) {
    console.error('âŒ Error actualizando historial mÃ©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando historial mÃ©dico',
      error: error.message
    });
  }
});

// ==========================================
// 6. MEDICIONES (Peso, Altura, PerÃ­metro CefÃ¡lico)
// ==========================================

// Obtener mediciones
app.get('/api/children/:childId/measurements', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const measurementsSnapshot = await db.collection('children').doc(childId)
      .collection('measurements')
      .orderBy('date', 'desc')
      .get();

    const measurements = [];
    measurementsSnapshot.forEach(doc => {
      measurements.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: measurements
    });

  } catch (error) {
    console.error('âŒ Error obteniendo mediciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mediciones',
      error: error.message
    });
  }
});

// Agregar mediciÃ³n
app.post('/api/children/:childId/measurements', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      weight, // en kg
      height, // en cm
      headCircumference, // en cm
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const measurementData = {
      date: new Date(date),
      weight: weight || null,
      height: height || null,
      headCircumference: headCircumference || null,
      notes: notes || '',
      createdAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements')
      .add(measurementData);

    res.json({
      success: true,
      message: 'MediciÃ³n registrada exitosamente',
      data: {
        id: measurementRef.id,
        ...measurementData
      }
    });

  } catch (error) {
    console.error('âŒ Error registrando mediciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando mediciÃ³n',
      error: error.message
    });
  }
});

// ==========================================
// 7. SEGUIMIENTO DE SUEÃ‘O
// ==========================================

// Obtener registros de sueÃ±o
app.get('/api/children/:childId/sleep-tracking', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { startDate, endDate } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    let query = db.collection('children').doc(childId).collection('sleep_tracking');
    
    if (startDate) {
      query = query.where('date', '>=', new Date(startDate));
    }
    if (endDate) {
      query = query.where('date', '<=', new Date(endDate));
    }

    const sleepSnapshot = await query.orderBy('date', 'desc').get();

    const sleepRecords = [];
    sleepSnapshot.forEach(doc => {
      sleepRecords.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: sleepRecords
    });

  } catch (error) {
    console.error('âŒ Error obteniendo registros de sueÃ±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo registros de sueÃ±o',
      error: error.message
    });
  }
});

// Agregar registro de sueÃ±o
app.post('/api/children/:childId/sleep-tracking', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      sleepTime, // hora de dormir
      wakeTime, // hora de despertar
      duration, // duraciÃ³n en minutos
      quality, // 'good', 'fair', 'poor'
      naps, // array de siestas [{time, duration}]
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const sleepData = {
      date: new Date(date),
      sleepTime: sleepTime ? new Date(sleepTime) : null,
      wakeTime: wakeTime ? new Date(wakeTime) : null,
      duration: duration || 0,
      quality: quality || 'fair',
      naps: naps || [],
      notes: notes || '',
      createdAt: new Date()
    };

    const sleepRef = await db.collection('children').doc(childId)
      .collection('sleep_tracking')
      .add(sleepData);

    res.json({
      success: true,
      message: 'Registro de sueÃ±o guardado exitosamente',
      data: {
        id: sleepRef.id,
        ...sleepData
      }
    });

  } catch (error) {
    console.error('âŒ Error guardando registro de sueÃ±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando registro de sueÃ±o',
      error: error.message
    });
  }
});

// ==========================================
// 8. REGISTRO DE ALIMENTACIÃ“N
// ==========================================

// Obtener registros de alimentaciÃ³n
app.get('/api/children/:childId/feeding-log', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { startDate, endDate } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    let query = db.collection('children').doc(childId).collection('feeding_log');
    
    if (startDate) {
      query = query.where('date', '>=', new Date(startDate));
    }
    if (endDate) {
      query = query.where('date', '<=', new Date(endDate));
    }

    const feedingSnapshot = await query.orderBy('date', 'desc').get();

    const feedingRecords = [];
    feedingSnapshot.forEach(doc => {
      feedingRecords.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: feedingRecords
    });

  } catch (error) {
    console.error('âŒ Error obteniendo registros de alimentaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo registros de alimentaciÃ³n',
      error: error.message
    });
  }
});

// Agregar registro de alimentaciÃ³n
app.post('/api/children/:childId/feeding-log', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      type, // 'breastfeeding', 'bottle', 'solid', 'water'
      amount, // ml o gramos
      duration, // minutos (para lactancia)
      food, // descripciÃ³n del alimento
      breast, // 'left', 'right', 'both' (para lactancia)
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const feedingData = {
      date: new Date(date),
      type,
      amount: amount || null,
      duration: duration || null,
      food: food || '',
      breast: breast || null,
      notes: notes || '',
      createdAt: new Date()
    };

    const feedingRef = await db.collection('children').doc(childId)
      .collection('feeding_log')
      .add(feedingData);

    res.json({
      success: true,
      message: 'Registro de alimentaciÃ³n guardado exitosamente',
      data: {
        id: feedingRef.id,
        ...feedingData
      }
    });

  } catch (error) {
    console.error('âŒ Error guardando registro de alimentaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando registro de alimentaciÃ³n',
      error: error.message
    });
  }
});

// ==========================================
// 9. HITOS DEL DESARROLLO
// ==========================================

// Obtener hitos
// NOTA: Este endpoint fue reemplazado por el de hitos de desarrollo (lÃ­nea ~37587)
// Este era para hitos de celebraciÃ³n (primera sonrisa, primer paso, etc.)
// Si necesitas hitos de celebraciÃ³n, usa un endpoint diferente
/*
app.get('/api/children/:childId/milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const milestonesSnapshot = await db.collection('children').doc(childId)
      .collection('milestones')
      .orderBy('date', 'desc')
      .get();

    const milestones = [];
    milestonesSnapshot.forEach(doc => {
      milestones.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: milestones
    });

  } catch (error) {
    console.error('âŒ Error obteniendo hitos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});
*/

// Agregar hito de celebraciÃ³n (primera sonrisa, primer paso, etc.)
// NOTA: Este es diferente a los hitos de desarrollo
app.post('/api/children/:childId/celebration-milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'first_smile', 'first_word', 'first_step', 'first_tooth', 'custom'
      title,
      date,
      description,
      photos, // array de URLs
      celebrationEmoji
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const milestoneData = {
      type,
      title,
      date: new Date(date),
      description: description || '',
      photos: photos || [],
      celebrationEmoji: celebrationEmoji || 'ðŸŽ‰',
      createdAt: new Date()
    };

    const milestoneRef = await db.collection('children').doc(childId)
      .collection('milestones')
      .add(milestoneData);

    res.json({
      success: true,
      message: 'Hito registrado exitosamente',
      data: {
        id: milestoneRef.id,
        ...milestoneData
      }
    });

  } catch (error) {
    console.error('âŒ Error registrando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando hito',
      error: error.message
    });
  }
});

// ==========================================
// 10. DIARIO DEL BEBÃ‰
// ==========================================

// Obtener entradas del diario
app.get('/api/children/:childId/diary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const diarySnapshot = await db.collection('children').doc(childId)
      .collection('diary')
      .orderBy('date', 'desc')
      .limit(50)
      .get();

    const diaryEntries = [];
    diarySnapshot.forEach(doc => {
      diaryEntries.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: diaryEntries
    });

  } catch (error) {
    console.error('âŒ Error obteniendo diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo diario',
      error: error.message
    });
  }
});

// Agregar entrada al diario
app.post('/api/children/:childId/diary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      title,
      content,
      mood, // 'happy', 'sad', 'neutral', 'excited'
      photos,
      tags
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const diaryData = {
      date: new Date(date),
      title: title || '',
      content,
      mood: mood || 'neutral',
      photos: photos || [],
      tags: tags || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const diaryRef = await db.collection('children').doc(childId)
      .collection('diary')
      .add(diaryData);

    res.json({
      success: true,
      message: 'Entrada del diario guardada exitosamente',
      data: {
        id: diaryRef.id,
        ...diaryData
      }
    });

  } catch (error) {
    console.error('âŒ Error guardando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando entrada del diario',
      error: error.message
    });
  }
});

// ==========================================
// 11. ÃLBUMES DE FOTOS
// ==========================================

// Obtener Ã¡lbumes
app.get('/api/children/:childId/albums', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumsSnapshot = await db.collection('children').doc(childId)
      .collection('albums')
      .orderBy('createdAt', 'desc')
      .get();

    const albums = [];
    albumsSnapshot.forEach(doc => {
      albums.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: albums
    });

  } catch (error) {
    console.error('âŒ Error obteniendo Ã¡lbumes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo Ã¡lbumes',
      error: error.message
    });
  }
});

// Crear Ã¡lbum
app.post('/api/children/:childId/albums', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name,
      description,
      coverPhoto,
      photos, // array de {url, caption, date}
      theme // 'birthday', 'first_year', 'vacation', 'custom'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumData = {
      name,
      description: description || '',
      coverPhoto: coverPhoto || '',
      photos: photos || [],
      theme: theme || 'custom',
      photoCount: (photos || []).length,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const albumRef = await db.collection('children').doc(childId)
      .collection('albums')
      .add(albumData);

    res.json({
      success: true,
      message: 'Ãlbum creado exitosamente',
      data: {
        id: albumRef.id,
        ...albumData
      }
    });

  } catch (error) {
    console.error('âŒ Error creando Ã¡lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando Ã¡lbum',
      error: error.message
    });
  }
});

// Agregar fotos a un Ã¡lbum
app.post('/api/children/:childId/albums/:albumId/photos', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;
    const { photos } = req.body; // array de {url, caption, date}

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumRef = db.collection('children').doc(childId).collection('albums').doc(albumId);
    const albumDoc = await albumRef.get();

    if (!albumDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Ãlbum no encontrado'
      });
    }

    const currentPhotos = albumDoc.data().photos || [];
    const updatedPhotos = [...currentPhotos, ...photos];

    await albumRef.update({
      photos: updatedPhotos,
      photoCount: updatedPhotos.length,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Fotos agregadas al Ã¡lbum exitosamente',
      data: {
        photoCount: updatedPhotos.length
      }
    });

  } catch (error) {
    console.error('âŒ Error agregando fotos al Ã¡lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando fotos al Ã¡lbum',
      error: error.message
    });
  }
});

// ==========================================
// 12. CUIDADORES (Compartir acceso)
// ==========================================

// Obtener cuidadores
app.get('/api/children/:childId/caregivers', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const caregiversSnapshot = await db.collection('children').doc(childId)
      .collection('caregivers')
      .get();

    const caregivers = [];
    caregiversSnapshot.forEach(doc => {
      caregivers.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: caregivers
    });

  } catch (error) {
    console.error('âŒ Error obteniendo cuidadores:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo cuidadores',
      error: error.message
    });
  }
});

// Agregar cuidador
app.post('/api/children/:childId/caregivers', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      email,
      name,
      relationship, // 'father', 'mother', 'grandparent', 'other'
      permissions // {canEdit: bool, canViewMedical: bool, canViewPhotos: bool}
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Verificar si el email ya existe como cuidador
    const existingCaregiver = await db.collection('children').doc(childId)
      .collection('caregivers')
      .where('email', '==', email)
      .get();

    if (!existingCaregiver.empty) {
      return res.status(400).json({
        success: false,
        message: 'Este email ya estÃ¡ registrado como cuidador'
      });
    }

    const caregiverData = {
      email,
      name: name || '',
      relationship: relationship || 'other',
      permissions: permissions || {
        canEdit: false,
        canViewMedical: true,
        canViewPhotos: true
      },
      status: 'pending', // 'pending', 'active', 'declined'
      invitedAt: new Date(),
      invitedBy: uid
    };

    const caregiverRef = await db.collection('children').doc(childId)
      .collection('caregivers')
      .add(caregiverData);

    res.json({
      success: true,
      message: 'Cuidador invitado exitosamente',
      data: {
        id: caregiverRef.id,
        ...caregiverData
      }
    });

  } catch (error) {
    console.error('âŒ Error agregando cuidador:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando cuidador',
      error: error.message
    });
  }
});

// ==========================================
// 13. EXPORTAR A PDF
// ==========================================

// Exportar informaciÃ³n completa del hijo a PDF
app.get('/api/children/:childId/export-pdf', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();

    // Recopilar toda la informaciÃ³n
    const vaccinesSnapshot = await db.collection('children').doc(childId).collection('vaccines').get();
    const appointmentsSnapshot = await db.collection('children').doc(childId).collection('appointments').get();
    const milestonesSnapshot = await db.collection('children').doc(childId).collection('milestones').get();
    const measurementsSnapshot = await db.collection('children').doc(childId).collection('measurements').get();

    const exportData = {
      child: {
        name: childData.name,
        birthDate: childData.birthDate,
        ageInMonths: childData.currentAgeInMonths,
        allergies: childData.allergies || []
      },
      vaccines: [],
      appointments: [],
      milestones: [],
      measurements: []
    };

    vaccinesSnapshot.forEach(doc => exportData.vaccines.push(doc.data()));
    appointmentsSnapshot.forEach(doc => exportData.appointments.push(doc.data()));
    milestonesSnapshot.forEach(doc => exportData.milestones.push(doc.data()));
    measurementsSnapshot.forEach(doc => exportData.measurements.push(doc.data()));

    // Por ahora devolver JSON (puedes integrar una librerÃ­a de PDF como PDFKit o Puppeteer)
    res.json({
      success: true,
      message: 'Datos recopilados para exportar',
      data: exportData,
      note: 'Integrar librerÃ­a de PDF para generar documento descargable'
    });

  } catch (error) {
    console.error('âŒ Error exportando datos:', error);
    res.status(500).json({
      success: false,
      message: 'Error exportando datos',
      error: error.message
    });
  }
});

// ==========================================
// FIN DE ENDPOINTS DE PERFIL DE HIJOS


// ==========================================
// ðŸ“ ENDPOINTS CRUD - UPDATE & DELETE
// ==========================================

// PUT (actualizar) y DELETE (eliminar) para todos los recursos

// ==========================================
// 1. VACUNAS - UPDATE & DELETE
// ==========================================

// Actualizar vacuna
app.put('/api/children/:childId/vaccines/:vaccineId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, vaccineId } = req.params;
    const { 
      name, 
      scheduledDate, 
      appliedDate, 
      status,
      location,
      batch,
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name;
    if (scheduledDate !== undefined) updateData.scheduledDate = new Date(scheduledDate);
    if (appliedDate !== undefined) updateData.appliedDate = appliedDate ? new Date(appliedDate) : null;
    if (status !== undefined) updateData.status = status;
    if (location !== undefined) updateData.location = location;
    if (batch !== undefined) updateData.batch = batch;
    if (notes !== undefined) updateData.notes = notes;

    await db.collection('children').doc(childId)
      .collection('vaccines').doc(vaccineId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Vacuna actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando vacuna',
      error: error.message
    });
  }
});

// Eliminar vacuna
app.delete('/api/children/:childId/vaccines/:vaccineId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, vaccineId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('vaccines').doc(vaccineId)
      .delete();

    res.json({
      success: true,
      message: 'Vacuna eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando vacuna',
      error: error.message
    });
  }
});

// ==========================================
// 2. CITAS MÃ‰DICAS - UPDATE & DELETE
// ==========================================

// Actualizar cita mÃ©dica
app.put('/api/children/:childId/appointments/:appointmentId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, appointmentId } = req.params;
    const { type, date, doctor, location, reason, notes, status } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (type !== undefined) updateData.type = type;
    if (date !== undefined) updateData.date = new Date(date);
    if (doctor !== undefined) updateData.doctor = doctor;
    if (location !== undefined) updateData.location = location;
    if (reason !== undefined) updateData.reason = reason;
    if (notes !== undefined) updateData.notes = notes;
    if (status !== undefined) updateData.status = status;

    await db.collection('children').doc(childId)
      .collection('appointments').doc(appointmentId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Cita actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando cita',
      error: error.message
    });
  }
});

// Eliminar cita mÃ©dica
app.delete('/api/children/:childId/appointments/:appointmentId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, appointmentId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('appointments').doc(appointmentId)
      .delete();

    res.json({
      success: true,
      message: 'Cita eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando cita',
      error: error.message
    });
  }
});

// ==========================================
// 3. MEDICAMENTOS - UPDATE & DELETE
// ==========================================

// Actualizar medicamento
app.put('/api/children/:childId/medications/:medicationId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, medicationId } = req.params;
    const { name, dosage, frequency, startDate, endDate, reason, prescribedBy, notes, status } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (name !== undefined) updateData.name = name;
    if (dosage !== undefined) updateData.dosage = dosage;
    if (frequency !== undefined) updateData.frequency = frequency;
    if (startDate !== undefined) updateData.startDate = new Date(startDate);
    if (endDate !== undefined) updateData.endDate = endDate ? new Date(endDate) : null;
    if (reason !== undefined) updateData.reason = reason;
    if (prescribedBy !== undefined) updateData.prescribedBy = prescribedBy;
    if (notes !== undefined) updateData.notes = notes;
    if (status !== undefined) updateData.status = status;

    await db.collection('children').doc(childId)
      .collection('medications').doc(medicationId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Medicamento actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando medicamento',
      error: error.message
    });
  }
});

// Eliminar medicamento
app.delete('/api/children/:childId/medications/:medicationId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, medicationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('medications').doc(medicationId)
      .delete();

    res.json({
      success: true,
      message: 'Medicamento eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando medicamento',
      error: error.message
    });
  }
});

// ==========================================
// 4. HISTORIAL MÃ‰DICO - UPDATE & DELETE
// ==========================================

// Actualizar historial mÃ©dico
app.put('/api/children/:childId/medical-history/:historyId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, historyId } = req.params;
    const { type, date, title, description, doctor, location, attachments } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (type !== undefined) updateData.type = type;
    if (date !== undefined) updateData.date = new Date(date);
    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (doctor !== undefined) updateData.doctor = doctor;
    if (location !== undefined) updateData.location = location;
    if (attachments !== undefined) updateData.attachments = attachments;

    await db.collection('children').doc(childId)
      .collection('medical_history').doc(historyId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Historial mÃ©dico actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando historial mÃ©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando historial mÃ©dico',
      error: error.message
    });
  }
});

// Eliminar historial mÃ©dico
app.delete('/api/children/:childId/medical-history/:historyId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, historyId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('medical_history').doc(historyId)
      .delete();

    res.json({
      success: true,
      message: 'Historial mÃ©dico eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando historial mÃ©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando historial mÃ©dico',
      error: error.message
    });
  }
});

// ==========================================
// 5. MEDICIONES - UPDATE & DELETE
// ==========================================

// Actualizar mediciÃ³n
app.put('/api/children/:childId/measurements/:measurementId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, measurementId } = req.params;
    const { date, weight, height, headCircumference, notes } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {};
    if (date !== undefined) updateData.date = new Date(date);
    if (weight !== undefined) updateData.weight = weight;
    if (height !== undefined) updateData.height = height;
    if (headCircumference !== undefined) updateData.headCircumference = headCircumference;
    if (notes !== undefined) updateData.notes = notes;

    await db.collection('children').doc(childId)
      .collection('measurements').doc(measurementId)
      .update(updateData);

    res.json({
      success: true,
      message: 'MediciÃ³n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando mediciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando mediciÃ³n',
      error: error.message
    });
  }
});

// Eliminar mediciÃ³n
app.delete('/api/children/:childId/measurements/:measurementId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, measurementId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements').doc(measurementId)
      .delete();

    res.json({
      success: true,
      message: 'MediciÃ³n eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando mediciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando mediciÃ³n',
      error: error.message
    });
  }
});

// ==========================================
// 6.1 MEDICIONES - PESO (ENDPOINTS DEDICADOS)
// ==========================================

const mapWeightMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueKg: data.valueKg ?? data.weight ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

const mapHeightMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueCm: data.valueCm ?? data.height ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

const mapHeadMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueCm: data.valueCm ?? data.headCircumference ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

// Obtener historial de peso
app.get('/api/children/:childId/measurements/weight', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'weight') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_weight')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapWeightMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueKg !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueKg, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().weight !== undefined && doc.data().weight !== null)
        .map((doc) => {
          const mapped = mapWeightMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueKg !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueKg, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('âŒ Error obteniendo peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo peso',
      error: error.message
    });
  }
});

// Crear registro de peso
app.post('/api/children/:childId/measurements/weight', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueKg, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueKg === undefined || valueKg === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueKg y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueKg: Number(valueKg),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_weight')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Peso registrado exitosamente',
      data: {
        id: measurementRef.id,
        ...mapWeightMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('âŒ Error registrando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando peso',
      error: error.message
    });
  }
});

// Actualizar registro de peso
app.put('/api/children/:childId/measurements/weight/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueKg, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueKg !== undefined) updateData.valueKg = Number(valueKg);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_weight').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Peso actualizado exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('âŒ Error actualizando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando peso',
      error: error.message
    });
  }
});

// Eliminar registro de peso
app.delete('/api/children/:childId/measurements/weight/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_weight').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Peso eliminado exitosamente'
    });
  } catch (error) {
    console.error('âŒ Error eliminando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando peso',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.1 MEDICIONES - ALTURA (ENDPOINTS DEDICADOS)
// ==========================================

// Obtener historial de altura
app.get('/api/children/:childId/measurements/height', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'height') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_height')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapHeightMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().height !== undefined && doc.data().height !== null)
        .map((doc) => {
          const mapped = mapHeightMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('âŒ Error obteniendo altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo altura',
      error: error.message
    });
  }
});

// Crear registro de altura
app.post('/api/children/:childId/measurements/height', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueCm === undefined || valueCm === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueCm y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueCm: Number(valueCm),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_height')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Altura registrada exitosamente',
      data: {
        id: measurementRef.id,
        ...mapHeightMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('âŒ Error registrando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando altura',
      error: error.message
    });
  }
});

// Actualizar registro de altura
app.put('/api/children/:childId/measurements/height/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueCm !== undefined) updateData.valueCm = Number(valueCm);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_height').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Altura actualizada exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('âŒ Error actualizando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando altura',
      error: error.message
    });
  }
});

// Eliminar registro de altura
app.delete('/api/children/:childId/measurements/height/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_height').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Altura eliminada exitosamente'
    });
  } catch (error) {
    console.error('âŒ Error eliminando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando altura',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.2 MEDICIONES - PERIMETRO CEFALICO (ENDPOINTS DEDICADOS)
// ==========================================

// Obtener historial de perimetro cefalico
app.get('/api/children/:childId/measurements/head', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'head') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_head')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapHeadMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().headCircumference !== undefined && doc.data().headCircumference !== null)
        .map((doc) => {
          const mapped = mapHeadMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('âŒ Error obteniendo perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo perimetro cefalico',
      error: error.message
    });
  }
});

// Crear registro de perimetro cefalico
app.post('/api/children/:childId/measurements/head', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueCm === undefined || valueCm === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueCm y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueCm: Number(valueCm),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_head')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Perimetro cefalico registrado exitosamente',
      data: {
        id: measurementRef.id,
        ...mapHeadMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('âŒ Error registrando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando perimetro cefalico',
      error: error.message
    });
  }
});

// Actualizar registro de perimetro cefalico
app.put('/api/children/:childId/measurements/head/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueCm !== undefined) updateData.valueCm = Number(valueCm);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_head').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Perimetro cefalico actualizado exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('âŒ Error actualizando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando perimetro cefalico',
      error: error.message
    });
  }
});

// Eliminar registro de perimetro cefalico
app.delete('/api/children/:childId/measurements/head/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_head').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Perimetro cefalico eliminado exitosamente'
    });
  } catch (error) {
    console.error('âŒ Error eliminando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando perimetro cefalico',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.3 MEDICIONES - RESUMEN (PANTALLA SUMMARY)
// ==========================================

app.get('/api/children/:childId/measurements/summary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const [weightPoints, heightPoints, headPoints] = childSex
      ? await Promise.all([
          getGrowthPercentilePoints(childSex, 'weight'),
          getGrowthPercentilePoints(childSex, 'height'),
          getGrowthPercentilePoints(childSex, 'head')
        ])
      : [[], [], []];

    const snapshot = await db.collection('children').doc(childId)
      .collection('measurements')
      .orderBy('date', 'desc')
      .get();

    const normalizeMeasuredAt = (value) => {
      const measuredAt = parseDateSafe(value);
      return measuredAt ? measuredAt.toISOString() : null;
    };

    const historyMap = new Map();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      const measuredAt = normalizeMeasuredAt(data.date);
      if (!measuredAt) return;
      const entry = {
        id: doc.id,
        measuredAt,
        weightKg: data.weight ?? null,
        heightCm: data.height ?? null,
        headCm: data.headCircumference ?? null,
        notes: data.notes || null,
        createdBy: data.createdBy || null
      };

      if (birthDate && measuredAt) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, measuredAt);
        if (entry.weightKg !== null && weightPoints.length > 0) {
          entry.weightPercentile = estimatePercentileFromPoint(entry.weightKg, interpolatePercentile(weightPoints, ageWeeks));
        }
        if (entry.heightCm !== null && heightPoints.length > 0) {
          entry.heightPercentile = estimatePercentileFromPoint(entry.heightCm, interpolatePercentile(heightPoints, ageWeeks));
        }
        if (entry.headCm !== null && headPoints.length > 0) {
          entry.headPercentile = estimatePercentileFromPoint(entry.headCm, interpolatePercentile(headPoints, ageWeeks));
        }
        entry.ageWeeks = ageWeeks;
      }

      historyMap.set(measuredAt, entry);
    });

    const mergeDedicated = (docs, field, mapFn, points) => {
      docs.forEach(doc => {
        const mapped = mapFn(doc);
        if (!mapped.measuredAt) return;
        const existing = historyMap.get(mapped.measuredAt);
        if (existing) {
          existing[field] = mapped.valueCm ?? mapped.valueKg ?? existing[field];
          if (!existing.createdBy && mapped.createdBy) existing.createdBy = mapped.createdBy;
          if (!existing.notes && mapped.notes) existing.notes = mapped.notes;
          if (birthDate && existing[field] !== null && points.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            existing.ageWeeks = existing.ageWeeks ?? ageWeeks;
            const percentile = estimatePercentileFromPoint(existing[field], interpolatePercentile(points, ageWeeks));
            if (field === 'weightKg') existing.weightPercentile = percentile;
            if (field === 'heightCm') existing.heightPercentile = percentile;
            if (field === 'headCm') existing.headPercentile = percentile;
          }
        } else {
          const entry = {
            id: mapped.id,
            measuredAt: mapped.measuredAt,
            weightKg: null,
            heightCm: null,
            headCm: null,
            notes: mapped.notes || null,
            createdBy: mapped.createdBy || null,
            [field]: mapped.valueCm ?? mapped.valueKg ?? null
          };
          if (birthDate && entry[field] !== null && points.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            entry.ageWeeks = ageWeeks;
            const percentile = estimatePercentileFromPoint(entry[field], interpolatePercentile(points, ageWeeks));
            if (field === 'weightKg') entry.weightPercentile = percentile;
            if (field === 'heightCm') entry.heightPercentile = percentile;
            if (field === 'headCm') entry.headPercentile = percentile;
          }
          historyMap.set(mapped.measuredAt, entry);
        }
      });
    };

    const [weightSnapshot, heightSnapshot, headSnapshot] = await Promise.all([
      db.collection('children').doc(childId).collection('measurements_weight').orderBy('measuredAt', 'desc').get(),
      db.collection('children').doc(childId).collection('measurements_height').orderBy('measuredAt', 'desc').get(),
      db.collection('children').doc(childId).collection('measurements_head').orderBy('measuredAt', 'desc').get()
    ]);

    mergeDedicated(weightSnapshot.docs, 'weightKg', mapWeightMeasurement, weightPoints);
    mergeDedicated(heightSnapshot.docs, 'heightCm', mapHeightMeasurement, heightPoints);
    mergeDedicated(headSnapshot.docs, 'headCm', mapHeadMeasurement, headPoints);

    const history = Array.from(historyMap.values()).sort((a, b) => {
      const dateA = parseDateSafe(a.measuredAt) || new Date(0);
      const dateB = parseDateSafe(b.measuredAt) || new Date(0);
      return dateB - dateA;
    });

    const latest = history[0] || null;

    res.json({
      success: true,
      data: {
        latest,
        history
      }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo resumen de mediciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo resumen de mediciones',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.4 DENTICION (ERUPCION Y CAIDA DE DIENTES)
// ==========================================

const handleTeethingSummary = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }

    const birthDate = childData.birthDate || null;
    const currentAgeMonths = birthDate ? calculateAgeFromBirthDate(birthDate) : null;
    const snapshot = await db.collection('children').doc(childId)
      .collection('teething_events')
      .orderBy('occurredAt', 'desc')
      .get();

    const latestByTooth = new Map();
    const timeline = snapshot.docs.map(doc => {
      const data = doc.data();
      const occurredAt = parseDateSafe(data.occurredAt);
      const ageMonthsAtEvent = birthDate && occurredAt ? calculateAgeInMonthsAtDate(birthDate, occurredAt) : null;
      const entry = {
        id: doc.id,
        toothId: data.toothId,
        toothName: data.toothName || null,
        type: data.type,
        occurredAt: occurredAt ? occurredAt.toISOString() : null,
        symptoms: Array.isArray(data.symptoms) ? data.symptoms : [],
        notes: data.notes || null,
        createdBy: data.createdBy || null,
        ageMonths: ageMonthsAtEvent,
        notifyToothFairy: Boolean(data.notifyToothFairy)
      };
      if (!latestByTooth.has(entry.toothId)) {
        latestByTooth.set(entry.toothId, entry);
      }
      return entry;
    });

    const teeth = TEETH_DEFINITIONS.map(def => {
      const latest = latestByTooth.get(def.id) || null;
      return {
        ...def,
        status: latest ? latest.type : 'none',
        lastEvent: latest
      };
    });

    res.json({
      success: true,
      data: {
        childId,
        ageMonths: currentAgeMonths,
        teeth,
        timeline
      }
    });
  } catch (error) {
    console.error('âŒ [TEETH] Error obteniendo resumen:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo resumen', error: error.message });
  }
};

const handleTeethingEventsList = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { month } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const birthDate = childData.birthDate || null;
    const snapshot = await db.collection('children').doc(childId)
      .collection('teething_events')
      .orderBy('occurredAt', 'desc')
      .get();
    let events = snapshot.docs.map(doc => {
      const data = doc.data();
      const occurredAt = parseDateSafe(data.occurredAt);
      const ageMonthsAtEvent = birthDate && occurredAt ? calculateAgeInMonthsAtDate(birthDate, occurredAt) : null;
      return {
        id: doc.id,
        toothId: data.toothId,
        toothName: data.toothName || null,
        type: data.type,
        occurredAt: occurredAt ? occurredAt.toISOString() : null,
        symptoms: Array.isArray(data.symptoms) ? data.symptoms : [],
        notes: data.notes || null,
        createdBy: data.createdBy || null,
        ageMonths: ageMonthsAtEvent,
        notifyToothFairy: Boolean(data.notifyToothFairy)
      };
    });

    if (month !== undefined) {
      const target = parseInt(month, 10);
      if (!Number.isNaN(target)) {
        events = events.filter(event => event.ageMonths === target);
      }
    }

    res.json({ success: true, data: events });
  } catch (error) {
    console.error('âŒ [TEETH] Error listando eventos:', error);
    res.status(500).json({ success: false, message: 'Error listando eventos', error: error.message });
  }
};

const handleTeethingEventCreate = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const rawBody = req.body || {};
    const resolvedToothId = rawBody.toothId || rawBody.tooth || rawBody.toothKey || rawBody.id;
    const resolvedType = normalizeTeethingType(rawBody.type || rawBody.eventType || rawBody.status);
    const { occurredAt, symptoms, notes } = rawBody;
    if (!resolvedToothId || !resolvedType) {
      return res.status(400).json({ success: false, message: 'toothId y type son requeridos', details: { toothId: resolvedToothId || null, type: resolvedType || null } });
    }
    const toothDef = getToothDefinition(resolvedToothId);
    if (!toothDef) {
      return res.status(400).json({ success: false, message: 'toothId invÃ¡lido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const eventDate = parseDateSafe(occurredAt) || new Date();
    const ageMonthsAtEvent = childData.birthDate ? calculateAgeInMonthsAtDate(childData.birthDate, eventDate) : null;
    const notifyToothFairy = resolvedType === 'shed' && typeof ageMonthsAtEvent === 'number' && ageMonthsAtEvent >= 48;
    const payload = {
      toothId: resolvedToothId,
      toothName: toothDef.name,
      type: resolvedType,
      occurredAt: eventDate,
      symptoms: Array.isArray(symptoms) ? symptoms : [],
      notes: notes || null,
      notifyToothFairy,
      createdBy: { uid, name: req.user.name || req.user.email || 'Usuario' },
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('children').doc(childId)
      .collection('teething_events')
      .add(payload);

    if (notifyToothFairy && childData.parentId) {
      await db.collection('notifications').add({
        userId: childData.parentId,
        type: 'tooth_fairy',
        title: 'Raton Perez',
        body: `${childData.name || 'Tu hijo'} se le cayo un diente`,
        data: {
          childId,
          toothId,
          eventId: ref.id
        },
        read: false,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    }

    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [TEETH] Error creando evento:', error);
    res.status(500).json({ success: false, message: 'Error creando evento', error: error.message });
  }
};

const handleTeethingEventUpdate = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, eventId } = req.params;
    const rawBody = req.body || {};
    const { occurredAt, symptoms, notes } = rawBody;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const eventRef = db.collection('children').doc(childId)
      .collection('teething_events').doc(eventId);
    const eventDoc = await eventRef.get();
    if (!eventDoc.exists) {
      return res.status(404).json({ success: false, message: 'Evento no encontrado' });
    }

    const updateData = { updatedAt: new Date() };
    if (rawBody.toothId !== undefined || rawBody.tooth !== undefined || rawBody.toothKey !== undefined || rawBody.id !== undefined) {
      const incomingToothId = rawBody.toothId || rawBody.tooth || rawBody.toothKey || rawBody.id;
      const toothDef = getToothDefinition(incomingToothId);
      if (!toothDef) {
        return res.status(400).json({ success: false, message: 'toothId invÃ¡lido' });
      }
      updateData.toothId = incomingToothId;
      updateData.toothName = toothDef.name;
    }
    if (rawBody.type !== undefined || rawBody.eventType !== undefined || rawBody.status !== undefined) {
      const normalizedType = normalizeTeethingType(rawBody.type || rawBody.eventType || rawBody.status);
      if (!normalizedType) {
        return res.status(400).json({ success: false, message: 'type invÃ¡lido' });
      }
      updateData.type = normalizedType;
    }
    if (occurredAt !== undefined) {
      const parsed = parseDateSafe(occurredAt);
      if (!parsed) {
        return res.status(400).json({ success: false, message: 'occurredAt invÃ¡lido' });
      }
      updateData.occurredAt = parsed;
    }
    if (symptoms !== undefined) {
      updateData.symptoms = Array.isArray(symptoms) ? symptoms : [];
    }
    if (notes !== undefined) updateData.notes = notes || null;

    const nextType = updateData.type || eventDoc.data().type;
    const nextOccurredAt = updateData.occurredAt || eventDoc.data().occurredAt;
    const ageMonthsAtEvent = childData.birthDate && nextOccurredAt
      ? calculateAgeInMonthsAtDate(childData.birthDate, nextOccurredAt)
      : null;
    const notifyToothFairy = nextType === 'shed' && typeof ageMonthsAtEvent === 'number' && ageMonthsAtEvent >= 48;
    updateData.notifyToothFairy = notifyToothFairy;

    await eventRef.update(stripUndefined(updateData));

    if (notifyToothFairy && childData.parentId && !eventDoc.data().notifyToothFairy) {
      await db.collection('notifications').add({
        userId: childData.parentId,
        type: 'tooth_fairy',
        title: 'Raton Perez',
        body: `${childData.name || 'Tu hijo'} se le cayo un diente`,
        data: {
          childId,
          toothId: updateData.toothId || eventDoc.data().toothId,
          eventId
        },
        read: false,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    }

    res.json({ success: true, data: { id: eventId, ...updateData } });
  } catch (error) {
    console.error('âŒ [TEETH] Error actualizando evento:', error);
    res.status(500).json({ success: false, message: 'Error actualizando evento', error: error.message });
  }
};

const handleTeethingEventDelete = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, eventId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    await db.collection('children').doc(childId)
      .collection('teething_events').doc(eventId).delete();
    res.json({ success: true, message: 'Evento eliminado' });
  } catch (error) {
    console.error('âŒ [TEETH] Error eliminando evento:', error);
    res.status(500).json({ success: false, message: 'Error eliminando evento', error: error.message });
  }
};

app.get('/api/children/:childId/teething/summary', authenticateToken, handleTeethingSummary);
app.get('/children/:childId/teething/summary', authenticateToken, handleTeethingSummary);

app.get('/api/children/:childId/teething/events', authenticateToken, handleTeethingEventsList);
app.get('/children/:childId/teething/events', authenticateToken, handleTeethingEventsList);

app.post('/api/children/:childId/teething/events', authenticateToken, handleTeethingEventCreate);
app.post('/children/:childId/teething/events', authenticateToken, handleTeethingEventCreate);

app.put('/api/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventUpdate);
app.put('/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventUpdate);

app.delete('/api/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventDelete);
app.delete('/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventDelete);

// ==========================================
// 6.2 CURVAS DE CRECIMIENTO (PERCENTILES)
// ==========================================

const interpolatePercentile = (points, ageWeeks) => {
  if (!points || points.length === 0) return null;
  const sorted = [...points].sort((a, b) => a.ageWeeks - b.ageWeeks);
  const exact = sorted.find(point => point.ageWeeks === ageWeeks);
  if (exact) return exact;
  let lower = null;
  let upper = null;
  for (const point of sorted) {
    if (point.ageWeeks < ageWeeks) lower = point;
    if (point.ageWeeks > ageWeeks) {
      upper = point;
      break;
    }
  }
  if (!lower) return sorted[0];
  if (!upper) return sorted[sorted.length - 1];
  const range = upper.ageWeeks - lower.ageWeeks;
  const ratio = range === 0 ? 0 : (ageWeeks - lower.ageWeeks) / range;
  const lerp = (a, b) => a + (b - a) * ratio;
  return {
    ageWeeks,
    p3: lerp(lower.p3, upper.p3),
    p10: lower.p10 !== undefined && upper.p10 !== undefined ? lerp(lower.p10, upper.p10) : undefined,
    p25: lower.p25 !== undefined && upper.p25 !== undefined ? lerp(lower.p25, upper.p25) : undefined,
    p50: lerp(lower.p50, upper.p50),
    p75: lower.p75 !== undefined && upper.p75 !== undefined ? lerp(lower.p75, upper.p75) : undefined,
    p90: lower.p90 !== undefined && upper.p90 !== undefined ? lerp(lower.p90, upper.p90) : undefined,
    p97: lerp(lower.p97, upper.p97)
  };
};

const buildDefaultPercentiles = (sex, type) => {
  const presets = {
    weight: {
      F: { start: { p3: 2.4, p50: 3.2, p97: 4.0 }, end: { p3: 5.8, p50: 7.2, p97: 8.6 } },
      M: { start: { p3: 2.5, p50: 3.3, p97: 4.1 }, end: { p3: 6.0, p50: 7.5, p97: 9.0 } }
    },
    height: {
      F: { start: { p3: 46.5, p50: 49.1, p97: 52.0 }, end: { p3: 60.5, p50: 65.0, p97: 69.5 } },
      M: { start: { p3: 47.0, p50: 49.9, p97: 53.0 }, end: { p3: 61.5, p50: 66.5, p97: 71.0 } }
    },
    head: {
      F: { start: { p3: 32.0, p50: 34.0, p97: 36.0 }, end: { p3: 40.0, p50: 42.0, p97: 44.0 } },
      M: { start: { p3: 32.5, p50: 34.5, p97: 36.5 }, end: { p3: 40.5, p50: 42.5, p97: 44.5 } }
    }
  };

  const preset = presets[type]?.[sex];
  if (!preset) return [];

  const points = [];
  const totalWeeks = 26;
  for (let week = 0; week <= totalWeeks; week += 1) {
    const ratio = totalWeeks === 0 ? 0 : week / totalWeeks;
    const lerp = (a, b) => a + (b - a) * ratio;
    points.push({
      ageWeeks: week,
      p3: lerp(preset.start.p3, preset.end.p3),
      p50: lerp(preset.start.p50, preset.end.p50),
      p97: lerp(preset.start.p97, preset.end.p97)
    });
  }
  return points;
};

const normalizeChildSex = (childData) => {
  if (!childData) return null;
  const raw = String(childData.sex || childData.gender || '').toLowerCase().trim();
  if (!raw) return null;
  if (['m', 'male', 'masculino', 'niÃ±o', 'nino', 'boy'].includes(raw)) return 'M';
  if (['f', 'female', 'femenino', 'niÃ±a', 'nina', 'girl'].includes(raw)) return 'F';
  return null;
};

const calculateWeeksBetweenDates = (startDate, endDate) => {
  const start = parseDateSafe(startDate);
  const end = parseDateSafe(endDate);
  if (!start || !end) return null;
  const diffMs = end.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  return Math.max(0, Math.floor(diffDays / 7));
};

const estimatePercentileFromPoint = (value, curvePoint) => {
  if (value === null || value === undefined || !curvePoint) return null;
  const pairs = [
    { percentile: 3, value: curvePoint.p3 },
    { percentile: 10, value: curvePoint.p10 },
    { percentile: 25, value: curvePoint.p25 },
    { percentile: 50, value: curvePoint.p50 },
    { percentile: 75, value: curvePoint.p75 },
    { percentile: 90, value: curvePoint.p90 },
    { percentile: 97, value: curvePoint.p97 }
  ].filter(entry => entry.value !== undefined && entry.value !== null)
    .sort((a, b) => a.value - b.value);

  if (pairs.length === 0) return null;
  if (value <= pairs[0].value) return pairs[0].percentile;
  if (value >= pairs[pairs.length - 1].value) return pairs[pairs.length - 1].percentile;

  for (let i = 0; i < pairs.length - 1; i += 1) {
    const lower = pairs[i];
    const upper = pairs[i + 1];
    if (value >= lower.value && value <= upper.value) {
      const range = upper.value - lower.value;
      const ratio = range === 0 ? 0 : (value - lower.value) / range;
      const percentile = lower.percentile + (upper.percentile - lower.percentile) * ratio;
      return Math.round(percentile * 10) / 10;
    }
  }
  return null;
};

const getGrowthPercentilePoints = async (sex, type) => {
  if (!db) return buildDefaultPercentiles(sex, type);
  const snapshot = await db.collection('growth_percentiles')
    .where('type', '==', type)
    .where('sex', '==', sex)
    .limit(1)
    .get();
  if (snapshot.empty) return buildDefaultPercentiles(sex, type);
  const data = snapshot.docs[0].data();
  return Array.isArray(data.points) ? data.points : [];
};

// Obtener curvas de percentiles por sexo y edad
app.get('/api/growth/percentiles', authenticateToken, async (req, res) => {
  try {
    const { sex, ageWeeks, type } = req.query;
    const sexValue = String(sex || '').toUpperCase();
    const typeValue = String(type || 'weight').toLowerCase();
    if (!sexValue || !['M', 'F'].includes(sexValue)) {
      return res.status(400).json({
        success: false,
        message: 'sex es requerido (M o F)'
      });
    }
    if (!['weight', 'height', 'head'].includes(typeValue)) {
      return res.status(400).json({
        success: false,
        message: 'type debe ser weight, height o head'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('growth_percentiles')
      .where('type', '==', typeValue)
      .where('sex', '==', sexValue)
      .limit(1)
      .get();

    if (snapshot.empty) {
      const fallbackPoints = buildDefaultPercentiles(sexValue, typeValue);
      return res.json({
        success: true,
        data: fallbackPoints,
        meta: { sex: sexValue, type: typeValue, empty: true, synthetic: true },
        message: 'Curvas de percentiles no configuradas'
      });
    }

    const curve = snapshot.docs[0].data();
    const points = Array.isArray(curve.points) ? curve.points : [];

    if (ageWeeks !== undefined) {
      const ageNumber = parseFloat(ageWeeks);
      if (Number.isNaN(ageNumber)) {
        return res.status(400).json({
          success: false,
          message: 'ageWeeks debe ser numÃ©rico'
        });
      }
      const interpolated = interpolatePercentile(points, ageNumber);
      return res.json({
        success: true,
        data: interpolated,
        meta: { sex: sexValue, type: typeValue }
      });
    }

    res.json({
      success: true,
      data: points,
      meta: { sex: sexValue, type: typeValue }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo percentiles:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo percentiles',
      error: error.message
    });
  }
});

// ==========================================
// 6. HITOS - UPDATE & DELETE
// ==========================================

// Actualizar hito
app.put('/api/children/:childId/milestones/:milestoneId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;
    const { type, title, date, description, photos, celebrationEmoji } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {};
    if (type !== undefined) updateData.type = type;
    if (title !== undefined) updateData.title = title;
    if (date !== undefined) updateData.date = new Date(date);
    if (description !== undefined) updateData.description = description;
    if (photos !== undefined) updateData.photos = photos;
    if (celebrationEmoji !== undefined) updateData.celebrationEmoji = celebrationEmoji;

    await db.collection('children').doc(childId)
      .collection('milestones').doc(milestoneId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Hito actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando hito',
      error: error.message
    });
  }
});

// Eliminar hito
app.delete('/api/children/:childId/milestones/:milestoneId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('milestones').doc(milestoneId)
      .delete();

    res.json({
      success: true,
      message: 'Hito eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hito',
      error: error.message
    });
  }
});

// ==========================================
// 7. DIARIO - UPDATE & DELETE
// ==========================================

// Actualizar entrada del diario
app.put('/api/children/:childId/diary/:diaryId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, diaryId } = req.params;
    const { date, title, content, mood, photos, tags } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (date !== undefined) updateData.date = new Date(date);
    if (title !== undefined) updateData.title = title;
    if (content !== undefined) updateData.content = content;
    if (mood !== undefined) updateData.mood = mood;
    if (photos !== undefined) updateData.photos = photos;
    if (tags !== undefined) updateData.tags = tags;

    await db.collection('children').doc(childId)
      .collection('diary').doc(diaryId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Entrada del diario actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando entrada del diario',
      error: error.message
    });
  }
});

// Eliminar entrada del diario
app.delete('/api/children/:childId/diary/:diaryId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, diaryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('diary').doc(diaryId)
      .delete();

    res.json({
      success: true,
      message: 'Entrada del diario eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando entrada del diario',
      error: error.message
    });
  }
});

// ==========================================
// 8. ÃLBUMES - UPDATE & DELETE
// ==========================================

// Actualizar Ã¡lbum
app.put('/api/children/:childId/albums/:albumId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;
    const { name, description, coverPhoto, theme } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (coverPhoto !== undefined) updateData.coverPhoto = coverPhoto;
    if (theme !== undefined) updateData.theme = theme;

    await db.collection('children').doc(childId)
      .collection('albums').doc(albumId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Ãlbum actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ Error actualizando Ã¡lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando Ã¡lbum',
      error: error.message
    });
  }
});

// Eliminar Ã¡lbum
app.delete('/api/children/:childId/albums/:albumId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('albums').doc(albumId)
      .delete();

    res.json({
      success: true,
      message: 'Ãlbum eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ Error eliminando Ã¡lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando Ã¡lbum',
      error: error.message
    });
  }
});

// ==========================================
// FIN DE ENDPOINTS CRUD ADICIONALES
// ==========================================




// Iniciar servidor
app.listen(PORT, () => {
  console.log(`ðŸš€ Servidor corriendo en puerto ${PORT}`);
  console.log(`ðŸ“± Ambiente: ${process.env.NODE_ENV || 'development'}`);
  console.log(`ðŸ”— URL: http://localhost:${PORT}`);
  console.log(`ðŸ”¥ Firebase: ${firebaseStatus}`);
});

// Manejo de seÃ±ales para cierre graceful
process.on('SIGTERM', () => {
  console.log('SIGTERM recibido, cerrando servidor...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT recibido, cerrando servidor...');
  process.exit(0);
});

module.exports = app;

// ===== SISTEMA DE APRENDIZAJE CONTINUO (RAG) =====

// FunciÃ³n para guardar conocimiento en el vector store (simulado en Firestore)
const saveKnowledge = async (text, metadata = {}) => {
  try {
    if (!db) return false;
    
    const knowledgeDoc = {
      text: text,
      metadata: {
        source: metadata.source || 'manual',
        topic: metadata.topic || 'general',
        stage: metadata.stage || 'general', // embarazo|posparto|lactancia|general
        version: metadata.version || '1.0',
        language: metadata.language || 'es',
        createdBy: metadata.createdBy || 'system',
        createdAt: new Date(),
        qualityScore: metadata.qualityScore || 1.0
      },
      // SimulaciÃ³n de embedding (en producciÃ³n usarÃ­as un servicio real)
      embedding: [0.1, 0.2, 0.3], // Placeholder
      isActive: true
    };
    
    await db.collection('knowledge_base').add(knowledgeDoc);
    console.log('ðŸ’¾ [RAG] Conocimiento guardado:', metadata.topic);
    return true;
  } catch (error) {
    console.error('âŒ [RAG] Error guardando conocimiento:', error);
    return false;
  }
};

// FunciÃ³n para recuperar conocimiento relevante
const retrieveKnowledge = async (query, filters = {}) => {
  try {
    if (!db) return [];
    
    let queryRef = db.collection('knowledge_base').where('isActive', '==', true);
    
    // Aplicar filtros
    if (filters.stage) {
      queryRef = queryRef.where('metadata.stage', '==', filters.stage);
    }
    if (filters.topic) {
      queryRef = queryRef.where('metadata.topic', '==', filters.topic);
    }
    if (filters.language) {
      queryRef = queryRef.where('metadata.language', '==', filters.language);
    }
    
    const snapshot = await queryRef.orderBy('metadata.qualityScore', 'desc').limit(5).get();
    
    const knowledge = [];
    snapshot.forEach(doc => {
      knowledge.push({
        id: doc.id,
        ...doc.data()
      });
    });
    
    console.log('ðŸ” [RAG] Conocimiento recuperado:', knowledge.length, 'fragmentos');
    return knowledge;
  } catch (error) {
    console.error('âŒ [RAG] Error recuperando conocimiento:', error);
    return [];
  }
};

// FunciÃ³n para guardar memoria del usuario
const saveUserMemory = async (userId, memoryData) => {
  try {
    if (!db) return false;
    
    const memoryDoc = {
      userId: userId,
      profile: memoryData.profile || {},
      notes: memoryData.notes || [],
      preferences: memoryData.preferences || {},
      lastUpdated: new Date()
    };
    
    await db.collection('user_memory').doc(userId).set(memoryDoc, { merge: true });
    console.log('ðŸ’¾ [MEMORY] Memoria guardada para usuario:', userId);
    return true;
  } catch (error) {
    console.error('âŒ [MEMORY] Error guardando memoria:', error);
    return false;
  }
};

// FunciÃ³n para obtener memoria del usuario
const getUserMemory = async (userId) => {
  try {
    if (!db) return null;
    
    const memoryDoc = await db.collection('user_memory').doc(userId).get();
    
    if (memoryDoc.exists) {
      console.log('ðŸ” [MEMORY] Memoria recuperada para usuario:', userId);
      return memoryDoc.data();
    }
    
    return null;
  } catch (error) {
    console.error('âŒ [MEMORY] Error obteniendo memoria:', error);
    return null;
  }
};

// FunciÃ³n para guardar Q&A validado
const saveValidatedQA = async (question, answer, tags = [], qualityScore = 1.0) => {
  try {
    if (!db) return false;
    
    const qaDoc = {
      question: question,
      answer: answer,
      tags: tags,
      qualityScore: qualityScore,
      createdAt: new Date(),
      isActive: true,
      usageCount: 0
    };
    
    await db.collection('validated_qa').add(qaDoc);
    console.log('ðŸ’¾ [QA] Q&A validado guardado');
    return true;
  } catch (error) {
    console.error('âŒ [QA] Error guardando Q&A:', error);
    return false;
  }
};

// FunciÃ³n para guardar feedback del usuario
const saveFeedback = async (userId, conversationId, feedback) => {
  try {
    if (!db) return false;
    
    const feedbackDoc = {
      userId: userId,
      conversationId: conversationId,
      feedback: feedback, // 'positive' | 'negative'
      timestamp: new Date(),
      processed: false
    };
    
    await db.collection('user_feedback').add(feedbackDoc);
    console.log('ðŸ’¾ [FEEDBACK] Feedback guardado:', feedback);
    return true;
  } catch (error) {
    console.error('âŒ [FEEDBACK] Error guardando feedback:', error);
    return false;
  }
};

// ============================================================================
// ðŸ›ï¸ MARKETPLACE - SISTEMA DE COMPRA/VENTA/DONACIÃ“N/TRUEQUE
// ============================================================================

// CategorÃ­as permitidas para productos
const MARKETPLACE_CATEGORIES = [
  'transporte',     // Carriolas, sillas de auto
  'ropa',          // Ropa de bebÃ©, mamÃ¡
  'juguetes',      // Juguetes educativos
  'alimentacion',  // Biberones, extractores
  'muebles',       // Cunas, cambiadores
  'higiene',       // BaÃ±eras, paÃ±aleras
  'libros',        // Libros infantiles
  'maternidad',    // Ropa de embarazo
  'electronica',   // Monitores, calentadores
  'otros'          // Otros artÃ­culos
];

// Condiciones del producto
const PRODUCT_CONDITIONS = [
  'nuevo',
  'como_nuevo',
  'buen_estado',
  'usado'
];

// Tipos de transacciÃ³n
const TRANSACTION_TYPES = [
  'venta',
  'donacion',
  'trueque'
];

// Estados del producto
const PRODUCT_STATUS = [
  'disponible',
  'reservado',
  'vendido',
  'donado',
  'intercambiado',
  'eliminado'
];

// ============================================================================
// ðŸ“± ENDPOINTS PARA USUARIOS - MARKETPLACE
// ============================================================================

// ðŸ” ENDPOINT DE DEBUGGING - Mostrar TODOS los productos sin filtros
app.get('/api/marketplace/products/debug', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener TODOS los productos sin ningÃºn filtro
    const snapshot = await db.collection('marketplace_products')
      .orderBy('createdAt', 'desc')
      .limit(50)
      .get();

    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      // Convertir timestamps a formato legible
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt,
      updatedAt: doc.data().updatedAt?.toDate?.() || doc.data().updatedAt,
    }));

    console.log('ðŸ” [DEBUG] Total de productos en Firebase:', products.length);
    
    res.json({
      success: true,
      message: 'Endpoint de debugging - TODOS los productos sin filtros',
      total: products.length,
      data: products
    });

  } catch (error) {
    console.error('âŒ [DEBUG] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Obtener lista de productos con filtros
app.get('/api/marketplace/products', authenticateToken, async (req, res) => {
  try {
    const { 
      type,           // venta, donacion, trueque
      category,       // transporte, ropa, etc.
      status,         // disponible, vendido, etc.
      minPrice,
      maxPrice,
      search,         // bÃºsqueda en tÃ­tulo/descripciÃ³n
      orderBy,        // reciente, precio_asc, precio_desc
      page = 1,
      limit = 20,
      userId,         // Filtrar por usuario especÃ­fico
      latitude,
      longitude
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);

    let query = db.collection('marketplace_products');
    if (userLocation.countryId) {
      query = query.where('countryId', '==', userLocation.countryId);
    }

    // Aplicar filtros
    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    // Filtrar por categorÃ­a (ahora dinÃ¡mica desde Firestore)
    // Soporta tanto slug como ID de categorÃ­a
    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      
      // Si no parece ser un ID de Firestore (muy corto o tiene guiones), buscar por slug
      if (category.length < 15 || category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category.toLowerCase())
            .limit(1)
            .get();
          
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('âš ï¸ Error buscando categorÃ­a por slug:', error);
        }
      }
      
      // Solo aplicar filtro si encontramos una categorÃ­a vÃ¡lida
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    console.log('ðŸ” [MARKETPLACE] Filtros recibidos:', { status, userId, category, type, minPrice, maxPrice, search, orderBy });
    
    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
      console.log('âœ… [MARKETPLACE] Filtrando por status:', status);
    } else {
      // Por defecto, solo mostrar productos disponibles
      query = query.where('status', '==', 'disponible');
      console.log('âœ… [MARKETPLACE] Filtrando por status por defecto: disponible');
    }

    if (userId) {
      query = query.where('userId', '==', userId);
      console.log('âœ… [MARKETPLACE] Filtrando por userId:', userId);
    }

    // Filtro de aprobaciÃ³n (deshabilitado temporalmente para compatibilidad)
    // Los productos antiguos sin isApproved se mostrarÃ¡n
    // TODO: En producciÃ³n, habilitar: query = query.where('isApproved', '==', true);

    // Ordenamiento
    switch (orderBy) {
      case 'precio_asc':
        query = query.orderBy('price', 'asc');
        break;
      case 'precio_desc':
        query = query.orderBy('price', 'desc');
        break;
      case 'reciente':
      default:
        query = query.orderBy('createdAt', 'desc');
        break;
    }

    // Ejecutar query
    const snapshot = await query.get();
    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const hasUserLocation = !isNaN(userLat) && !isNaN(userLng);

    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    // Filtro de precio (Firestore no permite where con != null)
    if (minPrice !== undefined) {
      const min = parseFloat(minPrice);
      products = products.filter(p => p.price >= min);
    }

    if (maxPrice !== undefined) {
      const max = parseFloat(maxPrice);
      products = products.filter(p => p.price <= max);
    }

    // BÃºsqueda en texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p => 
        p.title.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Ordenar por distancia si hay ubicaciÃ³n del usuario
    if (hasUserLocation && (!orderBy || orderBy === 'distancia')) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => ({
          ...p,
          distance: calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          )
        }))
        .sort((a, b) => a.distance - b.distance);
    }

    // Logging de productos encontrados
    console.log(`ðŸ“Š [MARKETPLACE] Productos encontrados: ${products.length}`);
    if (products.length > 0) {
      const statusCounts = products.reduce((acc, p) => {
        acc[p.status] = (acc[p.status] || 0) + 1;
        return acc;
      }, {});
      console.log('ðŸ“Š [MARKETPLACE] DistribuciÃ³n por status:', statusCounts);
    }
    
    // PaginaciÃ³n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    console.log(`ðŸ“„ [MARKETPLACE] Devolviendo pÃ¡gina ${page}: ${paginatedProducts.length} productos (de ${total} totales)`);

    res.json({
      success: true,
      data: paginatedProducts,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});
// Buscar productos cercanos (por proximidad geogrÃ¡fica)
app.get('/api/marketplace/products/nearby', authenticateToken, async (req, res) => {
  try {
    const cacheKey = `${buildCacheKey(req)}&uid=${req.user.uid}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const {
      latitude,
      longitude,
      radius = 50,    // Radio en kilÃ³metros (por defecto 50 km)
      type,
      category,
      status,
      minPrice,
      maxPrice,
      search,
      orderBy,
      page = 1,
      limit = 20
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);
    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const searchRadius = parseFloat(radius);
    const hasUserLocation = !isNaN(userLat) && !isNaN(userLng);

    if ((latitude || longitude) && !hasUserLocation) {
      return res.status(400).json({
        success: false,
        message: 'Latitude y longitude deben ser nÃºmeros vÃ¡lidos'
      });
    }
    // FunciÃ³n para calcular distancia entre dos puntos (fÃ³rmula de Haversine)
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371; // Radio de la Tierra en km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // Distancia en km
    };

    let query = db.collection('marketplace_products');

    // Aplicar filtros bÃ¡sicos
    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    // Filtrar por categorÃ­a (ahora dinÃ¡mica desde Firestore)
    // Soporta tanto slug como ID de categorÃ­a
    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      
      // Si no parece ser un ID de Firestore (muy corto o tiene guiones), buscar por slug
      if (category.length < 15 || category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category.toLowerCase())
            .limit(1)
            .get();
          
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('âš ï¸ Error buscando categorÃ­a por slug:', error);
        }
      }
      
      // Solo aplicar filtro si encontramos una categorÃ­a vÃ¡lida
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    } else {
      query = query.where('status', '==', 'disponible');
    }

    // Filtro de aprobaciÃ³n (deshabilitado temporalmente para compatibilidad)
    // Los productos antiguos sin isApproved se mostrarÃ¡n
    // TODO: En producciÃ³n, habilitar: query = query.where('isApproved', '==', true);

    // Obtener todos los productos
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    if (hasUserLocation && (!orderBy || orderBy === 'distancia')) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => ({
          ...p,
          distance: calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          )
        }))
        .filter(p => p.distance <= parseFloat(radius));
    }

    // Filtrar por distancia y calcular distancia para cada producto
    products = products
      .filter(p => p.location && p.location.latitude && p.location.longitude)
      .map(p => {
        const distance = calculateDistance(
          userLat, 
          userLng, 
          p.location.latitude, 
          p.location.longitude
        );
        return { ...p, distance };
      })
      .filter(p => p.distance <= searchRadius);

    // Filtro de precio
    if (minPrice !== undefined) {
      const min = parseFloat(minPrice);
      products = products.filter(p => p.price >= min);
    }

    if (maxPrice !== undefined) {
      const max = parseFloat(maxPrice);
      products = products.filter(p => p.price <= max);
    }

    // BÃºsqueda en texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p => 
        p.title.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Ordenamiento
    const orderByNormalized = orderBy || 'distancia';
    switch (orderByNormalized) {
      case 'distancia':
        products.sort((a, b) => a.distance - b.distance);
        break;
      case 'precio_asc':
        products.sort((a, b) => (a.price || 0) - (b.price || 0));
        break;
      case 'precio_desc':
        products.sort((a, b) => (b.price || 0) - (a.price || 0));
        break;
      case 'reciente':
      default:
        products.sort((a, b) => b.createdAt.seconds - a.createdAt.seconds);
        break;
    }

    // PaginaciÃ³n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    const responsePayload = {
      success: true,
      data: paginatedProducts,
      searchParams: {
        latitude: userLat,
        longitude: userLng,
        radius: searchRadius
      },
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error buscando productos cercanos:', error);
    res.status(500).json({
      success: false,
      message: 'Error buscando productos cercanos',
      error: error.message
    });
  }
});

// Top productos cercanos por vistas (APP)
app.get('/api/marketplace/products/nearby/top', authenticateToken, async (req, res) => {
  try {
    const cacheKey = `${buildCacheKey(req)}&uid=${req.user.uid}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const {
      latitude,
      longitude,
      radius = 50,
      type,
      category,
      status,
      limit = 3
    } = req.query;

    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const searchRadius = parseFloat(radius);
    const limitNumber = Math.min(parseInt(limit), 10);

    if ((latitude || longitude) && (isNaN(userLat) || userLat < -90 || userLat > 90)) {
      return res.status(400).json({
        success: false,
        message: 'Latitud invÃ¡lida'
      });
    }

    if ((latitude || longitude) && (isNaN(userLng) || userLng < -180 || userLng > 180)) {
      return res.status(400).json({
        success: false,
        message: 'Longitud invÃ¡lida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    };

    let query = db.collection('marketplace_products');

    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      if (typeof category === 'string' && category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category)
            .limit(1)
            .get();
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('âš ï¸ Error buscando categorÃ­a por slug:', error);
        }
      }
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    } else {
      query = query.where('status', '==', 'disponible');
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    if (!isNaN(userLat) && !isNaN(userLng)) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => {
          const distance = calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          );
          return { ...p, distance };
        })
        .filter(p => p.distance <= searchRadius);
    }

    products.sort((a, b) => {
      const aViews = a.views || 0;
      const bViews = b.views || 0;
      if (bViews !== aViews) return bViews - aViews;
      if (a.distance !== b.distance) return a.distance - b.distance;
      return (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0);
    });

    const topProducts = products.slice(0, limitNumber);

    const responsePayload = {
      success: true,
      data: topProducts,
      meta: {
        latitude: !isNaN(userLat) ? userLat : null,
        longitude: !isNaN(userLng) ? userLng : null,
        radius: searchRadius,
        limit: limitNumber
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo top productos cercanos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo top productos cercanos',
      error: error.message
    });
  }
});

// Obtener detalle de un producto especÃ­fico
app.get('/api/marketplace/products/:id', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    
    // Enriquecer con informaciÃ³n actualizada del vendedor
    const sellerDoc = await db.collection('users').doc(productData.userId).get();
    let enrichedProduct = {
      id: productDoc.id,
      ...productData,
      location: normalizeMarketplaceLocation(productData)
    };
    
    if (sellerDoc.exists) {
      const sellerData = sellerDoc.data();
      enrichedProduct.userName = sellerData.displayName || sellerData.name || productData.userName || 'Usuario';
      enrichedProduct.userPhoto = sellerData.photoUrl || productData.userPhoto || null;
      console.log(`âœ… [MARKETPLACE] Producto ${id} enriquecido con info del vendedor: ${enrichedProduct.userName}`);
    } else {
      console.log(`âš ï¸ [MARKETPLACE] Vendedor ${productData.userId} no encontrado para producto ${id}`);
    }

    // Incrementar contador de vistas
    await db.collection('marketplace_products').doc(id).update({
      views: admin.firestore.FieldValue.increment(1)
    });

    res.json({
      success: true,
      data: enrichedProduct
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo producto',
      error: error.message
    });
  }
});

// Crear nuevo producto
app.post('/api/marketplace/products', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const {
      title,
      description,
      category,
      condition,
      photos,
      type,
      price,
      tradeFor,
      location,
      cityId,
      countryId
    } = req.body;

    // Validaciones
    if (!title || title.trim().length < 10 || title.trim().length > 100) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ­tulo debe tener entre 10 y 100 caracteres'
      });
    }

    if (!description || description.trim().length < 20 || description.trim().length > 1000) {
      return res.status(400).json({
        success: false,
        message: 'La descripciÃ³n debe tener entre 20 y 1000 caracteres'
      });
    }

    // Validar categorÃ­a dinÃ¡mica desde Firestore
    if (!category) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la categorÃ­a existe y estÃ¡ activa (buscar por slug o por ID)
    let categoryDoc;
    let categoryId;
    
    // Primero intentar buscar por ID
    categoryDoc = await db.collection('marketplace_categories').doc(category).get();
    
    if (categoryDoc.exists) {
      categoryId = categoryDoc.id;
    } else {
      // Si no existe por ID, buscar por slug
      const categoryQuery = await db.collection('marketplace_categories')
        .where('slug', '==', category.toLowerCase())
        .limit(1)
        .get();
      
      if (categoryQuery.empty) {
        return res.status(400).json({
          success: false,
          message: 'CategorÃ­a invÃ¡lida o no existe'
        });
      }
      
      categoryDoc = categoryQuery.docs[0];
      categoryId = categoryDoc.id;
    }

    const categoryData = categoryDoc.data();
    if (!categoryData.isActive) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a no estÃ¡ disponible'
      });
    }

    if (!condition || !PRODUCT_CONDITIONS.includes(condition)) {
      return res.status(400).json({
        success: false,
        message: 'CondiciÃ³n del producto invÃ¡lida'
      });
    }

    if (!photos || !Array.isArray(photos) || photos.length === 0 || photos.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'Debes subir entre 1 y 5 fotos'
      });
    }

    if (!type || !TRANSACTION_TYPES.includes(type)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de transacciÃ³n invÃ¡lido'
      });
    }

    if (type === 'venta') {
      if (!price || price <= 0) {
        return res.status(400).json({
          success: false,
          message: 'El precio es requerido para ventas y debe ser mayor a 0'
        });
      }
    }

    if (type === 'trueque') {
      if (!tradeFor || tradeFor.trim().length < 5) {
        return res.status(400).json({
          success: false,
          message: 'Debes especificar quÃ© buscas a cambio'
        });
      }
    }

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    if (!cityId && !countryId) {
      locationData = await getDefaultUserLocation();
    } else {
      try {
        locationData = await resolveCountryCity(countryId, cityId);
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    let normalizedLocation = {
      city: locationData.cityName || '',
      state: '',
      country: locationData.countryName || null
    };
    if (location && typeof location === 'object') {
      const hasLat = location.latitude !== undefined && location.latitude !== null;
      const hasLng = location.longitude !== undefined && location.longitude !== null;
      normalizedLocation.city = location.city || locationData.cityName || '';
      normalizedLocation.state = location.state || '';
      normalizedLocation.country = location.country || locationData.countryName || null;
      if (hasLat || hasLng) {
        const lat = parseFloat(location.latitude);
        const lng = parseFloat(location.longitude);
        if (!isNaN(lat) && !isNaN(lng)) {
          normalizedLocation.latitude = lat;
          normalizedLocation.longitude = lng;
        }
      }
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener informaciÃ³n del usuario
    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();

    // Crear producto
    const now = new Date();
    const productData = {
      userId: uid,
      userName: userData?.displayName || userData?.name || 'Usuario',
      userPhoto: userData?.photoUrl || null,
      
      title: title.trim(),
      description: description.trim(),
      category: categoryId,  // Guardar el ID real de la categorÃ­a
      categoryName: categoryData.name,  // Guardar el nombre para facilitar consultas
      categorySlug: categoryData.slug,  // Guardar el slug para referencia
      condition,
      photos,
      
      type,
      price: type === 'venta' ? parseFloat(price) : null,
      tradeFor: type === 'trueque' ? tradeFor.trim() : null,
      
      location: normalizedLocation,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      
      status: 'disponible',
      
      views: 0,
      favorites: 0,
      messages: 0,
      
      createdAt: now,
      updatedAt: now,
      publishedAt: now,
      soldAt: null,
      
      isApproved: true,  // Auto-aprobar por ahora
      isReported: false,
      reportCount: 0
    };

    const productRef = await db.collection('marketplace_products').add(productData);

    console.log('âœ… [MARKETPLACE] Producto creado:', productRef.id);

    res.json({
      success: true,
      message: 'Producto publicado exitosamente',
      data: {
        id: productRef.id,
        ...productData
      }
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error creando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando producto',
      error: error.message
    });
  }
});

// Actualizar producto propio
app.put('/api/marketplace/products/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;
    const {
      title,
      description,
      category,
      condition,
      photos,
      price,
      tradeFor,
      location,
      cityId,
      countryId
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el producto existe y pertenece al usuario
    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para editar este producto'
      });
    }

    // Preparar datos de actualizaciÃ³n
    const updateData = {
      updatedAt: new Date()
    };

    if (title) {
      if (title.trim().length < 10 || title.trim().length > 100) {
        return res.status(400).json({
          success: false,
          message: 'El tÃ­tulo debe tener entre 10 y 100 caracteres'
        });
      }
      updateData.title = title.trim();
    }

    if (description) {
      if (description.trim().length < 20 || description.trim().length > 1000) {
        return res.status(400).json({
          success: false,
          message: 'La descripciÃ³n debe tener entre 20 y 1000 caracteres'
        });
      }
      updateData.description = description.trim();
    }

    if (category) {
      // Verificar que la categorÃ­a existe y estÃ¡ activa (buscar por slug o por ID)
      let categoryDoc;
      let categoryId;
      
      // Primero intentar buscar por ID
      categoryDoc = await db.collection('marketplace_categories').doc(category).get();
      
      if (categoryDoc.exists) {
        categoryId = categoryDoc.id;
      } else {
        // Si no existe por ID, buscar por slug
        const categoryQuery = await db.collection('marketplace_categories')
          .where('slug', '==', category.toLowerCase())
          .limit(1)
          .get();
        
        if (categoryQuery.empty) {
          return res.status(400).json({
            success: false,
            message: 'CategorÃ­a invÃ¡lida o no existe'
          });
        }
        
        categoryDoc = categoryQuery.docs[0];
        categoryId = categoryDoc.id;
      }

      const categoryData = categoryDoc.data();
      if (!categoryData.isActive) {
        return res.status(400).json({
          success: false,
          message: 'La categorÃ­a no estÃ¡ disponible'
        });
      }

      updateData.category = categoryId;
      updateData.categoryName = categoryData.name;
      updateData.categorySlug = categoryData.slug;
    }

    if (condition) {
      if (!PRODUCT_CONDITIONS.includes(condition)) {
        return res.status(400).json({
          success: false,
          message: 'CondiciÃ³n del producto invÃ¡lida'
        });
      }
      updateData.condition = condition;
    }

    if (photos) {
      if (!Array.isArray(photos) || photos.length === 0 || photos.length > 5) {
        return res.status(400).json({
          success: false,
          message: 'Debes tener entre 1 y 5 fotos'
        });
      }
      updateData.photos = photos;
    }

    if (price !== undefined) {
      if (productDoc.data().type === 'venta' && price <= 0) {
        return res.status(400).json({
          success: false,
          message: 'El precio debe ser mayor a 0'
        });
      }
      updateData.price = parseFloat(price);
    }

    if (tradeFor) {
      updateData.tradeFor = tradeFor.trim();
    }

    const hasLocationUpdate = Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId');
    if (hasLocationUpdate) {
      try {
        const locationData = await resolveCountryCity(countryId, cityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    if (location) {
      // Validar coordenadas si se proporciona ubicaciÃ³n
      if (location.latitude && location.longitude) {
        const lat = parseFloat(location.latitude);
        const lng = parseFloat(location.longitude);
        
        if (isNaN(lat) || lat < -90 || lat > 90) {
          return res.status(400).json({
            success: false,
            message: 'Latitud invÃ¡lida (debe estar entre -90 y 90)'
          });
        }

        if (isNaN(lng) || lng < -180 || lng > 180) {
          return res.status(400).json({
            success: false,
            message: 'Longitud invÃ¡lida (debe estar entre -180 y 180)'
          });
        }

        updateData.location = {
          latitude: lat,
          longitude: lng,
          city: location.city || '',
          state: location.state || '',
          country: location.country || updateData.countryName || 'MÃ©xico'
        };
      } else {
        return res.status(400).json({
          success: false,
          message: 'Las coordenadas (latitude, longitude) son requeridas'
        });
      }
    }

    await db.collection('marketplace_products').doc(id).update(updateData);

    console.log('âœ… [MARKETPLACE] Producto actualizado:', id);

    res.json({
      success: true,
      message: 'Producto actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error actualizando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando producto',
      error: error.message
    });
  }
});

// Eliminar producto propio (soft delete)
app.delete('/api/marketplace/products/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el producto existe y pertenece al usuario
    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar este producto'
      });
    }

    // Soft delete
    await db.collection('marketplace_products').doc(id).update({
      status: 'eliminado',
      updatedAt: new Date()
    });

    console.log('âœ… [MARKETPLACE] Producto eliminado:', id);

    res.json({
      success: true,
      message: 'Producto eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Cambiar estado del producto
app.patch('/api/marketplace/products/:id/status', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;
    const { status, buyerId, buyerName } = req.body;

    if (!status || !PRODUCT_STATUS.includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Estado invÃ¡lido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para cambiar el estado de este producto'
      });
    }

    const now = new Date();
    const updateData = {
      status,
      updatedAt: now
    };

    // Si se marca como vendido/donado/intercambiado, guardar fecha y crear transacciÃ³n
    if (['vendido', 'donado', 'intercambiado'].includes(status)) {
      updateData.soldAt = now;

      // Crear transacciÃ³n
      const productData = productDoc.data();
      const transactionData = {
        productId: id,
        productTitle: productData.title,
        sellerId: uid,
        sellerName: productData.userName,
        buyerId: buyerId || null,
        buyerName: buyerName || 'No especificado',
        type: productData.type,
        amount: productData.price || 0,
        tradeDetails: productData.tradeFor || null,
        status: 'completada',
        createdAt: now,
        completedAt: now
      };

      await db.collection('marketplace_transactions').add(transactionData);
      console.log('âœ… [MARKETPLACE] TransacciÃ³n creada para producto:', id);

      // Notificar a todos los usuarios que chatearon sobre este producto
      try {
        const productData = productDoc.data();
        console.log('ðŸ“¢ [MARKETPLACE] Buscando usuarios que chatearon sobre el producto:', id);
        
        // Obtener todos los mensajes relacionados con este producto
        const messagesSnapshot = await db.collection('marketplace_messages')
          .where('productId', '==', id)
          .get();

        // Recopilar IDs Ãºnicos de usuarios (excluyendo al vendedor)
        const interestedUserIds = new Set();
        messagesSnapshot.docs.forEach(doc => {
          const msgData = doc.data();
          if (msgData.senderId !== uid) {
            interestedUserIds.add(msgData.senderId);
          }
          if (msgData.receiverId !== uid) {
            interestedUserIds.add(msgData.receiverId);
          }
        });

        console.log(`ðŸ“¢ [MARKETPLACE] ${interestedUserIds.size} usuarios interesados encontrados`);

        // Enviar notificaciÃ³n a cada usuario interesado
        for (const userId of interestedUserIds) {
          try {
            // Obtener tokens FCM del usuario
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists || !userDoc.data().fcmTokens || userDoc.data().fcmTokens.length === 0) {
              console.log(`âš ï¸ [MARKETPLACE] Usuario ${userId} sin tokens FCM`);
              continue;
            }

            const tokens = userDoc.data().fcmTokens;
            const statusText = status === 'vendido' ? 'vendiÃ³' : status === 'donado' ? 'donÃ³' : 'intercambiÃ³';

            // Enviar push notification
            await sendPushNotification(
              tokens,
              {
                title: 'ðŸ›ï¸ ArtÃ­culo vendido',
                body: `${productData.title} ya se ${statusText}. Â¡Gracias por tu interÃ©s!`
              },
              {
                type: 'compra',
                productId: id,
                productTitle: productData.title,
                status: status,
                sellerId: uid
              }
            );

            // Guardar notificaciÃ³n en Firestore para historial
            await db.collection('notifications').add({
              userId: userId,
              type: 'compra',
              title: 'ðŸ›ï¸ ArtÃ­culo vendido',
              message: `${productData.title} ya se ${statusText}. Â¡Gracias por tu interÃ©s!`,
              data: {
                productId: id,
                productTitle: productData.title,
                status: status,
                sellerId: uid
              },
              read: false,
              createdAt: now
            });

            console.log(`âœ… [MARKETPLACE] NotificaciÃ³n enviada a usuario ${userId}`);

          } catch (userError) {
            console.error(`âŒ [MARKETPLACE] Error notificando a usuario ${userId}:`, userError.message);
          }
        }

      } catch (notifyError) {
        console.error('âŒ [MARKETPLACE] Error enviando notificaciones:', notifyError.message);
        // No fallar el endpoint si las notificaciones fallan
      }
    }

    await db.collection('marketplace_products').doc(id).update(updateData);

    console.log('âœ… [MARKETPLACE] Estado actualizado:', id, '->', status);
    console.log('ðŸ“ [MARKETPLACE] Datos actualizados:', JSON.stringify(updateData, null, 2));
    
    // Verificar que se guardÃ³ correctamente
    const updatedDoc = await db.collection('marketplace_products').doc(id).get();
    const updatedData = updatedDoc.data();
    console.log('ðŸ” [MARKETPLACE] VerificaciÃ³n - Status en BD:', updatedData.status);

    res.json({
      success: true,
      message: 'Estado actualizado exitosamente',
      data: {
        ...updateData,
        currentStatus: updatedData.status // Incluir el status actual de la BD
      }
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error actualizando estado:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estado',
      error: error.message
    });
  }
});

// Obtener productos propios
app.get('/api/marketplace/my-products', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { status } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_products')
      .where('userId', '==', uid);

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo productos propios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// ============================================================================
// â­ FAVORITOS
// ============================================================================

// Obtener favoritos del usuario
app.get('/api/marketplace/favorites', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const favoritesSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const productIds = favoritesSnapshot.docs.map(doc => doc.data().productId);

    if (productIds.length === 0) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener productos favoritos
    const productsSnapshot = await db.collection('marketplace_products')
      .where(admin.firestore.FieldPath.documentId(), 'in', productIds.slice(0, 10))
      .get();

    const products = productsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo favoritos',
      error: error.message
    });
  }
});

// Agregar producto a favoritos
app.post('/api/marketplace/favorites/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar si ya estÃ¡ en favoritos
    const existingFavorite = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .where('productId', '==', productId)
      .get();

    if (!existingFavorite.empty) {
      return res.status(400).json({
        success: false,
        message: 'El producto ya estÃ¡ en favoritos'
      });
    }

    // Agregar a favoritos
    await db.collection('marketplace_favorites').add({
      userId: uid,
      productId,
      createdAt: new Date()
    });

    // Incrementar contador en el producto
    await db.collection('marketplace_products').doc(productId).update({
      favorites: admin.firestore.FieldValue.increment(1)
    });

    console.log('âœ… [MARKETPLACE] Producto agregado a favoritos:', productId);

    res.json({
      success: true,
      message: 'Producto agregado a favoritos'
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error agregando a favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando a favoritos',
      error: error.message
    });
  }
});

// Quitar producto de favoritos
app.delete('/api/marketplace/favorites/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar y eliminar favorito
    const favoriteSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .where('productId', '==', productId)
      .get();

    if (favoriteSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'El producto no estÃ¡ en favoritos'
      });
    }

    // Eliminar todos los documentos encontrados
    const batch = db.batch();
    favoriteSnapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();

    // Decrementar contador en el producto
    await db.collection('marketplace_products').doc(productId).update({
      favorites: admin.firestore.FieldValue.increment(-1)
    });

    console.log('âœ… [MARKETPLACE] Producto quitado de favoritos:', productId);

    res.json({
      success: true,
      message: 'Producto quitado de favoritos'
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error quitando de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error quitando de favoritos',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ’¬ MENSAJES
// ============================================================================

// Obtener conversaciones del usuario
app.get('/api/marketplace/messages', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener mensajes donde el usuario es sender o receiver
    const sentMessages = await db.collection('marketplace_messages')
      .where('senderId', '==', uid)
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();

    const receivedMessages = await db.collection('marketplace_messages')
      .where('receiverId', '==', uid)
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();

    const allMessages = [
      ...sentMessages.docs.map(doc => ({ id: doc.id, ...doc.data() })),
      ...receivedMessages.docs.map(doc => ({ id: doc.id, ...doc.data() }))
    ];

    // Agrupar por producto
    const conversationsByProduct = {};
    allMessages.forEach(msg => {
      if (!conversationsByProduct[msg.productId]) {
        conversationsByProduct[msg.productId] = [];
      }
      conversationsByProduct[msg.productId].push(msg);
    });

    res.json({
      success: true,
      data: conversationsByProduct
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo mensajes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// Obtener mensajes de un producto especÃ­fico
app.get('/api/marketplace/messages/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const messagesSnapshot = await db.collection('marketplace_messages')
      .where('productId', '==', productId)
      .orderBy('createdAt', 'asc')
      .get();

    let messages = messagesSnapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() }))
      .filter(msg => msg.senderId === uid || msg.receiverId === uid);

    // Enriquecer mensajes con informaciÃ³n actual de usuarios
    const usersCache = {};
    const userIds = new Set();
    
    // Recolectar todos los IDs de usuarios Ãºnicos
    messages.forEach(msg => {
      if (msg.senderId) userIds.add(msg.senderId);
      if (msg.receiverId) userIds.add(msg.receiverId);
    });

    console.log(`ðŸ” [MARKETPLACE] Enriqueciendo ${messages.length} mensajes con info de ${userIds.size} usuarios`);

    // Obtener informaciÃ³n de todos los usuarios de una vez
    for (const userId of userIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          usersCache[userId] = userDoc.data();
          const userName = usersCache[userId].displayName || usersCache[userId].name || 'Usuario';
          console.log(`âœ… [MARKETPLACE] Usuario ${userId}: ${userName}, foto: ${usersCache[userId].photoUrl ? 'SÃ­' : 'No'}`);
        } else {
          console.log(`âš ï¸ [MARKETPLACE] Usuario ${userId} no encontrado en Firestore`);
        }
      } catch (error) {
        console.error(`âŒ [MARKETPLACE] Error obteniendo usuario ${userId}:`, error);
      }
    }

    // Enriquecer cada mensaje con la informaciÃ³n actualizada
    messages = messages.map(msg => {
      const enrichedMsg = { ...msg };

      // Enriquecer informaciÃ³n del sender - usar displayName o name (consistente con el resto del cÃ³digo)
      if (msg.senderId && usersCache[msg.senderId]) {
        enrichedMsg.senderName = usersCache[msg.senderId].displayName || usersCache[msg.senderId].name || 'Usuario';
        enrichedMsg.senderPhoto = usersCache[msg.senderId].photoUrl || null;
      } else if (msg.senderId) {
        console.log(`âš ï¸ [MARKETPLACE] No se encontrÃ³ info para sender: ${msg.senderId}`);
        enrichedMsg.senderName = enrichedMsg.senderName || 'Usuario';
        enrichedMsg.senderPhoto = null;
      }

      // Enriquecer informaciÃ³n del receiver - usar displayName o name (consistente con el resto del cÃ³digo)
      if (msg.receiverId && usersCache[msg.receiverId]) {
        enrichedMsg.receiverName = usersCache[msg.receiverId].displayName || usersCache[msg.receiverId].name || 'Usuario';
        enrichedMsg.receiverPhoto = usersCache[msg.receiverId].photoUrl || null;
      } else if (msg.receiverId) {
        console.log(`âš ï¸ [MARKETPLACE] No se encontrÃ³ info para receiver: ${msg.receiverId}`);
        enrichedMsg.receiverName = enrichedMsg.receiverName || 'Usuario';
        enrichedMsg.receiverPhoto = null;
      }

      return enrichedMsg;
    });

    console.log(`âœ… [MARKETPLACE] ${messages.length} mensajes enriquecidos para producto ${productId}`);

    res.json({
      success: true,
      data: messages
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo mensajes del producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// Enviar mensaje
app.post('/api/marketplace/messages', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId, message } = req.body;

    if (!productId || !message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Producto y mensaje son requeridos'
      });
    }

    if (message.trim().length > 500) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje no puede exceder 500 caracteres'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener info del producto y del sender
    const productDoc = await db.collection('marketplace_products').doc(productId).get();
    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    const userDoc = await db.collection('users').doc(uid).get();
    
    if (!userDoc.exists) {
      console.log(`âš ï¸ [MARKETPLACE] Usuario ${uid} no encontrado en Firestore`);
    }
    
    const userData = userDoc.exists ? userDoc.data() : {};
    
    console.log(`ðŸ” [MARKETPLACE] Datos del sender (${uid}):`);
    console.log(`   - Existe en Firestore: ${userDoc.exists}`);
    console.log(`   - displayName: ${userData.displayName || 'NO TIENE'}`);
    console.log(`   - name: ${userData.name || 'NO TIENE'}`);
    console.log(`   - Foto: ${userData.photoUrl || 'NO TIENE'}`);
    console.log(`   - Es dueÃ±o del producto: ${uid === productData.userId}`);

    // Determinar quiÃ©n es el receptor del mensaje
    let receiverId;
    
    // Si el que envÃ­a es el dueÃ±o del producto, buscar al otro usuario en los mensajes previos
    if (uid === productData.userId) {
      console.log(`ðŸ“¨ [MARKETPLACE] El sender es el dueÃ±o del producto, buscando al otro usuario...`);
      
      // Buscar mensajes previos de este producto donde el sender NO sea el dueÃ±o
      const previousMessagesSnapshot = await db.collection('marketplace_messages')
        .where('productId', '==', productId)
        .where('senderId', '!=', uid)
        .orderBy('senderId')
        .orderBy('createdAt', 'desc')
        .limit(1)
        .get();
      
      if (!previousMessagesSnapshot.empty) {
        receiverId = previousMessagesSnapshot.docs[0].data().senderId;
        console.log(`âœ… [MARKETPLACE] Receiver encontrado: ${receiverId}`);
      } else {
        // Si no hay mensajes previos, puede ser que el dueÃ±o estÃ© iniciando la conversaciÃ³n
        // (caso raro, pero posible). En este caso, no hay a quiÃ©n enviar notificaciÃ³n.
        console.log(`âš ï¸ [MARKETPLACE] El dueÃ±o estÃ¡ enviando el primer mensaje, no hay receptor conocido`);
        return res.status(400).json({
          success: false,
          message: 'No se puede iniciar una conversaciÃ³n como dueÃ±o del producto'
        });
      }
    } else {
      // Si el que envÃ­a NO es el dueÃ±o, el receptor es el dueÃ±o del producto
      receiverId = productData.userId;
      console.log(`âœ… [MARKETPLACE] El receiver es el dueÃ±o del producto: ${receiverId}`);
    }

    // Obtener informaciÃ³n del receiver
    const receiverDoc = await db.collection('users').doc(receiverId).get();
    const receiverData = receiverDoc.exists ? receiverDoc.data() : {};
    
    console.log(`ðŸ” [MARKETPLACE] Datos del receiver (${receiverId}):`);
    console.log(`   - Existe en Firestore: ${receiverDoc.exists}`);
    console.log(`   - displayName: ${receiverData.displayName || 'NO TIENE'}`);
    console.log(`   - name: ${receiverData.name || 'NO TIENE'}`);
    console.log(`   - Foto: ${receiverData.photoUrl || 'NO TIENE'}`);

    // Crear mensaje - usar displayName o name (consistente con el resto del cÃ³digo)
    const messageData = {
      productId,
      senderId: uid,
      senderName: userData?.displayName || userData?.name || 'Usuario',
      senderPhoto: userData?.photoUrl || null,
      receiverId: receiverId,
      receiverName: receiverData?.displayName || receiverData?.name || productData.userName || 'Usuario',
      receiverPhoto: receiverData?.photoUrl || null,
      message: message.trim(),
      isRead: false,
      createdAt: new Date()
    };
    
    console.log(`ðŸ“ [MARKETPLACE] Mensaje a guardar:`, {
      senderName: messageData.senderName,
      senderPhoto: messageData.senderPhoto ? 'SÃ­' : 'No',
      receiverName: messageData.receiverName,
      receiverPhoto: messageData.receiverPhoto ? 'SÃ­' : 'No'
    });

    const messageRef = await db.collection('marketplace_messages').add(messageData);

    // Incrementar contador de mensajes en el producto
    await db.collection('marketplace_products').doc(productId).update({
      messages: admin.firestore.FieldValue.increment(1)
    });

    console.log('âœ… [MARKETPLACE] Mensaje enviado:', messageRef.id);

    // Enviar notificaciÃ³n push al destinatario
    try {
      // Verificar que el receiver no sea el mismo que el sender
      if (uid === receiverId) {
        console.log(`âš ï¸ [MARKETPLACE] No se envÃ­a notificaciÃ³n: sender y receiver son el mismo usuario (${uid})`);
      } else {
        const receiverTokens = receiverData?.fcmTokens || [];
        
        if (receiverTokens.length > 0) {
          console.log(`ðŸ“¤ [MARKETPLACE] Enviando notificaciÃ³n push a ${receiverId}`);
        
        const senderFullName = userData?.displayName || userData?.name || 'Usuario';
        
        const notification = {
          title: `ðŸ’¬ Nuevo mensaje de ${senderFullName}`,
          body: message.trim().length > 100 ? message.trim().substring(0, 100) + '...' : message.trim()
        };

        const notificationData = {
          type: 'new_message',
          senderId: uid,
          senderName: senderFullName,
          senderPhoto: userData?.photoUrl || null,
          productId: productId,
          productTitle: productData.title || 'Producto',
          screen: 'ChatScreen',
          chatId: `${productId}_${uid}_${receiverId}`
        };

        const pushResult = await sendPushNotification(receiverTokens, notification, notificationData);
        
        if (pushResult.success) {
          console.log(`âœ… [MARKETPLACE] NotificaciÃ³n enviada: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);
        } else {
          console.log(`âš ï¸ [MARKETPLACE] No se pudo enviar notificaciÃ³n: ${pushResult.error || pushResult.message}`);
        }

        // Guardar notificaciÃ³n en Firestore
        await db.collection('notifications').add({
          userId: receiverId,
          type: 'new_message',
          title: notification.title,
          body: notification.body,
          data: notificationData,
          read: false,
          createdAt: admin.firestore.Timestamp.fromDate(new Date())
        });
        
        console.log('âœ… [MARKETPLACE] NotificaciÃ³n guardada en Firestore');
        } else {
          console.log('âš ï¸ [MARKETPLACE] El destinatario no tiene tokens FCM registrados');
        }
      }
    } catch (notificationError) {
      console.error('âŒ [MARKETPLACE] Error enviando notificaciÃ³n push:', notificationError);
      // No fallar el envÃ­o del mensaje si falla la notificaciÃ³n
    }

    res.json({
      success: true,
      message: 'Mensaje enviado exitosamente',
      data: {
        id: messageRef.id,
        ...messageData
      }
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error enviando mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando mensaje',
      error: error.message
    });
  }
});

// Marcar mensaje como leÃ­do
app.patch('/api/marketplace/messages/:id/read', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const messageDoc = await db.collection('marketplace_messages').doc(id).get();

    if (!messageDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Mensaje no encontrado'
      });
    }

    // Solo el receptor puede marcar como leÃ­do
    if (messageDoc.data().receiverId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para marcar este mensaje'
      });
    }

    await db.collection('marketplace_messages').doc(id).update({
      isRead: true
    });

    res.json({
      success: true,
      message: 'Mensaje marcado como leÃ­do'
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error marcando mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando mensaje',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ“Š TRANSACCIONES
// ============================================================================

// Obtener transacciones del usuario
app.get('/api/marketplace/transactions', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener transacciones donde el usuario es vendedor o comprador
    const asSellerSnapshot = await db.collection('marketplace_transactions')
      .where('sellerId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const asBuyerSnapshot = await db.collection('marketplace_transactions')
      .where('buyerId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const transactions = [
      ...asSellerSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        role: 'vendedor'
      })),
      ...asBuyerSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        role: 'comprador'
      }))
    ].sort((a, b) => b.createdAt - a.createdAt);

    res.json({
      success: true,
      data: transactions
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error obteniendo transacciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo transacciones',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸš¨ REPORTES
// ============================================================================

// Reportar un producto
app.post('/api/marketplace/reports', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId, reason, description } = req.body;

    const validReasons = [
      'spam',
      'fraude',
      'contenido_inapropiado',
      'precio_incorrecto',
      'informacion_falsa',
      'otro'
    ];

    if (!productId || !reason || !validReasons.includes(reason)) {
      return res.status(400).json({
        success: false,
        message: 'Producto y razÃ³n vÃ¡lida son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();

    const reportData = {
      productId,
      reportedBy: uid,
      reporterName: userData?.name || 'Usuario',
      reason,
      description: description || '',
      status: 'pendiente',
      reviewedBy: null,
      reviewedAt: null,
      actionTaken: null,
      createdAt: new Date()
    };

    const reportRef = await db.collection('marketplace_reports').add(reportData);

    // Incrementar contador de reportes en el producto
    await db.collection('marketplace_products').doc(productId).update({
      reportCount: admin.firestore.FieldValue.increment(1),
      isReported: true
    });

    console.log('âœ… [MARKETPLACE] Reporte creado:', reportRef.id);

    res.json({
      success: true,
      message: 'Reporte enviado exitosamente. Lo revisaremos pronto.',
      data: {
        id: reportRef.id,
        ...reportData
      }
    });

  } catch (error) {
    console.error('âŒ [MARKETPLACE] Error creando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando reporte',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ› ï¸ ENDPOINTS PARA ADMINISTRADOR - MARKETPLACE
// ============================================================================

// Ver todos los productos (incluye eliminados y pendientes)
app.get('/api/admin/marketplace/products', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status, isReported } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_products');

    if (status) {
      query = query.where('status', '==', status);
    }

    if (isReported === 'true') {
      query = query.where('isReported', '==', true);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Aprobar un producto
app.patch('/api/admin/marketplace/products/:id/approve', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved: true,
      updatedAt: new Date()
    });

    console.log('âœ… [ADMIN] Producto aprobado:', id);

    res.json({
      success: true,
      message: 'Producto aprobado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error aprobando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error aprobando producto',
      error: error.message
    });
  }
});

// Rechazar un producto
app.patch('/api/admin/marketplace/products/:id/reject', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved: false,
      status: 'eliminado',
      updatedAt: new Date()
    });

    console.log('âœ… [ADMIN] Producto rechazado:', id);

    res.json({
      success: true,
      message: 'Producto rechazado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error rechazando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando producto',
      error: error.message
    });
  }
});

// Eliminar permanentemente un producto
app.delete('/api/admin/marketplace/products/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).delete();

    console.log('âœ… [ADMIN] Producto eliminado permanentemente:', id);

    res.json({
      success: true,
      message: 'Producto eliminado permanentemente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Ver todos los reportes
app.get('/api/admin/marketplace/reports', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_reports');

    if (status) {
      query = query.where('status', '==', status);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const reports = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: reports
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo reportes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reportes',
      error: error.message
    });
  }
});

// Revisar y tomar acciÃ³n sobre un reporte
app.patch('/api/admin/marketplace/reports/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { actionTaken } = req.body;

    if (!actionTaken) {
      return res.status(400).json({
        success: false,
        message: 'AcciÃ³n tomada es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_reports').doc(id).update({
      status: 'revisado',
      reviewedBy: req.user.uid,
      reviewedAt: new Date(),
      actionTaken
    });

    console.log('âœ… [ADMIN] Reporte revisado:', id);

    res.json({
      success: true,
      message: 'Reporte procesado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error procesando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando reporte',
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas del marketplace
app.get('/api/admin/marketplace/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todos los productos
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    // Obtener todas las transacciones
    const transactionsSnapshot = await db.collection('marketplace_transactions').get();
    const transactions = transactionsSnapshot.docs.map(doc => doc.data());

    // Calcular estadÃ­sticas
    const stats = {
      totalProducts: products.length,
      productsByType: {
        venta: products.filter(p => p.type === 'venta').length,
        donacion: products.filter(p => p.type === 'donacion').length,
        trueque: products.filter(p => p.type === 'trueque').length
      },
      productsByStatus: {
        disponible: products.filter(p => p.status === 'disponible').length,
        vendido: products.filter(p => p.status === 'vendido').length,
        donado: products.filter(p => p.status === 'donado').length,
        intercambiado: products.filter(p => p.status === 'intercambiado').length,
        eliminado: products.filter(p => p.status === 'eliminado').length
      },
      productsByCategory: MARKETPLACE_CATEGORIES.reduce((acc, cat) => {
        acc[cat] = products.filter(p => p.category === cat).length;
        return acc;
      }, {}),
      totalTransactions: transactions.length,
      totalRevenue: transactions
        .filter(t => t.type === 'venta')
        .reduce((sum, t) => sum + (t.amount || 0), 0),
      reportedProducts: products.filter(p => p.isReported).length,
      averageViews: products.length > 0 
        ? Math.round(products.reduce((sum, p) => sum + (p.views || 0), 0) / products.length)
        : 0
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// Ver todas las transacciones
app.get('/api/admin/marketplace/transactions', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('marketplace_transactions')
      .orderBy('createdAt', 'desc')
      .get();

    const transactions = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: transactions
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo transacciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo transacciones',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ“… ENDPOINTS ADMIN - GESTIÃ“N DE EVENTOS
// ============================================================================

// Obtener todos los eventos (admin dashboard)
app.get('/api/admin/events', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { 
      status, 
      communityId, 
      page = 1, 
      limit = 20,
      sortBy = 'date',  // date, created, attendees, checkins
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Query base
    let query = db.collection('posts').where('postType', '==', 'event');

    // Aplicar filtros
    if (communityId) {
      query = query.where('communityId', '==', communityId);
    }

    // Obtener todos los eventos
    const snapshot = await query.get();

    let events = [];
    const now = new Date();

    for (const doc of snapshot.docs) {
      const eventPost = doc.data();
      
      if (!eventPost.eventData) continue;

      const eventDate = eventPost.eventData.eventDate.toDate();
      
      // Filtrar por status si se especifica
      if (status) {
        if (status === 'upcoming' && eventDate < now) continue;
        if (status === 'past' && eventDate >= now) continue;
        if (status === 'cancelled' && eventPost.eventData.status !== 'cancelled') continue;
      }

      // Obtener datos del autor y comunidad
      let authorData = { displayName: 'Usuario Desconocido' };
      let communityName = 'Comunidad';

      try {
        const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
        if (authorDoc.exists) {
          const data = authorDoc.data();
          authorData = {
            id: eventPost.authorId,
            displayName: data.displayName || data.name || 'Usuario',
            email: data.email || null,
            photoUrl: data.photoUrl || null
          };
        }

        const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
        if (communityDoc.exists) {
          communityName = communityDoc.data().name || 'Comunidad';
        }
      } catch (error) {
        console.warn(`âš ï¸ [ADMIN] Error obteniendo datos adicionales:`, error.message);
      }

      // Calcular mÃ©tricas
      const attendeeCount = eventPost.eventData.attendeeCount || 0;
      const checkedInCount = eventPost.eventData.checkedInCount || 0;
      const waitlistCount = eventPost.eventData.waitlistCount || 0;
      const attendanceRate = attendeeCount > 0 ? (checkedInCount / attendeeCount) * 100 : 0;

      events.push({
        id: doc.id,
        title: eventPost.eventData.title,
        description: eventPost.eventData.description || '',
        eventDate: eventPost.eventData.eventDate,
        eventEndDate: eventPost.eventData.eventEndDate || null,
        location: eventPost.eventData.location || null,
        status: eventPost.eventData.status,
        isBanner: eventPost.eventData.isBanner || false,  // NUEVO: estado de banner
        
        // MÃ©tricas
        attendeeCount,
        checkedInCount,
        waitlistCount,
        maxAttendees: eventPost.eventData.maxAttendees || null,
        attendanceRate: Math.round(attendanceRate),
        
        // Info adicional
        author: authorData,
        communityId: eventPost.communityId,
        communityName,
        imageUrl: eventPost.imageUrl || null,
        
        // Interacciones
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0,
        
        // Fechas
        createdAt: eventPost.createdAt,
        updatedAt: eventPost.updatedAt
      });
    }

    // Ordenar
    events.sort((a, b) => {
      switch (sortBy) {
        case 'date':
          const dateA = a.eventDate.toDate();
          const dateB = b.eventDate.toDate();
          return order === 'desc' ? dateB - dateA : dateA - dateB;
        
        case 'created':
          const createdA = a.createdAt.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
          const createdB = b.createdAt.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
          return order === 'desc' ? createdB - createdA : createdA - createdB;
        
        case 'attendees':
          return order === 'desc' 
            ? b.attendeeCount - a.attendeeCount 
            : a.attendeeCount - b.attendeeCount;
        
        case 'checkins':
          return order === 'desc' 
            ? b.checkedInCount - a.checkedInCount 
            : a.checkedInCount - b.checkedInCount;
        
        default:
          return 0;
      }
    });

    // PaginaciÃ³n
    const total = events.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedEvents = events.slice(startIndex, endIndex);

    // Calcular estadÃ­sticas generales
    const stats = {
      total: total,
      upcoming: events.filter(e => e.eventDate.toDate() >= now && e.status !== 'cancelled').length,
      past: events.filter(e => e.eventDate.toDate() < now).length,
      cancelled: events.filter(e => e.status === 'cancelled').length,
      totalAttendees: events.reduce((sum, e) => sum + e.attendeeCount, 0),
      totalCheckins: events.reduce((sum, e) => sum + e.checkedInCount, 0),
      totalWaitlist: events.reduce((sum, e) => sum + e.waitlistCount, 0),
      averageAttendanceRate: events.length > 0 
        ? Math.round(events.reduce((sum, e) => sum + e.attendanceRate, 0) / events.length)
        : 0
    };

    res.json({
      success: true,
      data: paginatedEvents,
      stats,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo eventos',
      error: error.message
    });
  }
});

// Obtener detalle completo de un evento (admin)
app.get('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el evento
    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event' || !eventPost.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Obtener datos del autor
    let authorData = { displayName: 'Usuario Desconocido' };
    try {
      const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
      if (authorDoc.exists) {
        const data = authorDoc.data();
        authorData = {
          id: eventPost.authorId,
          displayName: data.displayName || data.name || 'Usuario',
          email: data.email || null,
          photoUrl: data.photoUrl || null
        };
      }
    } catch (error) {
      console.warn(`âš ï¸ [ADMIN] Error obteniendo autor:`, error.message);
    }

    // Obtener datos de la comunidad
    let communityData = { name: 'Comunidad' };
    try {
      const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
      if (communityDoc.exists) {
        const data = communityDoc.data();
        communityData = {
          id: eventPost.communityId,
          name: data.name || 'Comunidad',
          imageUrl: data.imageUrl || null,
          memberCount: data.members?.length || 0
        };
      }
    } catch (error) {
      console.warn(`âš ï¸ [ADMIN] Error obteniendo comunidad:`, error.message);
    }

    // Obtener lista detallada de asistentes
    const attendeeIds = eventPost.eventData.attendees || [];
    const attendeesList = [];
    
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const data = attendeeDoc.data();
          const checkedIn = (eventPost.eventData.checkedInAttendees || []).includes(attendeeId);
          const checkInTime = eventPost.eventData.checkInTimes?.[attendeeId] || null;
          
          attendeesList.push({
            userId: attendeeId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null,
            checkedIn,
            checkInTime
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [ADMIN] Error obteniendo asistente ${attendeeId}:`, error.message);
      }
    }

    // Obtener lista de espera
    const waitlistIds = eventPost.eventData.waitlist || [];
    const waitlistList = [];
    
    for (const userId of waitlistIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const data = userDoc.data();
          waitlistList.push({
            userId: userId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [ADMIN] Error obteniendo usuario en espera ${userId}:`, error.message);
      }
    }

    // Construir respuesta completa
    const response = {
      id: eventId,
      postType: eventPost.postType,
      content: eventPost.content,
      imageUrl: eventPost.imageUrl || null,
      
      eventData: {
        title: eventPost.eventData.title,
        description: eventPost.eventData.description || '',
        eventDate: eventPost.eventData.eventDate,
        eventEndDate: eventPost.eventData.eventEndDate || null,
        location: eventPost.eventData.location || null,
        status: eventPost.eventData.status,
        isBanner: eventPost.eventData.isBanner || false,  // NUEVO: estado de banner
        bannerUpdatedAt: eventPost.eventData.bannerUpdatedAt || null,  // NUEVO: cuÃ¡ndo se marcÃ³ como banner
        maxAttendees: eventPost.eventData.maxAttendees || null,
        checkInCode: eventPost.eventData.checkInCode || null,
        requiresConfirmation: eventPost.eventData.requiresConfirmation || false
      },
      
      author: authorData,
      community: communityData,
      
      attendees: attendeesList,
      waitlist: waitlistList,
      
      metrics: {
        attendeeCount: attendeesList.length,
        checkedInCount: attendeesList.filter(a => a.checkedIn).length,
        waitlistCount: waitlistList.length,
        attendanceRate: attendeesList.length > 0 
          ? Math.round((attendeesList.filter(a => a.checkedIn).length / attendeesList.length) * 100)
          : 0,
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0
      },
      
      dates: {
        createdAt: eventPost.createdAt,
        updatedAt: eventPost.updatedAt,
        publishedAt: eventPost.publishedAt || eventPost.createdAt
      }
    };

    res.json({
      success: true,
      data: response
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalle de evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de evento',
      error: error.message
    });
  }
});

// Cancelar evento (admin)
app.patch('/api/admin/events/:eventId/cancel', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { reason } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Actualizar estado
    await db.collection('posts').doc(eventId).update({
      'eventData.status': 'cancelled',
      'eventData.cancelledAt': new Date(),
      'eventData.cancelReason': reason || 'Cancelado por administrador',
      updatedAt: new Date()
    });

    // Notificar a todos los asistentes y lista de espera
    try {
      const { sendEventCancelled } = require('./services/emailService');
      const attendees = eventPost.eventData.attendees || [];
      const waitlist = eventPost.eventData.waitlist || [];
      const allUsers = [...attendees, ...waitlist];

      if (allUsers.length > 0) {
        const usersPromises = allUsers.map(async (userId) => {
          try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists) {
              const userData = userDoc.data();
              
              // ðŸ“§ Enviar email de cancelaciÃ³n
              if (userData.email) {
                sendEventCancelled(
                  userData.displayName || userData.name || 'MamÃ¡',
                  userData.email,
                  {
                    id: eventId,
                    title: eventPost.eventData.title,
                    description: eventPost.content || eventPost.eventData.description,
                    eventDate: eventPost.eventData.eventDate,
                    location: eventPost.eventData.location || { name: 'Por definir', address: '' }
                  },
                  reason || 'Cancelado por administrador'
                ).catch(err => console.error('âŒ [EMAIL] Error enviando cancelaciÃ³n:', err));
              }
              
              return { userId, tokens: userData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`âš ï¸ [ADMIN] Error obteniendo tokens del usuario ${userId}:`, error.message);
          }
          return { userId, tokens: [] };
        });

        const usersWithTokens = await Promise.all(usersPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);

        if (allTokens.length > 0) {
          const notification = {
            title: 'âŒ Evento cancelado',
            body: `El evento "${eventPost.eventData.title}" ha sido cancelado por el administrador${reason ? ': ' + reason : ''}`
          };

          const notificationData = {
            type: 'event_cancelled_admin',
            postId: eventId,
            screen: 'CommunityPostScreen'
          };

          await sendPushNotification(allTokens, notification, notificationData);
          console.log(`âœ… [ADMIN] Notificaciones de cancelaciÃ³n enviadas a ${allUsers.length} usuarios`);
        }
      }
    } catch (notificationError) {
      console.error('âŒ [ADMIN] Error enviando notificaciones:', notificationError);
    }

    console.log(`âœ… [ADMIN] Evento ${eventId} cancelado por admin`);

    res.json({
      success: true,
      message: 'Evento cancelado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error cancelando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando evento',
      error: error.message
    });
  }
});

// Editar evento (admin)
app.put('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { 
      title, 
      description, 
      content,              // NUEVO: contenido del post
      imageUrl,             // NUEVO: imagen del post
      eventDate, 
      eventEndDate, 
      location,
      maxAttendees,
      requiresConfirmation,
      status
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Preparar datos de actualizaciÃ³n
    const updateData = {
      updatedAt: new Date()
    };

    // Actualizar campos del post (nivel superior)
    if (content !== undefined) {
      updateData['content'] = content.trim();
    }

    if (imageUrl !== undefined) {
      updateData['imageUrl'] = imageUrl || null;
    }

    // Actualizar solo los campos de eventData que se proporcionan
    if (title !== undefined) {
      if (!title || title.trim().length < 3) {
        return res.status(400).json({
          success: false,
          message: 'El tÃ­tulo debe tener al menos 3 caracteres'
        });
      }
      updateData['eventData.title'] = title.trim();
    }

    if (description !== undefined) {
      updateData['eventData.description'] = description.trim();
    }

    if (eventDate !== undefined) {
      try {
        const parsedDate = new Date(eventDate);
        if (isNaN(parsedDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'Fecha del evento invÃ¡lida'
          });
        }
        updateData['eventData.eventDate'] = parsedDate;
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: 'Formato de fecha invÃ¡lido'
        });
      }
    }

    if (eventEndDate !== undefined) {
      if (eventEndDate) {
        try {
          const parsedEndDate = new Date(eventEndDate);
          if (isNaN(parsedEndDate.getTime())) {
            return res.status(400).json({
              success: false,
              message: 'Fecha de fin del evento invÃ¡lida'
            });
          }
          updateData['eventData.eventEndDate'] = parsedEndDate;
        } catch (error) {
          return res.status(400).json({
            success: false,
            message: 'Formato de fecha de fin invÃ¡lido'
          });
        }
      } else {
        updateData['eventData.eventEndDate'] = null;
      }
    }

    if (location !== undefined) {
      updateData['eventData.location'] = location;
    }

    if (maxAttendees !== undefined) {
      if (maxAttendees !== null) {
        const maxAttendeesNum = parseInt(maxAttendees);
        if (isNaN(maxAttendeesNum) || maxAttendeesNum < 1) {
          return res.status(400).json({
            success: false,
            message: 'El mÃ¡ximo de asistentes debe ser un nÃºmero positivo'
          });
        }
        
        // Verificar que el nuevo mÃ¡ximo no sea menor que los asistentes actuales
        const currentAttendees = eventPost.eventData?.attendeeCount || 0;
        if (maxAttendeesNum < currentAttendees) {
          return res.status(400).json({
            success: false,
            message: `No puedes reducir el lÃ­mite a ${maxAttendeesNum} porque ya hay ${currentAttendees} asistentes confirmados`
          });
        }
        
        updateData['eventData.maxAttendees'] = maxAttendeesNum;
      } else {
        updateData['eventData.maxAttendees'] = null;
      }
    }

    if (requiresConfirmation !== undefined) {
      updateData['eventData.requiresConfirmation'] = Boolean(requiresConfirmation);
    }

    if (status !== undefined) {
      const validStatuses = ['active', 'cancelled', 'completed'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          success: false,
          message: `Estado invÃ¡lido. Debe ser: ${validStatuses.join(', ')}`
        });
      }
      updateData['eventData.status'] = status;
    }

    // Actualizar el evento
    await db.collection('posts').doc(eventId).update(updateData);

    console.log(`âœ… [ADMIN] Evento ${eventId} actualizado por admin ${req.user.uid}`);

    // Obtener el evento actualizado completo (como el GET /api/admin/events/:eventId)
    const updatedEventDoc = await db.collection('posts').doc(eventId).get();
    const updatedEventPost = updatedEventDoc.data();

    // Obtener datos del autor
    let authorData = { displayName: 'Usuario Desconocido' };
    try {
      const authorDoc = await db.collection('users').doc(updatedEventPost.authorId).get();
      if (authorDoc.exists) {
        const data = authorDoc.data();
        authorData = {
          id: updatedEventPost.authorId,
          displayName: data.displayName || data.name || 'Usuario',
          email: data.email || null,
          photoUrl: data.photoUrl || null
        };
      }
    } catch (error) {
      console.warn(`âš ï¸ [ADMIN] Error obteniendo autor:`, error.message);
    }

    // Obtener datos de la comunidad
    let communityData = { name: 'Comunidad' };
    try {
      const communityDoc = await db.collection('communities').doc(updatedEventPost.communityId).get();
      if (communityDoc.exists) {
        const data = communityDoc.data();
        communityData = {
          id: updatedEventPost.communityId,
          name: data.name || 'Comunidad',
          imageUrl: data.imageUrl || null,
          memberCount: data.members?.length || 0
        };
      }
    } catch (error) {
      console.warn(`âš ï¸ [ADMIN] Error obteniendo comunidad:`, error.message);
    }

    // Obtener lista detallada de asistentes
    const attendeeIds = updatedEventPost.eventData.attendees || [];
    const attendeesList = [];
    
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const data = attendeeDoc.data();
          const checkedIn = (updatedEventPost.eventData.checkedInAttendees || []).includes(attendeeId);
          const checkInTime = updatedEventPost.eventData.checkInTimes?.[attendeeId] || null;
          
          attendeesList.push({
            userId: attendeeId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null,
            checkedIn,
            checkInTime
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [ADMIN] Error obteniendo asistente ${attendeeId}:`, error.message);
      }
    }

    // Obtener lista de espera
    const waitlistIds = updatedEventPost.eventData.waitlist || [];
    const waitlistList = [];
    
    for (const userId of waitlistIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const data = userDoc.data();
          waitlistList.push({
            userId: userId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`âš ï¸ [ADMIN] Error obteniendo usuario en espera ${userId}:`, error.message);
      }
    }

    // Construir respuesta completa (igual que GET /api/admin/events/:eventId)
    const response = {
      id: eventId,
      postType: updatedEventPost.postType,
      content: updatedEventPost.content,
      imageUrl: updatedEventPost.imageUrl || null,
      
      eventData: {
        title: updatedEventPost.eventData.title,
        description: updatedEventPost.eventData.description || '',
        eventDate: updatedEventPost.eventData.eventDate,
        eventEndDate: updatedEventPost.eventData.eventEndDate || null,
        location: updatedEventPost.eventData.location || null,
        status: updatedEventPost.eventData.status,
        isBanner: updatedEventPost.eventData.isBanner || false,
        bannerUpdatedAt: updatedEventPost.eventData.bannerUpdatedAt || null,
        maxAttendees: updatedEventPost.eventData.maxAttendees || null,
        checkInCode: updatedEventPost.eventData.checkInCode || null,
        requiresConfirmation: updatedEventPost.eventData.requiresConfirmation || false
      },
      
      author: authorData,
      community: communityData,
      
      attendees: attendeesList,
      waitlist: waitlistList,
      
      metrics: {
        attendeeCount: attendeesList.length,
        checkedInCount: attendeesList.filter(a => a.checkedIn).length,
        waitlistCount: waitlistList.length,
        attendanceRate: attendeesList.length > 0 
          ? Math.round((attendeesList.filter(a => a.checkedIn).length / attendeesList.length) * 100)
          : 0,
        likeCount: updatedEventPost.likeCount || 0,
        commentCount: updatedEventPost.commentCount || 0
      },
      
      dates: {
        createdAt: updatedEventPost.createdAt,
        updatedAt: updatedEventPost.updatedAt,
        publishedAt: updatedEventPost.publishedAt || updatedEventPost.createdAt
      }
    };

    res.json({
      success: true,
      message: 'Evento actualizado exitosamente',
      data: response
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando evento',
      error: error.message
    });
  }
});

// Eliminar evento (admin)
app.delete('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    // Eliminar el documento
    await db.collection('posts').doc(eventId).delete();

    console.log(`âœ… [ADMIN] Evento ${eventId} eliminado permanentemente`);

    res.json({
      success: true,
      message: 'Evento eliminado permanentemente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando evento',
      error: error.message
    });
  }
});

// Marcar/desmarcar evento como banner (admin)
app.patch('/api/admin/events/:eventId/banner', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { 
      isBanner, 
      section = 'home',        // 'home', 'communities', 'marketplace', etc.
      order = 1,               // Orden de apariciÃ³n
      duration = 5,            // DuraciÃ³n en carrusel (segundos)
      publishNow = true        // Si se publica inmediatamente o no
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (typeof isBanner !== 'boolean') {
      return res.status(400).json({
        success: false,
        message: 'El campo isBanner debe ser un booleano'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaciÃ³n no es un evento'
      });
    }

    // Si se estÃ¡ marcando como banner, verificar que el evento no estÃ© cancelado
    if (isBanner && eventPost.eventData?.status === 'cancelled') {
      return res.status(400).json({
        success: false,
        message: 'No se puede marcar como banner un evento cancelado'
      });
    }

    // Preparar datos de actualizaciÃ³n
    const updateData = {
      'eventData.isBanner': isBanner,
      'eventData.bannerUpdatedAt': new Date(),
      'eventData.bannerUpdatedBy': req.user.uid,
      updatedAt: new Date()
    };

    // Si se estÃ¡ marcando como banner, agregar configuraciÃ³n
    if (isBanner) {
      updateData['eventData.bannerSection'] = section;
      updateData['eventData.bannerOrder'] = parseInt(order);
      updateData['eventData.bannerDuration'] = parseInt(duration);
      
      // Si publishNow es true, se publica inmediatamente
      // Si es false, se puede configurar una fecha especÃ­fica de publicaciÃ³n
      if (publishNow) {
        updateData['eventData.bannerPublishedAt'] = new Date();
      }
    }

    // Actualizar estado de banner
    await db.collection('posts').doc(eventId).update(updateData);

    console.log(`âœ… [ADMIN] Evento ${eventId} ${isBanner ? 'marcado' : 'desmarcado'} como banner`);
    if (isBanner) {
      console.log(`   - SecciÃ³n: ${section}, Orden: ${order}, DuraciÃ³n: ${duration}s`);
    }

    res.json({
      success: true,
      message: isBanner ? 'Evento marcado como banner' : 'Banner removido del evento',
      data: {
        eventId,
        isBanner,
        ...(isBanner && {
          section,
          order,
          duration,
          publishedAt: publishNow ? new Date() : null
        })
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estado de banner',
      error: error.message
    });
  }
});

// EstadÃ­sticas de eventos (admin dashboard)
app.get('/api/admin/events/stats/summary', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventsSnapshot = await db.collection('posts')
      .where('postType', '==', 'event')
      .get();

    const events = eventsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    const now = new Date();

    // EstadÃ­sticas generales
    const stats = {
      totalEvents: events.length,
      upcomingEvents: events.filter(e => {
        const eventDate = e.eventData?.eventDate?.toDate();
        return eventDate && eventDate >= now && e.eventData.status !== 'cancelled';
      }).length,
      pastEvents: events.filter(e => {
        const eventDate = e.eventData?.eventDate?.toDate();
        return eventDate && eventDate < now;
      }).length,
      cancelledEvents: events.filter(e => e.eventData?.status === 'cancelled').length,
      
      totalAttendees: events.reduce((sum, e) => sum + (e.eventData?.attendeeCount || 0), 0),
      totalCheckins: events.reduce((sum, e) => sum + (e.eventData?.checkedInCount || 0), 0),
      totalWaitlist: events.reduce((sum, e) => sum + (e.eventData?.waitlistCount || 0), 0),
      
      averageAttendeesPerEvent: events.length > 0
        ? Math.round(events.reduce((sum, e) => sum + (e.eventData?.attendeeCount || 0), 0) / events.length)
        : 0,
      
      averageAttendanceRate: events.length > 0
        ? Math.round(events.reduce((sum, e) => {
            const attendees = e.eventData?.attendeeCount || 0;
            const checkins = e.eventData?.checkedInCount || 0;
            return sum + (attendees > 0 ? (checkins / attendees) * 100 : 0);
          }, 0) / events.length)
        : 0,
      
      eventsWithWaitlist: events.filter(e => (e.eventData?.waitlistCount || 0) > 0).length,
      eventsWithCheckIn: events.filter(e => (e.eventData?.checkedInCount || 0) > 0).length,
      
      // Top comunidades con mÃ¡s eventos
      topCommunities: Object.entries(
        events.reduce((acc, e) => {
          acc[e.communityId] = (acc[e.communityId] || 0) + 1;
          return acc;
        }, {})
      )
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([communityId, count]) => ({ communityId, eventCount: count })),
      
      // Eventos por mes (Ãºltimos 6 meses)
      eventsByMonth: {},
      
      // Engagement
      totalLikes: events.reduce((sum, e) => sum + (e.likeCount || 0), 0),
      totalComments: events.reduce((sum, e) => sum + (e.commentCount || 0), 0)
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas de eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ·ï¸ CATEGORÃAS DINÃMICAS PARA MARKETPLACE
// ============================================================================

// Obtener todas las categorÃ­as (pÃºblico)
app.get('/api/marketplace/categories', async (req, res) => {
  try {
    const { includeInactive } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_categories');

    // Si no es admin o no se especifica, solo mostrar activas
    if (!includeInactive || includeInactive !== 'true') {
      query = query.where('isActive', '==', true);
    }

    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();
    const categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: categories
    });

  } catch (error) {
    console.error('âŒ [CATEGORIES] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Obtener detalle de una categorÃ­a
app.get('/api/marketplace/categories/:id', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        ...categoryDoc.data()
      }
    });

  } catch (error) {
    console.error('âŒ [CATEGORIES] Error obteniendo categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­a',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ› ï¸ ADMIN - GESTIÃ“N DE PRODUCTOS
// ============================================================================

// Listar todos los productos (Admin) - con filtros y paginaciÃ³n
app.get('/api/admin/marketplace/items', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 100,
      search = '',
      status = '',
      type = '',
      category = '',
      userId = '',
      orderBy = 'createdAt',
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Construir query base
    let query = db.collection('marketplace_products');

    // Aplicar filtros
    if (status) {
      query = query.where('status', '==', status);
    }

    if (type) {
      query = query.where('type', '==', type);
    }

    if (userId) {
      query = query.where('userId', '==', userId);
    }

    // Ordenar
    const orderDirection = order === 'asc' ? 'asc' : 'desc';
    query = query.orderBy(orderBy, orderDirection);

    // Obtener todos los productos
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtro por categorÃ­a (puede ser slug o ID)
    if (category) {
      products = products.filter(p => 
        p.category === category || 
        p.categorySlug === category
      );
    }

    // BÃºsqueda por texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p =>
        p.title?.toLowerCase().includes(searchLower) ||
        p.description?.toLowerCase().includes(searchLower) ||
        p.userName?.toLowerCase().includes(searchLower) ||
        p.categoryName?.toLowerCase().includes(searchLower)
      );
    }

    // PaginaciÃ³n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    console.log('âœ… [ADMIN] Productos del marketplace obtenidos:', paginatedProducts.length);

    res.json({
      success: true,
      data: paginatedProducts,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos del marketplace',
      error: error.message
    });
  }
});

// Ver detalles completos de un producto (Admin)
app.get('/api/admin/marketplace/items/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const product = {
      id: productDoc.id,
      ...productDoc.data()
    };

    // Obtener informaciÃ³n del usuario vendedor
    let userInfo = null;
    if (product.userId) {
      const userDoc = await db.collection('users').doc(product.userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userInfo = {
          id: product.userId,
          name: userData.name,
          email: userData.email,
          phone: userData.phone,
          photoUrl: userData.photoUrl,
          createdAt: userData.createdAt
        };
      }
    }

    console.log('âœ… [ADMIN] Detalles del producto obtenidos:', id);

    res.json({
      success: true,
      data: {
        product,
        user: userInfo
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalles del producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalles del producto',
      error: error.message
    });
  }
});

// Aprobar/Rechazar producto (Admin)
app.patch('/api/admin/marketplace/items/:id/approve', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { isApproved, reason = '' } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved,
      moderationReason: reason,
      moderatedAt: admin.firestore.Timestamp.fromDate(new Date()),
      moderatedBy: req.user.uid,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`âœ… [ADMIN] Producto ${isApproved ? 'aprobado' : 'rechazado'}:`, id);

    res.json({
      success: true,
      message: `Producto ${isApproved ? 'aprobado' : 'rechazado'} exitosamente`
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error moderando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error moderando producto',
      error: error.message
    });
  }
});

// Eliminar producto (Admin)
app.delete('/api/admin/marketplace/items/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    // Marcar como eliminado en lugar de borrar
    await db.collection('marketplace_products').doc(id).update({
      status: 'eliminado',
      deletedAt: admin.firestore.Timestamp.fromDate(new Date()),
      deletedBy: req.user.uid,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log('âœ… [ADMIN] Producto eliminado:', id);

    res.json({
      success: true,
      message: 'Producto eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Listar mensajes/chats del marketplace (Admin)
app.get('/api/admin/marketplace/messages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      productId = '',
      userId = '',
      orderBy = 'createdAt',
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_messages');

    if (productId) {
      query = query.where('productId', '==', productId);
    }

    if (userId) {
      query = query.where('participants', 'array-contains', userId);
    }

    const orderDirection = order === 'asc' ? 'asc' : 'desc';
    query = query.orderBy(orderBy, orderDirection);

    const snapshot = await query.get();
    let messages = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // PaginaciÃ³n
    const total = messages.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedMessages = messages.slice(startIndex, endIndex);

    console.log('âœ… [ADMIN] Mensajes obtenidos:', paginatedMessages.length);

    res.json({
      success: true,
      data: paginatedMessages,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo mensajes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// EstadÃ­sticas del marketplace (Admin)
app.get('/api/admin/marketplace/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // EstadÃ­sticas de productos
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    const productStats = {
      total: products.length,
      disponible: products.filter(p => p.status === 'disponible').length,
      vendido: products.filter(p => p.status === 'vendido').length,
      reservado: products.filter(p => p.status === 'reservado').length,
      eliminado: products.filter(p => p.status === 'eliminado').length,
      venta: products.filter(p => p.type === 'venta').length,
      donacion: products.filter(p => p.type === 'donacion').length,
      trueque: products.filter(p => p.type === 'trueque').length,
      pendientesAprobacion: products.filter(p => !p.isApproved).length,
      reportados: products.filter(p => p.isReported).length
    };

    // Top vendedores
    const sellerCounts = {};
    products.forEach(p => {
      if (p.userId) {
        sellerCounts[p.userId] = (sellerCounts[p.userId] || 0) + 1;
      }
    });

    const topSellersIds = Object.entries(sellerCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([userId]) => userId);

    const topSellers = [];
    for (const userId of topSellersIds) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        topSellers.push({
          userId,
          name: userData.name,
          email: userData.email,
          photoUrl: userData.photoUrl,
          productsCount: sellerCounts[userId]
        });
      }
    }

    // CategorÃ­as mÃ¡s populares
    const categoryCounts = {};
    products.forEach(p => {
      const catName = p.categoryName || 'Sin categorÃ­a';
      categoryCounts[catName] = (categoryCounts[catName] || 0) + 1;
    });

    const topCategories = Object.entries(categoryCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([category, count]) => ({ category, count }));

    console.log('âœ… [ADMIN] EstadÃ­sticas del marketplace obtenidas');

    res.json({
      success: true,
      data: {
        productStats,
        topSellers,
        topCategories
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// Listar usuarios vendedores (Admin)
app.get('/api/admin/marketplace/sellers', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search = ''
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener productos para contar por usuario
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    // Contar productos por usuario
    const userProductCounts = {};
    products.forEach(p => {
      if (p.userId) {
        if (!userProductCounts[p.userId]) {
          userProductCounts[p.userId] = {
            total: 0,
            disponible: 0,
            vendido: 0
          };
        }
        userProductCounts[p.userId].total++;
        if (p.status === 'disponible') userProductCounts[p.userId].disponible++;
        if (p.status === 'vendido') userProductCounts[p.userId].vendido++;
      }
    });

    // Obtener informaciÃ³n de usuarios
    const sellers = [];
    for (const [userId, stats] of Object.entries(userProductCounts)) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        sellers.push({
          id: userId,
          name: userData.name,
          email: userData.email,
          phone: userData.phone,
          photoUrl: userData.photoUrl,
          createdAt: userData.createdAt,
          stats
        });
      }
    }

    // BÃºsqueda
    let filteredSellers = sellers;
    if (search) {
      const searchLower = search.toLowerCase();
      filteredSellers = sellers.filter(s =>
        s.name?.toLowerCase().includes(searchLower) ||
        s.email?.toLowerCase().includes(searchLower)
      );
    }

    // Ordenar por nÃºmero de productos
    filteredSellers.sort((a, b) => b.stats.total - a.stats.total);

    // PaginaciÃ³n
    const total = filteredSellers.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedSellers = filteredSellers.slice(startIndex, endIndex);

    console.log('âœ… [ADMIN] Vendedores obtenidos:', paginatedSellers.length);

    res.json({
      success: true,
      data: paginatedSellers,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo vendedores:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo vendedores',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ› ï¸ ADMIN - GESTIÃ“N DE CATEGORÃAS
// ============================================================================

// Listar todas las categorÃ­as (Admin) - con filtros y paginaciÃ³n
app.get('/api/admin/marketplace/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 20, 
      search = '', 
      includeInactive = 'true',
      orderBy = 'order'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las categorÃ­as
    let query = db.collection('marketplace_categories');

    // El admin puede ver todas, incluidas las inactivas
    // (No aplicar filtro de isActive)

    // Ordenamiento
    const validOrderBy = ['order', 'name', 'createdAt', 'productCount'];
    const orderField = validOrderBy.includes(orderBy) ? orderBy : 'order';
    query = query.orderBy(orderField, 'asc');

    const snapshot = await query.get();
    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por includeInactive
    if (includeInactive === 'false') {
      categories = categories.filter(cat => cat.isActive);
    }

    // BÃºsqueda por nombre o slug
    if (search && search.trim().length > 0) {
      const searchLower = search.toLowerCase().trim();
      categories = categories.filter(cat => 
        cat.name.toLowerCase().includes(searchLower) ||
        cat.slug.toLowerCase().includes(searchLower) ||
        (cat.description && cat.description.toLowerCase().includes(searchLower))
      );
    }

    // PaginaciÃ³n
    const total = categories.length;
    const startIndex = (parseInt(page) - 1) * parseInt(limit);
    const endIndex = startIndex + parseInt(limit);
    const paginatedCategories = categories.slice(startIndex, endIndex);

    console.log(`âœ… [ADMIN] CategorÃ­as listadas: ${paginatedCategories.length} de ${total}`);

    res.json({
      success: true,
      data: paginatedCategories,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / parseInt(limit))
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Crear nueva categorÃ­a (Admin)
app.post('/api/admin/marketplace/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      name,
      slug,
      description,
      icon,
      imageUrl,
      imageStoragePath,
      order,
      isActive
    } = req.body;

    // Validaciones
    if (!name || name.trim().length < 2) {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido (mÃ­nimo 2 caracteres)'
      });
    }

    if (!slug || slug.trim().length < 2) {
      return res.status(400).json({
        success: false,
        message: 'El slug es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el slug sea Ãºnico
    const existingSlug = await db.collection('marketplace_categories')
      .where('slug', '==', slug.trim().toLowerCase())
      .get();

    if (!existingSlug.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una categorÃ­a con ese slug'
      });
    }

    const now = new Date();
    const categoryData = {
      name: name.trim(),
      slug: slug.trim().toLowerCase(),
      description: description?.trim() || '',
      icon: icon || 'ðŸ“¦',
      imageUrl: imageUrl || null,
      imageStoragePath: imageStoragePath || null,
      order: order || 999,
      isActive: isActive !== undefined ? isActive : true,
      productCount: 0,
      createdAt: now,
      updatedAt: now,
      createdBy: req.user.uid
    };

    const categoryRef = await db.collection('marketplace_categories').add(categoryData);

    console.log('âœ… [ADMIN] CategorÃ­a creada:', categoryRef.id);

    res.json({
      success: true,
      message: 'CategorÃ­a creada exitosamente',
      data: {
        id: categoryRef.id,
        ...categoryData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categorÃ­a',
      error: error.message
    });
  }
});

// Actualizar categorÃ­a (Admin)
app.put('/api/admin/marketplace/categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      slug,
      description,
      icon,
      imageUrl,
      imageStoragePath,
      order,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (icon) updateData.icon = icon;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (imageStoragePath !== undefined) updateData.imageStoragePath = imageStoragePath;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive;

    // Si se cambia el slug, verificar que sea Ãºnico
    if (slug && slug !== categoryDoc.data().slug) {
      const existingSlug = await db.collection('marketplace_categories')
        .where('slug', '==', slug.trim().toLowerCase())
        .get();

      if (!existingSlug.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una categorÃ­a con ese slug'
        });
      }

      updateData.slug = slug.trim().toLowerCase();
    }

    await db.collection('marketplace_categories').doc(id).update(updateData);

    console.log('âœ… [ADMIN] CategorÃ­a actualizada:', id);

    res.json({
      success: true,
      message: 'CategorÃ­a actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categorÃ­a',
      error: error.message
    });
  }
});

// Eliminar categorÃ­a (Admin)
app.delete('/api/admin/marketplace/categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    // Verificar que no tenga productos
    const categoryData = categoryDoc.data();
    if (categoryData.productCount > 0) {
      return res.status(400).json({
        success: false,
        message: `No se puede eliminar. La categorÃ­a tiene ${categoryData.productCount} productos asociados. Primero elimina o reasigna los productos.`
      });
    }

    // Eliminar imagen de Storage si existe
    if (categoryData.imageStoragePath) {
      try {
        const bucket = admin.storage().bucket();
        const file = bucket.file(categoryData.imageStoragePath);
        await file.delete();
        console.log('ðŸ—‘ï¸ [ADMIN] Imagen de categorÃ­a eliminada:', categoryData.imageStoragePath);
      } catch (error) {
        console.warn('âš ï¸ [ADMIN] No se pudo eliminar la imagen:', error.message);
      }
    }

    await db.collection('marketplace_categories').doc(id).delete();

    console.log('âœ… [ADMIN] CategorÃ­a eliminada:', id);

    res.json({
      success: true,
      message: 'CategorÃ­a eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categorÃ­a',
      error: error.message
    });
  }
});

// Toggle activo/inactivo (Admin)
app.patch('/api/admin/marketplace/categories/:id/toggle', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const currentStatus = categoryDoc.data().isActive;
    const newStatus = !currentStatus;

    await db.collection('marketplace_categories').doc(id).update({
      isActive: newStatus,
      updatedAt: new Date()
    });

    console.log('âœ… [ADMIN] CategorÃ­a toggle:', id, '->', newStatus);

    res.json({
      success: true,
      message: `CategorÃ­a ${newStatus ? 'activada' : 'desactivada'} exitosamente`,
      data: {
        isActive: newStatus
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error en toggle de categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categorÃ­a',
      error: error.message
    });
  }
});

// Subir imagen de categorÃ­a (Admin)
app.post('/api/admin/marketplace/categories/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    const { categoryId } = req.body;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna imagen'
      });
    }

    // Validar tipo de archivo
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
    if (!allowedTypes.includes(req.file.mimetype)) {
      return res.status(400).json({
        success: false,
        message: 'Formato de imagen no vÃ¡lido. Solo JPG, PNG o WEBP'
      });
    }

    // Validar tamaÃ±o (mÃ¡ximo 2MB)
    if (req.file.size > 2 * 1024 * 1024) {
      return res.status(400).json({
        success: false,
        message: 'La imagen no debe superar 2MB'
      });
    }

    // Obtener bucket de Firebase Storage
    const bucket = admin.storage().bucket();
    
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Firebase Storage no disponible'
      });
    }

    const timestamp = Date.now();
    const fileName = `${categoryId || timestamp}_${req.file.originalname}`;
    const filePath = `marketplace/categories/${fileName}`;
    const file = bucket.file(filePath);

    const stream = file.createWriteStream({
      metadata: {
        contentType: req.file.mimetype,
      },
    });

    stream.on('error', (error) => {
      console.error('âŒ [ADMIN] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      await file.makePublic();
      const publicUrl = `https://storage.googleapis.com/${bucket.name}/${filePath}`;

      console.log('âœ… [ADMIN] Imagen de categorÃ­a subida:', filePath);

      res.json({
        success: true,
        message: 'Imagen subida exitosamente',
        data: {
          imageUrl: publicUrl,
          imageStoragePath: filePath
        }
      });
    });

    stream.end(req.file.buffer);

  } catch (error) {
    console.error('âŒ [ADMIN] Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Inicializar categorÃ­as por defecto (Admin)
app.post('/api/admin/marketplace/categories/init-defaults', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar si ya existen categorÃ­as
    const existingCategories = await db.collection('marketplace_categories').get();
    if (!existingCategories.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existen categorÃ­as en el sistema'
      });
    }

    const defaultCategories = [
      {
        name: 'Transporte',
        slug: 'transporte',
        description: 'Carriolas, sillas de auto, portabebÃ©s',
        icon: 'ðŸš—',
        order: 1
      },
      {
        name: 'Ropa',
        slug: 'ropa',
        description: 'Ropa de bebÃ©, mamÃ¡ y embarazo',
        icon: 'ðŸ‘•',
        order: 2
      },
      {
        name: 'Juguetes',
        slug: 'juguetes',
        description: 'Juguetes educativos y de entretenimiento',
        icon: 'ðŸ§¸',
        order: 3
      },
      {
        name: 'AlimentaciÃ³n',
        slug: 'alimentacion',
        description: 'Biberones, extractores, esterilizadores',
        icon: 'ðŸ¼',
        order: 4
      },
      {
        name: 'Muebles',
        slug: 'muebles',
        description: 'Cunas, cambiadores, mecedoras',
        icon: 'ðŸ›ï¸',
        order: 5
      },
      {
        name: 'Higiene',
        slug: 'higiene',
        description: 'BaÃ±eras, paÃ±aleras, cambiadores',
        icon: 'ðŸ§¼',
        order: 6
      },
      {
        name: 'Libros',
        slug: 'libros',
        description: 'Libros infantiles y de crianza',
        icon: 'ðŸ“š',
        order: 7
      },
      {
        name: 'Maternidad',
        slug: 'maternidad',
        description: 'Ropa de embarazo, almohadas, fajas',
        icon: 'ðŸ¤°',
        order: 8
      },
      {
        name: 'ElectrÃ³nica',
        slug: 'electronica',
        description: 'Monitores, calentadores, luces',
        icon: 'ðŸ“±',
        order: 9
      },
      {
        name: 'Otros',
        slug: 'otros',
        description: 'Otros artÃ­culos para bebÃ©',
        icon: 'ðŸ“¦',
        order: 10
      }
    ];

    const now = new Date();
    const batch = db.batch();

    defaultCategories.forEach(category => {
      const categoryRef = db.collection('marketplace_categories').doc();
      batch.set(categoryRef, {
        ...category,
        imageUrl: null,
        imageStoragePath: null,
        isActive: true,
        productCount: 0,
        createdAt: now,
        updatedAt: now,
        createdBy: req.user.uid
      });
    });

    await batch.commit();

    console.log('âœ… [ADMIN] CategorÃ­as por defecto inicializadas');

    res.json({
      success: true,
      message: `${defaultCategories.length} categorÃ­as creadas exitosamente`,
      data: {
        count: defaultCategories.length
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error inicializando categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error inicializando categorÃ­as',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸŽ¨ BANNERS - Sistema de Banners Rotativos
// ============================================================================

// Obtener banners activos (pÃºblico)
app.get('/api/banners', async (req, res) => {
  try {
    const { section } = req.query; // Filtrar por secciÃ³n: home, marketplace, products, etc.

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();

    // Obtener banners activos
    let query = db.collection('banners')
      .where('isActive', '==', true);

    // Filtrar por secciÃ³n si se proporciona
    if (section) {
      query = query.where('section', '==', section);
    }

    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();

    let banners = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por fechas de visibilidad
    banners = banners.filter(banner => {
      const startDate = banner.startDate?.toDate?.() || new Date(0);
      const endDate = banner.endDate?.toDate?.() || new Date('2099-12-31');
      return now >= startDate && now <= endDate;
    });

    console.log(`ðŸ“° [BANNERS] Banners activos${section ? ` para secciÃ³n "${section}"` : ''}: ${banners.length}`);

    res.json({
      success: true,
      data: banners
    });

  } catch (error) {
    console.error('âŒ [BANNERS] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸŽ¨ ADMIN - GestiÃ³n de Banners
// ============================================================================

// Listar productos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/products-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 50 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener productos disponibles
    let query = db.collection('marketplace_products')
      .where('status', '==', 'disponible')
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit));

    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // BÃºsqueda por texto si se proporciona
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p =>
        p.title?.toLowerCase().includes(searchLower) ||
        p.categoryName?.toLowerCase().includes(searchLower)
      );
    }

    // Formatear para el selector
    const productOptions = products.map(p => ({
      id: p.id,
      title: p.title,
      category: p.categoryName || 'Sin categorÃ­a',
      imageUrl: p.photos?.[0] || null,
      link: `/marketplace/item/${p.id}`,
      label: `ðŸ›ï¸ ${p.title} (${p.categoryName || 'Sin categorÃ­a'})`
    }));

    console.log('âœ… [ADMIN] Productos para selector:', productOptions.length);

    res.json({
      success: true,
      data: productOptions
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo productos para selector:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Listar artÃ­culos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/articles-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 50 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('articles')
      .where('status', '==', 'published')
      .orderBy('publishedAt', 'desc')
      .limit(parseInt(limit));

    const snapshot = await query.get();
    let articles = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      articles = articles.filter(a =>
        a.title?.toLowerCase().includes(searchLower) ||
        a.summary?.toLowerCase().includes(searchLower)
      );
    }

    const articleOptions = articles.map(a => ({
      id: a.id,
      title: a.title,
      publishedAt: a.publishedAt || null,
      coverImageUrl: a.coverImageUrl || null,
      linkType: 'article',
      label: `ðŸ“° ${a.title}`
    }));

    res.json({
      success: true,
      data: articleOptions
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo artÃ­culos para selector:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo artÃ­culos',
      error: error.message
    });
  }
});

// Listar categorÃ­as de artÃ­culos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/article-categories-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 100 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('article_categories')
      .orderBy('name', 'asc')
      .limit(parseInt(limit))
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(c =>
        c.name?.toLowerCase().includes(searchLower)
      );
    }

    const categoryOptions = categories.map(c => ({
      id: c.id,
      name: c.name,
      linkType: 'article-category',
      label: `ðŸ“‚ ${c.name}`
    }));

    res.json({
      success: true,
      data: categoryOptions
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo categorÃ­as de artÃ­culos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Listar categorÃ­as de recomendaciones para selector de enlaces en banners (admin)
app.get('/api/admin/banners/recommendation-categories-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 100 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('categories')
      .orderBy('name', 'asc')
      .limit(parseInt(limit))
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(c =>
        c.name?.toLowerCase().includes(searchLower)
      );
    }

    const categoryOptions = categories.map(c => ({
      id: c.id,
      name: c.name,
      linkType: 'recommendation-category',
      label: `â­ ${c.name}`
    }));

    res.json({
      success: true,
      data: categoryOptions
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo categorÃ­as de recomendaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as de recomendaciones',
      error: error.message
    });
  }
});

// Listar todos los banners (admin)
app.get('/api/admin/banners', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search = '',
      includeInactive = 'true',
      section
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('banners');

    // Filtrar por estado activo
    if (includeInactive === 'false') {
      query = query.where('isActive', '==', true);
    }

    // Filtrar por secciÃ³n si se proporciona
    if (section) {
      query = query.where('section', '==', section);
    }

    // Ordenar
    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();
    let banners = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // BÃºsqueda por texto
    if (search) {
      const searchLower = search.toLowerCase();
      banners = banners.filter(banner =>
        banner.title?.toLowerCase().includes(searchLower) ||
        banner.description?.toLowerCase().includes(searchLower)
      );
    }

    // PaginaciÃ³n
    const total = banners.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedBanners = banners.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedBanners,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// Obtener banner especÃ­fico (admin)
app.get('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const banner = {
      id: bannerDoc.id,
      ...bannerDoc.data()
    };

    console.log('âœ… [ADMIN] Banner obtenido:', id);

    res.json({
      success: true,
      data: banner
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banner',
      error: error.message
    });
  }
});

// Crear banner (admin)
app.post('/api/admin/banners', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      title,
      description,
      imageUrl,
      imageStoragePath,
      link,
      linkType,
      articleId,
      articleCategoryId,
      recommendationCategoryId,
      order,
      duration,
      startDate,
      endDate,
      isActive,
      section
    } = req.body;

    // Validaciones
    if (!title || title.trim().length < 3) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ­tulo es requerido (mÃ­nimo 3 caracteres)'
      });
    }

    if (!imageUrl) {
      return res.status(400).json({
        success: false,
        message: 'La imagen es requerida'
      });
    }

    // Validar secciÃ³n
    const validSections = [
      'home',
      'home1',
      'home2',
      'home3',
      'marketplace',
      'products',
      'comunidades',
      'recomendaciones',
      'medicina',
      'crecimiento',
      'vacunas',
      'denticion',
      'hitos',
      'nutricion',
      'menu-lateral'
    ];
    if (section && !validSections.includes(section)) {
      return res.status(400).json({
        success: false,
        message: `SecciÃ³n invÃ¡lida. Debe ser: ${validSections.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const validLinkTypes = [
      'url',
      'article',
      'article-category',
      'recommendation-category',
      'denticion',
      'crecimiento',
      'hitos',
      'medicacion',
      'vacunas',
      'solicitud-servicio',
      'none'
    ];
    let resolvedLinkType = linkType;
    if (!resolvedLinkType) {
      if (articleId) {
        resolvedLinkType = 'article';
      } else if (link) {
        resolvedLinkType = 'url';
      } else {
        resolvedLinkType = 'none';
      }
    }
    if (!validLinkTypes.includes(resolvedLinkType)) {
      return res.status(400).json({
        success: false,
        message: `Tipo de navegaciÃ³n invÃ¡lido. Debe ser: ${validLinkTypes.join(', ')}`
      });
    }
    if (resolvedLinkType === 'article' && !articleId) {
      return res.status(400).json({
        success: false,
        message: 'articleId es requerido cuando linkType es article'
      });
    }
    if (resolvedLinkType === 'article-category' && !articleCategoryId) {
      return res.status(400).json({
        success: false,
        message: 'articleCategoryId es requerido cuando linkType es article-category'
      });
    }
    if (resolvedLinkType === 'recommendation-category' && !recommendationCategoryId) {
      return res.status(400).json({
        success: false,
        message: 'recommendationCategoryId es requerido cuando linkType es recommendation-category'
      });
    }

    let resolvedArticleId = articleId || null;
    if (resolvedLinkType === 'article') {
      const articleDoc = await db.collection('articles').doc(resolvedArticleId).get();
      if (!articleDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleId invÃ¡lido'
        });
      }
    }
    let resolvedArticleCategoryId = articleCategoryId || null;
    if (resolvedLinkType === 'article-category') {
      const categoryDoc = await db.collection('article_categories').doc(resolvedArticleCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId invÃ¡lido'
        });
      }
    }
    let resolvedRecommendationCategoryId = recommendationCategoryId || null;
    if (resolvedLinkType === 'recommendation-category') {
      const categoryDoc = await db.collection('categories').doc(resolvedRecommendationCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId invÃ¡lido'
        });
      }
    }

    const now = new Date();
    
    // Convertir fechas a Timestamp de Firestore
    let processedStartDate;
    if (startDate) {
      if (typeof startDate === 'object' && startDate._seconds) {
        processedStartDate = admin.firestore.Timestamp.fromMillis(startDate._seconds * 1000);
      } else {
        processedStartDate = admin.firestore.Timestamp.fromDate(new Date(startDate));
      }
    } else {
      processedStartDate = admin.firestore.Timestamp.fromDate(now);
    }
    
    let processedEndDate = null;
    if (endDate) {
      if (typeof endDate === 'object' && endDate._seconds) {
        processedEndDate = admin.firestore.Timestamp.fromMillis(endDate._seconds * 1000);
      } else {
        processedEndDate = admin.firestore.Timestamp.fromDate(new Date(endDate));
      }
    }
    
    const bannerData = {
      title: title.trim(),
      description: description?.trim() || '',
      imageUrl,
      imageStoragePath: imageStoragePath || null,
      link: resolvedLinkType === 'url' ? (link?.trim() || null) : null,
      linkType: resolvedLinkType,
      articleId: resolvedLinkType === 'article' ? resolvedArticleId : null,
      articleCategoryId: resolvedLinkType === 'article-category' ? resolvedArticleCategoryId : null,
      recommendationCategoryId: resolvedLinkType === 'recommendation-category' ? resolvedRecommendationCategoryId : null,
      section: section || 'home', // Por defecto: home
      order: order || 999,
      duration: duration || 5, // DuraciÃ³n en segundos (por defecto 5s)
      startDate: processedStartDate,
      endDate: processedEndDate,
      isActive: isActive !== undefined ? isActive : true,
      views: 0,
      clicks: 0,
      createdAt: admin.firestore.Timestamp.fromDate(now),
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      createdBy: req.user.uid
    };

    const bannerRef = await db.collection('banners').add(bannerData);

    console.log('âœ… [ADMIN] Banner creado:', bannerRef.id);

    res.json({
      success: true,
      message: 'Banner creado exitosamente',
      data: {
        id: bannerRef.id,
        ...bannerData
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error creando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando banner',
      error: error.message
    });
  }
});

// Actualizar banner (admin)
app.put('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      title,
      description,
      imageUrl,
      imageStoragePath,
      link,
      linkType,
      articleId,
      articleCategoryId,
      recommendationCategoryId,
      section,
      order,
      duration,
      startDate,
      endDate,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    };

    if (title) {
      if (title.trim().length < 3) {
        return res.status(400).json({
          success: false,
          message: 'El tÃ­tulo debe tener al menos 3 caracteres'
        });
      }
      updateData.title = title.trim();
    }

    if (description !== undefined) {
      updateData.description = description.trim();
    }

    if (imageUrl) {
      updateData.imageUrl = imageUrl;
    }

    if (imageStoragePath !== undefined) {
      updateData.imageStoragePath = imageStoragePath;
    }

    if (link !== undefined) {
      updateData.link = link?.trim() || null;
    }

    const validLinkTypes = [
      'url',
      'article',
      'article-category',
      'recommendation-category',
      'denticion',
      'crecimiento',
      'hitos',
      'medicacion',
      'vacunas',
      'solicitud-servicio',
      'none'
    ];
    if (linkType !== undefined) {
      if (!validLinkTypes.includes(linkType)) {
        return res.status(400).json({
          success: false,
          message: `Tipo de navegaciÃ³n invÃ¡lido. Debe ser: ${validLinkTypes.join(', ')}`
        });
      }
      updateData.linkType = linkType;
    }

    if (articleId !== undefined) {
      updateData.articleId = articleId || null;
    }

    if (articleCategoryId !== undefined) {
      updateData.articleCategoryId = articleCategoryId || null;
    }
    if (recommendationCategoryId !== undefined) {
      updateData.recommendationCategoryId = recommendationCategoryId || null;
    }

    if (updateData.linkType === 'article' || (linkType === undefined && updateData.articleId)) {
      const resolvedArticleId = updateData.articleId || bannerDoc.data().articleId;
      if (!resolvedArticleId) {
        return res.status(400).json({
          success: false,
          message: 'articleId es requerido cuando linkType es article'
        });
      }
      const articleDoc = await db.collection('articles').doc(resolvedArticleId).get();
      if (!articleDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleId invÃ¡lido'
        });
      }
      updateData.link = null;
      updateData.articleId = resolvedArticleId;
      updateData.articleCategoryId = null;
    } else if (updateData.linkType === 'article-category' || (linkType === undefined && updateData.articleCategoryId)) {
      const resolvedCategoryId = updateData.articleCategoryId || bannerDoc.data().articleCategoryId;
      if (!resolvedCategoryId) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId es requerido cuando linkType es article-category'
        });
      }
      const categoryDoc = await db.collection('article_categories').doc(resolvedCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId invÃ¡lido'
        });
      }
      updateData.link = null;
      updateData.articleCategoryId = resolvedCategoryId;
      updateData.articleId = null;
      updateData.recommendationCategoryId = null;
    } else if (updateData.linkType === 'recommendation-category' || (linkType === undefined && updateData.recommendationCategoryId)) {
      const resolvedCategoryId = updateData.recommendationCategoryId || bannerDoc.data().recommendationCategoryId;
      if (!resolvedCategoryId) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId es requerido cuando linkType es recommendation-category'
        });
      }
      const categoryDoc = await db.collection('categories').doc(resolvedCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId invÃ¡lido'
        });
      }
      updateData.link = null;
      updateData.recommendationCategoryId = resolvedCategoryId;
      updateData.articleId = null;
      updateData.articleCategoryId = null;
    } else if (updateData.linkType === 'url') {
      updateData.articleId = null;
      updateData.articleCategoryId = null;
      updateData.recommendationCategoryId = null;
    } else if (updateData.linkType === 'none') {
      updateData.articleId = null;
      updateData.articleCategoryId = null;
      updateData.recommendationCategoryId = null;
      updateData.link = null;
    }

    if (section !== undefined) {
      const validSections = [
        'home',
        'home1',
        'home2',
        'home3',
        'marketplace',
        'products',
        'comunidades',
        'recomendaciones',
        'medicina',
        'crecimiento',
        'vacunas',
        'denticion',
        'hitos',
        'nutricion'
      ];
      if (section && !validSections.includes(section)) {
        return res.status(400).json({
          success: false,
          message: `SecciÃ³n invÃ¡lida. Debe ser: ${validSections.join(', ')}`
        });
      }
      updateData.section = section || 'home';
    }

    if (order !== undefined) {
      updateData.order = parseInt(order);
    }

    if (duration !== undefined) {
      updateData.duration = parseInt(duration);
    }

    if (startDate !== undefined) {
      if (startDate === null || startDate === '') {
        updateData.startDate = null;
      } else if (typeof startDate === 'object' && startDate._seconds) {
        // Es un Timestamp de Firestore serializado
        updateData.startDate = admin.firestore.Timestamp.fromMillis(startDate._seconds * 1000);
      } else if (typeof startDate === 'string' || typeof startDate === 'number') {
        // Es un string ISO o timestamp en milisegundos
        updateData.startDate = admin.firestore.Timestamp.fromDate(new Date(startDate));
      }
    }

    if (endDate !== undefined) {
      if (endDate === null || endDate === '') {
        updateData.endDate = null;
      } else if (typeof endDate === 'object' && endDate._seconds) {
        // Es un Timestamp de Firestore serializado
        updateData.endDate = admin.firestore.Timestamp.fromMillis(endDate._seconds * 1000);
      } else if (typeof endDate === 'string' || typeof endDate === 'number') {
        // Es un string ISO o timestamp en milisegundos
        updateData.endDate = admin.firestore.Timestamp.fromDate(new Date(endDate));
      }
    }

    if (isActive !== undefined) {
      updateData.isActive = isActive;
    }

    await db.collection('banners').doc(id).update(updateData);

    console.log('âœ… [ADMIN] Banner actualizado:', id);

    res.json({
      success: true,
      message: 'Banner actualizado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando banner',
      error: error.message
    });
  }
});

// Eliminar banner (admin)
app.delete('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const bannerData = bannerDoc.data();

    // Eliminar imagen de Storage si existe
    if (bannerData.imageStoragePath) {
      try {
        const bucket = admin.storage().bucket();
        const file = bucket.file(bannerData.imageStoragePath);
        await file.delete();
        console.log('ðŸ—‘ï¸ [ADMIN] Imagen de banner eliminada:', bannerData.imageStoragePath);
      } catch (error) {
        console.warn('âš ï¸ [ADMIN] No se pudo eliminar la imagen:', error.message);
      }
    }

    await db.collection('banners').doc(id).delete();

    console.log('âœ… [ADMIN] Banner eliminado:', id);

    res.json({
      success: true,
      message: 'Banner eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando banner',
      error: error.message
    });
  }
});

// Activar/Desactivar banner (admin)
app.patch('/api/admin/banners/:id/toggle', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const currentStatus = bannerDoc.data().isActive;
    const newStatus = !currentStatus;

    await db.collection('banners').doc(id).update({
      isActive: newStatus,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log('âœ… [ADMIN] Banner toggle:', id, newStatus ? 'ACTIVADO' : 'DESACTIVADO');

    res.json({
      success: true,
      message: `Banner ${newStatus ? 'activado' : 'desactivado'} exitosamente`,
      isActive: newStatus
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error toggle banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error cambiando estado del banner',
      error: error.message
    });
  }
});

// Subir imagen de banner (admin)
app.post('/api/admin/banners/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ninguna imagen'
      });
    }

    const bucket = admin.storage().bucket();
    
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Firebase Storage no disponible'
      });
    }

    const timestamp = Date.now();
    const fileName = `banners/${timestamp}_${req.file.originalname}`;
    const file = bucket.file(fileName);

    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
      },
      public: true,
    });

    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;

    console.log('âœ… [ADMIN] Imagen de banner subida:', fileName);

    res.json({
      success: true,
      message: 'Imagen subida exitosamente',
      data: {
        imageUrl: publicUrl,
        imageStoragePath: fileName
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error subiendo imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Incrementar vistas de banner (pÃºblico)
app.post('/api/banners/:id/view', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Intentar actualizar en la colecciÃ³n banners
    const bannerDoc = await db.collection('banners').doc(id).get();
    
    if (bannerDoc.exists) {
      // Es un banner general
      await db.collection('banners').doc(id).update({
        views: admin.firestore.FieldValue.increment(1)
      });
    } else {
      // Puede ser un evento marcado como banner
      const postDoc = await db.collection('posts').doc(id).get();
      
      if (postDoc.exists && postDoc.data().postType === 'event' && postDoc.data().eventData?.isBanner) {
        // Es un evento-banner, actualizar las vistas del evento
        await db.collection('posts').doc(id).update({
          'eventData.bannerViews': admin.firestore.FieldValue.increment(1)
        });
      } else {
        return res.status(404).json({
          success: false,
          message: 'Banner no encontrado'
        });
      }
    }

    res.json({
      success: true,
      message: 'Vista registrada'
    });

  } catch (error) {
    console.error('âŒ [BANNERS] Error registrando vista:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando vista',
      error: error.message
    });
  }
});

// Incrementar clicks de banner (pÃºblico)
app.post('/api/banners/:id/click', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Intentar actualizar en la colecciÃ³n banners
    const bannerDoc = await db.collection('banners').doc(id).get();
    
    if (bannerDoc.exists) {
      // Es un banner general
      await db.collection('banners').doc(id).update({
        clicks: admin.firestore.FieldValue.increment(1)
      });
    } else {
      // Puede ser un evento marcado como banner
      const postDoc = await db.collection('posts').doc(id).get();
      
      if (postDoc.exists && postDoc.data().postType === 'event' && postDoc.data().eventData?.isBanner) {
        // Es un evento-banner, actualizar los clicks del evento
        await db.collection('posts').doc(id).update({
          'eventData.bannerClicks': admin.firestore.FieldValue.increment(1)
        });
      } else {
        return res.status(404).json({
          success: false,
          message: 'Banner no encontrado'
        });
      }
    }

    res.json({
      success: true,
      message: 'Click registrado'
    });

  } catch (error) {
    console.error('âŒ [BANNERS] Error registrando click:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando click',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ“Š ANALYTICS - Sistema de Analytics para Recomendaciones
// ============================================================================

// Tipos de eventos vÃ¡lidos
const ANALYTICS_EVENT_TYPES = [
  'view',      // Vista de recomendaciÃ³n
  'call',      // Llamada telefÃ³nica
  'whatsapp',  // Contacto por WhatsApp
  'email',     // Click en email
  'website',   // Click en website
  'map',       // Click en mapa
  'share',     // Compartir recomendaciÃ³n
  'favorite',  // Agregar a favoritos
  'wishlist'   // Agregar a wishlist
];

// Registrar evento de analytics (pÃºblico)
app.post('/api/recommendations/:recommendationId/analytics/events', async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      eventType,
      metadata = {},
      userId = null,
      source = 'app',
      utmParams = {}
    } = req.body;

    // Validaciones
    if (!eventType || !ANALYTICS_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `Tipo de evento invÃ¡lido. Debe ser uno de: ${ANALYTICS_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la recomendaciÃ³n existe
    const recommendationRef = db.collection('recommendations').doc(recommendationId);
    const recommendationDoc = await recommendationRef.get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'RecomendaciÃ³n no encontrada'
      });
    }

    const now = new Date();

    // Crear evento de analytics
    const analyticsEvent = {
      recommendationId,
      eventType,
      userId,
      source,
      metadata,
      utmParams: {
        utm_source: utmParams.utm_source || null,
        utm_medium: utmParams.utm_medium || null,
        utm_campaign: utmParams.utm_campaign || null,
        utm_content: utmParams.utm_content || null,
        utm_term: utmParams.utm_term || null
      },
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    // Guardar evento
    const eventRef = await db.collection('recommendation_analytics').add(analyticsEvent);

    // Actualizar contadores en la recomendaciÃ³n
    const updateData = {
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    // Incrementar contador especÃ­fico segÃºn el tipo de evento
    switch (eventType) {
      case 'view':
        updateData['analytics.views'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'call':
        updateData['analytics.calls'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'whatsapp':
        updateData['analytics.whatsappClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'email':
        updateData['analytics.emailClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'website':
        updateData['analytics.websiteClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'map':
        updateData['analytics.mapClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'share':
        updateData['analytics.shares'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'favorite':
        updateData['analytics.favorites'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'wishlist':
        updateData['analytics.wishlists'] = admin.firestore.FieldValue.increment(1);
        break;
    }

    // Total de interacciones (excluye views)
    if (eventType !== 'view') {
      updateData['analytics.totalInteractions'] = admin.firestore.FieldValue.increment(1);
    }

    await recommendationRef.update(updateData);

    console.log(`ðŸ“Š [ANALYTICS] Evento registrado: ${eventType} - RecomendaciÃ³n: ${recommendationId}`);

    res.json({
      success: true,
      message: 'Evento registrado exitosamente',
      data: {
        eventId: eventRef.id,
        eventType,
        timestamp: now
      }
    });

  } catch (error) {
    console.error('âŒ [ANALYTICS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento',
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas de una recomendaciÃ³n (pÃºblico)
app.get('/api/recommendations/:recommendationId/analytics', async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      startDate,
      endDate,
      eventType,
      groupBy = 'day' // day, week, month
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la recomendaciÃ³n existe
    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'RecomendaciÃ³n no encontrada'
      });
    }

    const recommendationData = recommendationDoc.data();

    // Obtener eventos de analytics
    let query = db.collection('recommendation_analytics')
      .where('recommendationId', '==', recommendationId);

    // Filtros opcionales
    if (startDate) {
      query = query.where('timestamp', '>=', admin.firestore.Timestamp.fromDate(new Date(startDate)));
    }

    if (endDate) {
      query = query.where('timestamp', '<=', admin.firestore.Timestamp.fromDate(new Date(endDate)));
    }

    if (eventType && ANALYTICS_EVENT_TYPES.includes(eventType)) {
      query = query.where('eventType', '==', eventType);
    }

    query = query.orderBy('timestamp', 'desc');

    const snapshot = await query.get();
    const events = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Agregar estadÃ­sticas por tipo de evento
    const eventStats = {};
    ANALYTICS_EVENT_TYPES.forEach(type => {
      eventStats[type] = events.filter(e => e.eventType === type).length;
    });

    // EstadÃ­sticas agregadas de la recomendaciÃ³n
    const aggregatedStats = recommendationData.analytics || {
      views: 0,
      calls: 0,
      whatsappClicks: 0,
      emailClicks: 0,
      websiteClicks: 0,
      mapClicks: 0,
      shares: 0,
      favorites: 0,
      wishlists: 0,
      totalInteractions: 0
    };

    // Calcular tasa de conversiÃ³n (interacciones / vistas)
    const conversionRate = aggregatedStats.views > 0
      ? (aggregatedStats.totalInteractions / aggregatedStats.views) * 100
      : 0;

    // Fuentes de trÃ¡fico (utm_source)
    const trafficSources = {};
    events.forEach(event => {
      const source = event.utmParams?.utm_source || 'direct';
      trafficSources[source] = (trafficSources[source] || 0) + 1;
    });

    // Eventos recientes (Ãºltimos 10)
    const recentEvents = events.slice(0, 10);

    console.log(`ðŸ“Š [ANALYTICS] EstadÃ­sticas obtenidas - RecomendaciÃ³n: ${recommendationId}`);

    res.json({
      success: true,
      data: {
        recommendationId,
        aggregatedStats,
        eventStats,
        conversionRate: Math.round(conversionRate * 100) / 100,
        trafficSources,
        recentEvents,
        totalEvents: events.length,
        dateRange: {
          start: startDate || null,
          end: endDate || null
        }
      }
    });

  } catch (error) {
    console.error('âŒ [ANALYTICS] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas globales (admin)
app.get('/api/admin/analytics/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      startDate,
      endDate,
      limit = 20
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las recomendaciones con analytics
    const recommendationsSnapshot = await db.collection('recommendations')
      .orderBy('analytics.views', 'desc')
      .limit(parseInt(limit))
      .get();

    const recommendations = recommendationsSnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title || 'Sin tÃ­tulo',
        description: data.description || '',
        category: data.category || 'general',
        categoryName: data.categoryName || data.category || 'General',
        imageUrl: data.imageUrl || data.images?.[0] || null,
        location: data.location || {},
        phone: data.phone || null,
        website: data.website || null,
        email: data.email || null,
        whatsapp: data.whatsapp || data.phone || null,
        createdBy: data.createdBy || null,
        createdByName: data.createdByName || 'Usuario',
        analytics: data.analytics || {
          views: 0,
          calls: 0,
          whatsappClicks: 0,
          emailClicks: 0,
          websiteClicks: 0,
          mapClicks: 0,
          shares: 0,
          favorites: 0,
          wishlists: 0,
          totalInteractions: 0
        },
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      };
    });

    // EstadÃ­sticas totales
    let totalStats = {
      views: 0,
      calls: 0,
      whatsappClicks: 0,
      emailClicks: 0,
      websiteClicks: 0,
      mapClicks: 0,
      shares: 0,
      favorites: 0,
      wishlists: 0,
      totalInteractions: 0
    };

    recommendations.forEach(rec => {
      const analytics = rec.analytics || {};
      Object.keys(totalStats).forEach(key => {
        totalStats[key] += (analytics[key] || 0);
      });
    });

    // Recomendaciones mÃ¡s populares (por vistas)
    const topByViews = [...recommendations]
      .sort((a, b) => (b.analytics.views || 0) - (a.analytics.views || 0))
      .slice(0, 10);

    // Recomendaciones con mÃ¡s interacciones
    const topByInteractions = [...recommendations]
      .sort((a, b) => (b.analytics.totalInteractions || 0) - (a.analytics.totalInteractions || 0))
      .slice(0, 10);

    // Recomendaciones con mejor conversiÃ³n
    const topByConversion = [...recommendations]
      .map(rec => ({
        ...rec,
        conversionRate: rec.analytics.views > 0
          ? (rec.analytics.totalInteractions / rec.analytics.views) * 100
          : 0
      }))
      .filter(rec => rec.analytics.views >= 3) // MÃ­nimo 3 vistas para conversiÃ³n confiable
      .sort((a, b) => b.conversionRate - a.conversionRate)
      .slice(0, 10);

    console.log('ðŸ“Š [ADMIN] EstadÃ­sticas globales obtenidas');

    res.json({
      success: true,
      data: {
        totalStats,
        totalRecommendations: recommendations.length,
        topByViews,
        topByInteractions,
        topByConversion
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas globales:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas globales',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ”” SISTEMA DE NOTIFICACIONES PUSH - FIREBASE CLOUD MESSAGING (FCM)
// ============================================================================

// FunciÃ³n helper para enviar notificaciones push
async function sendPushNotification(tokens, notification, data = {}) {
  try {
    if (!tokens || tokens.length === 0) {
      console.log('âš ï¸ [PUSH] No hay tokens para enviar notificaciÃ³n');
      return { success: false, message: 'No tokens provided' };
    }

    // Asegurar que tokens sea un array
    const tokenArray = Array.isArray(tokens) ? tokens : [tokens];
    
    // Filtrar tokens vÃ¡lidos
    const validTokens = tokenArray.filter(token => token && typeof token === 'string' && token.length > 0);
    
    if (validTokens.length === 0) {
      console.log('âš ï¸ [PUSH] No hay tokens vÃ¡lidos');
      return { success: false, message: 'No valid tokens' };
    }

    // Separar tokens de Expo de tokens de FCM
    const expoTokens = validTokens.filter(token => token.startsWith('ExponentPushToken['));
    const fcmTokens = validTokens.filter(token => !token.startsWith('ExponentPushToken['));

    console.log(`ðŸ“Š [PUSH] Tokens Expo: ${expoTokens.length}, Tokens FCM: ${fcmTokens.length}`);

    let totalSuccess = 0;
    let totalFailure = 0;
    const failedTokens = [];

    // Enviar a tokens de Expo
    if (expoTokens.length > 0) {
      const expoResult = await sendExpoNotifications(expoTokens, notification, data);
      totalSuccess += expoResult.successCount;
      totalFailure += expoResult.failureCount;
      if (expoResult.failedTokens) {
        failedTokens.push(...expoResult.failedTokens);
      }
    }

    // Enviar a tokens de FCM
    if (fcmTokens.length > 0) {
      const fcmResult = await sendFCMNotifications(fcmTokens, notification, data);
      totalSuccess += fcmResult.successCount;
      totalFailure += fcmResult.failureCount;
      if (fcmResult.failedTokens) {
        failedTokens.push(...fcmResult.failedTokens);
      }
    }

    console.log(`âœ… [PUSH] Total notificaciones enviadas: ${totalSuccess}/${validTokens.length}`);

    // Limpiar tokens invÃ¡lidos
    if (failedTokens.length > 0) {
      await cleanInvalidTokens(failedTokens);
    }

    return {
      success: true,
      successCount: totalSuccess,
      failureCount: totalFailure
    };

  } catch (error) {
    console.error('âŒ [PUSH] Error enviando notificaciÃ³n:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// ðŸ“Š ANALYTICS - UI (Pantallas y Botones)
// ============================================================================
const UI_ANALYTICS_EVENT_TYPES = ['view', 'click'];
const DEEPLINK_EVENT_TYPES = ['click', 'open', 'view'];

const buildDeeplinkUrl = (path, params = {}) => {
  const cleanPath = String(path || '').trim().replace(/^\/+/, '');
  if (!cleanPath) return null;
  const entries = Object.entries(params || {}).filter(
    ([key, value]) => key && value !== undefined && value !== null && value !== ''
  );
  let url = `munpa://${cleanPath}`;
  if (entries.length > 0) {
    const query = entries
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
      .join('&');
    url += `?${query}`;
  }
  return url;
};

const generateShortCode = (length = 7) => {
  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < length; i += 1) {
    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
  }
  return result;
};

// Registrar evento de UI (requiere auth)
app.post('/api/analytics/ui/events', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { page, button = null, eventType, metadata = {} } = req.body;

    if (!page || !eventType || !UI_ANALYTICS_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `page y eventType son requeridos. eventType debe ser: ${UI_ANALYTICS_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const cleanPage = String(page).trim();
    const cleanButton = button ? String(button).trim() : null;

    const eventData = {
      page: cleanPage,
      button: cleanButton,
      eventType,
      userId,
      metadata,
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('ui_analytics_events').add(eventData);

    const aggregateId = `${cleanPage}::${cleanButton || 'page'}`;
    const aggregateRef = db.collection('ui_analytics').doc(aggregateId);
    const updateData = {
      page: cleanPage,
      button: cleanButton,
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    if (eventType === 'view') {
      updateData.views = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'click') {
      updateData.clicks = admin.firestore.FieldValue.increment(1);
    }

    await aggregateRef.set(updateData, { merge: true });

    res.json({
      success: true,
      message: 'Evento registrado',
      data: {
        page: cleanPage,
        button: cleanButton,
        eventType,
        timestamp: now
      }
    });
  } catch (error) {
    console.error('âŒ [UI ANALYTICS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento',
      error: error.message
    });
  }
});

// Consultar estadÃ­sticas UI (admin)
app.get('/api/admin/analytics/ui', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page, button } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('ui_analytics');
    if (page) query = query.where('page', '==', String(page));
    if (button) query = query.where('button', '==', String(button));

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const results = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('âŒ [UI ANALYTICS] Error consultando stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando estadÃ­sticas',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ”— DEEPLINKS - Admin + Analytics
// ============================================================================

// Crear o actualizar deeplink (admin)
app.post('/api/admin/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { key, name, path, params = {}, category = null, description = null, enabled = true } = req.body;

    if (!key || !name || !path) {
      return res.status(400).json({
        success: false,
        message: 'key, name y path son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const cleanKey = String(key).trim();
    const cleanName = String(name).trim();
    const cleanPath = String(path).trim().replace(/^\/+/, '');
    const deeplinkUrl = buildDeeplinkUrl(cleanPath, params);

    if (!deeplinkUrl) {
      return res.status(400).json({
        success: false,
        message: 'path invalido'
      });
    }

    const now = new Date();
    const deeplinkRef = db.collection('deeplinks').doc(cleanKey);
    const existing = await deeplinkRef.get();

    const payload = {
      key: cleanKey,
      name: cleanName,
      path: cleanPath,
      params,
      category,
      description,
      enabled: Boolean(enabled),
      deeplinkUrl,
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      updatedBy: req.user.uid
    };

    if (!existing.exists) {
      payload.createdAt = admin.firestore.Timestamp.fromDate(now);
      payload.createdBy = req.user.uid;
    }

    await deeplinkRef.set(payload, { merge: true });

    res.json({
      success: true,
      message: 'Deeplink guardado',
      data: payload
    });
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error guardando deeplink:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando deeplink',
      error: error.message
    });
  }
});

const createDeeplinkShort = async (req, res) => {
  try {
    const { path, params = {}, key = null, webFallback = 'https://munpa.online', enabled = true } = req.body;

    if (!path) {
      return res.status(400).json({
        success: false,
        message: 'path es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const cleanPath = String(path).trim().replace(/^\/+/, '');
    const deeplinkUrl = buildDeeplinkUrl(cleanPath, params);
    if (!deeplinkUrl) {
      return res.status(400).json({
        success: false,
        message: 'path invalido'
      });
    }

    let code = null;
    let attempts = 0;
    while (!code && attempts < 5) {
      const candidate = generateShortCode(7);
      const existing = await db.collection('deeplink_short_urls').doc(candidate).get();
      if (!existing.exists) code = candidate;
      attempts += 1;
    }

    if (!code) {
      return res.status(500).json({
        success: false,
        message: 'No se pudo generar short link'
      });
    }

    const now = new Date();
    const payload = {
      code,
      key: key ? String(key).trim() : null,
      path: cleanPath,
      params,
      deeplinkUrl,
      webFallback: String(webFallback || 'https://munpa.online'),
      enabled: Boolean(enabled),
      createdAt: admin.firestore.Timestamp.fromDate(now),
      createdBy: req.user?.uid || null,
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('deeplink_short_urls').doc(code).set(payload);

    res.json({
      success: true,
      data: {
        ...payload,
        shortUrl: `https://api.munpa.online/dl/${code}`
      }
    });
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error creando short link:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando short link',
      error: error.message
    });
  }
};

// Crear short link para deeplink (admin)
app.post('/api/admin/deeplinks/short', authenticateToken, isAdmin, createDeeplinkShort);

// Crear short link publico (sin token)
app.post('/api/deeplinks/short', createDeeplinkShort);

// Resolver short link a deeplink
app.get('/dl/:code', async (req, res) => {
  try {
    const { code } = req.params;

    if (!db) {
      return res.status(500).send('DB no disponible');
    }

    const doc = await db.collection('deeplink_short_urls').doc(code).get();
    if (!doc.exists) {
      return res.status(404).send('Link no encontrado');
    }

    const data = doc.data();
    if (data.enabled === false) {
      return res.status(404).send('Link deshabilitado');
    }

    const deeplinkUrl = data.deeplinkUrl;
    const webFallback = data.webFallback || 'https://munpa.online';
    const analyticsKey = data.key || `short:${code}`;
    const now = admin.firestore.Timestamp.fromDate(new Date());

    await db.collection('deeplink_analytics').doc(analyticsKey).set({
      key: analyticsKey,
      path: data.path || null,
      updatedAt: now,
      lastEventAt: now,
      lastEventType: 'click',
      totalEvents: admin.firestore.FieldValue.increment(1),
      totalClicks: admin.firestore.FieldValue.increment(1)
    }, { merge: true });

    const html = `
      <html>
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>Munpa</title>
        </head>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 32px;">
          <h2>Abriendo Munpa...</h2>
          <p>Si no se abre automÃ¡ticamente, toca el botÃ³n.</p>
          <a href="${deeplinkUrl}" style="display:inline-block;padding:12px 20px;background:#2C7EF7;color:#fff;text-decoration:none;border-radius:6px;">Abrir app</a>
          <script>
            window.location.href = "${deeplinkUrl}";
            setTimeout(function() {
              window.location.href = "${webFallback}";
            }, 1600);
          </script>
        </body>
      </html>
    `;

    res.setHeader('Content-Type', 'text/html');
    return res.send(html);
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error resolviendo short link:', error);
    res.status(500).send('Error');
  }
});

// Listar deeplinks con stats (admin)
app.get('/api/admin/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { category, enabled } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('deeplinks');
    if (category) query = query.where('category', '==', String(category));
    if (enabled !== undefined) query = query.where('enabled', '==', String(enabled) === 'true');

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const deeplinks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    const analyticsRefs = deeplinks.map(item => db.collection('deeplink_analytics').doc(item.key));
    const analyticsSnaps = analyticsRefs.length ? await db.getAll(...analyticsRefs) : [];
    const analyticsMap = new Map(
      analyticsSnaps.map(doc => [doc.id, doc.exists ? doc.data() : null])
    );

    const results = deeplinks.map(item => ({
      ...item,
      analytics: analyticsMap.get(item.key) || {
        totalClicks: 0,
        totalOpens: 0,
        totalViews: 0,
        totalEvents: 0,
        lastEventAt: null
      }
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error consultando deeplinks:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando deeplinks',
      error: error.message
    });
  }
});

// Registrar evento de deeplink (requiere auth)
app.post('/api/analytics/deeplinks/events', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { key, eventType = 'click', path = null, params = {}, source = null, metadata = {} } = req.body;

    if (!key || !DEEPLINK_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `key y eventType son requeridos. eventType debe ser: ${DEEPLINK_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const cleanKey = String(key).trim();
    const cleanPath = path ? String(path).trim().replace(/^\/+/, '') : null;

    const eventData = {
      key: cleanKey,
      path: cleanPath,
      params,
      eventType,
      source,
      userId,
      metadata,
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('deeplink_events').add(eventData);

    const aggregateRef = db.collection('deeplink_analytics').doc(cleanKey);
    const updateData = {
      key: cleanKey,
      path: cleanPath,
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      lastEventAt: admin.firestore.Timestamp.fromDate(now),
      lastEventType: eventType,
      lastUserId: userId,
      totalEvents: admin.firestore.FieldValue.increment(1)
    };

    if (eventType === 'click') {
      updateData.totalClicks = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'open') {
      updateData.totalOpens = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'view') {
      updateData.totalViews = admin.firestore.FieldValue.increment(1);
    }

    await aggregateRef.set(updateData, { merge: true });

    res.json({
      success: true,
      message: 'Evento deeplink registrado',
      data: {
        key: cleanKey,
        eventType,
        timestamp: now
      }
    });
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento deeplink',
      error: error.message
    });
  }
});

// Consultar stats de deeplinks (admin)
app.get('/api/admin/analytics/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { key } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('deeplink_analytics');
    if (key) query = query.where('key', '==', String(key));

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const results = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('âŒ [DEEPLINKS] Error consultando stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando stats deeplinks',
      error: error.message
    });
  }
});

// Enviar notificaciones a travÃ©s de Expo Push Notification Service
async function sendExpoNotifications(tokens, notification, data) {
  try {
    const messages = tokens.map(token => ({
      to: token,
      sound: 'default',
      title: notification.title || 'Munpa',
      body: notification.body || '',
      data: {
        ...data,
        timestamp: new Date().toISOString()
      },
      badge: 1,
      priority: 'high',
    }));

    console.log('ðŸ“¤ [EXPO] Enviando notificaciÃ³n a Expo Push Service:');
    console.log('   TÃ­tulo:', notification.title);
    console.log('   Cuerpo:', notification.body);
    console.log('   Total tokens:', tokens.length);
    console.log('   Primer mensaje:', JSON.stringify(messages[0], null, 2));

    const chunks = [];
    for (let i = 0; i < messages.length; i += 100) {
      chunks.push(messages.slice(i, i + 100));
    }

    let successCount = 0;
    let failureCount = 0;
    const failedTokens = [];

    for (const chunk of chunks) {
      const response = await fetch('https://exp.host/--/api/v2/push/send', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(chunk),
      });

      const result = await response.json();
      
      console.log('ðŸ” [EXPO] Respuesta completa de Expo:', JSON.stringify(result, null, 2));
      
      if (result.data) {
        result.data.forEach((item, index) => {
          if (item.status === 'ok') {
            successCount++;
            console.log(`âœ… [EXPO] NotificaciÃ³n enviada exitosamente a: ${chunk[index].to.substring(0, 30)}...`);
          } else {
            failureCount++;
            failedTokens.push(chunk[index].to);
            console.log(`âŒ [EXPO] Error enviando notificaciÃ³n:`);
            console.log(`   Token: ${chunk[index].to.substring(0, 30)}...`);
            console.log(`   Status: ${item.status}`);
            console.log(`   Message: ${item.message}`);
            console.log(`   Details: ${JSON.stringify(item.details || {})}`);
          }
        });
      } else {
        console.log('âŒ [EXPO] Respuesta sin data:', JSON.stringify(result));
      }
    }

    console.log(`âœ… [EXPO] Notificaciones Expo enviadas: ${successCount}/${tokens.length}`);

    return { successCount, failureCount, failedTokens };

  } catch (error) {
    console.error('âŒ [EXPO] Error enviando notificaciones Expo:', error);
    return { successCount: 0, failureCount: tokens.length, failedTokens: tokens };
  }
}

// Enviar notificaciones a travÃ©s de Firebase Cloud Messaging
async function sendFCMNotifications(tokens, notification, data) {
  try {
    const message = {
      notification: {
        title: notification.title || 'Munpa',
        body: notification.body || '',
        ...(notification.imageUrl && isValidUrl(notification.imageUrl) ? { imageUrl: notification.imageUrl } : {})
      },
      data: {
        ...data,
        click_action: data.click_action || 'FLUTTER_NOTIFICATION_CLICK',
        timestamp: new Date().toISOString()
      },
      tokens: tokens,
      android: {
        priority: 'high',
        notification: {
          sound: 'default',
          channelId: 'munpa_notifications'
        }
      },
      apns: {
        payload: {
          aps: {
            sound: 'default',
            badge: 1
          }
        }
      }
    };

    const response = await admin.messaging().sendEachForMulticast(message);
    
    console.log(`âœ… [FCM] Notificaciones FCM enviadas: ${response.successCount}/${tokens.length}`);
    
    const failedTokens = [];
    const invalidTokenCodes = new Set([
      'messaging/registration-token-not-registered',
      'messaging/invalid-registration-token'
    ]);
    if (response.failureCount > 0) {
      response.responses.forEach((resp, idx) => {
        if (!resp.success) {
          const errorCode = resp.error?.code;
          if (invalidTokenCodes.has(errorCode)) {
            failedTokens.push(tokens[idx]);
            console.log(`âŒ [FCM] Token invÃ¡lido: ${errorCode}`);
          } else {
            console.log(`âš ï¸ [FCM] Error enviando token (${errorCode || 'unknown'})`);
          }
        }
      });
    }

    return {
      successCount: response.successCount,
      failureCount: response.failureCount,
      failedTokens
    };

  } catch (error) {
    console.error('âŒ [FCM] Error enviando notificaciones FCM:', error);
    return { successCount: 0, failureCount: tokens.length, failedTokens: [] };
  }
}

// Limpiar tokens invÃ¡lidos
async function cleanInvalidTokens(invalidTokens) {
  try {
    const usersRef = db.collection('users');
    const snapshot = await usersRef.where('fcmTokens', 'array-contains-any', invalidTokens.slice(0, 10)).get();
    
    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      const userData = doc.data();
      const validTokens = userData.fcmTokens?.filter(token => !invalidTokens.includes(token)) || [];
      batch.update(doc.ref, { fcmTokens: validTokens });
    });
    
    await batch.commit();
    console.log(`ðŸ§¹ [PUSH] Tokens invÃ¡lidos limpiados: ${invalidTokens.length}`);
  } catch (error) {
    console.error('âŒ [PUSH] Error limpiando tokens:', error);
  }
}

// Registrar/actualizar token FCM del dispositivo
app.post('/api/notifications/register-token', authenticateToken, async (req, res) => {
  try {
    const { token, platform } = req.body;
    const userId = req.user.uid;

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token FCM requerido'
      });
    }

    // Evitar guardar tokens APNS (64 hex) en lugar de FCM
    const looksLikeApnsToken = /^[a-f0-9]{64}$/i.test(token);
    if (looksLikeApnsToken) {
      return res.status(400).json({
        success: false,
        message: 'Token invÃ¡lido. Se requiere token FCM, no APNS.'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();

    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();
    const currentTokens = userData.fcmTokens || [];

    // Agregar token si no existe
    if (!currentTokens.includes(token)) {
      await userRef.update({
        fcmTokens: admin.firestore.FieldValue.arrayUnion(token),
        lastTokenUpdate: admin.firestore.Timestamp.fromDate(new Date()),
        platform: platform || 'unknown'
      });
      console.log('âœ… [PUSH] Token registrado para:', userId);
    } else {
      console.log('â„¹ï¸ [PUSH] Token ya existe para:', userId);
    }

    res.json({
      success: true,
      message: 'Token registrado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [PUSH] Error registrando token:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando token',
      error: error.message
    });
  }
});

// Verificar tokens FCM registrados (debug)
app.get('/api/notifications/check-tokens', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(userId).get();

    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();
    const tokens = userData.fcmTokens || [];

    console.log(`ðŸ” [DEBUG] Tokens FCM para ${userId}:`, tokens.length);

    res.json({
      success: true,
      data: {
        userId,
        tokensCount: tokens.length,
        tokens: tokens,
        hasTokens: tokens.length > 0,
        lastTokenUpdate: userData.lastTokenUpdate,
        platform: userData.platform
      }
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error verificando tokens:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando tokens',
      error: error.message
    });
  }
});

const removeNotificationToken = async (req, res) => {
  try {
    const token = req.body?.token || req.query?.token;
    const userId = req.user.uid;

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token FCM requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('users').doc(userId).update({
      fcmTokens: admin.firestore.FieldValue.arrayRemove(token)
    });

    console.log('âœ… [PUSH] Token eliminado para:', userId);

    res.json({
      success: true,
      message: 'Token eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [PUSH] Error eliminando token:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando token',
      error: error.message
    });
  }
};

// Eliminar token FCM (logout o desinstalaciÃ³n)
app.post('/api/notifications/remove-token', authenticateToken, removeNotificationToken);
app.delete('/api/notifications/remove-token', authenticateToken, removeNotificationToken);

// Obtener notificaciones del usuario
app.get('/api/notifications', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { page = 1, limit = 50, unreadOnly = false } = req.query;
    const cacheKey = `${req.path}?uid=${userId}&page=${page}&limit=${limit}&unreadOnly=${unreadOnly}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      res.set('Cache-Control', 'private, max-age=10');
      return res.json(cached);
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones del usuario
    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .get();

    // Si estÃ¡ vacÃ­o, devolver array vacÃ­o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0,
          unreadCount: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar solo no leÃ­das si se especifica
    if (unreadOnly === 'true') {
      notifications = notifications.filter(n => !n.read);
    }

    // Ordenar por fecha de creaciÃ³n (mÃ¡s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.createdAt instanceof Date ? a.createdAt : new Date(a.createdAt || 0);
      const dateB = b.createdAt instanceof Date ? b.createdAt : new Date(b.createdAt || 0);
      return dateB - dateA;
    });

    // Calcular contador de no leÃ­das antes de paginar
    const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;

    // PaginaciÃ³n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`âœ… [NOTIFICATIONS] Notificaciones obtenidas para ${userId}: ${paginatedNotifications.length}`);

    const responsePayload = {
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
        unreadCount
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 1000);
    res.set('Cache-Control', 'private, max-age=10');
    res.json(responsePayload);

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error obteniendo notificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo notificaciones',
      error: error.message
    });
  }
});

// Marcar notificaciÃ³n como leÃ­da
app.patch('/api/notifications/:id/read', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationRef = db.collection('notifications').doc(id);
    const notificationDoc = await notificationRef.get();

    if (!notificationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'NotificaciÃ³n no encontrada'
      });
    }

    const notificationData = notificationDoc.data();

    // Verificar que la notificaciÃ³n pertenece al usuario
    if (notificationData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para modificar esta notificaciÃ³n'
      });
    }

    await notificationRef.update({
      read: true,
      readAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`âœ… [NOTIFICATIONS] NotificaciÃ³n marcada como leÃ­da: ${id}`);

    res.json({
      success: true,
      message: 'NotificaciÃ³n marcada como leÃ­da'
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error marcando notificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando notificaciÃ³n',
      error: error.message
    });
  }
});

// Marcar todas las notificaciones como leÃ­das (con alias para compatibilidad)
const markAllNotificationsAsReadHandler = async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', false)
      .get();

    if (snapshot.empty) {
      return res.json({
        success: true,
        message: 'No hay notificaciones sin leer'
      });
    }

    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      batch.update(doc.ref, {
        read: true,
        readAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    });

    await batch.commit();

    console.log(`âœ… [NOTIFICATIONS] ${snapshot.size} notificaciones marcadas como leÃ­das para: ${userId}`);

    res.json({
      success: true,
      message: `${snapshot.size} notificaciones marcadas como leÃ­das`
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error marcando todas como leÃ­das:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando notificaciones',
      error: error.message
    });
  }
};

// Registrar ambas rutas para compatibilidad
app.patch('/api/notifications/read-all', authenticateToken, markAllNotificationsAsReadHandler);
app.patch('/api/notifications/mark-all-read', authenticateToken, markAllNotificationsAsReadHandler);

// Eliminar notificaciÃ³n
app.delete('/api/notifications/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationRef = db.collection('notifications').doc(id);
    const notificationDoc = await notificationRef.get();

    if (!notificationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'NotificaciÃ³n no encontrada'
      });
    }

    const notificationData = notificationDoc.data();

    // Verificar que la notificaciÃ³n pertenece al usuario
    if (notificationData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar esta notificaciÃ³n'
      });
    }

    await notificationRef.delete();

    console.log(`âœ… [NOTIFICATIONS] NotificaciÃ³n eliminada: ${id}`);

    res.json({
      success: true,
      message: 'NotificaciÃ³n eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error eliminando notificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando notificaciÃ³n',
      error: error.message
    });
  }
});

// Eliminar todas las notificaciones leÃ­das
app.delete('/api/notifications/read-all', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', true)
      .get();

    if (snapshot.empty) {
      return res.json({
        success: true,
        message: 'No hay notificaciones leÃ­das para eliminar'
      });
    }

    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    console.log(`âœ… [NOTIFICATIONS] ${snapshot.size} notificaciones eliminadas para: ${userId}`);

    res.json({
      success: true,
      message: `${snapshot.size} notificaciones eliminadas exitosamente`
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error eliminando notificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando notificaciones',
      error: error.message
    });
  }
});

// Obtener contador de notificaciones sin leer
app.get('/api/notifications/unread-count', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', false)
      .get();

    const count = snapshot.size;

    res.json({
      success: true,
      data: {
        unreadCount: count
      }
    });

  } catch (error) {
    console.error('âŒ [NOTIFICATIONS] Error obteniendo contador:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo contador',
      error: error.message
    });
  }
});

// Enviar notificaciÃ³n cuando hay un nuevo mensaje
app.post('/api/notifications/new-message', authenticateToken, async (req, res) => {
  try {
    const { receiverId, senderName, message, productId, productTitle } = req.body;

    if (!receiverId || !message) {
      return res.status(400).json({
        success: false,
        message: 'receiverId y message son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens del receptor
    const receiverDoc = await db.collection('users').doc(receiverId).get();
    if (!receiverDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario receptor no encontrado'
      });
    }

    const receiverData = receiverDoc.data();
    const tokens = receiverData.fcmTokens || [];

    if (tokens.length === 0) {
      return res.json({
        success: true,
        message: 'Usuario no tiene tokens registrados'
      });
    }

    // Enviar notificaciÃ³n
    const notification = {
      title: `ðŸ’¬ Nuevo mensaje de ${senderName}`,
      body: message.length > 100 ? message.substring(0, 100) + '...' : message,
      imageUrl: null
    };

    const data = {
      type: 'new_message',
      senderId: req.user.uid,
      senderName: senderName || 'Usuario',
      productId: productId || '',
      productTitle: productTitle || '',
      screen: 'ChatScreen',
      chatId: `${req.user.uid}_${receiverId}_${productId}`
    };

    const result = await sendPushNotification(tokens, notification, data);

    // Guardar notificaciÃ³n en Firestore
    await db.collection('notifications').add({
      userId: receiverId,
      type: 'new_message',
      title: notification.title,
      body: notification.body,
      data: data,
      read: false,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    res.json({
      success: true,
      message: 'NotificaciÃ³n enviada',
      result
    });

  } catch (error) {
    console.error('âŒ [PUSH] Error enviando notificaciÃ³n de mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaciÃ³n',
      error: error.message
    });
  }
});

// Enviar notificaciÃ³n de compra/venta
app.post('/api/notifications/transaction', authenticateToken, async (req, res) => {
  try {
    const { sellerId, buyerName, productTitle, transactionType } = req.body;

    if (!sellerId || !productTitle) {
      return res.status(400).json({
        success: false,
        message: 'sellerId y productTitle son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens del vendedor
    const sellerDoc = await db.collection('users').doc(sellerId).get();
    if (!sellerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario vendedor no encontrado'
      });
    }

    const sellerData = sellerDoc.data();
    const tokens = sellerData.fcmTokens || [];

    if (tokens.length === 0) {
      return res.json({
        success: true,
        message: 'Vendedor no tiene tokens registrados'
      });
    }

    // Preparar notificaciÃ³n segÃºn el tipo
    let notification;
    let data;

    switch (transactionType) {
      case 'purchase':
        notification = {
          title: 'ðŸŽ‰ Â¡Venta realizada!',
          body: `${buyerName} comprÃ³ tu producto: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'purchase',
          buyerId: req.user.uid,
          buyerName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      case 'reservation':
        notification = {
          title: 'ðŸ“Œ Producto reservado',
          body: `${buyerName} reservÃ³ tu producto: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'reservation',
          buyerId: req.user.uid,
          buyerName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      case 'interest':
        notification = {
          title: 'ðŸ‘€ Alguien estÃ¡ interesado',
          body: `${buyerName} mostrÃ³ interÃ©s en: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'interest',
          userId: req.user.uid,
          userName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      default:
        notification = {
          title: 'ðŸ“¦ ActualizaciÃ³n de producto',
          body: `Hay una actualizaciÃ³n sobre: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'transaction',
          productTitle,
          screen: 'MyProductsScreen'
        };
    }

    const result = await sendPushNotification(tokens, notification, data);

    // Guardar notificaciÃ³n en Firestore
    await db.collection('notifications').add({
      userId: sellerId,
      type: transactionType || 'transaction',
      title: notification.title,
      body: notification.body,
      data: data,
      read: false,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    res.json({
      success: true,
      message: 'NotificaciÃ³n enviada',
      result
    });

  } catch (error) {
    console.error('âŒ [PUSH] Error enviando notificaciÃ³n de transacciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaciÃ³n',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ› ï¸ ADMIN - ENVIAR NOTIFICACIONES DESDE EL DASHBOARD
// ============================================================================

// Enviar notificaciÃ³n a usuarios especÃ­ficos
app.post('/api/admin/notifications/send', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userIds, title, body, imageUrl, data, screen } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'TÃ­tulo y mensaje son requeridos'
      });
    }

    if (!userIds || userIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe especificar al menos un usuario'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens de los usuarios
    let allTokens = [];
    for (const userId of userIds) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        if (userData.fcmTokens && userData.fcmTokens.length > 0) {
          allTokens = allTokens.concat(userData.fcmTokens);
        }
      }
    }

    if (allTokens.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'NingÃºn usuario tiene tokens registrados'
      });
    }

    const notification = {
      title,
      body,
      imageUrl: imageUrl || null
    };

    const notificationData = {
      type: 'admin_notification',
      screen: screen || 'HomeScreen',
      ...(data || {})
    };

    const result = await sendPushNotification(allTokens, notification, notificationData);

    // Guardar notificaciÃ³n para cada usuario
    const batch = db.batch();
    userIds.forEach(userId => {
      const notifRef = db.collection('notifications').doc();
      batch.set(notifRef, {
        userId,
        type: 'admin_notification',
        title,
        body,
        imageUrl: imageUrl || null,
        data: notificationData,
        read: false,
        sentBy: req.user.uid,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    });
    await batch.commit();

    console.log(`âœ… [ADMIN] NotificaciÃ³n enviada a ${userIds.length} usuarios`);

    res.json({
      success: true,
      message: `NotificaciÃ³n enviada a ${userIds.length} usuarios`,
      result
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error enviando notificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaciÃ³n',
      error: error.message
    });
  }
});

// Enviar notificaciÃ³n a todos los usuarios (broadcast)
app.post('/api/admin/notifications/broadcast', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, body, imageUrl, data, screen, segment } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'TÃ­tulo y mensaje son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Construir query segÃºn segmento
    let query = db.collection('users');

    // Aplicar filtros de segmentaciÃ³n
    if (segment) {
      if (segment.hasChildren !== undefined) {
        query = query.where('hasChildren', '==', segment.hasChildren);
      }
      if (segment.city) {
        query = query.where('city', '==', segment.city);
      }
      if (segment.state) {
        query = query.where('state', '==', segment.state);
      }
    }

    const snapshot = await query.get();
    
    if (snapshot.empty) {
      return res.status(400).json({
        success: false,
        message: 'No se encontraron usuarios con los filtros especificados'
      });
    }

    // Recolectar todos los tokens
    let allTokens = [];
    const userIds = [];
    let usersWithTokens = 0;
    let usersWithoutTokens = 0;

    snapshot.docs.forEach(doc => {
      const userData = doc.data();
      if (userData.fcmTokens && userData.fcmTokens.length > 0) {
        allTokens = allTokens.concat(userData.fcmTokens);
        userIds.push(doc.id);
        usersWithTokens++;
      } else {
        usersWithoutTokens++;
      }
    });

    console.log(`ðŸ“Š [BROADCAST] Total usuarios: ${snapshot.size}, Con tokens: ${usersWithTokens}, Sin tokens: ${usersWithoutTokens}`);
    console.log(`ðŸ“± [BROADCAST] Total tokens FCM recolectados: ${allTokens.length}`);

    if (allTokens.length === 0) {
      return res.status(400).json({
        success: false,
        message: `NingÃºn usuario tiene tokens registrados. ${snapshot.size} usuarios encontrados pero ninguno tiene la app instalada o FCM configurado.`,
        stats: {
          totalUsers: snapshot.size,
          usersWithTokens: 0,
          usersWithoutTokens: snapshot.size
        }
      });
    }

    const notification = {
      title,
      body,
      imageUrl: imageUrl || null
    };

    const notificationData = {
      type: 'broadcast',
      screen: screen || 'HomeScreen',
      ...(data || {})
    };

    // Enviar en lotes de 500 (lÃ­mite de FCM)
    const batchSize = 500;
    let totalSuccess = 0;
    let totalFailure = 0;

    for (let i = 0; i < allTokens.length; i += batchSize) {
      const tokenBatch = allTokens.slice(i, i + batchSize);
      const result = await sendPushNotification(tokenBatch, notification, notificationData);
      totalSuccess += result.successCount || 0;
      totalFailure += result.failureCount || 0;
    }

    // Guardar notificaciÃ³n para cada usuario (en lotes)
    const batchPromises = [];
    for (let i = 0; i < userIds.length; i += 500) {
      const userBatch = userIds.slice(i, i + 500);
      const batch = db.batch();
      
      userBatch.forEach(userId => {
        const notifRef = db.collection('notifications').doc();
        batch.set(notifRef, {
          userId,
          type: 'broadcast',
          title,
          body,
          imageUrl: imageUrl || null,
          data: notificationData,
          read: false,
          sentBy: req.user.uid,
          segment: segment || null,
          createdAt: admin.firestore.Timestamp.fromDate(new Date())
        });
      });
      
      batchPromises.push(batch.commit());
    }

    await Promise.all(batchPromises);

    console.log(`âœ… [ADMIN] Broadcast enviado a ${userIds.length} usuarios`);
    console.log(`ðŸ“¤ [PUSH] Notificaciones enviadas: ${totalSuccess}/${allTokens.length} exitosas, ${totalFailure} fallidas`);

    res.json({
      success: true,
      message: `NotificaciÃ³n enviada a ${userIds.length} usuarios`,
      stats: {
        usersCount: userIds.length,
        tokensCount: allTokens.length,
        successCount: totalSuccess,
        failureCount: totalFailure,
        usersWithTokens,
        usersWithoutTokens
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error enviando broadcast:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando broadcast',
      error: error.message
    });
  }
});

// Programar notificaciÃ³n para envÃ­o futuro
app.post('/api/admin/notifications/schedule', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, body, imageUrl, data, screen, userIds, segment, scheduledFor } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'TÃ­tulo y mensaje son requeridos'
      });
    }

    if (!scheduledFor) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de envÃ­o programada es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const scheduledDate = new Date(scheduledFor);
    if (scheduledDate <= new Date()) {
      return res.status(400).json({
        success: false,
        message: 'La fecha programada debe ser futura'
      });
    }

    // Guardar notificaciÃ³n programada
    const scheduledNotification = {
      title,
      body,
      imageUrl: imageUrl || null,
      data: data || {},
      screen: screen || 'HomeScreen',
      userIds: userIds || null,
      segment: segment || null,
      scheduledFor: admin.firestore.Timestamp.fromDate(scheduledDate),
      status: 'pending',
      createdBy: req.user.uid,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    };

    const docRef = await db.collection('scheduled_notifications').add(scheduledNotification);

    console.log(`âœ… [ADMIN] NotificaciÃ³n programada para: ${scheduledDate}`);

    res.json({
      success: true,
      message: 'NotificaciÃ³n programada exitosamente',
      id: docRef.id,
      scheduledFor: scheduledDate
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error programando notificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error programando notificaciÃ³n',
      error: error.message
    });
  }
});

// Listar notificaciones programadas
app.get('/api/admin/notifications/scheduled', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status = '', page = 1, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones programadas
    const snapshot = await db.collection('scheduled_notifications').get();
    
    // Si la colecciÃ³n estÃ¡ vacÃ­a, devolver array vacÃ­o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      scheduledFor: doc.data().scheduledFor?.toDate?.() || doc.data().scheduledFor,
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar por status si se especifica
    if (status) {
      notifications = notifications.filter(n => n.status === status);
    }

    // Ordenar por fecha programada (mÃ¡s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.scheduledFor instanceof Date ? a.scheduledFor : new Date(a.scheduledFor);
      const dateB = b.scheduledFor instanceof Date ? b.scheduledFor : new Date(b.scheduledFor);
      return dateB - dateA;
    });

    // PaginaciÃ³n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`âœ… [ADMIN] Notificaciones programadas obtenidas: ${paginatedNotifications.length}`);

    res.json({
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo notificaciones programadas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo notificaciones programadas',
      error: error.message
    });
  }
});

// Cancelar notificaciÃ³n programada
app.delete('/api/admin/notifications/scheduled/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('scheduled_notifications').doc(id).update({
      status: 'cancelled',
      cancelledBy: req.user.uid,
      cancelledAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`âœ… [ADMIN] NotificaciÃ³n programada cancelada: ${id}`);

    res.json({
      success: true,
      message: 'NotificaciÃ³n cancelada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error cancelando notificaciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando notificaciÃ³n',
      error: error.message
    });
  }
});

// Obtener historial de notificaciones enviadas
app.get('/api/admin/notifications/history', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 50, type = '' } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones
    const snapshot = await db.collection('notifications').get();
    
    // Si estÃ¡ vacÃ­o, devolver array vacÃ­o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar por tipo si se especifica
    if (type) {
      notifications = notifications.filter(n => n.type === type);
    }

    // Ordenar por fecha de creaciÃ³n (mÃ¡s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.createdAt instanceof Date ? a.createdAt : new Date(a.createdAt);
      const dateB = b.createdAt instanceof Date ? b.createdAt : new Date(b.createdAt);
      return dateB - dateA;
    });

    // PaginaciÃ³n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`âœ… [ADMIN] Historial de notificaciones obtenido: ${paginatedNotifications.length}`);

    res.json({
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// EstadÃ­sticas de notificaciones
app.get('/api/admin/notifications/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationsSnapshot = await db.collection('notifications').get();
    const notifications = notificationsSnapshot.docs.map(doc => doc.data());

    const stats = {
      total: notifications.length,
      byType: {},
      read: notifications.filter(n => n.read).length,
      unread: notifications.filter(n => !n.read).length,
      last24h: notifications.filter(n => {
        const createdAt = n.createdAt?.toDate() || new Date(0);
        const dayAgo = new Date();
        dayAgo.setDate(dayAgo.getDate() - 1);
        return createdAt >= dayAgo;
      }).length,
      last7days: notifications.filter(n => {
        const createdAt = n.createdAt?.toDate() || new Date(0);
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        return createdAt >= weekAgo;
      }).length
    };

    // Contar por tipo
    notifications.forEach(n => {
      const type = n.type || 'other';
      stats.byType[type] = (stats.byType[type] || 0) + 1;
    });

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ“… NOTIFICACIONES DIARIAS AUTOMÃTICAS - Vacunas, Consejos y Recordatorios
// Powered by ChatGPT para mensajes personalizados
// ============================================================================

// ConfiguraciÃ³n por defecto para recordatorios
const DEFAULT_REMINDER_CONFIG = {
  enabled: true,
  frequency: 'daily', // daily, every2days, every3days, weekly
  timeOfDay: '09:00', // Hora local para enviar
  types: {
    vaccines: true,
    tips: true,
    milestones: true
  }
};

// FunciÃ³n para generar mensaje personalizado con ChatGPT
async function generatePersonalizedReminder(childData, reminderType, ageInMonths, ageInDays) {
  // Intentar inicializar OpenAI si no estÃ¡ disponible (para funciones serverless)
  if (!openai && process.env.OPENAI_API_KEY) {
    console.log('ðŸ¤– [DAILY] Inicializando OpenAI dinÃ¡micamente...');
    try {
      openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
      console.log('âœ… [DAILY] OpenAI inicializado correctamente');
    } catch (error) {
      console.error('âŒ [DAILY] Error inicializando OpenAI:', error.message);
    }
  }
  
  if (!openai) {
    console.warn('âš ï¸ [DAILY] OpenAI no configurado, usando mensaje por defecto');
    return null;
  }

  try {
    let prompt = '';
    
    const childName = childData.name || 'el bebÃ©';
    const childGender = childData.gender || 'bebÃ©';
    
    if (reminderType === 'vaccine') {
      // Buscar vacuna prÃ³xima segÃºn edad
      const upcomingVaccines = [];
      if (ageInMonths === 0 && ageInDays <= 7) upcomingVaccines.push('BCG y Hepatitis B');
      else if (ageInMonths === 2) upcomingVaccines.push('Pentavalente, Rotavirus y NeumocÃ³cica');
      else if (ageInMonths === 4) upcomingVaccines.push('2da dosis de Pentavalente, Rotavirus y NeumocÃ³cica');
      else if (ageInMonths === 6) upcomingVaccines.push('3ra dosis de Pentavalente y 2da de Rotavirus');
      else if (ageInMonths === 12) upcomingVaccines.push('SRP y NeumocÃ³cica de refuerzo');
      else if (ageInMonths === 18) upcomingVaccines.push('Pentavalente de refuerzo');
      
      if (upcomingVaccines.length > 0) {
        prompt = `Eres una doula experta y cÃ¡lida. Escribe un recordatorio breve (mÃ¡ximo 100 caracteres) para que los padres no olviden las vacunas de ${childName}, un ${childGender} de ${ageInMonths} meses. Las vacunas son: ${upcomingVaccines[0]}. 
        
Debe ser:
- CÃ¡lido y empÃ¡tico
- Recordar la importancia sin asustar
- Mencionar el nombre del bebÃ©
- Incluir emoji relevante
- No usar comillas ni puntos finales innecesarios

Ejemplo: "ðŸ’‰ ${childName} necesita sus vacunas de los ${ageInMonths} meses pronto. Â¡Agenda tu cita!"`;
      }
    } 
    else if (reminderType === 'tip') {
      prompt = `Eres una doula experta y cÃ¡lida. Da un consejo prÃ¡ctico y valioso para padres de ${childName}, un ${childGender} de ${ageInMonths} meses.

El consejo debe ser:
- EspecÃ­fico para la edad de ${ageInMonths} meses
- PrÃ¡ctico y aplicable hoy
- MÃ¡ximo 120 caracteres
- Incluir emoji relevante
- Mencionar el nombre del bebÃ© cuando sea natural
- Basado en evidencia cientÃ­fica
- CÃ¡lido y empÃ¡tico

Temas sugeridos segÃºn edad:
- 0 meses: Contacto piel con piel, lactancia, sueÃ±o
- 1-2 meses: EstimulaciÃ³n visual, hablar mucho, tiempo boca abajo
- 3-5 meses: Juegos, sonidos, agarrar objetos
- 6 meses: AlimentaciÃ³n complementaria, gateo, denticiÃ³n
- 12 meses: Primeras palabras, caminar, independencia
- 18-24 meses: Lenguaje, juego simbÃ³lico, socializaciÃ³n

No uses comillas ni puntos finales innecesarios.`;
    }
    else if (reminderType === 'milestone') {
      prompt = `Eres una doula experta. ${childName}, un ${childGender}, cumple ${ageInMonths} meses hoy. Escribe un mensaje celebratorio breve (mÃ¡ximo 100 caracteres) que:
- Celebre el hito
- Mencione 1 logro tÃ­pico de esta edad
- Sea emotivo y positivo
- Incluya emoji de celebraciÃ³n
- Mencione el nombre del bebÃ©

No uses comillas ni puntos finales innecesarios.`;
    }

    if (!prompt) return null;

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "Eres una doula experta, cÃ¡lida y empÃ¡tica. Tus mensajes son breves, prÃ¡cticos y basados en evidencia."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.8,
      max_tokens: 100
    });

    const message = completion.choices[0]?.message?.content?.trim();
    
    if (!message) {
      console.warn('âš ï¸ [DAILY] OpenAI no devolviÃ³ mensaje');
      return null;
    }

    // Limpiar comillas y puntos innecesarios
    const cleanedMessage = message.replace(/^["']|["']$/g, '').replace(/\.+$/, '');

    console.log(`âœ… [DAILY] Mensaje generado por ChatGPT: "${cleanedMessage}"`);
    
    return {
      title: reminderType === 'vaccine' ? 'ðŸ’‰ Recordatorio de vacunas' :
             reminderType === 'milestone' ? 'ðŸŽ‰ Â¡Hito especial!' :
             'ðŸ‘¶ Consejo del dÃ­a',
      message: cleanedMessage,
      generatedBy: 'chatgpt',
      model: 'gpt-3.5-turbo',
      prompt: prompt
    };

  } catch (error) {
    console.error('âŒ [DAILY] Error generando mensaje con ChatGPT:', error.message);
    return null;
  }
}

// Base de datos de recordatorios segÃºn edad del bebÃ© (en meses) - FALLBACK
const DAILY_REMINDERS = {
  // Vacunas segÃºn calendario mexicano
  vaccines: [
    { ageMonths: 0, daysBefore: 3, title: 'ðŸ’‰ Vacunas del reciÃ©n nacido', message: 'En unos dÃ­as tu bebÃ© debe recibir BCG y Hepatitis B. Â¡No olvides agendar tu cita!' },
    { ageMonths: 2, daysBefore: 7, title: 'ðŸ’‰ Vacunas de los 2 meses', message: 'La prÃ³xima semana tu bebÃ© debe recibir: Pentavalente, Rotavirus y NeumocÃ³cica. Â¡Recuerda agendar!' },
    { ageMonths: 2, daysBefore: 1, title: 'ðŸ’‰ Vacunas maÃ±ana', message: 'Â¡MaÃ±ana toca vacunas de los 2 meses! Pentavalente, Rotavirus y NeumocÃ³cica.' },
    { ageMonths: 4, daysBefore: 7, title: 'ðŸ’‰ Vacunas de los 4 meses', message: 'La prÃ³xima semana tu bebÃ© debe recibir su segunda dosis de: Pentavalente, Rotavirus y NeumocÃ³cica.' },
    { ageMonths: 4, daysBefore: 1, title: 'ðŸ’‰ Vacunas maÃ±ana', message: 'Â¡MaÃ±ana toca la segunda dosis de vacunas! Pentavalente, Rotavirus y NeumocÃ³cica.' },
    { ageMonths: 6, daysBefore: 7, title: 'ðŸ’‰ Vacunas de los 6 meses', message: 'La prÃ³xima semana: tercera dosis de Pentavalente y segunda de Rotavirus. Â¡Agenda tu cita!' },
    { ageMonths: 6, daysBefore: 1, title: 'ðŸ’‰ Vacunas maÃ±ana', message: 'Â¡MaÃ±ana toca vacunas! Tercera dosis de Pentavalente y segunda de Rotavirus.' },
    { ageMonths: 7, daysBefore: 7, title: 'ðŸ’‰ Vacuna de Influenza', message: 'La prÃ³xima semana tu bebÃ© debe recibir la primera dosis de Influenza estacional.' },
    { ageMonths: 12, daysBefore: 7, title: 'ðŸ’‰ Vacunas del primer aÃ±o', message: 'La prÃ³xima semana: SRP (SarampiÃ³n, RubÃ©ola, Parotiditis) y NeumocÃ³cica de refuerzo. Â¡Un aÃ±o de protecciÃ³n!' },
    { ageMonths: 12, daysBefore: 1, title: 'ðŸ’‰ Vacunas maÃ±ana', message: 'Â¡MaÃ±ana toca vacunas del aÃ±o! SRP y NeumocÃ³cica de refuerzo.' },
    { ageMonths: 18, daysBefore: 7, title: 'ðŸ’‰ Vacunas de los 18 meses', message: 'La prÃ³xima semana: Pentavalente de refuerzo. Â¡MantÃ©n al dÃ­a su cartilla!' },
    { ageMonths: 24, daysBefore: 7, title: 'ðŸ’‰ Vacunas de los 2 aÃ±os', message: 'La prÃ³xima semana tu pequeÃ±o debe recibir su refuerzo anual de Influenza.' }
  ],
  
  // Consejos segÃºn edad
  tips: {
    0: [ // ReciÃ©n nacido
      { title: 'ðŸ‘¶ ReciÃ©n nacido', message: 'El contacto piel con piel fortalece el vÃ­nculo. AbrÃ¡zalo mucho, es lo que mÃ¡s necesita ahora.' },
      { title: 'ðŸ˜´ SueÃ±o del bebÃ©', message: 'Los reciÃ©n nacidos duermen 16-17 horas al dÃ­a. Es normal que se despierten cada 2-3 horas para comer.' },
      { title: 'ðŸ¼ AlimentaciÃ³n', message: 'La leche materna o fÃ³rmula es todo lo que necesita. No necesita agua ni otros lÃ­quidos.' },
      { title: 'ðŸ‘ƒ Cuidados bÃ¡sicos', message: 'El cordÃ³n umbilical se cae solo en 1-2 semanas. MantÃ©nlo limpio y seco.' }
    ],
    1: [
      { title: 'ðŸ˜Š Primer mes', message: 'Tu bebÃ© ya puede enfocar objetos a 20-30 cm. Â¡HÃ¡blale mucho, reconoce tu voz!' },
      { title: 'ðŸ‘€ EstimulaciÃ³n visual', message: 'Usa colores contrastantes como blanco y negro. Ayuda al desarrollo visual.' },
      { title: 'ðŸŽµ MÃºsica suave', message: 'La mÃºsica clÃ¡sica o canciones de cuna ayudan a calmar y estimular su cerebro.' }
    ],
    2: [
      { title: 'ðŸ˜„ Â¡Sonrisas sociales!', message: 'A los 2 meses empiezan las primeras sonrisas sociales. Â¡SonrÃ­ele mucho!' },
      { title: 'ðŸ—£ï¸ Balbuceos', message: 'Tu bebÃ© empieza a hacer sonidos. RespÃ³ndele para fomentar la comunicaciÃ³n.' },
      { title: 'ðŸ’ª Tiempo boca abajo', message: '3-5 minutos varias veces al dÃ­a fortalece su cuello y espalda. Siempre supervisado.' }
    ],
    3: [
      { title: 'ðŸ¤² Manos descubiertas', message: 'Empieza a descubrir sus manos. OfrÃ©cele juguetes suaves para agarrar.' },
      { title: 'ðŸ‘‚ Responde a sonidos', message: 'Gira la cabeza hacia los sonidos. Habla y canta para estimular su audiciÃ³n.' }
    ],
    4: [
      { title: 'ðŸ”„ Â¡Puede girar!', message: 'Muchos bebÃ©s empiezan a girarse. Nunca lo dejes solo en superficies altas.' },
      { title: 'ðŸ˜‚ Risas a carcajadas', message: 'Las cosquillas suaves y juegos le hacen reÃ­r. Â¡Disfruta este momento!' }
    ],
    5: [
      { title: 'ðŸŽ PreparaciÃ³n para sÃ³lidos', message: 'Pronto empezarÃ¡ con sÃ³lidos. Observa seÃ±ales: se sienta con apoyo, muestra interÃ©s en comida.' },
      { title: 'ðŸƒ Muy activo', message: 'Empieza a prepararse para gatear. Dale espacio seguro para moverse.' }
    ],
    6: [
      { title: 'ðŸ¥„ AlimentaciÃ³n complementaria', message: 'A los 6 meses puedes iniciar papillas y purÃ©s. La leche sigue siendo su alimento principal.' },
      { title: 'ðŸ¦· Posible denticiÃ³n', message: 'Pueden aparecer los primeros dientes. Mordederas frÃ­as alivian las molestias.' },
      { title: 'ðŸª‘ Â¡Ya se sienta!', message: 'Muchos bebÃ©s ya se sientan sin apoyo. Coloca cojines alrededor por seguridad.' }
    ],
    9: [
      { title: 'ðŸ‘‹ Dice adiÃ³s', message: 'Empieza a imitar gestos como decir adiÃ³s. Â¡Practiquen juntos!' },
      { title: 'ðŸ§¸ Juego de esconder', message: 'Le encanta el "Â¿dÃ³nde estÃ¡ el bebÃ©?". Desarrolla permanencia de objeto.' }
    ],
    12: [
      { title: 'ðŸŽ‚ Â¡Primer aÃ±o!', message: 'Â¡Felicidades! Ha sido un aÃ±o increÃ­ble. Muchos bebÃ©s ya caminan o estÃ¡n por hacerlo.' },
      { title: 'ðŸ—£ï¸ Primeras palabras', message: 'Puede decir "mamÃ¡" o "papÃ¡". HÃ¡blale mucho para ampliar su vocabulario.' }
    ],
    18: [
      { title: 'ðŸš¶ Caminando seguro', message: 'Ya camina con confianza. Puede empezar a correr y subir escaleras con ayuda.' },
      { title: 'ðŸ“š Cuentos interactivos', message: 'Le encantan los cuentos con imÃ¡genes. SeÃ±ala y nombra objetos para aprender palabras.' }
    ],
    24: [
      { title: 'ðŸŽ‰ Â¡Dos aÃ±os!', message: 'Tu pequeÃ±o tiene personalidad propia. Es normal la etapa del "no" y las rabietas.' },
      { title: 'ðŸ§© Juego simbÃ³lico', message: 'Imita situaciones cotidianas. Dale juguetes para cocinar, limpiar o cuidar muÃ±ecos.' }
    ],
    30: [
      { title: 'ðŸ—£ï¸ Lenguaje en desarrollo', message: 'Tu hijo ya forma frases simples. LÃ©ele cuentos todos los dÃ­as para ampliar su vocabulario.' },
      { title: 'ðŸŽ¨ Creatividad', message: 'Ofrece crayones, pinturas y plastilina. La creatividad estimula su desarrollo cognitivo.' }
    ],
    36: [
      { title: 'ðŸŽ‰ Â¡Tres aÃ±os!', message: 'Tu hijo es mÃ¡s independiente. Dale pequeÃ±as responsabilidades apropiadas para su edad.' },
      { title: 'ðŸ‘¥ SocializaciÃ³n', message: 'Es buen momento para actividades en grupo. Aprende a compartir y hacer amigos.' }
    ],
    42: [
      { title: 'ðŸš² Actividad fÃ­sica', message: 'Fomenta el juego activo. Puede andar en triciclo, saltar y trepar.' },
      { title: 'ðŸ“š Cuentos complejos', message: 'Su atenciÃ³n es mayor. Disfruta historias mÃ¡s largas y hace preguntas.' }
    ],
    48: [
      { title: 'ðŸŽ‰ Â¡Cuatro aÃ±os!', message: 'Tu hijo tiene mucha energÃ­a e imaginaciÃ³n. Responde "por quÃ©" a todo.' },
      { title: 'ðŸŽ­ Juego de rol', message: 'Le encanta disfrazarse y jugar a ser otros. Esto desarrolla su empatÃ­a.' }
    ],
    54: [
      { title: 'âœï¸ Pre-escritura', message: 'Practica trazos y figuras. Empieza a reconocer algunas letras.' },
      { title: 'ðŸ§® NÃºmeros y conteo', message: 'Puede contar hasta 10 o mÃ¡s. Incorpora matemÃ¡ticas en juegos diarios.' }
    ],
    60: [
      { title: 'ðŸŽ‰ Â¡Cinco aÃ±os!', message: 'Tu hijo estÃ¡ listo para la escuela. Es mÃ¡s independiente y sociable.' },
      { title: 'ðŸŽ“ PreparaciÃ³n escolar', message: 'Practica rutinas, sigue instrucciones y desarrolla habilidades de autoayuda.' }
    ]
  },
  
  // Hitos del desarrollo
  milestones: [
    { ageMonths: 1, title: 'ðŸ“¸ Primer mes cumplido', message: 'Â¡Tu bebÃ© cumple su primer mes! Es buen momento para fotos y registro de peso/talla.' },
    { ageMonths: 3, title: 'ðŸŽ¯ 3 meses de logros', message: 'Â¡Ya son 3 meses! Tu bebÃ© tiene mÃ¡s control de cuello y muestra mÃ¡s expresiones.' },
    { ageMonths: 6, title: 'ðŸŽ‚ Medio aÃ±o', message: 'Â¡6 meses! Tu bebÃ© ha crecido increÃ­blemente. Tiempo de evaluar su desarrollo con el pediatra.' },
    { ageMonths: 9, title: 'ðŸ“Š 9 meses de desarrollo', message: 'Â¡9 meses afuera! Probablemente gatea y explora todo. Seguridad en casa es clave.' },
    { ageMonths: 12, title: 'ðŸŽŠ Â¡Primer aÃ±o!', message: 'Â¡Un aÃ±o! De bebÃ© reciÃ©n nacido a pequeÃ±o explorador. Â¡Celebra este gran logro!' }
  ]
};

// FunciÃ³n para obtener recordatorio segÃºn edad
function getDailyReminder(ageInMonths, ageInDays) {
  const reminders = [];
  
  // Verificar vacunas prÃ³ximas
  DAILY_REMINDERS.vaccines.forEach(vaccine => {
    const targetDays = vaccine.ageMonths * 30;
    const daysUntilVaccine = targetDays - ageInDays;
    
    if (daysUntilVaccine === vaccine.daysBefore) {
      reminders.push({
        type: 'vaccine',
        priority: 1,
        title: vaccine.title,
        message: vaccine.message
      });
    }
  });
  
  // Verificar hitos
  DAILY_REMINDERS.milestones.forEach(milestone => {
    if (milestone.ageMonths === ageInMonths && ageInDays % 30 === 0) {
      reminders.push({
        type: 'milestone',
        priority: 2,
        title: milestone.title,
        message: milestone.message
      });
    }
  });
  
  // Consejos segÃºn edad (rotar diariamente)
  const ageTips = DAILY_REMINDERS.tips[ageInMonths];
  if (ageTips) {
    const dayOfWeek = new Date().getDay(); // 0-6
    const tipIndex = dayOfWeek % ageTips.length;
    reminders.push({
      type: 'tip',
      priority: 3,
      title: ageTips[tipIndex].title,
      message: ageTips[tipIndex].message
    });
  }
  
  // Si no hay consejos especÃ­ficos, usar del mes mÃ¡s cercano (extendido hasta 144 meses = 12 aÃ±os)
  if (reminders.filter(r => r.type === 'tip').length === 0) {
    const availableAges = [0, 1, 2, 3, 4, 5, 6, 9, 12, 18, 24, 30, 36, 42, 48, 54, 60, 72, 84, 96, 108, 120, 132, 144];
    const nearestAge = availableAges.reduce((prev, curr) => {
      return Math.abs(curr - ageInMonths) < Math.abs(prev - ageInMonths) ? curr : prev;
    });
    const fallbackTips = DAILY_REMINDERS.tips[nearestAge] || DAILY_REMINDERS.tips[24];
    if (fallbackTips) {
      const dayOfWeek = new Date().getDay();
      const tipIndex = dayOfWeek % fallbackTips.length;
      reminders.push({
        type: 'tip',
        priority: 3,
        title: fallbackTips[tipIndex].title,
        message: fallbackTips[tipIndex].message
      });
    }
  }
  
  // GARANTIZAR que siempre haya un recordatorio para TODOS los hijos
  if (reminders.length === 0) {
    // Consejos genÃ©ricos por rango de edad
    const genericTips = [
      { title: 'ðŸ’ Momento especial', message: 'Dedica unos minutos hoy para jugar y conectar con tu bebÃ©. Los momentos de calidad fortalecen el vÃ­nculo.' },
      { title: 'ðŸŒŸ Tip del dÃ­a', message: 'Habla con tu bebÃ© durante las actividades diarias. Esto estimula su desarrollo del lenguaje.' },
      { title: 'ðŸŽˆ DiversiÃ³n en familia', message: 'Los juegos simples como esconderse y aparecer son excelentes para el desarrollo cognitivo.' },
      { title: 'ðŸ“š Lectura diaria', message: 'Leer cuentos juntos, aunque sea por pocos minutos, beneficia enormemente su desarrollo.' },
      { title: 'ðŸ¤— ConexiÃ³n emocional', message: 'Los abrazos y el contacto fÃ­sico son fundamentales para el bienestar emocional de tu pequeÃ±o.' },
      { title: 'ðŸŽµ MÃºsica y movimiento', message: 'Cantar y bailar juntos estimula mÃºltiples Ã¡reas del desarrollo de tu hijo.' },
      { title: 'ðŸŒˆ ExploraciÃ³n', message: 'Permite que tu hijo explore de forma segura. La curiosidad es el motor del aprendizaje.' }
    ];
    
    const dayOfWeek = new Date().getDay();
    const tipIndex = dayOfWeek % genericTips.length;
    
    reminders.push({
      type: 'tip',
      priority: 3,
      title: genericTips[tipIndex].title,
      message: genericTips[tipIndex].message
    });
  }
  
  // Ordenar por prioridad (vacunas primero)
  return reminders.sort((a, b) => a.priority - b.priority)[0];
}

const getUpcomingScheduledVaccineReminder = async (childId, childName) => {
  if (!db) return null;
  const now = new Date();
  const targetDate = new Date(now);
  targetDate.setDate(targetDate.getDate() + 7);
  const startOfDay = new Date(targetDate);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(targetDate);
  endOfDay.setHours(23, 59, 59, 999);

  const snapshot = await db.collection('children').doc(childId)
    .collection('vaccines')
    .where('scheduledDate', '>=', startOfDay)
    .where('scheduledDate', '<=', endOfDay)
    .orderBy('scheduledDate', 'asc')
    .limit(1)
    .get();

  if (snapshot.empty) return null;
  const vaccineDoc = snapshot.docs[0].data();
  if (vaccineDoc.status === 'applied') return null;
  const name = vaccineDoc.name || 'vacuna';
  const childLabel = childName || 'tu bebÃ©';
  return {
    type: 'vaccine',
    priority: 1,
    title: 'ðŸ’‰ Vacuna prÃ³xima',
    message: `En una semana ${childLabel} tiene la vacuna ${name}.`
  };
};

// Middleware especial para cron jobs: acepta JWT admin o CRON_SECRET
const authenticateCron = (req, res, next) => {
  console.log('ðŸ” [CRON] Headers recibidos:', Object.keys(req.headers));
  
  // OpciÃ³n 1: x-cron-secret header (para servicios externos como cron-job.org)
  const cronSecretHeader = req.headers['x-cron-secret'];
  if (cronSecretHeader && cronSecretHeader === process.env.CRON_SECRET) {
    console.log('âœ… [CRON] Autenticado con x-cron-secret');
    req.user = { uid: 'cron-job', isAdmin: true };
    return next();
  }

  // OpciÃ³n 2: Authorization Bearer (para Vercel Cron Jobs)
  const authHeader = req.headers.authorization;
  if (authHeader) {
    const parts = authHeader.split(' ');
    if (parts.length === 2 && parts[0] === 'Bearer') {
      const token = parts[1];
      
      // Verificar si es el CRON_SECRET
      if (token === process.env.CRON_SECRET) {
        console.log('âœ… [CRON] Autenticado con Authorization Bearer (CRON_SECRET)');
        req.user = { uid: 'cron-job', isAdmin: true };
        return next();
      }
      
      // Si no es CRON_SECRET, intentar como JWT de admin
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        
        // Verificar que es admin
        if (!req.user.isAdmin) {
          return res.status(403).json({
            success: false,
            message: 'Acceso denegado. Se requieren permisos de administrador'
          });
        }
        
        console.log('âœ… [CRON] Autenticado con JWT admin');
        return next();
      } catch (error) {
        // No es un JWT vÃ¡lido, continuar con error
      }
    }
  }

  // Si llegamos aquÃ­, no hay autenticaciÃ³n vÃ¡lida
  return res.status(401).json({
    success: false,
    message: 'No autorizado. Requiere CRON_SECRET header o token de admin'
  });
};

// Endpoint para enviar notificaciones diarias (llamado por cron job)
// Vercel Cron Jobs usan GET por defecto
app.get('/api/notifications/daily-reminders', authenticateCron, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('ðŸ“… [DAILY] Iniciando envÃ­o de recordatorios diarios...');
    
    let notificationsSent = 0;
    let errors = 0;
    const results = [];
    let usersWithoutTokens = 0;
    let usersWithoutChildren = 0;
    let childrenTooOld = 0;
    let noReminderForAge = 0;

    // Obtener todos los usuarios
    const usersSnapshot = await db.collection('users').get();
    console.log(`ðŸ‘¥ [DAILY] Total usuarios en BD: ${usersSnapshot.docs.length}`);

    for (const userDoc of usersSnapshot.docs) {
      try {
        const userData = userDoc.data();
        const userId = userDoc.id;

        // Saltar si no tiene tokens FCM
        if (!userData.fcmTokens || userData.fcmTokens.length === 0) {
          usersWithoutTokens++;
          continue;
        }

        // Obtener hijos del usuario (como padre principal)
        const childrenSnapshot = await db.collection('children')
          .where('parentId', '==', userId)
          .get();

        // TambiÃ©n obtener hijos compartidos con el usuario
        const sharedChildrenSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', userId)
          .get();

        const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

        if (allChildren.length === 0) {
          usersWithoutChildren++;
          continue; // Usuario sin hijos asignados
        }

        console.log(`ðŸ‘¶ [DAILY] Usuario ${userId} tiene ${allChildren.length} hijo(s) total(es)`);

        // Recopilar TODOS los hijos elegibles (< 24 meses) con sus recordatorios
        const eligibleChildren = [];

        for (const childDoc of allChildren) {
          const childData = childDoc.data();
          
          // Calcular edad actual
          if (childData.birthDate) {
            const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
            const now = new Date();
            const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
            const ageInMonths = Math.floor(ageInDays / 30);

            console.log(`   ðŸ‘¶ Hijo: ${childData.name}, ${ageInMonths} meses, ${ageInDays} dÃ­as`);

            // Priorizar vacuna programada 1 semana antes
            let fallbackReminder = null;
            try {
              fallbackReminder = await getUpcomingScheduledVaccineReminder(childDoc.id, childData.name);
            } catch (error) {
              console.warn('âš ï¸ [DAILY] Error buscando vacuna programada:', error.message);
            }
            if (!fallbackReminder) {
              // Obtener recordatorio sin lÃ­mite de edad
              fallbackReminder = getDailyReminder(ageInMonths, ageInDays);
            }
            
            if (fallbackReminder) {
              console.log(`   âœ… Tiene recordatorio: ${fallbackReminder.title}`);
              eligibleChildren.push({
                ...childData,
                id: childDoc.id,
                ageInMonths,
                ageInDays,
                fallbackReminder
              });
            } else {
              console.log(`   â­ï¸ No hay recordatorio para ${childData.name} (${ageInMonths} meses, ${ageInDays} dÃ­as)`);
              noReminderForAge++;
            }
          } else {
            console.log(`   âš ï¸ ${childData.name} no tiene birthDate`);
          }
        }

        console.log(`   ðŸ“Š Hijos elegibles para ${userId}: ${eligibleChildren.length}/${allChildren.length}`);

        if (eligibleChildren.length === 0) {
          if (allChildren.length > 0) {
            childrenTooOld++;
          }
          continue; // No hay hijos elegibles
        }

        // Generar mensajes para cada hijo
        const childReminders = [];
        for (const child of eligibleChildren) {
          const gptReminder = await generatePersonalizedReminder(
            child,
            child.fallbackReminder.type,
            child.ageInMonths,
            child.ageInDays
          );

          const reminder = gptReminder || child.fallbackReminder;
          let message = reminder.message || child.fallbackReminder.message;
          const childName = child.name || 'tu bebÃ©';
          message = message.replace(/tu bebÃ©|el bebÃ©/gi, childName);

          childReminders.push({
            child,
            reminder,
            message,
            childName
          });
        }

        // Crear tÃ­tulo y mensaje combinado
        let title, message;
        if (eligibleChildren.length === 1) {
          // Un solo hijo: mensaje personalizado
          const { child, reminder, message: childMessage, childName } = childReminders[0];
          
          if (childName !== 'tu bebÃ©') {
            if (child.fallbackReminder.type === 'tip') {
              title = `ðŸ‘¶ Consejo para ${childName}`;
            } else if (child.fallbackReminder.type === 'milestone') {
              // Formatear edad en tÃ­tulo de milestone
              let ageText;
              if (child.ageInMonths < 24) {
                ageText = `${child.ageInMonths} meses`;
              } else {
                const years = Math.floor(child.ageInMonths / 12);
                const remainingMonths = child.ageInMonths % 12;
                if (remainingMonths === 0) {
                  ageText = `${years} ${years === 1 ? 'aÃ±o' : 'aÃ±os'}`;
                } else {
                  ageText = `${years} ${years === 1 ? 'aÃ±o' : 'aÃ±os'} y ${remainingMonths} meses`;
                }
              }
              title = `ðŸŽ‰ Â¡${childName} cumple ${ageText}!`;
            } else {
              title = reminder.title || child.fallbackReminder.title;
            }
          } else {
            title = reminder.title || child.fallbackReminder.title;
          }
          
          message = childMessage;
        } else {
          // MÃºltiples hijos: combinar en un mensaje
          const childNames = childReminders.map(r => r.childName).join(' y ');
          title = `ðŸ‘¶ Consejos para ${childNames}`;
          
          // Combinar mensajes
          const messages = childReminders.map((r, idx) => {
            // Formatear edad: < 24 meses en meses, >= 24 meses en aÃ±os
            let ageDisplay;
            if (r.child.ageInMonths < 24) {
              ageDisplay = `${r.child.ageInMonths}m`;
            } else {
              const years = Math.floor(r.child.ageInMonths / 12);
              const remainingMonths = r.child.ageInMonths % 12;
              if (remainingMonths === 0) {
                ageDisplay = `${years}a`;
              } else if (remainingMonths === 6) {
                ageDisplay = `${years}.5a`;
              } else {
                ageDisplay = `${years}a ${remainingMonths}m`;
              }
            }
            return `${r.childName} (${ageDisplay}): ${r.message}`;
          });
          message = messages.join('\n\n');
        }

        // Enviar push notification
        await sendPushNotification(
          userData.fcmTokens,
          {
            title: title,
            body: message
          },
          {
            type: 'daily_reminder',
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', ')
          }
        );

        // Guardar notificaciÃ³n en Firestore
        await db.collection('notifications').add({
          userId: userId,
          type: 'daily_reminder',
          title: title,
          body: message, // Campo body para consistencia con otras notificaciones
          message: message, // Mantener message para compatibilidad
          data: {
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', '),
            childrenCount: eligibleChildren.length
          },
          read: false,
          createdAt: new Date()
        });

        // Guardar log detallado para cada hijo en el dashboard
        for (const childReminderData of childReminders) {
          await db.collection('reminders_history').add({
            userId: userId,
            userName: userData.displayName || userData.name || 'Usuario',
            childId: childReminderData.child.id,
            childName: childReminderData.childName,
            childAge: childReminderData.child.ageInMonths,
            childAgeDays: childReminderData.child.ageInDays,
            reminderType: childReminderData.child.fallbackReminder.type,
            title: eligibleChildren.length === 1 ? title : `ðŸ‘¶ Consejo para ${childReminderData.childName}`,
            message: childReminderData.message,
            generatedBy: childReminderData.reminder.generatedBy || 'fallback',
            model: childReminderData.reminder.model || null,
            prompt: childReminderData.reminder.prompt || null,
            sent: true,
            sentAt: new Date(),
            createdAt: new Date()
          });
        }

        notificationsSent++;
        
        const childrenNames = eligibleChildren.map(c => c.name).join(', ');
        results.push({
          userId,
          childrenNames: childrenNames,
          childrenCount: eligibleChildren.length,
          title: title,
          generatedBy: childReminders[0]?.reminder?.generatedBy || 'fallback'
        });

        console.log(`âœ… [DAILY] NotificaciÃ³n enviada a ${userId} para ${eligibleChildren.length} hijo(s): ${childrenNames}`);

      } catch (userError) {
        errors++;
        console.error(`âŒ [DAILY] Error procesando usuario ${userDoc.id}:`, userError.message);
      }
    }

    console.log(`ðŸ“Š [DAILY] Completado: ${notificationsSent} enviadas, ${errors} errores`);
    console.log(`ðŸ“Š [DAILY] EstadÃ­sticas:`);
    console.log(`   ðŸ‘¥ Total usuarios en BD: ${usersSnapshot.docs.length}`);
    console.log(`   âŒ Sin tokens FCM: ${usersWithoutTokens}`);
    console.log(`   âŒ Sin hijos: ${usersWithoutChildren}`);
    console.log(`   âŒ Hijos > 24 meses: ${childrenTooOld}`);
    console.log(`   âŒ Sin recordatorio para edad: ${noReminderForAge}`);
    console.log(`   âœ… Notificaciones enviadas: ${notificationsSent}`);

    res.json({
      success: true,
      message: 'Recordatorios diarios enviados',
      data: {
        notificationsSent,
        errors,
        results: results.slice(0, 10), // Primeros 10 para muestra
        stats: {
          totalUsers: usersSnapshot.docs.length,
          usersWithoutTokens,
          usersWithoutChildren,
          childrenTooOld,
          noReminderForAge
        }
      }
    });

  } catch (error) {
    console.error('âŒ [DAILY] Error en recordatorios diarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando recordatorios diarios',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ“… RECORDATORIOS SEMANALES ALEATORIOS
// ============================================================================

// Endpoint para enviar notificaciones semanales en horarios aleatorios
// Se ejecuta cada hora entre 9am-7pm, pero solo envÃ­a 1 vez por semana
app.get('/api/notifications/weekly-reminders', authenticateCron, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('ðŸ“… [WEEKLY] Verificando si enviar recordatorios semanales...');

    // Obtener configuraciÃ³n de envÃ­o semanal
    const configRef = db.collection('config').doc('weekly_reminders');
    const configDoc = await configRef.get();
    const configData = configDoc.exists ? configDoc.data() : {};

    // Verificar si ya se enviÃ³ esta semana
    const now = new Date();
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay()); // Domingo de esta semana
    startOfWeek.setHours(0, 0, 0, 0);

    if (configData.lastSentAt) {
      const lastSent = configData.lastSentAt.toDate();
      if (lastSent >= startOfWeek) {
        console.log(`â­ï¸ [WEEKLY] Ya se enviaron notificaciones esta semana (${lastSent.toLocaleString()})`);
        return res.json({
          success: true,
          message: 'Ya se enviaron notificaciones esta semana',
          data: {
            lastSentAt: lastSent,
            nextAvailableAt: new Date(startOfWeek.getTime() + 7 * 24 * 60 * 60 * 1000)
          }
        });
      }
    }

    // Probabilidad aleatoria de envÃ­o (15% cada hora = ~100% de probabilidad en el dÃ­a)
    const randomChance = Math.random();
    const sendProbability = 0.15; // 15%

    if (randomChance > sendProbability) {
      console.log(`ðŸŽ² [WEEKLY] Probabilidad no cumplida (${(randomChance * 100).toFixed(1)}% > ${(sendProbability * 100)}%). Esperando prÃ³xima ejecuciÃ³n...`);
      return res.json({
        success: true,
        message: 'Esperando momento aleatorio para enviar',
        data: {
          randomValue: randomChance,
          threshold: sendProbability,
          willSend: false
        }
      });
    }

    console.log(`ðŸŽ² [WEEKLY] Â¡Momento de enviar! (${(randomChance * 100).toFixed(1)}% <= ${(sendProbability * 100)}%)`);

    // ===== LÃ“GICA DE ENVÃO (misma que daily-reminders) =====
    
    let notificationsSent = 0;
    let errors = 0;
    const results = [];
    let usersWithoutTokens = 0;
    let usersWithoutChildren = 0;
    let childrenTooOld = 0;
    let noReminderForAge = 0;

    // Obtener todos los usuarios
    const usersSnapshot = await db.collection('users').get();
    console.log(`ðŸ‘¥ [WEEKLY] Total usuarios en BD: ${usersSnapshot.docs.length}`);

    for (const userDoc of usersSnapshot.docs) {
      try {
        const userData = userDoc.data();
        const userId = userDoc.id;

        // Saltar si no tiene tokens FCM
        if (!userData.fcmTokens || userData.fcmTokens.length === 0) {
          usersWithoutTokens++;
          continue;
        }

        // Obtener hijos del usuario (como padre principal)
        const childrenSnapshot = await db.collection('children')
          .where('parentId', '==', userId)
          .get();

        // TambiÃ©n obtener hijos compartidos con el usuario
        const sharedChildrenSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', userId)
          .get();

        const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

        if (allChildren.length === 0) {
          usersWithoutChildren++;
          continue;
        }

        console.log(`ðŸ‘¶ [WEEKLY] Usuario ${userId} tiene ${allChildren.length} hijo(s) total(es)`);

        // Recopilar TODOS los hijos elegibles con sus recordatorios
        const eligibleChildren = [];

        for (const childDoc of allChildren) {
          const childData = childDoc.data();
          
          // Calcular edad actual
          if (childData.birthDate) {
            const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
            const now = new Date();
            const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
            const ageInMonths = Math.floor(ageInDays / 30);

            console.log(`   ðŸ‘¶ Hijo: ${childData.name}, ${ageInMonths} meses, ${ageInDays} dÃ­as`);

            // Priorizar vacuna programada 1 semana antes
            let fallbackReminder = null;
            try {
              fallbackReminder = await getUpcomingScheduledVaccineReminder(childDoc.id, childData.name);
            } catch (error) {
              console.warn('âš ï¸ [WEEKLY] Error buscando vacuna programada:', error.message);
            }
            if (!fallbackReminder) {
              // Obtener recordatorio
              fallbackReminder = getDailyReminder(ageInMonths, ageInDays);
            }
            
            if (fallbackReminder) {
              console.log(`   âœ… Tiene recordatorio: ${fallbackReminder.title}`);
              eligibleChildren.push({
                ...childData,
                id: childDoc.id,
                ageInMonths,
                ageInDays,
                fallbackReminder
              });
            } else {
              console.log(`   â­ï¸ No hay recordatorio para ${childData.name} (${ageInMonths} meses, ${ageInDays} dÃ­as)`);
              noReminderForAge++;
            }
          } else {
            console.log(`   âš ï¸ ${childData.name} no tiene birthDate`);
          }
        }

        console.log(`   ðŸ“Š Hijos elegibles para ${userId}: ${eligibleChildren.length}/${allChildren.length}`);

        if (eligibleChildren.length === 0) {
          if (allChildren.length > 0) {
            childrenTooOld++;
          }
          continue;
        }

        // Generar mensajes para cada hijo
        const childReminders = [];
        for (const child of eligibleChildren) {
          const gptReminder = await generatePersonalizedReminder(
            child,
            child.fallbackReminder.type,
            child.ageInMonths,
            child.ageInDays
          );

          const reminder = gptReminder || child.fallbackReminder;
          let message = reminder.message || child.fallbackReminder.message;
          const childName = child.name || 'tu bebÃ©';
          message = message.replace(/tu bebÃ©|el bebÃ©/gi, childName);

          childReminders.push({
            child,
            reminder,
            message,
            childName
          });
        }

        // Crear tÃ­tulo y mensaje combinado
        let title, message;
        if (eligibleChildren.length === 1) {
          const { child, reminder, message: childMessage, childName } = childReminders[0];
          
          if (childName !== 'tu bebÃ©') {
            if (child.fallbackReminder.type === 'tip') {
              title = `ðŸ‘¶ Consejo para ${childName}`;
            } else if (child.fallbackReminder.type === 'milestone') {
              let ageText;
              if (child.ageInMonths < 24) {
                ageText = `${child.ageInMonths} meses`;
              } else {
                const years = Math.floor(child.ageInMonths / 12);
                const remainingMonths = child.ageInMonths % 12;
                if (remainingMonths === 0) {
                  ageText = `${years} ${years === 1 ? 'aÃ±o' : 'aÃ±os'}`;
                } else {
                  ageText = `${years} ${years === 1 ? 'aÃ±o' : 'aÃ±os'} y ${remainingMonths} meses`;
                }
              }
              title = `ðŸŽ‰ Â¡${childName} cumple ${ageText}!`;
            } else {
              title = reminder.title || child.fallbackReminder.title;
            }
          } else {
            title = reminder.title || child.fallbackReminder.title;
          }
          
          message = childMessage;
        } else {
          const childNames = childReminders.map(r => r.childName).join(' y ');
          title = `ðŸ‘¶ Consejos para ${childNames}`;
          
          const messages = childReminders.map((r, idx) => {
            let ageDisplay;
            if (r.child.ageInMonths < 24) {
              ageDisplay = `${r.child.ageInMonths}m`;
            } else {
              const years = Math.floor(r.child.ageInMonths / 12);
              const remainingMonths = r.child.ageInMonths % 12;
              if (remainingMonths === 0) {
                ageDisplay = `${years}a`;
              } else if (remainingMonths === 6) {
                ageDisplay = `${years}.5a`;
              } else {
                ageDisplay = `${years}a ${remainingMonths}m`;
              }
            }
            return `${r.childName} (${ageDisplay}): ${r.message}`;
          });
          message = messages.join('\n\n');
        }

        // Enviar push notification
        await sendPushNotification(
          userData.fcmTokens,
          {
            title: title,
            body: message
          },
          {
            type: 'weekly_reminder',
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', ')
          }
        );

        // Guardar notificaciÃ³n en Firestore
        await db.collection('notifications').add({
          userId: userId,
          type: 'weekly_reminder',
          title: title,
          body: message,
          message: message,
          data: {
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', '),
            childrenCount: eligibleChildren.length
          },
          read: false,
          createdAt: new Date()
        });

        // Guardar log detallado para cada hijo en el dashboard
        for (const childReminderData of childReminders) {
          await db.collection('reminders_history').add({
            userId: userId,
            userName: userData.displayName || userData.name || 'Usuario',
            childId: childReminderData.child.id,
            childName: childReminderData.childName,
            childAge: childReminderData.child.ageInMonths,
            childAgeDays: childReminderData.child.ageInDays,
            reminderType: childReminderData.child.fallbackReminder.type,
            title: eligibleChildren.length === 1 ? title : `ðŸ‘¶ Consejo para ${childReminderData.childName}`,
            message: childReminderData.message,
            generatedBy: childReminderData.reminder.generatedBy || 'fallback',
            model: childReminderData.reminder.model || null,
            prompt: childReminderData.reminder.prompt || null,
            sent: true,
            sentAt: new Date(),
            sentType: 'weekly_random',
            createdAt: new Date()
          });
        }

        notificationsSent++;
        
        const childrenNames = eligibleChildren.map(c => c.name).join(', ');
        results.push({
          userId,
          childrenNames: childrenNames,
          childrenCount: eligibleChildren.length,
          title: title,
          generatedBy: childReminders[0]?.reminder?.generatedBy || 'fallback'
        });

        console.log(`âœ… [WEEKLY] NotificaciÃ³n enviada a ${userId} para ${eligibleChildren.length} hijo(s): ${childrenNames}`);

      } catch (userError) {
        errors++;
        console.error(`âŒ [WEEKLY] Error procesando usuario ${userDoc.id}:`, userError.message);
      }
    }

    // Registrar que ya se enviÃ³ esta semana
    await configRef.set({
      lastSentAt: now,
      lastSentHour: now.getHours(),
      notificationsSent,
      errors
    }, { merge: true });

    console.log(`ðŸ“Š [WEEKLY] Completado: ${notificationsSent} enviadas, ${errors} errores`);
    console.log(`ðŸ“Š [WEEKLY] Horario: ${now.toLocaleString()}`);
    console.log(`ðŸ“Š [WEEKLY] EstadÃ­sticas:`);
    console.log(`   ðŸ‘¥ Total usuarios en BD: ${usersSnapshot.docs.length}`);
    console.log(`   âŒ Sin tokens FCM: ${usersWithoutTokens}`);
    console.log(`   âŒ Sin hijos: ${usersWithoutChildren}`);
    console.log(`   âŒ Hijos > 24 meses: ${childrenTooOld}`);
    console.log(`   âŒ Sin recordatorio para edad: ${noReminderForAge}`);
    console.log(`   âœ… Notificaciones enviadas: ${notificationsSent}`);

    res.json({
      success: true,
      message: 'Recordatorios semanales enviados',
      data: {
        sentAt: now,
        sentHour: now.getHours(),
        notificationsSent,
        errors,
        results: results.slice(0, 10),
        stats: {
          totalUsers: usersSnapshot.docs.length,
          usersWithoutTokens,
          usersWithoutChildren,
          childrenTooOld,
          noReminderForAge
        }
      }
    });

  } catch (error) {
    console.error('âŒ [WEEKLY] Error en recordatorios semanales:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando recordatorios semanales',
      error: error.message
    });
  }
});

// Endpoint para probar recordatorio de un usuario especÃ­fico
app.post('/api/notifications/test-daily-reminder', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();

    // Obtener hijos
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

    if (allChildren.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No tienes hijos registrados'
      });
    }

    // Buscar hijo mÃ¡s pequeÃ±o
    let youngestChild = null;
    let youngestAge = 999;

    for (const childDoc of allChildren) {
      const childData = childDoc.data();
      
      if (childData.birthDate) {
        const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
        const now = new Date();
        const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
        const ageInMonths = Math.floor(ageInDays / 30);

        if (ageInMonths < youngestAge && ageInMonths <= 24) {
          youngestAge = ageInMonths;
          youngestChild = {
            ...childData,
            id: childDoc.id,
            ageInMonths,
            ageInDays
          };
        }
      }
    }

    if (!youngestChild) {
      return res.status(404).json({
        success: false,
        message: 'No se pudo calcular la edad de los hijos'
      });
    }

    // Priorizar vacuna programada 1 semana antes
    let reminder = null;
    try {
      reminder = await getUpcomingScheduledVaccineReminder(youngestChild.id, youngestChild.name);
    } catch (error) {
      console.warn('âš ï¸ [TEST] Error buscando vacuna programada:', error.message);
    }
    if (!reminder) {
      // Obtener recordatorio
      reminder = getDailyReminder(youngestChild.ageInMonths, youngestChild.ageInDays);
    }

    if (!reminder) {
      return res.json({
        success: true,
        message: 'No hay recordatorio disponible para hoy',
        data: {
          childName: youngestChild.name,
          ageMonths: youngestChild.ageInMonths,
          ageDays: youngestChild.ageInDays
        }
      });
    }

    const personalizedMessage = reminder.message.replace('tu bebÃ©', youngestChild.name || 'tu bebÃ©');

    // Enviar push si tiene tokens
    if (userData.fcmTokens && userData.fcmTokens.length > 0) {
      await sendPushNotification(
        userData.fcmTokens,
        {
          title: `ðŸ§ª Test: ${reminder.title}`,
          body: personalizedMessage
        },
        {
          type: 'daily_reminder',
          reminderType: reminder.type,
          childId: youngestChild.id,
          test: true
        }
      );
    }

    res.json({
      success: true,
      message: 'Recordatorio de prueba enviado',
      data: {
        childName: youngestChild.name,
        ageMonths: youngestChild.ageInMonths,
        ageDays: youngestChild.ageInDays,
        reminder: {
          type: reminder.type,
          title: reminder.title,
          message: personalizedMessage
        }
      }
    });

  } catch (error) {
    console.error('âŒ [DAILY] Error en test:', error);
    res.status(500).json({
      success: false,
      message: 'Error en recordatorio de prueba',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸŽ›ï¸ ADMINISTRACIÃ“N DE RECORDATORIOS - Dashboard
// ============================================================================

// Obtener configuraciÃ³n de recordatorios
app.get('/api/admin/reminders/config', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener configuraciÃ³n de Firestore
    const configDoc = await db.collection('system_config').doc('reminders').get();
    
    const config = configDoc.exists ? configDoc.data() : DEFAULT_REMINDER_CONFIG;

    res.json({
      success: true,
      data: config
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo configuraciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo configuraciÃ³n',
      error: error.message
    });
  }
});

// Actualizar configuraciÃ³n de recordatorios
app.put('/api/admin/reminders/config', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { enabled, frequency, timeOfDay, types } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar frecuencia
    const validFrequencies = ['daily', 'every2days', 'every3days', 'weekly'];
    if (frequency && !validFrequencies.includes(frequency)) {
      return res.status(400).json({
        success: false,
        message: 'Frecuencia invÃ¡lida. Debe ser: daily, every2days, every3days, weekly'
      });
    }

    const updateData = {
      updatedAt: new Date(),
      updatedBy: req.user.uid
    };

    if (enabled !== undefined) updateData.enabled = enabled;
    if (frequency) updateData.frequency = frequency;
    if (timeOfDay) updateData.timeOfDay = timeOfDay;
    if (types) updateData.types = types;

    await db.collection('system_config').doc('reminders').set(updateData, { merge: true });

    console.log('âœ… [ADMIN] ConfiguraciÃ³n de recordatorios actualizada:', updateData);

    res.json({
      success: true,
      message: 'ConfiguraciÃ³n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando configuraciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando configuraciÃ³n',
      error: error.message
    });
  }
});

// Obtener historial de recordatorios enviados
app.get('/api/admin/reminders/history', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 50, childName, reminderType, generatedBy } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('reminders_history');

    // Filtros opcionales
    if (childName) {
      query = query.where('childName', '==', childName);
    }
    if (reminderType) {
      query = query.where('reminderType', '==', reminderType);
    }
    if (generatedBy) {
      query = query.where('generatedBy', '==', generatedBy);
    }

    // Obtener todos los documentos que cumplan con los filtros
    const snapshot = await query.get();

    // Ordenar y paginar en memoria
    let reminders = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      sentAt: doc.data().sentAt?.toDate?.() || doc.data().sentAt,
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Ordenar por fecha descendente
    reminders.sort((a, b) => {
      const dateA = a.sentAt || a.createdAt || new Date(0);
      const dateB = b.sentAt || b.createdAt || new Date(0);
      return dateB - dateA;
    });

    // Paginar
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;

    const paginatedReminders = reminders.slice(startIndex, endIndex);
    const totalPages = Math.ceil(reminders.length / limitNum);

    res.json({
      success: true,
      data: paginatedReminders,
      pagination: {
        currentPage: pageNum,
        totalPages: totalPages,
        itemsPerPage: limitNum,
        totalItems: reminders.length
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas de recordatorios
app.get('/api/admin/reminders/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const remindersSnapshot = await db.collection('reminders_history').get();
    const reminders = remindersSnapshot.docs.map(doc => doc.data());

    const now = new Date();
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const stats = {
      total: reminders.length,
      last24h: 0,
      last7days: 0,
      last30days: 0,
      byType: {},
      bySource: {
        chatgpt: 0,
        fallback: 0
      },
      mostActiveUsers: {},
      averagePerDay: 0
    };

    reminders.forEach(reminder => {
      const sentAt = reminder.sentAt?.toDate?.() || reminder.sentAt || new Date(0);
      
      // Conteo por perÃ­odo
      if (sentAt >= dayAgo) stats.last24h++;
      if (sentAt >= weekAgo) stats.last7days++;
      if (sentAt >= monthAgo) stats.last30days++;

      // Conteo por tipo
      const type = reminder.reminderType || 'unknown';
      stats.byType[type] = (stats.byType[type] || 0) + 1;

      // Conteo por fuente
      const source = reminder.generatedBy || 'fallback';
      if (source === 'chatgpt') {
        stats.bySource.chatgpt++;
      } else {
        stats.bySource.fallback++;
      }

      // Usuarios mÃ¡s activos
      const userName = reminder.userName || 'Usuario';
      stats.mostActiveUsers[userName] = (stats.mostActiveUsers[userName] || 0) + 1;
    });

    // Promedio por dÃ­a (Ãºltimos 30 dÃ­as)
    stats.averagePerDay = stats.last30days > 0 ? (stats.last30days / 30).toFixed(1) : 0;

    // Top 10 usuarios mÃ¡s activos
    stats.topUsers = Object.entries(stats.mostActiveUsers)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));

    delete stats.mostActiveUsers; // No enviamos el objeto completo

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

// Ver detalle de un recordatorio especÃ­fico
app.get('/api/admin/reminders/history/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const reminderDoc = await db.collection('reminders_history').doc(id).get();

    if (!reminderDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recordatorio no encontrado'
      });
    }

    const reminderData = reminderDoc.data();

    res.json({
      success: true,
      data: {
        id: reminderDoc.id,
        ...reminderData,
        sentAt: reminderData.sentAt?.toDate?.() || reminderData.sentAt,
        createdAt: reminderData.createdAt?.toDate?.() || reminderData.createdAt
      }
    });

  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo detalle:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ›Œ SISTEMA DE PREDICCIÃ“N DE SUEÃ‘O (Tipo Napper)
// ============================================================================
const sleepController = require('./controllers/sleepPredictionController');

// Registrar evento de sueÃ±o
app.post('/api/sleep/record', authenticateToken, (req, res) => {
  sleepController.recordSleepEvent(req, res);
});

// Registrar hora de despertar
app.post('/api/sleep/wake-time', authenticateToken, (req, res) => {
  sleepController.recordWakeTime(req, res);
});

// Obtener hora de despertar de hoy
app.get('/api/sleep/wake-time/:childId', authenticateToken, (req, res) => {
  sleepController.getWakeTime(req, res);
});

// Obtener predicciÃ³n de sueÃ±o (GET con childId en URL)
app.get('/api/sleep/predict/:childId', authenticateToken, (req, res) => {
  sleepController.predictSleep(req, res);
});

// Obtener predicciÃ³n de sueÃ±o (POST con childId en body) - compatibilidad
app.post('/api/sleep/predict', authenticateToken, (req, res) => {
  // Mover childId del body a params para compatibilidad
  if (req.body.childId) {
    req.params.childId = req.body.childId;
  }
  sleepController.predictSleep(req, res);
});

// Obtener historial de sueÃ±o
app.get('/api/sleep/history/:childId', authenticateToken, (req, res) => {
  sleepController.getSleepHistoryEndpoint(req, res);
});

// ============================================================================
// ðŸ”” SISTEMA DE NOTIFICACIONES DE SUEÃ‘O
// ============================================================================
const sleepNotificationsController = require('./controllers/sleepNotificationsController');
const medicationsController = require('./controllers/medicationsController');

// Programar notificaciones 30min antes de cada siesta
app.post('/api/sleep/notifications/pre-nap/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.schedulePreNapNotifications(req, res);
});

// Programar notificaciones a la hora exacta de cada siesta/bedtime
app.post('/api/sleep/notifications/nap-time/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.scheduleNapTimeNotifications(req, res);
});

// Verificar y notificar si hay registro tarde (30+ min despuÃ©s)
app.post('/api/sleep/notifications/check-late/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.checkLateNapRegistration(req, res);
});

// Verificar y notificar siestas largas (4+ horas)
app.post('/api/sleep/notifications/check-long/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.checkLongNaps(req, res);
});

// Enviar notificaciÃ³n inmediata personalizada
app.post('/api/sleep/notifications/send', authenticateToken, (req, res) => {
  sleepNotificationsController.sendSleepNotification(req, res);
});

// Procesar notificaciones programadas (para cron job)
app.post('/api/sleep/notifications/process-scheduled', (req, res) => {
  sleepNotificationsController.processScheduledNotifications(req, res);
});
// Vercel cron usa GET por defecto; soportar ambos mÃ©todos
app.get('/api/sleep/notifications/process-scheduled', (req, res) => {
  sleepNotificationsController.processScheduledNotifications(req, res);
});

// ============== CRON: PROCESAR NOTIFICACIONES DE MEDICAMENTOS ==============
app.get('/api/cron/process-medication-notifications', async (req, res) => {
  try {
    // Verificar que viene del cron de Vercel
    const authHeader = req.headers.authorization;
    const expectedSecret = process.env.CRON_SECRET;
    
    if (!expectedSecret) {
      console.error('âŒ [CRON] CRON_SECRET no estÃ¡ configurado en las variables de entorno');
      return res.status(500).json({ 
        success: false, 
        message: 'CRON_SECRET not configured' 
      });
    }
    
    if (authHeader !== `Bearer ${expectedSecret}`) {
      console.log('âš ï¸ [CRON] Intento de acceso no autorizado');
      return res.status(401).json({ 
        success: false, 
        message: 'Unauthorized' 
      });
    }

    console.log('ðŸ”” [CRON] Iniciando procesamiento de notificaciones de medicamentos...');
    
    const now = new Date();
    const twentyMinutesFromNow = new Date(now.getTime() + 20 * 60 * 1000);
    
    // Buscar notificaciones que deben enviarse en los prÃ³ximos 20 minutos
    // y que no han sido enviadas
    const pendingSnapshot = await db
      .collection('scheduled_med_notifications')
      .where('scheduledFor', '>=', now)
      .where('scheduledFor', '<=', twentyMinutesFromNow)
      .where('sent', '==', false)
      .limit(100)
      .get();

    console.log(`ðŸ“¦ [CRON] Encontradas ${pendingSnapshot.size} notificaciones pendientes`);

    let sentCount = 0;
    let scheduledCount = 0;
    let errorCount = 0;
    let noTokensCount = 0;

    // Helper para programar follow-up
    const scheduleMedicationFollowup = async (notif, originalDocId) => {
      if (!notif || notif.type !== 'medication_reminder') return;
      const followUpMinutes = Number.isFinite(notif.followUpMinutes) ? notif.followUpMinutes : 120;
      if (!followUpMinutes || followUpMinutes <= 0) return;

      const scheduledForDate = notif.scheduledFor?.toDate
        ? notif.scheduledFor.toDate()
        : new Date(notif.scheduledFor);
      if (Number.isNaN(scheduledForDate.getTime())) return;

      const followupAt = new Date(scheduledForDate.getTime() + followUpMinutes * 60 * 1000);
      if (followupAt <= now) return;

      const title = 'â° Recuerda el medicamento';
      const body = `Recuerda darle ${notif.medicationName}: ${notif.dose} ${notif.doseUnit} a ${notif.childName}.`;

      try {
        const followupRef = db.collection('scheduled_med_notifications').doc();
        await followupRef.set({
          userId: notif.userId,
          childId: notif.childId,
          childName: notif.childName,
          medicationId: notif.medicationId,
          medicationName: notif.medicationName,
          dose: notif.dose,
          doseUnit: notif.doseUnit,
          type: 'medication_followup',
          title,
          body,
          scheduledFor: followupAt,
          sent: false,
          isFollowup: true,
          originalReminder: originalDocId,
          data: {
            ...(notif.data || {}),
            type: 'medication_followup',
            isFollowup: true,
            originalReminder: originalDocId,
            reminderId: followupRef.id
          },
          createdAt: admin.firestore.FieldValue.serverTimestamp()
        });
        console.log(`â° [CRON] Follow-up programado para ${followupAt.toISOString()}`);
      } catch (error) {
        console.error('âŒ [CRON] Error programando follow-up:', error);
      }
    };

    for (const doc of pendingSnapshot.docs) {
      try {
        const notif = doc.data();
        const scheduledTime = notif.scheduledFor.toDate();
        const minutesUntil = (scheduledTime - now) / 1000 / 60;

        // Si falta menos de 2 minutos, enviar ahora
        if (minutesUntil < 2) {
          console.log(`ðŸ“¤ [CRON] Enviando notificaciÃ³n (falta ${minutesUntil.toFixed(1)} min): ${notif.title}`);
          
          // Obtener tokens FCM del usuario
          const userDoc = await db.collection('users').doc(notif.userId).get();
          if (!userDoc.exists) {
            console.log(`âš ï¸ [CRON] Usuario no encontrado: ${notif.userId}`);
            await doc.ref.update({ 
              sent: true, 
              failed: true, 
              failReason: 'User not found',
              sentAt: now
            });
            errorCount++;
            continue;
          }

          const userData = userDoc.data();
          const tokens = userData.fcmTokens || [];

          if (tokens.length === 0) {
            console.log(`âš ï¸ [CRON] Usuario sin tokens FCM: ${notif.userId}`);
            await doc.ref.update({ 
              sent: true, 
              failed: true, 
              failReason: 'No FCM tokens',
              sentAt: now
            });
            noTokensCount++;
            continue;
          }

          // Enviar notificaciÃ³n push
          try {
            const messaging = admin.messaging();
            const promises = tokens.map(token =>
              messaging.send({
                token,
                notification: {
                  title: notif.title,
                  body: notif.body
                },
                data: Object.entries(notif.data || {}).reduce((acc, [key, val]) => {
                  acc[key] = String(val);
                  return acc;
                }, {}),
                android: {
                  priority: 'high',
                  notification: {
                    sound: 'default',
                    channelId: 'medication_reminders',
                    priority: 'high'
                  }
                },
                apns: {
                  headers: { 'apns-priority': '10' },
                  payload: {
                    aps: {
                      sound: 'default',
                      badge: 1,
                      'content-available': 1
                    }
                  }
                }
              }).catch(err => {
                console.error(`âŒ [CRON] Error enviando a token ${token.substring(0, 20)}...`, err.message);
                return null;
              })
            );

            await Promise.all(promises);

            // Guardar en historial de notificaciones
            await db.collection('notifications').add({
              userId: notif.userId,
              childId: notif.childId,
              type: notif.type,
              title: notif.title,
              body: notif.body,
              data: notif.data,
              read: false,
              sentAt: admin.firestore.FieldValue.serverTimestamp(),
              createdAt: admin.firestore.FieldValue.serverTimestamp()
            });

            // Marcar como enviado
            await doc.ref.update({ 
              sent: true, 
              sentAt: now,
              sentToTokens: tokens.length
            });
            
            sentCount++;
            console.log(`âœ… [CRON] NotificaciÃ³n enviada a ${tokens.length} dispositivo(s)`);

            // Programar follow-up si aplica
            if (notif.type === 'medication_reminder' && notif.followUpMinutes) {
              await scheduleMedicationFollowup(notif, doc.id);
            }

          } catch (sendError) {
            console.error('âŒ [CRON] Error enviando push:', sendError);
            await doc.ref.update({ 
              sent: true, 
              failed: true, 
              failReason: sendError.message,
              sentAt: now
            });
            errorCount++;
          }

        } else {
          // TodavÃ­a falta tiempo, se procesarÃ¡ en el prÃ³ximo ciclo
          scheduledCount++;
          console.log(`â³ [CRON] Programada para dentro de ${minutesUntil.toFixed(1)} min: ${notif.title}`);
        }

      } catch (docError) {
        console.error(`âŒ [CRON] Error procesando documento ${doc.id}:`, docError);
        errorCount++;
      }
    }

    const summary = {
      success: true,
      sent: sentCount,
      scheduled: scheduledCount,
      errors: errorCount,
      noTokens: noTokensCount,
      total: pendingSnapshot.size,
      timestamp: now.toISOString()
    };

    console.log(`âœ… [CRON] Resumen: ${sentCount} enviados, ${scheduledCount} programados, ${errorCount} errores, ${noTokensCount} sin tokens`);

    res.json(summary);

  } catch (error) {
    console.error('âŒ [CRON] Error general procesando medicamentos:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// ============================================================================
// ðŸ’Š SISTEMA DE MEDICAMENTOS Y RECORDATORIOS
// ============================================================================
app.post('/api/medications', authenticateToken, (req, res) => {
  medicationsController.createMedication(req, res);
});

app.get('/api/medications/:childId', authenticateToken, (req, res) => {
  medicationsController.listMedications(req, res);
});

app.put('/api/medications/:medicationId', authenticateToken, (req, res) => {
  medicationsController.updateMedication(req, res);
});

app.delete('/api/medications/:medicationId', authenticateToken, (req, res) => {
  medicationsController.deleteMedication(req, res);
});

app.post('/api/medications/reminders/:reminderId/taken', authenticateToken, (req, res) => {
  medicationsController.markMedicationTaken(req, res);
});

// ============================================================================
// ðŸŽ¨ SISTEMA DE ACTIVIDADES PARA BEBÃ‰S
// ============================================================================
const activitiesController = require('./controllers/activitiesController');

// Obtener sugerencias de actividades basadas en edad y ventanas de vigilia
app.get('/api/activities/suggestions/:childId', authenticateToken, (req, res) => {
  activitiesController.getActivitySuggestions(req, res);
});

// Actualizar evento de sueÃ±o
app.put('/api/sleep/:eventId', authenticateToken, (req, res) => {
  sleepController.updateSleepEvent(req, res);
});

// Eliminar evento de sueÃ±o
app.delete('/api/sleep/:eventId', authenticateToken, (req, res) => {
  sleepController.deleteSleepEvent(req, res);
});

// Agregar pausa a un evento de sueÃ±o
app.post('/api/sleep/:eventId/pause', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId } = req.params;
    const { startTime, endTime, duration, reason } = req.body;

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Calcular duraciÃ³n de la pausa si no se proporciona
    let pauseDuration = duration;
    if (startTime && endTime && !duration) {
      const start = new Date(startTime);
      const end = new Date(endTime);
      pauseDuration = Math.floor((end - start) / 1000 / 60); // en minutos
    }

    // Crear objeto de pausa
    const pause = {
      id: `pause_${Date.now()}`,
      startTime: startTime || null,
      endTime: endTime || null,
      duration: pauseDuration || 0,
      reason: reason || 'DespertÃ³',
      createdAt: new Date().toISOString()
    };

    // Obtener pausas existentes
    const pauses = eventData.pauses || [];
    pauses.push(pause);

    // Recalcular duraciÃ³n neta
    const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
    const grossDuration = eventData.grossDuration || eventData.duration || 0;
    const netDuration = Math.max(0, grossDuration - totalPauseTime);

    // Actualizar evento
    await db.collection('sleepEvents').doc(eventId).update({
      pauses,
      netDuration,
      duration: netDuration,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    res.json({
      success: true,
      message: 'Pausa agregada exitosamente',
      pause,
      totalPauses: pauses.length,
      netDuration
    });

  } catch (error) {
    console.error('âŒ Error al agregar pausa:', error);
    res.status(500).json({
      error: 'Error al agregar pausa',
      details: error.message
    });
  }
});

// Eliminar pausa de un evento de sueÃ±o
app.delete('/api/sleep/:eventId/pause/:pauseId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId, pauseId } = req.params;

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Filtrar pausas para eliminar la especificada
    const pauses = (eventData.pauses || []).filter(p => p.id !== pauseId);

    // Recalcular duraciÃ³n neta
    const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
    const grossDuration = eventData.grossDuration || eventData.duration || 0;
    const netDuration = Math.max(0, grossDuration - totalPauseTime);

    // Actualizar evento
    await db.collection('sleepEvents').doc(eventId).update({
      pauses,
      netDuration,
      duration: netDuration,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    res.json({
      success: true,
      message: 'Pausa eliminada exitosamente',
      totalPauses: pauses.length,
      netDuration
    });

  } catch (error) {
    console.error('âŒ Error al eliminar pausa:', error);
    res.status(500).json({
      error: 'Error al eliminar pausa',
      details: error.message
    });
  }
});

// Editar horarios de un evento (inicio/fin)
app.patch('/api/sleep/:eventId/times', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId } = req.params;
    const { startTime, endTime } = req.body;

    if (!startTime && !endTime) {
      return res.status(400).json({
        error: 'Debes proporcionar al menos startTime o endTime'
      });
    }

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Preparar actualizaciones
    const updates = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    // Actualizar horarios
    const newStartTime = startTime 
      ? new Date(startTime) 
      : eventData.startTime.toDate();
    
    const newEndTime = endTime 
      ? new Date(endTime) 
      : (eventData.endTime ? eventData.endTime.toDate() : null);

    if (startTime) {
      updates.startTime = admin.firestore.Timestamp.fromDate(new Date(startTime));
    }
    if (endTime) {
      updates.endTime = admin.firestore.Timestamp.fromDate(new Date(endTime));
    }

    // Recalcular duraciones
    if (newStartTime && newEndTime) {
      const grossDuration = Math.floor((newEndTime - newStartTime) / 1000 / 60);
      const pauses = eventData.pauses || [];
      const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
      const netDuration = Math.max(0, grossDuration - totalPauseTime);

      updates.grossDuration = grossDuration;
      updates.netDuration = netDuration;
      updates.duration = netDuration;
    }

    await db.collection('sleepEvents').doc(eventId).update(updates);

    // Obtener evento actualizado
    const updatedDoc = await db.collection('sleepEvents').doc(eventId).get();
    const updatedData = updatedDoc.data();

    res.json({
      success: true,
      message: 'Horarios actualizados exitosamente',
      sleepEvent: {
        id: eventId,
        startTime: updatedData.startTime.toDate().toISOString(),
        endTime: updatedData.endTime ? updatedData.endTime.toDate().toISOString() : null,
        duration: updatedData.duration,
        grossDuration: updatedData.grossDuration,
        netDuration: updatedData.netDuration,
        pauses: updatedData.pauses || []
      }
    });

  } catch (error) {
    console.error('âŒ Error al actualizar horarios:', error);
    res.status(500).json({
      error: 'Error al actualizar horarios',
      details: error.message
    });
  }
});

// Obtener anÃ¡lisis detallado de patrones
app.get('/api/sleep/analysis/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;
    const { days = 30 } = req.query;

    // Obtener informaciÃ³n del niÃ±o
    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({ error: 'NiÃ±o no encontrado' });
    }

    const childData = childDoc.data();
    const birthDate = childData.birthDate.toDate();
    const ageInMonths = sleepController.calculateAgeInMonths(birthDate);

    // Obtener historial
    const sleepHistory = await sleepController.getSleepHistory(userId, childId, parseInt(days));

    if (sleepHistory.length === 0) {
      return res.json({
        success: true,
        message: 'No hay datos de sueÃ±o registrados',
        childInfo: { name: childData.name, ageInMonths }
      });
    }

    // Analizar patrones
    const patterns = sleepController.analyzeSleepPatterns(sleepHistory, ageInMonths);
    const recommendations = sleepController.generateRecommendations(patterns, ageInMonths, sleepHistory);

    res.json({
      success: true,
      analysis: {
        patterns,
        recommendations,
        childInfo: {
          name: childData.name,
          ageInMonths
        },
        dataRange: {
          days: parseInt(days),
          totalEvents: sleepHistory.length,
          firstEvent: sleepHistory[0].startTime,
          lastEvent: sleepHistory[sleepHistory.length - 1].startTime
        }
      }
    });

  } catch (error) {
    console.error('âŒ Error en anÃ¡lisis de sueÃ±o:', error);
    res.status(500).json({
      error: 'Error al generar anÃ¡lisis',
      details: error.message
    });
  }
});

// Obtener estadÃ­sticas semanales/mensuales
app.get('/api/sleep/stats/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;
    const { period = 'week' } = req.query; // 'week' o 'month'
    
    const days = period === 'week' ? 7 : 30;
    const sleepHistory = await sleepController.getSleepHistory(userId, childId, days);

    if (sleepHistory.length === 0) {
      return res.json({
        success: true,
        message: 'No hay datos disponibles',
        stats: null
      });
    }

    // Agrupar por dÃ­as
    const dailyStats = {};
    
    sleepHistory.forEach(event => {
      const date = new Date(event.startTime).toISOString().split('T')[0];
      
      if (!dailyStats[date]) {
        dailyStats[date] = {
          date,
          totalSleep: 0,
          naps: 0,
          nightSleep: 0,
          events: []
        };
      }

      dailyStats[date].events.push(event);
      dailyStats[date].totalSleep += event.duration || 0;
      
      if (event.type === 'nap') {
        dailyStats[date].naps++;
      } else {
        dailyStats[date].nightSleep += event.duration || 0;
      }
    });

    const dailyArray = Object.values(dailyStats).sort((a, b) => 
      new Date(a.date) - new Date(b.date)
    );

    res.json({
      success: true,
      period,
      days,
      dailyStats: dailyArray,
      summary: {
        totalEvents: sleepHistory.length,
        avgSleepPerDay: Math.round(
          dailyArray.reduce((sum, day) => sum + day.totalSleep, 0) / dailyArray.length
        ),
        avgNapsPerDay: parseFloat(
          (dailyArray.reduce((sum, day) => sum + day.naps, 0) / dailyArray.length).toFixed(1)
        )
      }
    });

  } catch (error) {
    console.error('âŒ Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      error: 'Error al obtener estadÃ­sticas',
      details: error.message
    });
  }
});

// Endpoint para obtener recordatorios inteligentes
app.get('/api/sleep/reminders/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;

    // Obtener predicciÃ³n
    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({ error: 'NiÃ±o no encontrado' });
    }

    const childData = childDoc.data();
    const birthDate = childData.birthDate.toDate();
    const ageInMonths = sleepController.calculateAgeInMonths(birthDate);

    // âœ… Construir childInfo correctamente (con id y userId)
    const childInfo = {
      id: childId,
      userId: userId,
      name: childData.name,
      ageInMonths: ageInMonths
    };

    // âœ… CAMBIO: Siempre generar predicciÃ³n (eliminar validaciÃ³n de 3 datos)
    // Incluso sin historial, darÃ¡ horarios por defecto

    // ðŸŒ Obtener timezone del usuario
    const TimezoneHelper = require('./utils/timezoneHelper');
    const userTimezone = TimezoneHelper.getUserTimezone(req);

    // âš¡ Intentar usar cache de predicciones recientes (evitar recomputo)
    const todayInfo = TimezoneHelper.getTodayInUserTimezone(userTimezone);
    const todayStr = format(todayInfo.userLocalTime, 'yyyy-MM-dd');
    const predictionDoc = await db.collection('sleepPredictions').doc(`${childId}_${todayStr}`).get();
    const forceRefresh = req.query?.force === 'true' || req.headers['x-force-refresh'] === 'true';
    const cacheTtlMinutes = 5;

    if (!forceRefresh && predictionDoc.exists) {
      const cached = predictionDoc.data();
      const lastUpdated = cached.lastUpdated?.toDate ? cached.lastUpdated.toDate() : null;
      const cacheAgeMinutes = lastUpdated ? Math.floor((Date.now() - lastUpdated.getTime()) / 60000) : null;
      const hasPredictions = (cached.predictedNaps && cached.predictedNaps.length > 0) || cached.predictedBedtime;

      if (hasPredictions && cacheAgeMinutes !== null && cacheAgeMinutes <= cacheTtlMinutes) {
        const reminders = [];
        const now = new Date();

        const nextNap = cached.predictedNaps && cached.predictedNaps.length > 0
          ? cached.predictedNaps[0]
          : null;

        if (nextNap?.time) {
          const napTime = new Date(nextNap.time);
          const minutesUntilNap = Math.floor((napTime - now) / 60000);
          if (minutesUntilNap > 0 && minutesUntilNap <= 30) {
            reminders.push({
              type: 'nap',
              title: 'ðŸ›Œ Hora de siesta pronto',
              message: `La prÃ³xima siesta de ${childData.name} es en ${minutesUntilNap} minutos`,
              time: nextNap.time,
              minutesUntil: minutesUntilNap,
              priority: minutesUntilNap <= 15 ? 'high' : 'medium'
            });
          }
        }

        if (cached.predictedBedtime?.time) {
          const bedtime = new Date(cached.predictedBedtime.time);
          const minutesUntilBedtime = Math.floor((bedtime - now) / 60000);
          if (minutesUntilBedtime > 0 && minutesUntilBedtime <= 60) {
            reminders.push({
              type: 'bedtime',
              title: 'ðŸŒ™ Hora de dormir se acerca',
              message: `Es hora de empezar la rutina de ${childData.name}`,
              time: cached.predictedBedtime.time,
              minutesUntil: minutesUntilBedtime,
              priority: minutesUntilBedtime <= 30 ? 'high' : 'medium'
            });
          }
        }

        return res.json({
          success: true,
          reminders,
          sleepPressure: cached.sleepPressure || null,
          nextPrediction: {
            nap: nextNap,
            bedtime: cached.predictedBedtime || null
          },
          timezone: userTimezone,
          cached: true
        });
      }
    }

    const sleepHistory = await sleepController.getSleepHistory(userId, childId, 7);
    const prediction = await sleepController.generateSleepPrediction(
      sleepHistory,
      ageInMonths,
      childInfo,  // âœ… Pasar childInfo, no childData
      userTimezone  // âœ… Pasar timezone
    );

    const reminders = [];
    const now = new Date();

    // Recordatorio de siesta
    if (prediction.nextNap && prediction.nextNap.time) {
      const napTime = new Date(prediction.nextNap.time);
      const minutesUntilNap = Math.floor((napTime - now) / 1000 / 60);

      if (minutesUntilNap > 0 && minutesUntilNap <= 30) {
        reminders.push({
          type: 'nap',
          title: 'ðŸ›Œ Hora de siesta pronto',
          message: `La prÃ³xima siesta de ${childData.name} es en ${minutesUntilNap} minutos`,
          time: prediction.nextNap.time,
          minutesUntil: minutesUntilNap,
          priority: minutesUntilNap <= 15 ? 'high' : 'medium'
        });
      }
    }

    // Recordatorio de hora de dormir
    if (prediction.bedtime && prediction.bedtime.time) {
      const bedtime = new Date(prediction.bedtime.time);
      const minutesUntilBedtime = Math.floor((bedtime - now) / 1000 / 60);

      if (minutesUntilBedtime > 0 && minutesUntilBedtime <= 60) {
        reminders.push({
          type: 'bedtime',
          title: 'ðŸŒ™ Hora de dormir se acerca',
          message: `Es hora de empezar la rutina de ${childData.name}`,
          time: prediction.bedtime.time,
          minutesUntil: minutesUntilBedtime,
          priority: minutesUntilBedtime <= 30 ? 'high' : 'medium'
        });
      }
    }

    // Recordatorio de presiÃ³n de sueÃ±o alta
    if (prediction.sleepPressure && prediction.sleepPressure.level === 'critical') {
      reminders.push({
        type: 'urgent',
        title: 'âš ï¸ Necesita dormir urgentemente',
        message: prediction.sleepPressure.recommendation,
        priority: 'critical'
      });
    }

    // ðŸŒ Localizar las fechas a la timezone del usuario
    const localizedPrediction = sleepController.localizePredictionDates(prediction, userTimezone);
    
    res.json({
      success: true,
      reminders,
      sleepPressure: localizedPrediction.sleepPressure,
      nextPrediction: {
        nap: localizedPrediction.nextNap,
        bedtime: localizedPrediction.bedtime
      },
      timezone: userTimezone  // âœ… Indicar timezone
    });

  } catch (error) {
    console.error('âŒ Error obteniendo recordatorios:', error);
    res.status(500).json({
      error: 'Error al obtener recordatorios',
      details: error.message
    });
  }
});

console.log('ðŸ›Œ Sistema de predicciÃ³n de sueÃ±o cargado');

// ============================================================================
// ðŸ“° ARTICULOS (BLOG) - DASHBOARD Y APP
// ============================================================================

const slugifyText = (value) => {
  if (!value) return '';
  return String(value)
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

const stripHtml = (html) => {
  if (!html) return '';
  return String(html).replace(/<[^>]*>/g, ' ');
};

const calculateReadingTimeMinutes = (html) => {
  const text = stripHtml(html);
  const words = text.trim().split(/\s+/).filter(Boolean).length;
  return Math.max(1, Math.ceil(words / 200));
};

const resolveAuthorInfo = async (uid, fallbackName) => {
  if (!db) {
    return { uid, name: fallbackName || 'Usuario' };
  }
  const userDoc = await db.collection('users').doc(uid).get();
  const userData = userDoc.exists ? userDoc.data() : {};
  return {
    uid,
    name: fallbackName || userData.displayName || userData.name || userData.email || 'Usuario'
  };
};

const resolveProfessionalAuthor = async (professionalId) => {
  if (!db) {
    return { id: professionalId, name: 'Profesional' };
  }
  const doc = await db.collection('professionals').doc(professionalId).get();
  if (!doc.exists) {
    const error = new Error('Perfil profesional no encontrado');
    error.code = 'professional-not-found';
    throw error;
  }
  const data = doc.data() || {};
  return {
    id: doc.id,
    userId: data.userId || null,
    name: data.name || 'Profesional',
    headline: data.headline || null,
    photoUrl: data.photoUrl || null,
    contactEmail: data.contactEmail || null,
    contactPhone: data.contactPhone || null,
    website: data.website || null
  };
};

const resolveProfessionalProfileCategory = async (categoryId) => {
  if (!db) {
    return { id: categoryId, name: 'CategorÃ­a' };
  }
  const doc = await db.collection('professional_profile_categories').doc(categoryId).get();
  if (!doc.exists) {
    const error = new Error('CategorÃ­a de perfil no encontrada');
    error.code = 'professional-profile-category-not-found';
    throw error;
  }
  const data = doc.data() || {};
  return {
    id: doc.id,
    name: data.name || 'CategorÃ­a',
    logoUrl: data.logoUrl || null
  };
};

const fetchProfessionalsMap = async (ids) => {
  const map = new Map();
  if (!db || !Array.isArray(ids) || ids.length === 0) return map;
  const uniqueIds = Array.from(new Set(ids.filter(Boolean)));
  const chunkSize = 10;
  for (let i = 0; i < uniqueIds.length; i += chunkSize) {
    const chunk = uniqueIds.slice(i, i + chunkSize);
    const snapshot = await db.collection('professionals')
      .where(admin.firestore.FieldPath.documentId(), 'in', chunk)
      .get();
    snapshot.forEach(doc => {
      const data = doc.data() || {};
      map.set(doc.id, {
        id: doc.id,
        userId: data.userId || null,
        name: data.name || 'Profesional',
        headline: data.headline || null,
        photoUrl: data.photoUrl || null,
        contactEmail: data.contactEmail || null,
        contactPhone: data.contactPhone || null,
        website: data.website || null
      });
    });
  }
  return map;
};

const fetchCategoriesMap = async () => {
  if (!db) return new Map();
  const snapshot = await db.collection('article_categories').get();
  const map = new Map();
  snapshot.forEach(doc => {
    map.set(doc.id, { id: doc.id, ...doc.data() });
  });
  return map;
};

const fetchKeywordsMap = async () => {
  if (!db) return new Map();
  const snapshot = await db.collection('article_keywords').get();
  const map = new Map();
  snapshot.forEach(doc => {
    map.set(doc.id, { id: doc.id, ...doc.data() });
  });
  return map;
};

// =========================
// Categorias (admin/app)
// =========================

app.get('/api/articles/categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('article_categories').orderBy('name', 'asc').get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('âŒ Error obteniendo categorias:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categorias', error: error.message });
  }
});

app.post('/api/admin/article-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description } = req.body || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const slug = slugifyText(name);
    const categoryData = {
      name,
      description: description || '',
      slug,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('article_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('âŒ Error creando categoria:', error);
    res.status(500).json({ success: false, message: 'Error creando categoria', error: error.message });
  }
});

app.put('/api/admin/article-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    await db.collection('article_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ Error actualizando categoria:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categoria', error: error.message });
  }
});

app.delete('/api/admin/article-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('article_categories').doc(id).delete();
    res.json({ success: true, message: 'Categoria eliminada' });
  } catch (error) {
    console.error('âŒ Error eliminando categoria:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categoria', error: error.message });
  }
});

// =========================
// Palabras clave (admin/app)
// =========================

app.get('/api/articles/keywords', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('article_keywords').orderBy('name', 'asc').get();
    const keywords = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: keywords });
  } catch (error) {
    console.error('âŒ Error obteniendo palabras clave:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo palabras clave', error: error.message });
  }
});

app.post('/api/admin/article-keywords', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const slug = slugifyText(name);
    const keywordData = {
      name,
      slug,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('article_keywords').add(keywordData);
    res.json({ success: true, data: { id: ref.id, ...keywordData } });
  } catch (error) {
    console.error('âŒ Error creando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error creando palabra clave', error: error.message });
  }
});

app.put('/api/admin/article-keywords/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    await db.collection('article_keywords').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ Error actualizando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error actualizando palabra clave', error: error.message });
  }
});

app.delete('/api/admin/article-keywords/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('article_keywords').doc(id).delete();
    res.json({ success: true, message: 'Palabra clave eliminada' });
  } catch (error) {
    console.error('âŒ Error eliminando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error eliminando palabra clave', error: error.message });
  }
});

// =========================
// Articulos (dashboard/app)
// =========================

// Subir imagen para artÃ­culos (admin)
app.post('/api/admin/articles/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se enviÃ³ ninguna imagen'
      });
    }

    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Storage no disponible'
      });
    }

    const fileName = `images/articles/article-${req.user.uid}-${Date.now()}-${req.file.originalname}`;
    const file = bucket.file(fileName);

    const stream = file.createWriteStream({
      metadata: {
        contentType: req.file.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('âŒ [ARTICLES] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      try {
        await file.makePublic();
      } catch (error) {
        console.warn('âš ï¸ [ARTICLES] Error haciendo imagen pÃºblica:', error.message);
      }

      res.json({
        success: true,
        data: {
          imageUrl: `https://storage.googleapis.com/${bucket.name}/${fileName}`,
          imageStoragePath: fileName
        }
      });
    });

    stream.end(req.file.buffer);
  } catch (error) {
    console.error('âŒ [ARTICLES] Error subiendo imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Listar artÃ­culos (admin)
app.get('/api/admin/articles', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', status } = req.query;

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('articles');
    if (status) {
      query = query.where('status', '==', status);
    }

    const snapshot = await query.orderBy('publishedAt', 'desc').get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const bannerIds = new Set();
    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.bannerId) bannerIds.add(data.bannerId);
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const bannerMap = new Map();
    if (bannerIds.size > 0) {
      const bannerSnapshot = await db.collection('banners')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(bannerIds).slice(0, 10))
        .get();
      bannerSnapshot.forEach(doc => {
        bannerMap.set(doc.id, { id: doc.id, ...doc.data() });
      });
    }
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const banner = data.bannerId ? bannerMap.get(data.bannerId) || null : null;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo artÃ­culos:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo artÃ­culos', error: error.message });
  }
});

app.get('/api/articles', authenticateToken, async (req, res) => {
  try {
    const { categoryId, keywordId, search = '', page = 1, limit = 20 } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('articles').where('status', '==', 'published');
    if (categoryId) query = query.where('categoryId', '==', categoryId);
    if (keywordId) query = query.where('keywordIds', 'array-contains', keywordId);

    const snapshot = await query.orderBy('publishedAt', 'desc').get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const bannerIds = new Set();
    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.bannerId) bannerIds.add(data.bannerId);
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const bannerMap = new Map();
    if (bannerIds.size > 0) {
      const bannerSnapshot = await db.collection('banners')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(bannerIds).slice(0, 10))
        .get();
      bannerSnapshot.forEach(doc => {
        bannerMap.set(doc.id, { id: doc.id, ...doc.data() });
      });
    }
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const banner = data.bannerId ? bannerMap.get(data.bannerId) || null : null;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo articulos:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulos', error: error.message });
  }
});

// Listar artÃ­culos por categorÃ­a (app)
app.get('/api/articles/category/:categoryId', authenticateToken, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const { search = '', page = 1, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('articles')
      .where('status', '==', 'published')
      .where('categoryId', '==', categoryId)
      .orderBy('publishedAt', 'desc');

    const snapshot = await query.get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ [ARTICLES] Error obteniendo artÃ­culos por categorÃ­a:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo artÃ­culos', error: error.message });
  }
});

app.get('/api/articles/:articleId', authenticateToken, async (req, res) => {
  try {
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const doc = await db.collection('articles').doc(articleId).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Articulo no encontrado' });
    }
    const data = doc.data();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();
    const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
    const keywords = Array.isArray(data.keywordIds)
      ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
      : [];
    const shareUrl = `munpa://article/${doc.id}`;
    const webUrl = `https://munpa.online/article/${doc.id}`;
    let banner = null;
    if (data.bannerId) {
      try {
        const bannerDoc = await db.collection('banners').doc(data.bannerId).get();
        if (bannerDoc.exists) {
          banner = { id: bannerDoc.id, ...bannerDoc.data() };
        }
      } catch (error) {
        console.warn('âš ï¸ [ARTICLES] Error obteniendo banner:', error.message);
      }
    }
    let authorProfessional = null;
    if (data.professionalId) {
      try {
        authorProfessional = await resolveProfessionalAuthor(data.professionalId);
      } catch (error) {
        console.warn('âš ï¸ [ARTICLES] Error obteniendo profesional:', error.message);
      }
    }
    res.json({
      success: true,
      data: {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo articulo:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulo', error: error.message });
  }
});

app.post('/api/admin/articles', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { uid } = req.user;
    const {
      title,
      htmlContent,
      publishedAt,
      readingTimeMinutes,
      authorName,
      professionalId,
      categoryId,
      keywordIds,
      coverImageUrl,
      bannerId,
      summary,
      status = 'published'
    } = req.body || {};

    if (!title || !htmlContent || !professionalId) {
      return res.status(400).json({ success: false, message: 'title, htmlContent y professionalId son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const authorProfessional = await resolveProfessionalAuthor(professionalId);
    const author = {
      uid: authorProfessional.userId || uid,
      name: authorProfessional.name || authorName || 'Profesional'
    };
    const articleData = {
      title,
      htmlContent,
      summary: summary || '',
      coverImageUrl: coverImageUrl || '',
      categoryId: categoryId || null,
      keywordIds: Array.isArray(keywordIds) ? keywordIds : [],
      readingTimeMinutes: readingTimeMinutes || calculateReadingTimeMinutes(htmlContent),
      publishedAt: publishedAt ? new Date(publishedAt) : new Date(),
      author,
      professionalId,
      authorProfessional,
      bannerId: bannerId || null,
      status,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const ref = await db.collection('articles').add(articleData);
    res.json({ success: true, data: { id: ref.id, ...articleData } });
  } catch (error) {
    console.error('âŒ Error creando articulo:', error);
    res.status(500).json({ success: false, message: 'Error creando articulo', error: error.message });
  }
});

app.put('/api/admin/articles/:articleId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    const {
      title,
      htmlContent,
      publishedAt,
      readingTimeMinutes,
      authorName,
      professionalId,
      categoryId,
      keywordIds,
      coverImageUrl,
      bannerId,
      summary,
      status
    } = req.body || {};

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const updateData = { updatedAt: new Date() };
    if (title) updateData.title = title;
    if (htmlContent) {
      updateData.htmlContent = htmlContent;
      updateData.readingTimeMinutes = readingTimeMinutes || calculateReadingTimeMinutes(htmlContent);
    } else if (readingTimeMinutes) {
      updateData.readingTimeMinutes = readingTimeMinutes;
    }
    if (publishedAt) updateData.publishedAt = new Date(publishedAt);
    if (categoryId !== undefined) updateData.categoryId = categoryId;
    if (Array.isArray(keywordIds)) updateData.keywordIds = keywordIds;
    if (summary !== undefined) updateData.summary = summary;
    if (coverImageUrl !== undefined) updateData.coverImageUrl = coverImageUrl;
    if (bannerId !== undefined) updateData.bannerId = bannerId || null;
    if (status) updateData.status = status;
    if (authorName && professionalId === undefined) {
      return res.status(400).json({ success: false, message: 'Para cambiar autor se requiere professionalId' });
    }
    if (professionalId !== undefined) {
      const authorProfessional = await resolveProfessionalAuthor(professionalId);
      updateData.professionalId = professionalId;
      updateData.authorProfessional = authorProfessional;
      updateData.author = {
        uid: authorProfessional.userId || uid,
        name: authorProfessional.name || authorName || 'Profesional'
      };
    }

    await db.collection('articles').doc(articleId).update(updateData);
    res.json({ success: true, data: { id: articleId, ...updateData } });
  } catch (error) {
    console.error('âŒ Error actualizando articulo:', error);
    res.status(500).json({ success: false, message: 'Error actualizando articulo', error: error.message });
  }
});

app.delete('/api/admin/articles/:articleId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('articles').doc(articleId).delete();
    res.json({ success: true, message: 'Articulo eliminado' });
  } catch (error) {
    console.error('âŒ Error eliminando articulo:', error);
    res.status(500).json({ success: false, message: 'Error eliminando articulo', error: error.message });
  }
});

// =========================
// Guardar articulos (app)
// =========================

app.post('/api/articles/:articleId/save', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const articleDoc = await db.collection('articles').doc(articleId).get();
    if (!articleDoc.exists) {
      return res.status(404).json({ success: false, message: 'Articulo no encontrado' });
    }
    await db.collection('users').doc(uid)
      .collection('saved_articles')
      .doc(articleId)
      .set({
        articleId,
        savedAt: new Date()
      });
    res.json({ success: true, message: 'Articulo guardado' });
  } catch (error) {
    console.error('âŒ Error guardando articulo:', error);
    res.status(500).json({ success: false, message: 'Error guardando articulo', error: error.message });
  }
});

app.delete('/api/articles/:articleId/save', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('users').doc(uid)
      .collection('saved_articles')
      .doc(articleId)
      .delete();
    res.json({ success: true, message: 'Articulo eliminado de guardados' });
  } catch (error) {
    console.error('âŒ Error eliminando articulo guardado:', error);
    res.status(500).json({ success: false, message: 'Error eliminando articulo guardado', error: error.message });
  }
});

app.get('/api/articles/saved', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const savedSnapshot = await db.collection('users').doc(uid)
      .collection('saved_articles')
      .orderBy('savedAt', 'desc')
      .get();

    if (savedSnapshot.empty) {
      return res.json({ success: true, data: [] });
    }

    const articleIds = savedSnapshot.docs.map(doc => doc.id);
    const articlesSnapshot = await db.collection('articles')
      .where(admin.firestore.FieldPath.documentId(), 'in', articleIds.slice(0, 10))
      .get();

    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();
    const articlesMap = new Map();
    articlesSnapshot.forEach(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      articlesMap.set(doc.id, { id: doc.id, ...data, category, keywords });
    });

    const savedArticles = savedSnapshot.docs.map(doc => articlesMap.get(doc.id)).filter(Boolean);
    res.json({ success: true, data: savedArticles });
  } catch (error) {
    console.error('âŒ Error obteniendo articulos guardados:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulos guardados', error: error.message });
  }
});

// ============================================================================
// ðŸ“± VERSIONES DE APP (ADMIN + PUBLICO)
// ============================================================================

// Obtener configuraciÃ³n de versiÃ³n (pÃºblico)
app.get('/api/app/version', async (req, res) => {
  try {
    const { platform } = req.query;
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('app_versions').doc(normalizedPlatform).get();
    if (!doc.exists) {
      return res.json({
        success: true,
        data: {
          platform: normalizedPlatform,
          minVersion: null,
          latestVersion: null,
          forceUpdate: false,
          message: null
        }
      });
    }

    res.json({
      success: true,
      data: {
        platform: normalizedPlatform,
        ...doc.data()
      }
    });
  } catch (error) {
    console.error('âŒ [APP] Error obteniendo versiÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo versiÃ³n',
      error: error.message
    });
  }
});

// Crear/actualizar configuraciÃ³n de versiÃ³n (admin)
app.post('/api/admin/app/version', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { platform, minVersion, latestVersion, forceUpdate, message } = req.body || {};
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const payload = {
      minVersion: minVersion || null,
      latestVersion: latestVersion || null,
      forceUpdate: Boolean(forceUpdate),
      message: message || null,
      updatedAt: new Date()
    };

    await db.collection('app_versions').doc(normalizedPlatform).set(payload, { merge: true });

    res.json({
      success: true,
      data: { platform: normalizedPlatform, ...payload }
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error guardando versiÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando versiÃ³n',
      error: error.message
    });
  }
});

// Obtener configuraciÃ³n de versiÃ³n (admin)
app.get('/api/admin/app/version', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { platform } = req.query;
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('app_versions').doc(normalizedPlatform).get();
    if (!doc.exists) {
      return res.json({
        success: true,
        data: {
          platform: normalizedPlatform,
          minVersion: null,
          latestVersion: null,
          forceUpdate: false,
          message: null
        }
      });
    }

    res.json({
      success: true,
      data: {
        platform: normalizedPlatform,
        ...doc.data()
      }
    });
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo versiÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo versiÃ³n',
      error: error.message
    });
  }
});

// ============================================================================
// ðŸ‘©â€âš•ï¸ SERVICIOS PROFESIONALES (PERFILES + SERVICIOS + PAQUETES)
// ============================================================================

const buildProfessionalPayload = (data) => ({
  userId: data.userId,
  name: data.name || '',
  headline: data.headline || '',
  bio: data.bio || '',
  photoUrl: data.photoUrl || '',
  specialties: Array.isArray(data.specialties) ? data.specialties : [],
  tags: Array.isArray(data.tags) ? data.tags : [],
  profileCategoryId: data.profileCategoryId || null,
  profileCategory: data.profileCategory || null,
  location: data.location || '',
  countryId: data.countryId || null,
  countryName: data.countryName || null,
  cityId: data.cityId || null,
  cityName: data.cityName || null,
  locations: Array.isArray(data.locations) ? data.locations : [],
  contactEmail: data.contactEmail || '',
  contactPhone: data.contactPhone || '',
  website: data.website || '',
  address: data.address || '',
  latitude: Number.isFinite(data.latitude) ? data.latitude : null,
  longitude: Number.isFinite(data.longitude) ? data.longitude : null,
  instagram: data.instagram || '',
  whatsappLink: data.whatsappLink || '',
  extraInfo: data.extraInfo || '',
  logoUrl: data.logoUrl || '',
  status: data.status || 'pending', // pending | active | suspended
  createdAt: new Date(),
  updatedAt: new Date()
});

// =========================
// Solicitudes de servicios profesionales (pre-registro)
// =========================

app.post('/api/professionals/requests/upload-logo', authenticateToken, upload.fields([{ name: 'logo', maxCount: 1 }, { name: 'image', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.logo?.[0] || req.files?.image?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se enviÃ³ ningÃºn logo (usa logo o image)' });
    }
    const allowedTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!allowedTypes.includes(fileUpload.mimetype)) {
      return res.status(400).json({ success: false, message: 'El logo debe ser PNG o JPG' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-requests/logo-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: { contentType: fileUpload.mimetype }
    });

    stream.on('error', (error) => {
      console.error('âŒ [PRO-REQ] Error subiendo logo:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('âš ï¸ [PRO-REQ] Error haciendo logo pÃºblico:', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error subiendo logo:', error);
    res.status(500).json({ success: false, message: 'Error subiendo logo', error: error.message });
  }
});

app.post('/api/professionals/requests', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const {
      businessName,
      summary,
      profileCategoryId,
      logoUrl,
      logoStoragePath,
      address,
      countryId,
      cityId,
      latitude,
      longitude,
      website,
      instagram,
      whatsappLink,
      extraInfo
    } = req.body || {};

    if (!businessName || String(businessName).trim().length < 3) {
      return res.status(400).json({ success: false, message: 'businessName es requerido' });
    }
    if (!summary || String(summary).trim().length < 10) {
      return res.status(400).json({ success: false, message: 'summary es requerido (mÃ­nimo 10 caracteres)' });
    }
    if (!profileCategoryId) {
      return res.status(400).json({ success: false, message: 'profileCategoryId es requerido' });
    }
    const categoryData = await resolveProfessionalProfileCategory(profileCategoryId);
    if (!logoUrl) {
      return res.status(400).json({ success: false, message: 'logoUrl es requerido' });
    }
    if (!address) {
      return res.status(400).json({ success: false, message: 'address es requerido' });
    }
    if (!countryId || !cityId) {
      return res.status(400).json({ success: false, message: 'countryId y cityId son requeridos' });
    }
    const lat = latitude !== undefined ? parseFloat(latitude) : NaN;
    const lng = longitude !== undefined ? parseFloat(longitude) : NaN;
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return res.status(400).json({ success: false, message: 'latitude y longitude son requeridos' });
    }

    let locationData = {};
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({ success: false, message: err.message });
    }

    const payload = {
      userId: req.user.uid,
      businessName: String(businessName).trim(),
      summary: String(summary).trim(),
      profileCategoryId,
      profileCategory: categoryData,
      logoUrl,
      logoStoragePath: logoStoragePath || null,
      address: String(address).trim(),
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      latitude: lat,
      longitude: lng,
      website: website || null,
      instagram: instagram || null,
      whatsappLink: whatsappLink || null,
      extraInfo: extraInfo || null,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const ref = await db.collection('professional_service_requests').add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error creando solicitud:', error);
    res.status(500).json({ success: false, message: 'Error creando solicitud', error: error.message });
  }
});

app.get('/api/admin/professionals/requests', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, status, search = '' } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('professional_service_requests');
    if (status) {
      query = query.where('status', '==', status);
    }
    const snapshot = await query.orderBy('createdAt', 'desc').get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.businessName?.toLowerCase().includes(searchLower) ||
        item.summary?.toLowerCase().includes(searchLower)
      );
    }
    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);
    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error listando solicitudes:', error);
    res.status(500).json({ success: false, message: 'Error listando solicitudes', error: error.message });
  }
});

app.get('/api/admin/professionals/requests/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const doc = await db.collection('professional_service_requests').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error obteniendo solicitud:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo solicitud', error: error.message });
  }
});

app.put('/api/admin/professionals/requests/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const docRef = db.collection('professional_service_requests').doc(id);
    const doc = await docRef.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }

    const updateData = { ...req.body };
    if (Object.prototype.hasOwnProperty.call(updateData, 'countryId')
      || Object.prototype.hasOwnProperty.call(updateData, 'cityId')) {
      try {
        const resolved = await resolveCountryCity(updateData.countryId, updateData.cityId);
        updateData.countryId = resolved.countryId;
        updateData.countryName = resolved.countryName;
        updateData.cityId = resolved.cityId;
        updateData.cityName = resolved.cityName;
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }
    if (Object.prototype.hasOwnProperty.call(updateData, 'profileCategoryId')) {
      if (!updateData.profileCategoryId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId invÃ¡lido' });
      }
      try {
        const categoryData = await resolveProfessionalProfileCategory(updateData.profileCategoryId);
        updateData.profileCategory = categoryData;
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    if (Object.prototype.hasOwnProperty.call(updateData, 'latitude')
      || Object.prototype.hasOwnProperty.call(updateData, 'longitude')) {
      const lat = updateData.latitude !== undefined ? parseFloat(updateData.latitude) : NaN;
      const lng = updateData.longitude !== undefined ? parseFloat(updateData.longitude) : NaN;
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        return res.status(400).json({ success: false, message: 'latitude y longitude invÃ¡lidos' });
      }
      updateData.latitude = lat;
      updateData.longitude = lng;
    }

    updateData.updatedAt = new Date();
    await docRef.update(stripUndefined(updateData));
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error actualizando solicitud (admin):', error);
    res.status(500).json({ success: false, message: 'Error actualizando solicitud', error: error.message });
  }
});

app.patch('/api/admin/professionals/requests/:id/status', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { status, notes } = req.body || {};
    if (!['pending', 'approved', 'rejected'].includes(status)) {
      return res.status(400).json({ success: false, message: 'status invÃ¡lido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const requestRef = db.collection('professional_service_requests').doc(id);
    const requestDoc = await requestRef.get();
    if (!requestDoc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }
    const requestData = requestDoc.data() || {};

    let professionalId = requestData.professionalId || null;
    let professionalPayload = null;
    if (status === 'approved') {
      if (professionalId) {
        return res.status(400).json({
          success: false,
          message: 'La solicitud ya tiene un perfil asociado',
          professionalId
        });
      }
      const missingFields = [];
      if (!requestData.userId) missingFields.push('userId');
      if (!requestData.businessName) missingFields.push('businessName');
      if (!requestData.summary) missingFields.push('summary');
      if (!requestData.profileCategoryId) missingFields.push('profileCategoryId');
      if (!requestData.logoUrl) missingFields.push('logoUrl');
      if (!requestData.address) missingFields.push('address');
      if (!requestData.countryId) missingFields.push('countryId');
      if (!requestData.cityId) missingFields.push('cityId');
      if (!Number.isFinite(parseFloat(requestData.latitude))) missingFields.push('latitude');
      if (!Number.isFinite(parseFloat(requestData.longitude))) missingFields.push('longitude');
      if (missingFields.length) {
        return res.status(400).json({
          success: false,
          message: 'Faltan campos obligatorios para aprobar',
          fields: missingFields
        });
      }

      let categoryData;
      try {
        categoryData = await resolveProfessionalProfileCategory(requestData.profileCategoryId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }

      professionalPayload = stripUndefined({
        userId: requestData.userId,
        name: requestData.businessName,
        headline: requestData.summary,
        bio: requestData.summary,
        photoUrl: requestData.logoUrl,
        profileCategoryId: requestData.profileCategoryId,
        profileCategory: categoryData,
        location: requestData.address,
        address: requestData.address,
        countryId: requestData.countryId,
        countryName: requestData.countryName,
        cityId: requestData.cityId,
        cityName: requestData.cityName,
        latitude: parseFloat(requestData.latitude),
        longitude: parseFloat(requestData.longitude),
        website: requestData.website || '',
        instagram: requestData.instagram || '',
        whatsappLink: requestData.whatsappLink || '',
        extraInfo: requestData.extraInfo || '',
        logoUrl: requestData.logoUrl,
        status: 'active',
        updatedAt: new Date()
      });

      const existingProfile = await db.collection('professionals')
        .where('userId', '==', requestData.userId)
        .limit(1)
        .get();
      if (!existingProfile.empty) {
        return res.status(400).json({
          success: false,
          message: 'El usuario ya tiene un perfil profesional',
          professionalId: existingProfile.docs[0].id
        });
      }
      const payload = buildProfessionalPayload({
        ...professionalPayload,
        status: 'active'
      });
      const createdRef = await db.collection('professionals').add(payload);
      professionalId = createdRef.id;
    }

    await requestRef.update(stripUndefined({
      status,
      professionalId: professionalId || null,
      adminNotes: notes || null,
      updatedAt: new Date()
    }));

    res.json({ success: true, data: { id, status, professionalId: professionalId || null } });
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error actualizando solicitud:', error);
    res.status(500).json({ success: false, message: 'Error actualizando solicitud', error: error.message });
  }
});

// =========================
// CategorÃ­as de perfil profesional (admin/app)
// =========================

app.get('/api/professionals/profile-categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professional_profile_categories')
      .orderBy('name', 'asc')
      .get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('âŒ [PRO] Error obteniendo categorÃ­as de perfil:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categorÃ­as', error: error.message });
  }
});

app.post('/api/admin/professionals/profile-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, logoUrl } = req.body || {};
    if (!name || !logoUrl) {
      return res.status(400).json({ success: false, message: 'name y logoUrl son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const categoryData = {
      name,
      description: description || '',
      logoUrl: logoUrl || '',
      slug: slugifyText(name),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professional_profile_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando categorÃ­a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error creando categorÃ­a', error: error.message });
  }
});

app.put('/api/admin/professionals/profile-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, logoUrl } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    if (logoUrl !== undefined) updateData.logoUrl = logoUrl || '';
    await db.collection('professional_profile_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando categorÃ­a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categorÃ­a', error: error.message });
  }
});

app.delete('/api/admin/professionals/profile-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('professional_profile_categories').doc(id).delete();
    res.json({ success: true, message: 'CategorÃ­a eliminada' });
  } catch (error) {
    console.error('âŒ [PRO] Error eliminando categorÃ­a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categorÃ­a', error: error.message });
  }
});

// Subir logo de categorÃ­a de perfil (admin)
app.post('/api/admin/professionals/profile-categories/upload-logo', authenticateToken, isAdmin, upload.fields([{ name: 'image', maxCount: 1 }, { name: 'logo', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.image?.[0] || req.files?.logo?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se enviÃ³ ninguna imagen' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-profile-categories/cat-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('âŒ [PRO] Error subiendo logo categorÃ­a de perfil:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('âš ï¸ [PRO] Error haciendo logo pÃºblico (perfil):', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('âŒ [PRO] Error subiendo logo categorÃ­a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
  }
});

// =========================
// CategorÃ­as de servicios profesionales (admin/app)
// =========================

app.get('/api/professionals/service-categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professional_service_categories')
      .orderBy('name', 'asc')
      .get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('âŒ [PRO] Error obteniendo categorÃ­as:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categorÃ­as', error: error.message });
  }
});

app.post('/api/admin/professionals/service-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, logoUrl } = req.body || {};
    if (!name || !logoUrl) {
      return res.status(400).json({ success: false, message: 'name y logoUrl son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const categoryData = {
      name,
      description: description || '',
      logoUrl: logoUrl || '',
      slug: slugifyText(name),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professional_service_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando categorÃ­a:', error);
    res.status(500).json({ success: false, message: 'Error creando categorÃ­a', error: error.message });
  }
});

app.put('/api/admin/professionals/service-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, logoUrl } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    if (logoUrl !== undefined) updateData.logoUrl = logoUrl || '';
    await db.collection('professional_service_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando categorÃ­a:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categorÃ­a', error: error.message });
  }
});

app.delete('/api/admin/professionals/service-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('professional_service_categories').doc(id).delete();
    res.json({ success: true, message: 'CategorÃ­a eliminada' });
  } catch (error) {
    console.error('âŒ [PRO] Error eliminando categorÃ­a:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categorÃ­a', error: error.message });
  }
});

// Subir logo de categorÃ­a de servicio (admin)
app.post('/api/admin/professionals/service-categories/upload-logo', authenticateToken, isAdmin, upload.fields([{ name: 'image', maxCount: 1 }, { name: 'logo', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.image?.[0] || req.files?.logo?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se enviÃ³ ninguna imagen' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-service-categories/cat-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('âŒ [PRO] Error subiendo logo categorÃ­a:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('âš ï¸ [PRO] Error haciendo logo pÃºblico:', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('âŒ [PRO] Error subiendo logo categorÃ­a:', error);
    res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
  }
});

// Subir foto del profesional (usuario)
app.post('/api/professionals/upload-photo', authenticateToken, upload.fields([{ name: 'photo', maxCount: 1 }, { name: 'image', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.photo?.[0] || req.files?.image?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({
        success: false,
        message: 'No se enviÃ³ ninguna foto (usa campo photo o image)'
      });
    }

    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Storage no disponible'
      });
    }

    const fileName = `images/professionals/pro-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);

    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('âŒ [PRO] Error subiendo foto:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo foto',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('âš ï¸ [PRO] Error haciendo foto pÃºblica:', error.message);
      }

      res.json({
        success: true,
        data: {
          photoUrl: `https://storage.googleapis.com/${bucket.name}/${fileName}`,
          photoStoragePath: fileName
        }
      });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('âŒ [PRO] Error subiendo foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});

// Proxy para avatar (evita CORS de ui-avatars.com)
app.get('/api/professionals/avatar', async (req, res) => {
  try {
    const { name, background = '667eea', color = 'fff', size = 120 } = req.query || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    const sizeNumber = Math.max(16, Math.min(512, parseInt(size, 10) || 120));
    const url = `https://ui-avatars.com/api/?name=${encodeURIComponent(String(name))}&background=${encodeURIComponent(String(background))}&color=${encodeURIComponent(String(color))}&size=${sizeNumber}`;
    const response = await fetch(url);
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo avatar' });
    }
    const contentType = response.headers.get('content-type') || 'image/png';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('âŒ [PRO] Error en proxy de avatar:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo avatar', error: error.message });
  }
});

// Proxy de imÃ¡genes para fotos de profesionales (evita CORS de Storage)
app.get('/api/professionals/photo', async (req, res) => {
  try {
    const { url } = req.query || {};
    if (!url || !isValidUrl(String(url))) {
      return res.status(400).json({ success: false, message: 'url invÃ¡lida' });
    }
    const response = await fetch(String(url));
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo imagen' });
    }
    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('âŒ [PRO] Error en proxy de foto:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo imagen', error: error.message });
  }
});

// Proxy logo solicitudes profesionales (evita CORS)
app.get('/api/professionals/requests/logo', authenticateToken, async (req, res) => {
  try {
    const { url } = req.query || {};
    if (!url || !isValidUrl(String(url))) {
      return res.status(400).json({ success: false, message: 'url invÃ¡lida' });
    }
    const response = await fetch(String(url));
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo imagen' });
    }
    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('âŒ [PRO-REQ] Error en proxy de logo:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo imagen', error: error.message });
  }
});

// Crear perfil profesional (usuario)
app.post('/api/professionals', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const existing = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (!existing.empty) {
      return res.status(400).json({ success: false, message: 'El perfil ya existe' });
    }

    const { profileCategoryId, categoryId } = req.body || {};
    const resolvedProfileCategoryId = profileCategoryId || categoryId || null;
    if (!resolvedProfileCategoryId) {
      return res.status(400).json({ success: false, message: 'profileCategoryId es requerido' });
    }
    let categoryData = null;
    try {
      categoryData = await resolveProfessionalProfileCategory(resolvedProfileCategoryId);
    } catch (err) {
      return res.status(400).json({ success: false, message: err.message });
    }

    let locationData = {};
    if (req.body?.countryId || req.body?.cityId) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = [];
    if (Array.isArray(req.body?.locations)) {
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    const payload = buildProfessionalPayload({
      ...req.body,
      profileCategoryId: resolvedProfileCategoryId,
      profileCategory: categoryData,
      ...locationData,
      locations,
      userId: req.user.uid
    });

    const ref = await db.collection('professionals').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando perfil:', error);
    res.status(500).json({ success: false, message: 'Error creando perfil', error: error.message });
  }
});

// Obtener perfil propio
app.get('/api/professionals/me', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('âŒ [PRO] Error obteniendo perfil:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo perfil', error: error.message });
  }
});

// Actualizar perfil propio
app.put('/api/professionals/me', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    let locationData = {};
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'locations')) {
      if (!Array.isArray(req.body.locations)) {
        return res.status(400).json({ success: false, message: 'locations debe ser un array' });
      }
      locations = [];
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    let categoryData = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'profileCategoryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'categoryId')) {
      const incomingId = req.body.profileCategoryId || req.body.categoryId;
      if (!incomingId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId invÃ¡lido' });
      }
      try {
        categoryData = await resolveProfessionalProfileCategory(incomingId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    const updateData = {
      ...req.body,
      ...locationData,
      updatedAt: new Date()
    };
    if (categoryData !== undefined) {
      updateData.profileCategoryId = req.body.profileCategoryId || req.body.categoryId;
      updateData.profileCategory = categoryData;
    }
    if (locations !== undefined) {
      updateData.locations = locations;
    }
    delete updateData.userId;
    delete updateData.status;

    await db.collection('professionals').doc(doc.id).update(stripUndefined(updateData));
    res.json({ success: true, data: { id: doc.id, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando perfil:', error);
    res.status(500).json({ success: false, message: 'Error actualizando perfil', error: error.message });
  }
});

// Admin: actualizar perfil profesional por ID
app.put('/api/professionals/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const doc = await db.collection('professionals').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }

    let locationData = {};
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'locations')) {
      if (!Array.isArray(req.body.locations)) {
        return res.status(400).json({ success: false, message: 'locations debe ser un array' });
      }
      locations = [];
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    let categoryData = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'profileCategoryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'categoryId')) {
      const incomingId = req.body.profileCategoryId || req.body.categoryId;
      if (!incomingId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId invÃ¡lido' });
      }
      try {
        categoryData = await resolveProfessionalProfileCategory(incomingId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    const updateData = {
      ...req.body,
      ...locationData,
      updatedAt: new Date()
    };
    if (categoryData !== undefined) {
      updateData.profileCategoryId = req.body.profileCategoryId || req.body.categoryId;
      updateData.profileCategory = categoryData;
    }
    if (locations !== undefined) {
      updateData.locations = locations;
    }
    delete updateData.userId;

    await db.collection('professionals').doc(id).update(stripUndefined(updateData));
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando perfil (admin):', error);
    res.status(500).json({ success: false, message: 'Error actualizando perfil', error: error.message });
  }
});

// Listado pÃºblico de profesionales (solo activos)
app.get('/api/professionals', authenticateToken, async (req, res) => {
  try {
    const { search = '', page = 1, limit = 20 } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('status', '==', 'active')
      .get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.name?.toLowerCase().includes(searchLower) ||
        item.headline?.toLowerCase().includes(searchLower) ||
        item.specialties?.join(' ').toLowerCase().includes(searchLower)
      );
    }
    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);
    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ [PRO] Error listando profesionales:', error);
    res.status(500).json({ success: false, message: 'Error listando profesionales', error: error.message });
  }
});

// Detalle pÃºblico de profesional (admin puede ver aunque estÃ© pending)
app.get('/api/professionals/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let isAdminUser = false;
    try {
      const userDoc = await db.collection('users').doc(req.user.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        isAdminUser = userData.role === 'admin' || userData.isAdmin === true;
      }
    } catch (_) {
      // Si falla la verificaciÃ³n, se mantiene como no admin
    }
    const doc = await db.collection('professionals').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    if (!isAdminUser && doc.data().status !== 'active') {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('âŒ [PRO] Error obteniendo profesional:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo profesional', error: error.message });
  }
});

// Admin: aprobar/suspender
app.patch('/api/admin/professionals/:id/status', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body || {};
    if (!['pending', 'active', 'suspended'].includes(status)) {
      return res.status(400).json({ success: false, message: 'status invÃ¡lido' });
    }
    await db.collection('professionals').doc(id).update({ status, updatedAt: new Date() });
    res.json({ success: true, message: 'Estado actualizado', data: { id, status } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando estado:', error);
    res.status(500).json({ success: false, message: 'Error actualizando estado', error: error.message });
  }
});

// Admin: enlazar profesional con usuario del app (userId o email)
app.patch('/api/admin/professionals/:id/link-user', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { userId, email } = req.body || {};
    if (!userId && !email) {
      return res.status(400).json({ success: false, message: 'userId o email es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let resolvedUserId = userId;
    if (!resolvedUserId && email) {
      if (!auth) {
        return res.status(500).json({ success: false, message: 'Auth no disponible' });
      }
      const userRecord = await auth.getUserByEmail(String(email).trim());
      resolvedUserId = userRecord?.uid;
    }
    if (!resolvedUserId) {
      return res.status(404).json({ success: false, message: 'Usuario no encontrado' });
    }

    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }

    await db.collection('professionals').doc(id).update({
      userId: resolvedUserId,
      updatedAt: new Date()
    });
    res.json({ success: true, message: 'Perfil enlazado', data: { id, userId: resolvedUserId } });
  } catch (error) {
    console.error('âŒ [PRO] Error enlazando usuario:', error);
    res.status(500).json({ success: false, message: 'Error enlazando usuario', error: error.message });
  }
});

// Admin: listar profesionales
app.get('/api/admin/professionals', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', status } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('professionals');
    if (status) {
      query = query.where('status', '==', status);
    }

    const snapshot = await query.orderBy('createdAt', 'desc').get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.name?.toLowerCase().includes(searchLower) ||
        item.headline?.toLowerCase().includes(searchLower) ||
        item.contactEmail?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('âŒ [PRO] Error listando profesionales (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando profesionales', error: error.message });
  }
});

// =========================
// Servicios (por profesional)
// =========================

// Servicios pÃºblicos por profesional (admin puede ver todos)
app.get('/api/professionals/:id/services', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let isAdminUser = false;
    try {
      const userDoc = await db.collection('users').doc(req.user.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        isAdminUser = userData.role === 'admin' || userData.isAdmin === true;
      }
    } catch (_) {
      // Mantener no admin si falla
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    if (!isAdminUser && proDoc.data().status !== 'active') {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    let servicesQuery = db.collection('professionals').doc(id)
      .collection('services')
      .orderBy('createdAt', 'desc');
    if (!isAdminUser) {
      servicesQuery = servicesQuery.where('isActive', '==', true);
    }
    const servicesSnapshot = await servicesQuery.get();
    const services = servicesSnapshot.docs.map(s => ({ id: s.id, ...s.data() }));
    res.json({ success: true, data: services });
  } catch (error) {
    console.error('âŒ [PRO] Error listando servicios pÃºblicos:', error);
    res.status(500).json({ success: false, message: 'Error listando servicios', error: error.message });
  }
});

// Admin: crear servicio para un profesional especÃ­fico
app.post('/api/professionals/:id/services', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, price, durationMinutes, type, currency, isActive, mediaUrl, categoryId } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const now = new Date();
    const payload = {
      title,
      description: description || null,
      price,
      durationMinutes: durationMinutes || null,
      type: type || 'consulta',
      currency: currency || 'USD',
      isActive: isActive !== undefined ? isActive : true,
      mediaUrl: mediaUrl || null,
      categoryId: categoryId || null,
      createdAt: now,
      updatedAt: now
    };
    const ref = await db.collection('professionals').doc(id)
      .collection('services')
      .add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando servicio (admin):', error);
    res.status(500).json({ success: false, message: 'Error creando servicio', error: error.message });
  }
});

app.get('/api/professionals/me/services', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const servicesSnapshot = await db.collection('professionals').doc(doc.id)
      .collection('services')
      .orderBy('createdAt', 'desc')
      .get();
    const services = servicesSnapshot.docs.map(s => ({ id: s.id, ...s.data() }));
    res.json({ success: true, data: services });
  } catch (error) {
    console.error('âŒ [PRO] Error listando servicios:', error);
    res.status(500).json({ success: false, message: 'Error listando servicios', error: error.message });
  }
});

app.post('/api/professionals/me/services', authenticateToken, async (req, res) => {
  try {
    const { title, description, price, durationMinutes, type, currency, isActive, mediaUrl, categoryId } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    if (categoryId) {
      const categoryDoc = await db.collection('professional_service_categories').doc(categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({ success: false, message: 'categoryId invÃ¡lido' });
      }
    }

    const serviceData = {
      title,
      description: description || '',
      price,
      currency: currency || 'USD',
      type: type || 'consulta', // consulta | asesoria | producto | otro
      categoryId: categoryId || null,
      durationMinutes: durationMinutes || null,
      isActive: isActive !== undefined ? Boolean(isActive) : true,
      mediaUrl: mediaUrl || null,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professionals').doc(doc.id)
      .collection('services')
      .add(serviceData);
    res.json({ success: true, data: { id: ref.id, ...serviceData } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando servicio:', error);
    res.status(500).json({ success: false, message: 'Error creando servicio', error: error.message });
  }
});

app.put('/api/professionals/me/services/:serviceId', authenticateToken, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const updateData = { ...req.body, updatedAt: new Date() };
    if (updateData.isActive !== undefined) {
      updateData.isActive = Boolean(updateData.isActive);
    }
    if (updateData.categoryId !== undefined && updateData.categoryId !== null) {
      const categoryDoc = await db.collection('professional_service_categories').doc(updateData.categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({ success: false, message: 'categoryId invÃ¡lido' });
      }
    }
    await db.collection('professionals').doc(doc.id)
      .collection('services').doc(serviceId)
      .update(updateData);
    res.json({ success: true, data: { id: serviceId, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando servicio:', error);
    res.status(500).json({ success: false, message: 'Error actualizando servicio', error: error.message });
  }
});

app.delete('/api/professionals/me/services/:serviceId', authenticateToken, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    await db.collection('professionals').doc(doc.id)
      .collection('services').doc(serviceId)
      .delete();
    res.json({ success: true, message: 'Servicio eliminado' });
  } catch (error) {
    console.error('âŒ [PRO] Error eliminando servicio:', error);
    res.status(500).json({ success: false, message: 'Error eliminando servicio', error: error.message });
  }
});

// =========================
// Paquetes (por profesional)
// =========================

app.get('/api/professionals/me/packages', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const packagesSnapshot = await db.collection('professionals').doc(doc.id)
      .collection('packages')
      .orderBy('createdAt', 'desc')
      .get();
    const packages = packagesSnapshot.docs.map(p => ({ id: p.id, ...p.data() }));
    res.json({ success: true, data: packages });
  } catch (error) {
    console.error('âŒ [PRO] Error listando paquetes:', error);
    res.status(500).json({ success: false, message: 'Error listando paquetes', error: error.message });
  }
});

// Admin: listar paquetes de un profesional por ID
app.get('/api/professionals/:id/packages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const profDoc = await db.collection('professionals').doc(id).get();
    if (!profDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const packagesSnapshot = await db.collection('professionals').doc(id)
      .collection('packages')
      .orderBy('createdAt', 'desc')
      .get();
    const packages = packagesSnapshot.docs.map(p => ({ id: p.id, ...p.data() }));
    res.json({ success: true, data: packages });
  } catch (error) {
    console.error('âŒ [PRO] Error listando paquetes (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando paquetes', error: error.message });
  }
});

// Admin: crear paquete para un profesional especÃ­fico
app.post('/api/professionals/:id/packages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, price, currency, isActive, items, validDays } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const now = new Date();
    const payload = {
      title,
      description: description || null,
      price,
      currency: currency || 'USD',
      isActive: isActive !== undefined ? isActive : true,
      items: Array.isArray(items) ? items : [],
      validDays: validDays || null,
      createdAt: now,
      updatedAt: now
    };
    const ref = await db.collection('professionals').doc(id)
      .collection('packages')
      .add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando paquete (admin):', error);
    res.status(500).json({ success: false, message: 'Error creando paquete', error: error.message });
  }
});

app.post('/api/professionals/me/packages', authenticateToken, async (req, res) => {
  try {
    const { title, description, price, sessionCount } = req.body || {};
    if (!title || price === undefined || !sessionCount) {
      return res.status(400).json({ success: false, message: 'title, price y sessionCount son requeridos' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const packageData = {
      title,
      description: description || '',
      price,
      sessionCount,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professionals').doc(doc.id)
      .collection('packages')
      .add(packageData);
    res.json({ success: true, data: { id: ref.id, ...packageData } });
  } catch (error) {
    console.error('âŒ [PRO] Error creando paquete:', error);
    res.status(500).json({ success: false, message: 'Error creando paquete', error: error.message });
  }
});

app.put('/api/professionals/me/packages/:packageId', authenticateToken, async (req, res) => {
  try {
    const { packageId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const updateData = { ...req.body, updatedAt: new Date() };
    await db.collection('professionals').doc(doc.id)
      .collection('packages').doc(packageId)
      .update(updateData);
    res.json({ success: true, data: { id: packageId, ...updateData } });
  } catch (error) {
    console.error('âŒ [PRO] Error actualizando paquete:', error);
    res.status(500).json({ success: false, message: 'Error actualizando paquete', error: error.message });
  }
});

app.delete('/api/professionals/me/packages/:packageId', authenticateToken, async (req, res) => {
  try {
    const { packageId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    await db.collection('professionals').doc(doc.id)
      .collection('packages').doc(packageId)
      .delete();
    res.json({ success: true, message: 'Paquete eliminado' });
  } catch (error) {
    console.error('âŒ [PRO] Error eliminando paquete:', error);
    res.status(500).json({ success: false, message: 'Error eliminando paquete', error: error.message });
  }
});


// ============================================================================
// ðŸ“Š HITOS DEL DESARROLLO INFANTIL
// ============================================================================

// ==========================================
// ADMIN - GestiÃ³n de CategorÃ­as de Hitos
// ==========================================

// Crear categorÃ­a (Admin)
app.post('/api/admin/milestones/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      name,
      description,
      icon,
      color,
      order = 999,
      isActive = true
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validaciones
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la categorÃ­a es requerido'
      });
    }

    // Verificar si ya existe una categorÃ­a con ese nombre
    const existingCategory = await db.collection('milestoneCategories')
      .where('name', '==', name.trim())
      .get();

    if (!existingCategory.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una categorÃ­a con ese nombre'
      });
    }

    const categoryData = {
      name: name.trim(),
      description: description?.trim() || '',
      icon: icon || 'ðŸ“‹',
      color: color || '#2196F3',
      order: parseInt(order) || 999,
      isActive: isActive !== undefined ? isActive : true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    const docRef = await db.collection('milestoneCategories').add(categoryData);

    console.log(`âœ… [MILESTONES] CategorÃ­a creada: ${docRef.id}`);

    res.status(201).json({
      success: true,
      message: 'CategorÃ­a creada exitosamente',
      data: {
        id: docRef.id,
        ...categoryData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error creando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categorÃ­a',
      error: error.message
    });
  }
});

// Listar categorÃ­as (Admin)
app.get('/api/admin/milestones/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('milestoneCategories')
      .orderBy('order', 'asc')
      .orderBy('name', 'asc')
      .get();

    const categories = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      categories.push({
        id: doc.id,
        name: data.name,
        description: data.description || '',
        icon: data.icon || 'ðŸ“‹',
        color: data.color || '#2196F3',
        order: data.order || 999,
        isActive: data.isActive !== undefined ? data.isActive : true,
        createdAt: data.createdAt?.toDate()?.toISOString() || null,
        updatedAt: data.updatedAt?.toDate()?.toISOString() || null
      });
    });

    res.json({
      success: true,
      data: categories,
      total: categories.length
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Obtener detalle de categorÃ­a (Admin)
app.get('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    const data = doc.data();
    const category = {
      id: doc.id,
      name: data.name,
      description: data.description || '',
      icon: data.icon || 'ðŸ“‹',
      color: data.color || '#2196F3',
      order: data.order || 999,
      isActive: data.isActive !== undefined ? data.isActive : true,
      createdAt: data.createdAt?.toDate()?.toISOString() || null,
      updatedAt: data.updatedAt?.toDate()?.toISOString() || null
    };

    res.json({
      success: true,
      data: category
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­a',
      error: error.message
    });
  }
});

// Actualizar categorÃ­a (Admin)
app.put('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const {
      name,
      description,
      icon,
      color,
      order,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    // Si se estÃ¡ cambiando el nombre, verificar que no exista otra con ese nombre
    if (name && name.trim() !== doc.data().name) {
      const existingCategory = await db.collection('milestoneCategories')
        .where('name', '==', name.trim())
        .get();

      if (!existingCategory.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una categorÃ­a con ese nombre'
        });
      }
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (icon !== undefined) updateData.icon = icon;
    if (color !== undefined) updateData.color = color;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive;

    await db.collection('milestoneCategories').doc(categoryId).update(updateData);

    console.log(`âœ… [MILESTONES] CategorÃ­a actualizada: ${categoryId}`);

    // Obtener datos actualizados
    const updatedDoc = await db.collection('milestoneCategories').doc(categoryId).get();
    const updatedData = updatedDoc.data();

    res.json({
      success: true,
      message: 'CategorÃ­a actualizada exitosamente',
      data: {
        id: categoryId,
        name: updatedData.name,
        description: updatedData.description || '',
        icon: updatedData.icon || 'ðŸ“‹',
        color: updatedData.color || '#2196F3',
        order: updatedData.order || 999,
        isActive: updatedData.isActive !== undefined ? updatedData.isActive : true,
        createdAt: updatedData.createdAt?.toDate()?.toISOString() || null,
        updatedAt: updatedData.updatedAt?.toDate()?.toISOString() || null
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error actualizando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categorÃ­a',
      error: error.message
    });
  }
});

// Eliminar categorÃ­a (Admin)
app.delete('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CategorÃ­a no encontrada'
      });
    }

    // Verificar si hay hitos usando esta categorÃ­a
    const categoryName = doc.data().name;
    const milestonesUsingCategory = await db.collection('milestones')
      .where('category', '==', categoryName)
      .limit(1)
      .get();

    if (!milestonesUsingCategory.empty) {
      return res.status(400).json({
        success: false,
        message: 'No se puede eliminar la categorÃ­a porque tiene hitos asociados'
      });
    }

    await db.collection('milestoneCategories').doc(categoryId).delete();

    console.log(`âœ… [MILESTONES] CategorÃ­a eliminada: ${categoryId}`);

    res.json({
      success: true,
      message: 'CategorÃ­a eliminada exitosamente'
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error eliminando categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categorÃ­a',
      error: error.message
    });
  }
});

// ==========================================
// ADMIN - GestiÃ³n de Hitos
// ==========================================

// Carga masiva de hitos (Admin) - Endpoint temporal
app.post('/api/admin/milestones/bulk', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestones_0_12_months } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!milestones_0_12_months || !Array.isArray(milestones_0_12_months)) {
      return res.status(400).json({
        success: false,
        message: 'Datos de hitos invÃ¡lidos'
      });
    }

    // Mapeo de categorÃ­as del JSON a nombres de categorÃ­as en BD
    const categoryMapping = {
      'social': 'Social y Emocional',
      'cognitivo': 'Cognitivo',
      'motriz': 'Motor Grueso',
      'comunicacion': 'Lenguaje y ComunicaciÃ³n'
    };

    const createdMilestones = [];
    const errors = [];

    // Procesar cada mes
    for (const monthData of milestones_0_12_months) {
      const { month, social, cognitivo, motriz, comunicacion } = monthData;
      
      const allCategories = {
        social,
        cognitivo,
        motriz,
        comunicacion
      };

      // Por cada categorÃ­a en el mes
      for (const [categoryKey, items] of Object.entries(allCategories)) {
        if (!items || !Array.isArray(items)) continue;

        const categoryName = categoryMapping[categoryKey];
        if (!categoryName) {
          console.warn(`âš ï¸ CategorÃ­a no mapeada: ${categoryKey}`);
          continue;
        }

        // Por cada hito en la categorÃ­a
        for (let i = 0; i < items.length; i++) {
          const title = items[i];
          
          try {
            const milestoneData = {
              title: title.trim(),
              description: `Hito del desarrollo para el mes ${month}`,
              category: categoryName,
              ageRangeMonths: {
                min: month,
                max: month
              },
              order: i + 1,
              isActive: true,
              tips: '',
              videoUrl: null,
              imageUrl: null,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              createdBy: req.user.uid
            };

            const docRef = await db.collection('milestones').add(milestoneData);
            
            createdMilestones.push({
              id: docRef.id,
              month,
              category: categoryName,
              title
            });

            console.log(`âœ… Hito creado: ${title} (Mes ${month}, ${categoryName})`);

          } catch (error) {
            console.error(`âŒ Error creando hito "${title}":`, error);
            errors.push({
              title,
              month,
              category: categoryName,
              error: error.message
            });
          }
        }
      }
    }

    res.status(201).json({
      success: true,
      message: `Carga masiva completada. ${createdMilestones.length} hitos creados`,
      data: {
        created: createdMilestones.length,
        errors: errors.length,
        createdMilestones: createdMilestones.slice(0, 10), // Primeros 10 para no saturar respuesta
        errorDetails: errors
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error en carga masiva:', error);
    res.status(500).json({
      success: false,
      message: 'Error en carga masiva',
      error: error.message
    });
  }
});

// Crear hito (Admin)
app.post('/api/admin/milestones', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      title,
      description,
      categoryId,
      ageMonthsMin,
      ageMonthsMax,
      order = 999,
      tips,
      videoUrl,
      imageUrl,
      isActive = true
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validaciones
    if (!title || title.trim().length < 3) {
      return res.status(400).json({
        success: false,
        message: 'El tÃ­tulo debe tener al menos 3 caracteres'
      });
    }

    if (!categoryId) {
      return res.status(400).json({
        success: false,
        message: 'El ID de categorÃ­a es requerido'
      });
    }

    // Verificar que la categorÃ­a existe
    const categoryDoc = await db.collection('milestoneCategories').doc(categoryId).get();
    if (!categoryDoc.exists) {
      return res.status(400).json({
        success: false,
        message: 'La categorÃ­a especificada no existe'
      });
    }

    if (ageMonthsMin === undefined || ageMonthsMax === undefined) {
      return res.status(400).json({
        success: false,
        message: 'El rango de edad es requerido (ageMonthsMin y ageMonthsMax)'
      });
    }

    const milestoneData = {
      title: title.trim(),
      description: description?.trim() || '',
      categoryId,
      ageMonthsMin: parseInt(ageMonthsMin),
      ageMonthsMax: parseInt(ageMonthsMax),
      order: parseInt(order),
      tips: tips?.trim() || '',
      videoUrl: videoUrl || null,
      imageUrl: imageUrl || null,
      isActive: Boolean(isActive),
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: req.user.uid
    };

    const milestoneRef = await db.collection('milestones').add(milestoneData);

    console.log(`âœ… [MILESTONES] Hito creado: ${milestoneRef.id}`);

    res.json({
      success: true,
      message: 'Hito creado exitosamente',
      data: {
        id: milestoneRef.id,
        ...milestoneData
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error creando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando hito',
      error: error.message
    });
  }
});

// Listar hitos (Admin)
app.get('/api/admin/milestones', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      category,
      ageMin,
      ageMax,
      includeInactive = 'false',
      page = 1,
      limit = 100
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('milestones');

    // Filtros
    if (category) {
      query = query.where('categoryId', '==', category);
    }

    if (includeInactive !== 'true') {
      query = query.where('isActive', '==', true);
    }

    // Ordenar solo por ageMonthsMin para evitar Ã­ndices compuestos complejos
    query = query.orderBy('ageMonthsMin', 'asc');

    const snapshot = await query.get();
    let milestones = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title,
        description: data.description || '',
        categoryId: data.categoryId,
        ageMonthsMin: data.ageMonthsMin,
        ageMonthsMax: data.ageMonthsMax,
        order: data.order || 999,
        isActive: data.isActive !== undefined ? data.isActive : true,
        tips: data.tips || '',
        videoUrl: data.videoUrl || null,
        imageUrl: data.imageUrl || null,
        createdAt: data.createdAt?.toDate()?.toISOString() || null,
        updatedAt: data.updatedAt?.toDate()?.toISOString() || null,
        createdBy: data.createdBy || null
      };
    });

    // Ordenar en memoria por categoryId y order
    milestones.sort((a, b) => {
      if (a.ageMonthsMin !== b.ageMonthsMin) {
        return a.ageMonthsMin - b.ageMonthsMin;
      }
      if (a.categoryId !== b.categoryId) {
        return a.categoryId.localeCompare(b.categoryId);
      }
      return a.order - b.order;
    });

    // Filtrar por rango de edad si se especifica
    if (ageMin !== undefined || ageMax !== undefined) {
      milestones = milestones.filter(m => {
        const matchesMin = ageMin === undefined || m.ageMonthsMax >= parseInt(ageMin);
        const matchesMax = ageMax === undefined || m.ageMonthsMin <= parseInt(ageMax);
        return matchesMin && matchesMax;
      });
    }

    // PaginaciÃ³n
    const total = milestones.length;
    const startIndex = (parseInt(page) - 1) * parseInt(limit);
    const endIndex = startIndex + parseInt(limit);
    const paginatedMilestones = milestones.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedMilestones,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / parseInt(limit))
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo hitos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Obtener hito especÃ­fico (Admin)
app.get('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    res.json({
      success: true,
      data: {
        id: milestoneDoc.id,
        ...milestoneDoc.data()
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hito',
      error: error.message
    });
  }
});

// Actualizar hito (Admin)
app.put('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;
    const updateData = { ...req.body, updatedAt: new Date() };

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    // Validar categorÃ­a si se actualiza
    if (updateData.category) {
      const validCategories = ['social', 'motor-grueso', 'motor-fino', 'lenguaje', 'cognitivo'];
      if (!validCategories.includes(updateData.category)) {
        return res.status(400).json({
          success: false,
          message: `CategorÃ­a invÃ¡lida. Debe ser: ${validCategories.join(', ')}`
        });
      }
    }

    await db.collection('milestones').doc(milestoneId).update(updateData);

    const updatedDoc = await db.collection('milestones').doc(milestoneId).get();

    console.log(`âœ… [MILESTONES] Hito actualizado: ${milestoneId}`);

    res.json({
      success: true,
      message: 'Hito actualizado exitosamente',
      data: {
        id: milestoneId,
        ...updatedDoc.data()
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error actualizando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando hito',
      error: error.message
    });
  }
});

// Eliminar hito (Admin)
app.delete('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    await db.collection('milestones').doc(milestoneId).delete();

    console.log(`âœ… [MILESTONES] Hito eliminado: ${milestoneId}`);

    res.json({
      success: true,
      message: 'Hito eliminado exitosamente'
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error eliminando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hito',
      error: error.message
    });
  }
});

// ==========================================
// APP - Hitos para Usuarios
// ==========================================

// Obtener categorÃ­as de hitos (pÃºblico)
app.get('/api/milestones/categories', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('milestoneCategories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .orderBy('name', 'asc')
      .get();

    const categories = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      categories.push({
        id: doc.id,
        name: data.name,
        description: data.description || '',
        icon: data.icon || 'ðŸ“‹',
        color: data.color || '#2196F3',
        order: data.order || 999
      });
    });

    res.json({
      success: true,
      data: categories,
      total: categories.length
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo categorÃ­as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categorÃ­as',
      error: error.message
    });
  }
});

// Obtener hitos por edad del niÃ±o
app.get('/api/children/:childId/milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { category, ageBuffer = 3, includeAll = 'false' } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el niÃ±o pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'NiÃ±o no encontrado'
      });
    }

    const childData = childDoc.data();

    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este niÃ±o'
      });
    }

    // Calcular edad del niÃ±o en meses
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    console.log(`[MILESTONES] Edad del niÃ±o: ${ageMonths} meses`);
    console.log(`[MILESTONES] Fecha nacimiento: ${birthDate}`);

    // Obtener hitos
    let query = db.collection('milestones').where('isActive', '==', true);

    if (category) {
      query = query.where('categoryId', '==', category);
    }

    const milestonesSnapshot = await query.get();
    console.log(`[MILESTONES] Total hitos activos en BD: ${milestonesSnapshot.size}`);
    
    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Log de algunos hitos para ver su estructura
    if (milestones.length > 0) {
      console.log(`[MILESTONES] Ejemplo de hito:`, JSON.stringify({
        id: milestones[0].id,
        ageMonthsMin: milestones[0].ageMonthsMin,
        ageMonthsMax: milestones[0].ageMonthsMax,
        categoryId: milestones[0].categoryId
      }));
    }

    // Filtrar por rango de edad solo si includeAll no estÃ¡ activo
    const shouldIncludeAll = includeAll === 'true' || includeAll === true;
    
    let minAge, maxAge;
    
    if (!shouldIncludeAll) {
      // Filtrar por rango de edad con buffer
      minAge = Math.max(0, ageMonths - parseInt(ageBuffer));
      maxAge = ageMonths + parseInt(ageBuffer);

      console.log(`[MILESTONES] Filtro edad - ageMonths: ${ageMonths}, buffer: ${ageBuffer}, minAge: ${minAge}, maxAge: ${maxAge}`);

      milestones = milestones.filter(m => {
        const passes = m.ageMonthsMax >= minAge && m.ageMonthsMin <= maxAge;
        if (!passes && milestones.length < 10) {
          console.log(`[MILESTONES] Hito rechazado: ${m.id}, edad: ${m.ageMonthsMin}-${m.ageMonthsMax}`);
        }
        return passes;
      });

      console.log(`[MILESTONES] Hitos filtrados por edad: ${milestones.length}`);
    } else {
      console.log(`[MILESTONES] Modo includeAll activado, devolviendo todos los hitos: ${milestones.length}`);
      // Para includeAll, el rango es desde 0 hasta el mÃ¡ximo
      minAge = 0;
      maxAge = Math.max(...milestones.map(m => m.ageMonthsMax));
    }

    // Ordenar
    milestones.sort((a, b) => {
      if (a.ageMonthsMin !== b.ageMonthsMin) {
        return a.ageMonthsMin - b.ageMonthsMin;
      }
      if (a.categoryId !== b.categoryId) {
        return a.categoryId.localeCompare(b.categoryId);
      }
      return a.order - b.order;
    });

    // Obtener progreso del niÃ±o
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .get();

    const progressMap = {};
    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = {
        completed: data.completed,
        completedAt: data.completedAt,
        notes: data.notes || null
      };
    });

    // Agregar estado de completado a cada hito
    const milestonesWithProgress = milestones.map(m => ({
      ...m,
      completed: progressMap[m.id]?.completed || false,
      completedAt: progressMap[m.id]?.completedAt || null,
      notes: progressMap[m.id]?.notes || null
    }));

    // Calcular estadÃ­sticas
    const completedCount = milestonesWithProgress.filter(m => m.completed).length;

    res.json({
      success: true,
      data: milestonesWithProgress,
      metadata: {
        childAge: {
          months: ageMonths,
          displayAge: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        ageRange: {
          min: minAge,
          max: maxAge
        },
        summary: {
          total: milestonesWithProgress.length,
          completed: completedCount,
          completionRate: milestonesWithProgress.length > 0 
            ? Math.round((completedCount / milestonesWithProgress.length) * 100)
            : 0
        }
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo hitos del niÃ±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Obtener hitos agrupados por categorÃ­a
app.get('/api/children/:childId/milestones/by-category', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { ageBuffer = 3 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el niÃ±o pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'NiÃ±o no encontrado'
      });
    }

    const childData = childDoc.data();

    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Calcular edad
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    // Obtener hitos
    const milestonesSnapshot = await db.collection('milestones')
      .where('isActive', '==', true)
      .get();

    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por edad
    const minAge = Math.max(0, ageMonths - parseInt(ageBuffer));
    const maxAge = ageMonths + parseInt(ageBuffer);

    milestones = milestones.filter(m => {
      return m.ageMonthsMax >= minAge && m.ageMonthsMin <= maxAge;
    });

    // Obtener progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .get();

    const progressMap = {};
    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = {
        completed: data.completed,
        completedAt: data.completedAt,
        notes: data.notes || null
      };
    });

    // Obtener categorÃ­as de la BD
    const categoriesSnapshot = await db.collection('milestoneCategories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .get();

    const categoryInfo = {};
    categoriesSnapshot.forEach(doc => {
      const data = doc.data();
      categoryInfo[doc.id] = {
        id: doc.id,
        name: data.name,
        icon: data.icon || 'ðŸ“',
        color: data.color || '#757575'
      };
    });

    // Agrupar por categorÃ­a
    const categorized = {};
    
    milestones.forEach(m => {
      const catId = m.categoryId;
      if (!catId) return; // Ignorar hitos sin categorÃ­a
      
      if (!categorized[catId]) {
        categorized[catId] = [];
      }
      categorized[catId].push({
        ...m,
        completed: progressMap[m.id]?.completed || false,
        completedAt: progressMap[m.id]?.completedAt || null,
        notes: progressMap[m.id]?.notes || null
      });
    });

    // Crear array de categorÃ­as con estadÃ­sticas
    const categories = Object.keys(categorized).map(catId => {
      const items = categorized[catId];
      const completedCount = items.filter(i => i.completed).length;
      const catInfo = categoryInfo[catId] || { name: 'Sin categorÃ­a', icon: 'ðŸ“', color: '#757575' };
      
      return {
        categoryId: catId,
        categoryName: catInfo.name,
        icon: catInfo.icon,
        color: catInfo.color,
        milestones: items.sort((a, b) => a.order - b.order),
        stats: {
          total: items.length,
          completed: completedCount,
          completionRate: items.length > 0 
            ? Math.round((completedCount / items.length) * 100)
            : 0
        }
      };
    });

    // Calcular estadÃ­sticas generales
    const totalMilestones = milestones.length;
    const totalCompleted = Object.values(progressMap).filter(p => p.completed).length;

    res.json({
      success: true,
      data: {
        childAge: {
          months: ageMonths,
          displayAge: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        categories,
        overall: {
          total: totalMilestones,
          completed: totalCompleted,
          completionRate: totalMilestones > 0 
            ? Math.round((totalCompleted / totalMilestones) * 100)
            : 0
        }
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error obteniendo hitos por categorÃ­a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Marcar hito como completado
app.post('/api/children/:childId/milestones/:milestoneId/complete', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;
    const { notes = '' } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Verificar que el hito existe
    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    // Buscar si ya existe un registro de progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('milestoneId', '==', milestoneId)
      .limit(1)
      .get();

    const progressData = {
      childId,
      milestoneId,
      completed: true,
      completedAt: new Date(),
      completedBy: uid,
      notes: notes.trim(),
      updatedAt: new Date()
    };

    if (progressSnapshot.empty) {
      // Crear nuevo registro
      progressData.createdAt = new Date();
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .add(progressData);
    } else {
      // Actualizar existente
      const doc = progressSnapshot.docs[0];
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .doc(doc.id)
        .update(progressData);
    }

    console.log(`âœ… [MILESTONES] Hito ${milestoneId} completado para niÃ±o ${childId}`);

    res.json({
      success: true,
      message: 'Hito marcado como completado',
      data: {
        milestoneId,
        completed: true,
        completedAt: progressData.completedAt,
        notes: progressData.notes
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error marcando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando hito',
      error: error.message
    });
  }
});

// Desmarcar hito
app.delete('/api/children/:childId/milestones/:milestoneId/complete', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Buscar y eliminar el registro de progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('milestoneId', '==', milestoneId)
      .limit(1)
      .get();

    if (!progressSnapshot.empty) {
      const doc = progressSnapshot.docs[0];
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .doc(doc.id)
        .delete();
    }

    console.log(`âœ… [MILESTONES] Hito ${milestoneId} desmarcado para niÃ±o ${childId}`);

    res.json({
      success: true,
      message: 'Hito desmarcado'
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error desmarcando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error desmarcando hito',
      error: error.message
    });
  }
});

// Reporte de progreso completo
app.get('/api/children/:childId/milestones/progress-report', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();

    // Calcular edad
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    // Obtener todos los hitos activos
    const milestonesSnapshot = await db.collection('milestones')
      .where('isActive', '==', true)
      .get();

    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar relevantes para la edad (con buffer amplio)
    milestones = milestones.filter(m => {
      return m.ageMonthsMax >= (ageMonths - 6) && m.ageMonthsMin <= (ageMonths + 12);
    });

    // Obtener progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('completed', '==', true)
      .get();

    const progressMap = {};
    const completedMilestones = [];

    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = data;
      
      const milestone = milestones.find(m => m.id === data.milestoneId);
      if (milestone) {
        completedMilestones.push({
          milestoneId: data.milestoneId,
          title: milestone.title,
          categoryId: milestone.categoryId,
          completedAt: data.completedAt,
          ageAtCompletion: Math.floor((data.completedAt.toDate() - birthDate) / (1000 * 60 * 60 * 24 * 30.44))
        });
      }
    });

    // Ordenar por fecha de completado (mÃ¡s reciente primero)
    completedMilestones.sort((a, b) => b.completedAt.toDate() - a.completedAt.toDate());

    // Agrupar por categorÃ­a
    const categoryInfo = {
      'social': { name: 'Social y Emocional', icon: 'ðŸ‘¥', color: '#4CAF50' },
      'motor-grueso': { name: 'Motor Grueso', icon: 'ðŸƒ', color: '#2196F3' },
      'motor-fino': { name: 'Motor Fino', icon: 'âœ‹', color: '#FF9800' },
      'lenguaje': { name: 'Lenguaje y ComunicaciÃ³n', icon: 'ðŸ’¬', color: '#9C27B0' },
      'cognitivo': { name: 'Cognitivo', icon: 'ðŸ§ ', color: '#F44336' }
    };

    const progressByCategory = Object.keys(categoryInfo).map(cat => {
      const categoryMilestones = milestones.filter(m => m.category === cat);
      const completed = categoryMilestones.filter(m => progressMap[m.id]?.completed).length;
      
      return {
        category: cat,
        categoryName: categoryInfo[cat].name,
        icon: categoryInfo[cat].icon,
        color: categoryInfo[cat].color,
        total: categoryMilestones.length,
        completed,
        completionRate: categoryMilestones.length > 0 
          ? Math.round((completed / categoryMilestones.length) * 100)
          : 0
      };
    }).filter(c => c.total > 0);

    // PrÃ³ximos hitos (no completados, edad apropiada)
    const upcomingMilestones = milestones
      .filter(m => !progressMap[m.id]?.completed)
      .filter(m => m.ageMonthsMin <= (ageMonths + 3))
      .sort((a, b) => a.ageMonthsMin - b.ageMonthsMin)
      .slice(0, 5)
      .map(m => ({
        milestoneId: m.id,
        title: m.title,
        categoryId: m.categoryId,
        expectedAge: `${m.ageMonthsMin}-${m.ageMonthsMax} meses`
      }));

    res.json({
      success: true,
      data: {
        child: {
          id: childId,
          name: childData.name,
          birthDate: childData.birthDate,
          ageMonths,
          ageDisplay: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        overallProgress: {
          totalMilestones: milestones.length,
          completed: Object.keys(progressMap).length,
          completionRate: milestones.length > 0 
            ? Math.round((Object.keys(progressMap).length / milestones.length) * 100)
            : 0,
          lastUpdated: completedMilestones.length > 0 
            ? completedMilestones[0].completedAt
            : null
        },
        progressByCategory,
        recentlyCompleted: completedMilestones.slice(0, 5),
        upcomingMilestones
      }
    });

  } catch (error) {
    console.error('âŒ [MILESTONES] Error generando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando reporte',
      error: error.message
    });
  }
});

// ============================================================================
// NUTRICIÃ“N - RECETAS PERSONALIZADAS CON IA
// ============================================================================

// Obtener recetas personalizadas para un niÃ±o segÃºn su edad
app.get('/api/children/:childId/nutrition/recipes', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { mealType, regenerate = 'false' } = req.query; // mealType: 'breakfast', 'lunch', 'dinner', 'all'

    console.log(`ðŸ½ï¸ [NUTRITION] Solicitando recetas para niÃ±o: ${childId}, mealType: ${mealType || 'all'}`);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el niÃ±o pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'NiÃ±o no encontrado'
      });
    }

    const childData = childDoc.data();

    // Verificar si el usuario es el padre o tiene acceso compartido
    const isParent = childData.parentId === uid;
    const hasSharedAccess = childData.sharedWith && 
      Array.isArray(childData.sharedWith) && 
      childData.sharedWith.includes(uid);

    if (!isParent && !hasSharedAccess) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este niÃ±o'
      });
    }

    // Calcular edad del niÃ±o
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));
    const ageYears = Math.floor(ageMonths / 12);
    const remainingMonths = ageMonths % 12;

    console.log(`ðŸ‘¶ [NUTRITION] Edad del niÃ±o: ${ageMonths} meses (${ageYears} aÃ±os, ${remainingMonths} meses)`);

    // Verificar cachÃ© (si no se solicita regenerar)
    const shouldRegenerate = regenerate === 'true';
    const cacheKey = `nutrition_${childId}_${mealType || 'all'}`;
    
    if (!shouldRegenerate) {
      const cachedRecipes = await db.collection('nutritionCache')
        .where('childId', '==', childId)
        .where('mealType', '==', mealType || 'all')
        .where('ageMonths', '==', ageMonths)
        .orderBy('createdAt', 'desc')
        .limit(1)
        .get();

      if (!cachedRecipes.empty) {
        const cachedData = cachedRecipes.docs[0].data();
        const cacheAge = (now - cachedData.createdAt.toDate()) / (1000 * 60 * 60); // horas
        
        // Si el cachÃ© tiene menos de 24 horas, usarlo
        if (cacheAge < 24) {
          console.log(`âœ… [NUTRITION] Usando recetas en cachÃ© (${Math.round(cacheAge)}h)`);
          return res.json({
            success: true,
            data: cachedData.recipes,
            metadata: {
              childAge: {
                months: ageMonths,
                years: ageYears,
                remainingMonths: remainingMonths,
                displayAge: ageYears > 0 
                  ? `${ageYears} ${ageYears === 1 ? 'aÃ±o' : 'aÃ±os'}${remainingMonths > 0 ? ` y ${remainingMonths} ${remainingMonths === 1 ? 'mes' : 'meses'}` : ''}`
                  : `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
              },
              cached: true,
              cacheAge: Math.round(cacheAge),
              generatedAt: cachedData.createdAt
            }
          });
        }
      }
    }

    // Verificar que OpenAI estÃ© disponible
    if (!openai) {
      console.warn('âš ï¸ [NUTRITION] OpenAI no configurado');
      return res.status(503).json({
        success: false,
        message: 'Servicio de generaciÃ³n de recetas no disponible',
        error: 'OpenAI no configurado'
      });
    }

    // Determinar quÃ© tipo de comidas generar
    const mealTypes = mealType && mealType !== 'all' 
      ? [mealType] 
      : ['breakfast', 'lunch', 'dinner'];

    // Crear contexto para OpenAI segÃºn la edad
    let ageContext = '';
    if (ageMonths < 6) {
      ageContext = 'BebÃ© menor de 6 meses (solo lactancia materna o fÃ³rmula). NO GENERAR RECETAS, solo indicar que estÃ¡ en periodo de lactancia exclusiva.';
    } else if (ageMonths < 12) {
      ageContext = `BebÃ© de ${ageMonths} meses en etapa de alimentaciÃ³n complementaria. Incluir papillas, purÃ©s suaves, alimentos machacados. Sin sal, sin azÃºcar, sin miel. IntroducciÃ³n gradual de alimentos.`;
    } else if (ageMonths < 24) {
      ageContext = `NiÃ±o de ${ageYears > 0 ? ageYears + ' aÃ±o' + (remainingMonths > 0 ? ' y ' + remainingMonths + ' meses' : '') : ageMonths + ' meses'}. Puede comer alimentos mÃ¡s sÃ³lidos, texturas variadas, comida picada. Baja sal, sin azÃºcar aÃ±adido.`;
    } else if (ageMonths < 36) {
      ageContext = `NiÃ±o de ${ageYears} aÃ±os${remainingMonths > 0 ? ' y ' + remainingMonths + ' meses' : ''}. Puede comer casi como adultos pero en porciones pequeÃ±as. Comida variada, nutritiva, colorida.`;
    } else {
      ageContext = `NiÃ±o de ${ageYears} aÃ±os${remainingMonths > 0 ? ' y ' + remainingMonths + ' meses' : ''}. AlimentaciÃ³n normal pero saludable. Comidas balanceadas, nutritivas, atractivas para niÃ±os.`;
    }

    const mealTypeNames = {
      'breakfast': 'desayuno',
      'lunch': 'almuerzo',
      'dinner': 'cena'
    };

    console.log(`ðŸ¤– [NUTRITION] Generando recetas con OpenAI...`);

    const prompt = `Eres un nutricionista pediÃ¡trico experto. Genera 2 recetas ${mealTypes.length === 1 ? 'de ' + mealTypeNames[mealTypes[0]] : 'para cada tipo de comida (desayuno, almuerzo, cena)'} apropiadas para:

${ageContext}

IMPORTANTE:
- Recetas nutritivas, balanceadas y apropiadas para la edad
- Ingredientes fÃ¡ciles de conseguir
- PreparaciÃ³n sencilla para padres ocupados
- Incluir alÃ©rgenos comunes a evitar segÃºn la edad

Para CADA receta, devuelve un JSON con esta estructura EXACTA:
{
  "recipes": [
    {
      "mealType": "breakfast" | "lunch" | "dinner",
      "name": "Nombre atractivo de la receta",
      "description": "Breve descripciÃ³n (1-2 lÃ­neas)",
      "ageAppropriate": true,
      "prepTime": nÃºmero en minutos,
      "cookTime": nÃºmero en minutos,
      "servings": nÃºmero de porciones,
      "difficulty": "fÃ¡cil" | "media" | "avanzada",
      "ingredients": [
        {
          "item": "ingrediente",
          "quantity": "cantidad con unidad"
        }
      ],
      "instructions": [
        "Paso 1 detallado",
        "Paso 2 detallado",
        "etc..."
      ],
      "nutritionalInfo": {
        "calories": "aproximado por porciÃ³n",
        "protein": "gramos aproximados",
        "carbs": "gramos aproximados",
        "fat": "gramos aproximados"
      },
      "tips": [
        "Consejo Ãºtil 1",
        "Consejo Ãºtil 2"
      ],
      "allergens": ["posibles alÃ©rgenos presentes"]
    }
  ]
}

Genera ${mealTypes.length === 1 ? '2' : '6'} recetas en total (${mealTypes.length === 1 ? '2 de ' + mealTypeNames[mealTypes[0]] : '2 de cada tipo de comida'}).
Devuelve SOLO el JSON, sin texto adicional.`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'Eres un nutricionista pediÃ¡trico experto. Siempre respondes en formato JSON vÃ¡lido.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.8,
      max_tokens: 2500
    });

    const responseText = completion.choices[0]?.message?.content;

    if (!responseText) {
      throw new Error('OpenAI no devolviÃ³ respuesta');
    }

    console.log(`âœ… [NUTRITION] Respuesta de OpenAI recibida`);

    // Parse JSON
    let recipesData;
    try {
      // Limpiar la respuesta si tiene markdown
      const cleanedResponse = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      recipesData = JSON.parse(cleanedResponse);
    } catch (parseError) {
      console.error('âŒ [NUTRITION] Error parseando JSON:', parseError.message);
      console.log('Raw response:', responseText.substring(0, 500));
      throw new Error('Error procesando respuesta de IA');
    }

    if (!recipesData.recipes || !Array.isArray(recipesData.recipes)) {
      throw new Error('Formato de respuesta invÃ¡lido');
    }

    // Agregar metadata a cada receta
    const enrichedRecipes = recipesData.recipes.map((recipe, index) => ({
      id: `recipe_${Date.now()}_${index}`,
      ...recipe,
      childId,
      ageMonths,
      generatedAt: new Date().toISOString()
    }));

    console.log(`âœ… [NUTRITION] ${enrichedRecipes.length} recetas generadas`);

    // Guardar en cachÃ©
    try {
      await db.collection('nutritionCache').add({
        childId,
        mealType: mealType || 'all',
        ageMonths,
        recipes: enrichedRecipes,
        createdAt: new Date()
      });
      console.log(`ðŸ’¾ [NUTRITION] Recetas guardadas en cachÃ©`);
    } catch (cacheError) {
      console.error('âš ï¸ [NUTRITION] Error guardando en cachÃ©:', cacheError.message);
      // No fallar si el cachÃ© falla
    }

    res.json({
      success: true,
      data: enrichedRecipes,
      metadata: {
        childAge: {
          months: ageMonths,
          years: ageYears,
          remainingMonths: remainingMonths,
          displayAge: ageYears > 0 
            ? `${ageYears} ${ageYears === 1 ? 'aÃ±o' : 'aÃ±os'}${remainingMonths > 0 ? ` y ${remainingMonths} ${remainingMonths === 1 ? 'mes' : 'meses'}` : ''}`
            : `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        cached: false,
        generatedAt: new Date().toISOString(),
        totalRecipes: enrichedRecipes.length
      }
    });

  } catch (error) {
    console.error('âŒ [NUTRITION] Error generando recetas:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando recetas',
      error: error.message
    });
  }
});

// ============================================================================
// ENDPOINT TEMPORAL: Contar campos de usuarios (displayName vs name)
// ============================================================================
app.get('/api/admin/analytics/user-fields-count', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“Š [ADMIN] Contando campos de usuarios...');
    
    const usersSnapshot = await db.collection('users').get();
    const totalUsers = usersSnapshot.size;
    
    let usersWithDisplayName = 0;
    let usersWithName = 0;
    let usersWithBoth = 0;
    let usersWithNeither = 0;
    let usersOnlyDisplayName = 0;
    let usersOnlyName = 0;
    
    usersSnapshot.forEach(doc => {
      const userData = doc.data();
      const hasDisplayName = userData.displayName && userData.displayName.trim() !== '';
      const hasName = userData.name && userData.name.trim() !== '';
      
      if (hasDisplayName) usersWithDisplayName++;
      if (hasName) usersWithName++;
      
      if (hasDisplayName && hasName) {
        usersWithBoth++;
      } else if (hasDisplayName && !hasName) {
        usersOnlyDisplayName++;
      } else if (!hasDisplayName && hasName) {
        usersOnlyName++;
      } else {
        usersWithNeither++;
      }
    });
    
    console.log(`âœ… [ADMIN] AnÃ¡lisis completo: ${totalUsers} usuarios`);
    
    res.json({
      success: true,
      data: {
        totalUsers,
        usersWithDisplayName,
        usersWithName,
        usersWithBoth,
        usersOnlyDisplayName,
        usersOnlyName,
        usersWithNeither,
        percentages: {
          withDisplayName: ((usersWithDisplayName/totalUsers)*100).toFixed(1),
          withName: ((usersWithName/totalUsers)*100).toFixed(1),
          withBoth: ((usersWithBoth/totalUsers)*100).toFixed(1),
          onlyDisplayName: ((usersOnlyDisplayName/totalUsers)*100).toFixed(1),
          onlyName: ((usersOnlyName/totalUsers)*100).toFixed(1),
          withNeither: ((usersWithNeither/totalUsers)*100).toFixed(1)
        }
      },
      generatedAt: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error contando campos de usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas de usuarios',
      error: error.message
    });
  }
});

// ============================================================================
// ENDPOINT TEMPORAL: Contar campos de usuarios (displayName vs name)
// ============================================================================
app.get('/api/admin/analytics/user-fields-count', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ“Š [ADMIN] Contando campos de usuarios...');
    
    const usersSnapshot = await db.collection('users').get();
    const totalUsers = usersSnapshot.size;
    
    let usersWithDisplayName = 0;
    let usersWithName = 0;
    let usersWithBoth = 0;
    let usersWithNeither = 0;
    let usersOnlyDisplayName = 0;
    let usersOnlyName = 0;
    
    usersSnapshot.forEach(doc => {
      const userData = doc.data();
      const hasDisplayName = userData.displayName && userData.displayName.trim() !== '';
      const hasName = userData.name && userData.name.trim() !== '';
      
      if (hasDisplayName) usersWithDisplayName++;
      if (hasName) usersWithName++;
      
      if (hasDisplayName && hasName) {
        usersWithBoth++;
      } else if (hasDisplayName && !hasName) {
        usersOnlyDisplayName++;
      } else if (!hasDisplayName && hasName) {
        usersOnlyName++;
      } else {
        usersWithNeither++;
      }
    });
    
    console.log(`âœ… [ADMIN] AnÃ¡lisis completo: ${totalUsers} usuarios`);
    
    res.json({
      success: true,
      data: {
        totalUsers,
        usersWithDisplayName,
        usersWithName,
        usersWithBoth,
        usersOnlyDisplayName,
        usersOnlyName,
        usersWithNeither,
        percentages: {
          withDisplayName: ((usersWithDisplayName/totalUsers)*100).toFixed(1),
          withName: ((usersWithName/totalUsers)*100).toFixed(1),
          withBoth: ((usersWithBoth/totalUsers)*100).toFixed(1),
          onlyDisplayName: ((usersOnlyDisplayName/totalUsers)*100).toFixed(1),
          onlyName: ((usersOnlyName/totalUsers)*100).toFixed(1),
          withNeither: ((usersWithNeither/totalUsers)*100).toFixed(1)
        }
      },
      generatedAt: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error contando campos de usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas de usuarios',
      error: error.message
    });
  }
});

// ============================================================================
// ENDPOINTS DE PRUEBA - EMAILS (Solo para desarrollo/testing)
// ============================================================================

/**
 * Endpoint de prueba para email de bienvenida
 * POST /api/test/send-welcome-email
 */
app.post('/api/test/send-welcome-email', async (req, res) => {
  try {
    const { userName, userEmail } = req.body;
    
    if (!userName || !userEmail) {
      return res.status(400).json({
        success: false,
        message: 'userName y userEmail son requeridos'
      });
    }
    
    const { sendWelcomeEmail } = require('./services/emailService');
    const result = await sendWelcomeEmail(userName, userEmail);
    
    res.json({
      success: result.success,
      message: result.success ? 'Email enviado exitosamente' : 'Error enviando email',
      emailId: result.id,
      error: result.error
    });
    
  } catch (error) {
    console.error('âŒ [TEST] Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Endpoint de prueba para email de cumpleaÃ±os
 * POST /api/test/send-birthday-email
 */
app.post('/api/test/send-birthday-email', async (req, res) => {
  try {
    const { userName, userEmail, childName, age } = req.body;
    
    if (!userName || !userEmail || !childName || !age) {
      return res.status(400).json({
        success: false,
        message: 'userName, userEmail, childName y age son requeridos'
      });
    }
    
    const { sendBirthdayEmail } = require('./services/emailService');
    const result = await sendBirthdayEmail(userName, userEmail, childName, age);
    
    res.json({
      success: result.success,
      message: result.success ? 'Email enviado exitosamente' : 'Error enviando email',
      emailId: result.id,
      error: result.error
    });
    
  } catch (error) {
    console.error('âŒ [TEST] Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================================================
// CRON JOBS - EMAILS AUTOMATIZADOS
// ============================================================================

/**
 * Cron Job: Procesar cumpleaÃ±os
 * Se ejecuta diariamente a las 8am
 * EnvÃ­a emails de cumpleaÃ±os y recordatorios
 */
app.get('/api/cron/process-birthdays', async (req, res) => {
  try {
    console.log('ðŸŽ‚ [CRON] Procesando cumpleaÃ±os...');
    
    // Importar servicio de emails
    const { sendBirthdayEmail, sendBirthdayReminder } = require('./services/emailService');
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // Obtener todos los hijos
    const childrenSnapshot = await db.collection('children').get();
    
    let birthdaysToday = 0;
    let birthdaysTomorrow = 0;
    let emailsSent = 0;
    
    for (const childDoc of childrenSnapshot.docs) {
      const child = childDoc.data();
      
      if (!child.birthdate) continue;
      
      const birthdate = new Date(child.birthdate);
      
      // Mismo dÃ­a y mes que hoy (cumpleaÃ±os)
      if (birthdate.getDate() === today.getDate() && 
          birthdate.getMonth() === today.getMonth()) {
        
        birthdaysToday++;
        
        // Obtener datos del padre
        const parentDoc = await db.collection('users').doc(child.parentId).get();
        const parent = parentDoc.data();
        
        if (parent && parent.email) {
          const age = today.getFullYear() - birthdate.getFullYear();
          
          console.log(`ðŸŽ‚ Enviando cumpleaÃ±os de ${child.name} (${age} aÃ±os) a ${parent.email}`);
          
          await sendBirthdayEmail(
            parent.displayName || parent.name || 'MamÃ¡',
            parent.email,
            child.name,
            age
          );
          
          emailsSent++;
        }
      }
      
      // Mismo dÃ­a y mes que maÃ±ana (recordatorio)
      if (birthdate.getDate() === tomorrow.getDate() && 
          birthdate.getMonth() === tomorrow.getMonth()) {
        
        birthdaysTomorrow++;
        
        const parentDoc = await db.collection('users').doc(child.parentId).get();
        const parent = parentDoc.data();
        
        if (parent && parent.email) {
          const age = tomorrow.getFullYear() - birthdate.getFullYear();
          
          console.log(`ðŸŽˆ Enviando recordatorio de cumpleaÃ±os de ${child.name} a ${parent.email}`);
          
          await sendBirthdayReminder(
            parent.displayName || parent.name || 'MamÃ¡',
            parent.email,
            child.name,
            age
          );
          
          emailsSent++;
        }
      }
    }
    
    console.log(`âœ… [CRON] CumpleaÃ±os hoy: ${birthdaysToday}, MaÃ±ana: ${birthdaysTomorrow}, Emails: ${emailsSent}`);
    
    res.json({
      success: true,
      birthdaysToday,
      birthdaysTomorrow,
      emailsSent
    });
    
  } catch (error) {
    console.error('âŒ [CRON] Error procesando cumpleaÃ±os:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Cron Job: Recordatorios de eventos
 * Se ejecuta diariamente a las 9am
 * EnvÃ­a recordatorios 24h antes de los eventos
 */
app.get('/api/cron/process-event-reminders', async (req, res) => {
  try {
    console.log('â° [CRON] Procesando recordatorios de eventos...');
    
    const { sendEventReminder } = require('./services/emailService');
    
    const now = new Date();
    const in24Hours = new Date(now.getTime() + 24 * 60 * 60 * 1000);
    const in25Hours = new Date(now.getTime() + 25 * 60 * 60 * 1000);
    
    // Buscar eventos que ocurren en las prÃ³ximas 24-25 horas
    const postsSnapshot = await db.collection('posts')
      .where('postType', '==', 'event')
      .get();
    
    let remindersSent = 0;
    let eventsProcessed = 0;
    
    for (const postDoc of postsSnapshot.docs) {
      const post = postDoc.data();
      
      if (!post.eventData || post.eventData.status !== 'upcoming') continue;
      if (!post.eventData.eventDate || !post.eventData.attendees) continue;
      
      const eventDate = new Date(post.eventData.eventDate._seconds * 1000);
      
      // Verificar si el evento es en las prÃ³ximas 24 horas
      if (eventDate > in24Hours && eventDate <= in25Hours) {
        eventsProcessed++;
        
        // Enviar recordatorio a cada asistente
        for (const attendee of post.eventData.attendees) {
          if (!attendee.userEmail) continue;
          
          console.log(`â° Enviando recordatorio de ${post.eventData.title} a ${attendee.userEmail}`);
          
          await sendEventReminder(
            attendee.userName || 'MamÃ¡',
            attendee.userEmail,
            {
              id: postDoc.id,
              title: post.eventData.title,
              description: post.content,
              eventDate: post.eventData.eventDate,
              location: post.eventData.location,
              checkInCode: post.eventData.checkInCode
            }
          );
          
          remindersSent++;
        }
      }
    }
    
    console.log(`âœ… [CRON] Eventos procesados: ${eventsProcessed}, Recordatorios enviados: ${remindersSent}`);
    
    res.json({
      success: true,
      eventsProcessed,
      remindersSent
    });
    
  } catch (error) {
    console.error('âŒ [CRON] Error procesando recordatorios:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - SÃNTOMAS
// ============================================================================

// ==================== ADMIN - CRUD DE SÃNTOMAS ====================

/**
 * Crear sÃ­ntoma (Admin)
 * POST /api/admin/symptoms
 */
app.post('/api/admin/symptoms', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, imageUrl, category, severity, order } = req.body;
    
    if (!name || !description) {
      return res.status(400).json({
        success: false,
        message: 'Nombre y descripciÃ³n son requeridos'
      });
    }
    
    const validCategories = ['general', 'digestivo', 'respiratorio', 'piel', 'neurologico', 'ojos_oidos', 'otros'];
    if (category && !validCategories.includes(category)) {
      return res.status(400).json({
        success: false,
        message: 'CategorÃ­a invÃ¡lida',
        validCategories
      });
    }
    
    const validSeverities = ['mild', 'moderate', 'severe'];
    if (severity && !validSeverities.includes(severity)) {
      return res.status(400).json({
        success: false,
        message: 'Severidad invÃ¡lida',
        validSeverities
      });
    }
    
    const symptomData = {
      name: name.trim(),
      description: description.trim(),
      imageUrl: imageUrl || null,
      category: category || 'general',
      severity: severity || 'moderate',
      order: order || 0,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const symptomRef = await db.collection('symptoms').add(symptomData);
    
    console.log(`âœ… [ADMIN] SÃ­ntoma creado: ${symptomRef.id}`);
    
    res.json({
      success: true,
      message: 'SÃ­ntoma creado exitosamente',
      data: {
        id: symptomRef.id,
        ...symptomData
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error creando sÃ­ntoma:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando sÃ­ntoma',
      error: error.message
    });
  }
});

/**
 * Listar sÃ­ntomas (Admin)
 * GET /api/admin/symptoms
 */
app.get('/api/admin/symptoms', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { category, isActive, page = 1, limit = 20, search } = req.query;
    
    let query = db.collection('symptoms');
    
    // Filtros
    if (category) {
      query = query.where('category', '==', category);
    }
    
    if (isActive !== undefined) {
      query = query.where('isActive', '==', isActive === 'true');
    }
    
    // Ordenar
    query = query.orderBy('order', 'asc').orderBy('name', 'asc');
    
    const snapshot = await query.get();
    
    let symptoms = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      
      // Filtro de bÃºsqueda en memoria
      if (search && !data.name.toLowerCase().includes(search.toLowerCase()) && 
          !data.description.toLowerCase().includes(search.toLowerCase())) {
        return;
      }
      
      symptoms.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedSymptoms = symptoms.slice(startIndex, endIndex);
    
    console.log(`âœ… [ADMIN] SÃ­ntomas listados: ${symptoms.length} total, ${paginatedSymptoms.length} en pÃ¡gina`);
    
    res.json({
      success: true,
      data: paginatedSymptoms,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: symptoms.length,
        totalPages: Math.ceil(symptoms.length / limitNum)
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error listando sÃ­ntomas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando sÃ­ntomas',
      error: error.message
    });
  }
});

/**
 * Obtener sÃ­ntoma por ID (Admin)
 * GET /api/admin/symptoms/:symptomId
 */
app.get('/api/admin/symptoms/:symptomId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { symptomId } = req.params;
    
    const symptomDoc = await db.collection('symptoms').doc(symptomId).get();
    
    if (!symptomDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'SÃ­ntoma no encontrado'
      });
    }
    
    const data = symptomDoc.data();
    
    res.json({
      success: true,
      data: {
        id: symptomDoc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo sÃ­ntoma:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo sÃ­ntoma',
      error: error.message
    });
  }
});

/**
 * Actualizar sÃ­ntoma (Admin)
 * PUT /api/admin/symptoms/:symptomId
 */
app.put('/api/admin/symptoms/:symptomId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { symptomId } = req.params;
    const { name, description, imageUrl, category, severity, order, isActive } = req.body;
    
    const symptomDoc = await db.collection('symptoms').doc(symptomId).get();
    
    if (!symptomDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'SÃ­ntoma no encontrado'
      });
    }
    
    const updateData = {
      updatedAt: new Date()
    };
    
    if (name) updateData.name = name.trim();
    if (description) updateData.description = description.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (category) updateData.category = category;
    if (severity) updateData.severity = severity;
    if (order !== undefined) updateData.order = order;
    if (isActive !== undefined) updateData.isActive = isActive;
    
    await db.collection('symptoms').doc(symptomId).update(updateData);
    
    const updatedDoc = await db.collection('symptoms').doc(symptomId).get();
    const data = updatedDoc.data();
    
    console.log(`âœ… [ADMIN] SÃ­ntoma actualizado: ${symptomId}`);
    
    res.json({
      success: true,
      message: 'SÃ­ntoma actualizado exitosamente',
      data: {
        id: symptomId,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando sÃ­ntoma:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando sÃ­ntoma',
      error: error.message
    });
  }
});

/**
 * Eliminar/Desactivar sÃ­ntoma (Admin)
 * DELETE /api/admin/symptoms/:symptomId
 */
app.delete('/api/admin/symptoms/:symptomId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { symptomId } = req.params;
    const { permanent = false } = req.query;
    
    const symptomDoc = await db.collection('symptoms').doc(symptomId).get();
    
    if (!symptomDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'SÃ­ntoma no encontrado'
      });
    }
    
    if (permanent === 'true') {
      // EliminaciÃ³n permanente
      await db.collection('symptoms').doc(symptomId).delete();
      console.log(`âœ… [ADMIN] SÃ­ntoma eliminado permanentemente: ${symptomId}`);
      
      res.json({
        success: true,
        message: 'SÃ­ntoma eliminado permanentemente'
      });
    } else {
      // Solo desactivar
      await db.collection('symptoms').doc(symptomId).update({
        isActive: false,
        updatedAt: new Date()
      });
      
      console.log(`âœ… [ADMIN] SÃ­ntoma desactivado: ${symptomId}`);
      
      res.json({
        success: true,
        message: 'SÃ­ntoma desactivado exitosamente'
      });
    }
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando sÃ­ntoma:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando sÃ­ntoma',
      error: error.message
    });
  }
});

// ==================== APP - LISTA PÃšBLICA DE SÃNTOMAS ====================

/**
 * Listar sÃ­ntomas activos (App)
 * GET /api/symptoms
 */
app.get('/api/symptoms', authenticateToken, async (req, res) => {
  try {
    const { category } = req.query;
    
    let query = db.collection('symptoms')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .orderBy('name', 'asc');
    
    if (category) {
      query = query.where('category', '==', category);
    }
    
    const snapshot = await query.get();
    
    const symptoms = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      symptoms.push({
        id: doc.id,
        name: data.name,
        description: data.description,
        imageUrl: data.imageUrl,
        category: data.category,
        severity: data.severity
      });
    });
    
    // Agrupar por categorÃ­a
    const groupedByCategory = symptoms.reduce((acc, symptom) => {
      if (!acc[symptom.category]) {
        acc[symptom.category] = [];
      }
      acc[symptom.category].push(symptom);
      return acc;
    }, {});
    
    console.log(`âœ… [SYMPTOMS] SÃ­ntomas listados: ${symptoms.length} activos`);
    
    res.json({
      success: true,
      data: symptoms,
      grouped: groupedByCategory,
      total: symptoms.length
    });
    
  } catch (error) {
    console.error('âŒ [SYMPTOMS] Error listando sÃ­ntomas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando sÃ­ntomas',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - ESPECIALISTAS
// ============================================================================

/**
 * Crear profesional para consultas (Admin)
 * POST /api/admin/specialists
 * Estructura unificada compatible con professionals existentes
 */
app.post('/api/admin/specialists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { personalInfo, professional, pricing, availability, accountType } = req.body;
    
    if (!personalInfo?.displayName) {
      return res.status(400).json({
        success: false,
        message: 'Nombre es requerido'
      });
    }
    
    if (!professional?.specialties || professional.specialties.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe especificar al menos una especialidad'
      });
    }
    
    // Estructura unificada: compatible con professionals existentes + campos de consultas
    const professionalData = {
      // Campos del formato existente de professionals
      name: personalInfo.displayName.trim(),
      headline: personalInfo.headline || '',
      bio: personalInfo.bio || '',
      photoUrl: personalInfo.photoUrl || null,
      contactEmail: personalInfo.email?.trim().toLowerCase() || '',
      contactPhone: personalInfo.phone || '',
      website: personalInfo.website || '',
      location: personalInfo.location || '',
      specialties: professional.specialties || [],
      tags: professional.specialties || [], // Usar specialties como tags tambiÃ©n
      
      // Nuevos campos para consultas mÃ©dicas
      accountType: accountType || 'specialist', // specialist, nutritionist, coach, psychologist
      canAcceptConsultations: true,
      
      // InformaciÃ³n profesional adicional
      professionalInfo: {
        licenseNumber: professional.licenseNumber || null,
        university: professional.university || null,
        yearsExperience: professional.yearsExperience || 0,
        certifications: professional.certifications || []
      },
      
      // Disponibilidad
      availability: {
        schedule: availability?.schedule || {},
        timezone: availability?.timezone || 'America/Guayaquil',
        maxConsultationsPerDay: availability?.maxConsultationsPerDay || 10
      },
      
      // Precios de consultas
      consultationPricing: {
        chatConsultation: pricing?.chatConsultation || 25,
        videoConsultation: pricing?.videoConsultation || 40,
        currency: pricing?.currency || 'USD',
        acceptsFreeConsultations: pricing?.acceptsFreeConsultations || false
      },
      
      // EstadÃ­sticas
      consultationStats: {
        totalConsultations: 0,
        averageRating: 0,
        responseTime: 0,
        completionRate: 100
      },
      
      // Permisos segÃºn tipo de cuenta
      permissions: {
        canAcceptConsultations: true,
        canPrescribe: accountType === 'specialist',
        canDiagnose: ['specialist', 'psychologist'].includes(accountType),
        canSellProducts: ['nutritionist', 'coach'].includes(accountType),
        canCreateMealPlans: accountType === 'nutritionist',
        canWriteArticles: true
      },
      
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const professionalRef = await db.collection('professionals').add(professionalData);
    
    console.log(`âœ… [ADMIN] Profesional creado: ${professionalRef.id} - ${personalInfo.displayName} (${accountType})`);
    
    res.json({
      success: true,
      message: 'Profesional creado exitosamente',
      data: {
        id: professionalRef.id,
        ...professionalData
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error creando profesional:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando profesional',
      error: error.message
    });
  }
});

/**
 * TEMPORAL: Actualizar profesionales existentes para consultas
 * POST /api/admin/specialists/migrate
 */
app.post('/api/admin/specialists/migrate', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('ðŸ”„ Iniciando migraciÃ³n de profesionales...');
    
    const snapshot = await db.collection('professionals').get();
    
    let updated = 0;
    let skipped = 0;
    const results = [];
    
    for (const doc of snapshot.docs) {
      const data = doc.data();
      const id = doc.id;
      
      // Si ya tiene canAcceptConsultations, saltar
      if (data.canAcceptConsultations !== undefined) {
        skipped++;
        results.push({
          id,
          name: data.name,
          action: 'skipped',
          reason: 'Ya tiene canAcceptConsultations'
        });
        continue;
      }
      
      // Determinar accountType basado en specialties
      let accountType = 'specialist';
      const specialties = data.specialties || [];
      
      if (specialties.some(s => s.toLowerCase().includes('nutriciÃ³n') || s.toLowerCase().includes('nutricionista'))) {
        accountType = 'nutritionist';
      } else if (specialties.some(s => s.toLowerCase().includes('lactancia') || s.toLowerCase().includes('doula') || s.toLowerCase().includes('sueÃ±o'))) {
        accountType = 'coach';
      } else if (specialties.some(s => s.toLowerCase().includes('psicÃ³log'))) {
        accountType = 'psychologist';
      }
      
      // Actualizar
      await db.collection('professionals').doc(id).update({
        canAcceptConsultations: true,
        accountType: accountType,
        professionalInfo: {
          licenseNumber: null,
          university: null,
          yearsExperience: 5,
          certifications: []
        },
        availability: {
          schedule: {},
          timezone: 'America/Guayaquil',
          maxConsultationsPerDay: 10
        },
        consultationPricing: {
          chatConsultation: 25,
          videoConsultation: 40,
          currency: 'USD',
          acceptsFreeConsultations: false
        },
        consultationStats: {
          totalConsultations: 0,
          averageRating: 0,
          responseTime: 0,
          completionRate: 100
        },
        permissions: {
          canAcceptConsultations: true,
          canPrescribe: accountType === 'specialist',
          canDiagnose: ['specialist', 'psychologist'].includes(accountType),
          canSellProducts: ['nutritionist', 'coach'].includes(accountType),
          canCreateMealPlans: accountType === 'nutritionist',
          canWriteArticles: true
        },
        updatedAt: new Date()
      });
      
      updated++;
      results.push({
        id,
        name: data.name,
        action: 'updated',
        accountType
      });
    }
    
    console.log(`âœ… MigraciÃ³n completada: ${updated} actualizados, ${skipped} saltados`);
    
    res.json({
      success: true,
      message: 'MigraciÃ³n completada',
      summary: {
        total: snapshot.size,
        updated,
        skipped
      },
      results
    });
    
  } catch (error) {
    console.error('âŒ Error en migraciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error en migraciÃ³n',
      error: error.message
    });
  }
});

/**
 * DEBUG: Ver todos los profesionales sin filtros
 * GET /api/admin/specialists/debug
 */
app.get('/api/admin/specialists/debug', authenticateToken, isAdmin, async (req, res) => {
  try {
    const snapshot = await db.collection('professionals')
      .orderBy('createdAt', 'desc')
      .limit(10)
      .get();
    
    const professionals = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      professionals.push({
        id: doc.id,
        name: data.name,
        canAcceptConsultations: data.canAcceptConsultations,
        consultationPricing: data.consultationPricing ? 'EXISTS' : 'NO',
        linkedUserId: data.linkedUserId || 'NO',
        accountType: data.accountType || 'NO',
        hasOldStructure: data.personalInfo ? 'YES (OLD)' : 'NO'
      });
    });
    
    res.json({
      success: true,
      total: snapshot.size,
      data: professionals
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Listar profesionales que dan consultas (Admin)
 * GET /api/admin/specialists
 */
app.get('/api/admin/specialists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialty, status, page = 1, limit = 20, search, accountType } = req.query;
    
    // Obtener TODOS los profesionales y filtrar en memoria
    const snapshot = await db.collection('professionals')
      .orderBy('createdAt', 'desc')
      .get();
    
    let specialists = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      
      // Filtro: Solo los que dan consultas
      // Incluye si:
      // 1. canAcceptConsultations === true
      // 2. O tiene consultationPricing (profesionales antiguos)
      // 3. O tiene linkedUserId (estÃ¡ vinculado a un usuario)
      const givesConsultations = 
        data.canAcceptConsultations === true || 
        data.consultationPricing !== undefined ||
        data.linkedUserId !== undefined;
      
      if (!givesConsultations) {
        return;
      }
      
      // Filtro por estado
      if (status && data.status !== status) {
        return;
      }
      
      // Filtro por tipo de cuenta
      if (accountType && data.accountType !== accountType) {
        return;
      }
      
      // Filtro por especialidad (en memoria)
      if (specialty && !data.specialties?.includes(specialty)) {
        return;
      }
      
      // Filtro de bÃºsqueda
      if (search) {
        const searchLower = search.toLowerCase();
        const matchesName = data.name?.toLowerCase().includes(searchLower);
        const matchesSpecialty = data.specialties?.some(s => 
          s.toLowerCase().includes(searchLower)
        );
        if (!matchesName && !matchesSpecialty) {
          return;
        }
      }
      
      specialists.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedSpecialists = specialists.slice(startIndex, endIndex);
    
    console.log(`âœ… [ADMIN] Profesionales con consultas listados: ${specialists.length} total`);
    
    res.json({
      success: true,
      data: paginatedSpecialists,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: specialists.length,
        totalPages: Math.ceil(specialists.length / limitNum)
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error listando profesionales:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando profesionales',
      error: error.message
    });
  }
});

/**
 * Obtener especialista por ID (Admin)
 * GET /api/admin/specialists/:specialistId
 */
app.get('/api/admin/specialists/:specialistId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialistId } = req.params;
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const data = specialistDoc.data();
    
    // Obtener estadÃ­sticas de consultas
    const consultationsSnapshot = await db.collection('consultations')
      .where('specialistId', '==', specialistId)
      .get();
    
    const consultations = [];
    consultationsSnapshot.forEach(doc => {
      consultations.push({ id: doc.id, ...doc.data() });
    });
    
    res.json({
      success: true,
      data: {
        id: specialistDoc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
        recentConsultations: consultations.slice(0, 5)
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo especialista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo especialista',
      error: error.message
    });
  }
});

/**
 * Actualizar especialista (Admin)
 * PUT /api/admin/specialists/:specialistId
 */
app.put('/api/admin/specialists/:specialistId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialistId } = req.params;
    const { personalInfo, professional, pricing, availability, status } = req.body;
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const updateData = {
      updatedAt: new Date()
    };
    
    if (personalInfo) updateData.personalInfo = personalInfo;
    if (professional) updateData.professional = professional;
    if (pricing) updateData.pricing = pricing;
    if (availability) updateData.availability = availability;
    if (status) updateData.status = status;
    
    await db.collection('professionals').doc(specialistId).update(updateData);
    
    const updatedDoc = await db.collection('professionals').doc(specialistId).get();
    const data = updatedDoc.data();
    
    console.log(`âœ… [ADMIN] Especialista actualizado: ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Especialista actualizado exitosamente',
      data: {
        id: specialistId,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando especialista:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando especialista',
      error: error.message
    });
  }
});

/**
 * Eliminar/Desactivar especialista (Admin)
 * DELETE /api/admin/specialists/:specialistId
 */
app.delete('/api/admin/specialists/:specialistId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialistId } = req.params;
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    // Solo desactivar, no eliminar
    await db.collection('professionals').doc(specialistId).update({
      status: 'inactive',
      updatedAt: new Date()
    });
    
    console.log(`âœ… [ADMIN] Especialista desactivado: ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Especialista desactivado exitosamente'
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error eliminando especialista:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando especialista',
      error: error.message
    });
  }
});

// ==================== APP - LISTA PÃšBLICA DE ESPECIALISTAS ====================

/**
 * Listar especialistas disponibles (App)
 * GET /api/specialists
 */
app.get('/api/specialists', authenticateToken, async (req, res) => {
  try {
    const { specialty, available = 'true' } = req.query;
    
    let query = db.collection('professionals')
      .where('status', '==', 'active')
      .orderBy('stats.averageRating', 'desc');
    
    const snapshot = await query.get();
    
    const specialists = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      
      // Filtro por especialidad
      if (specialty && !data.specialties.includes(specialty)) {
        return;
      }
      
      specialists.push({
        id: doc.id,
        displayName: data.name,
        photoUrl: data.photoUrl,
        bio: data.bio,
        specialties: data.specialties,
        yearsExperience: data.professional.yearsExperience,
        pricing: data.pricing,
        stats: data.stats
      });
    });
    
    console.log(`âœ… [SPECIALISTS] Especialistas listados: ${specialists.length} disponibles`);
    
    res.json({
      success: true,
      data: specialists,
      total: specialists.length
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALISTS] Error listando especialistas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando especialistas',
      error: error.message
    });
  }
});

/**
 * Obtener especialista por ID (App)
 * GET /api/specialists/:specialistId
 */
app.get('/api/specialists/:specialistId', authenticateToken, async (req, res) => {
  try {
    const { specialistId } = req.params;
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const data = specialistDoc.data();
    
    if (data.status !== 'active') {
      return res.status(404).json({
        success: false,
        message: 'Especialista no disponible'
      });
    }
    
    res.json({
      success: true,
      data: {
        id: specialistDoc.id,
        displayName: data.name,
        photoUrl: data.photoUrl,
        bio: data.bio,
        specialties: data.specialties,
        yearsExperience: data.professional.yearsExperience,
        certifications: data.professional.certifications,
        pricing: data.pricing,
        stats: data.stats
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALISTS] Error obteniendo especialista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo especialista',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE PERFILES PROFESIONALES - VINCULACIÃ“N
// ============================================================================

/**
 * Vincular especialista con usuario del app (Admin)
 * POST /api/admin/specialists/:specialistId/link-user
 */
app.post('/api/admin/specialists/:specialistId/link-user', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialistId } = req.params;
    const { userEmail } = req.body;
    
    if (!userEmail) {
      return res.status(400).json({
        success: false,
        message: 'Email del usuario es requerido'
      });
    }
    
    // Verificar que el especialista existe
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const specialistData = specialistDoc.data();
    
    // Buscar usuario por email
    const usersSnapshot = await db.collection('users')
      .where('email', '==', userEmail.toLowerCase().trim())
      .limit(1)
      .get();
    
    if (usersSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado con ese email'
      });
    }
    
    const userDoc = usersSnapshot.docs[0];
    const userId = userDoc.id;
    const userData = userDoc.data();
    
    // Verificar si el usuario ya tiene un perfil profesional
    if (userData.professionalProfile?.isActive) {
      return res.status(400).json({
        success: false,
        message: 'El usuario ya tiene un perfil profesional activo',
        currentProfile: userData.professionalProfile
      });
    }
    
    // Verificar si el especialista ya estÃ¡ vinculado
    if (specialistData.linkedUserId) {
      return res.status(400).json({
        success: false,
        message: 'Este especialista ya estÃ¡ vinculado a otro usuario',
        linkedUserId: specialistData.linkedUserId
      });
    }
    
    // Actualizar especialista con linkedUserId
    await db.collection('professionals').doc(specialistId).update({
      linkedUserId: userId,
      accountType: 'specialist',
      permissions: {
        canAcceptConsultations: true,
        canSellProducts: false,
        canCreateEvents: false
      },
      updatedAt: new Date()
    });
    
    // Actualizar usuario con professionalProfile
    await db.collection('users').doc(userId).update({
      professionalProfile: {
        isActive: true,
        specialistId: specialistId,
        accountType: 'specialist',
        verifiedAt: new Date()
      },
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    console.log(`âœ… [ADMIN] Usuario vinculado: ${userEmail} -> Especialista ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Usuario vinculado exitosamente con perfil profesional',
      data: {
        userId,
        userEmail: userData.email,
        userName: userData.displayName,
        specialistId,
        specialistName: specialistData.name,
        linkedAt: new Date()
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error vinculando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error vinculando usuario con especialista',
      error: error.message
    });
  }
});

/**
 * Desvincular usuario de especialista (Admin)
 * DELETE /api/admin/specialists/:specialistId/link-user
 */
app.delete('/api/admin/specialists/:specialistId/link-user', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { specialistId } = req.params;
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const specialistData = specialistDoc.data();
    
    if (!specialistData.linkedUserId) {
      return res.status(400).json({
        success: false,
        message: 'Este especialista no estÃ¡ vinculado a ningÃºn usuario'
      });
    }
    
    const linkedUserId = specialistData.linkedUserId;
    
    // Remover linkedUserId del especialista
    await db.collection('professionals').doc(specialistId).update({
      linkedUserId: admin.firestore.FieldValue.delete(),
      accountType: admin.firestore.FieldValue.delete(),
      permissions: admin.firestore.FieldValue.delete(),
      updatedAt: new Date()
    });
    
    // Remover professionalProfile del usuario
    await db.collection('users').doc(linkedUserId).update({
      professionalProfile: admin.firestore.FieldValue.delete(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    console.log(`âœ… [ADMIN] Usuario desvinculado: ${linkedUserId} -> Especialista ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Usuario desvinculado exitosamente',
      data: {
        specialistId,
        unlinkedUserId: linkedUserId
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error desvinculando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error desvinculando usuario',
      error: error.message
    });
  }
});

/**
 * Verificar si usuario tiene perfil profesional (App)
 * GET /api/profile/professional
 */
app.get('/api/profile/professional', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userData = userDoc.data();
    
    // Verificar si tiene perfil profesional
    if (!userData.professionalProfile?.isActive) {
      return res.json({
        success: true,
        data: {
          hasProfessionalProfile: false
        }
      });
    }
    
    const profile = userData.professionalProfile;
    
    // Obtener datos completos del especialista
    const specialistDoc = await db.collection('professionals').doc(profile.specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.json({
        success: true,
        data: {
          hasProfessionalProfile: false,
          error: 'Perfil profesional no encontrado'
        }
      });
    }
    
    const specialistData = specialistDoc.data();
    
    res.json({
      success: true,
      data: {
        hasProfessionalProfile: true,
        type: profile.accountType,
        specialistId: profile.specialistId,
        status: specialistData.status,
        verifiedAt: profile.verifiedAt?.toDate?.() || profile.verifiedAt,
        specialist: {
          displayName: specialistData.name,
          photoUrl: specialistData.photoUrl,
          specialties: specialistData.specialties,
          stats: specialistData.consultationStats,
          pricing: specialistData.consultationPricing
        }
      }
    });
    
  } catch (error) {
    console.error('âŒ [PROFILE] Error verificando perfil profesional:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando perfil profesional',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE PERFILES PROFESIONALES - SOLICITUDES
// ============================================================================

/**
 * Solicitar ser profesional (App)
 * POST /api/profile/request-professional
 */
app.post('/api/profile/request-professional', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { accountType, personalInfo, professional, documents } = req.body;
    
    // Validaciones
    if (!accountType || !['specialist', 'nutritionist', 'coach', 'psychologist'].includes(accountType)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de cuenta invÃ¡lido. Debe ser: specialist, nutritionist, coach o psychologist'
      });
    }
    
    if (!personalInfo?.displayName || !personalInfo?.phone) {
      return res.status(400).json({
        success: false,
        message: 'Nombre y telÃ©fono son requeridos'
      });
    }
    
    if (!professional?.specialties || professional.specialties.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe especificar al menos una especialidad'
      });
    }
    
    if (!documents || documents.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe adjuntar al menos un documento (tÃ­tulo, cÃ©dula o licencia)'
      });
    }
    
    // Verificar que el usuario existe
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userData = userDoc.data();
    
    // Verificar que no tenga ya un perfil profesional activo
    if (userData.professionalProfile?.isActive) {
      return res.status(400).json({
        success: false,
        message: 'Ya tienes un perfil profesional activo'
      });
    }
    
    // Verificar que no tenga una solicitud pendiente
    const existingRequestSnapshot = await db.collection('professionalRequests')
      .where('userId', '==', userId)
      .where('status', '==', 'pending')
      .limit(1)
      .get();
    
    if (!existingRequestSnapshot.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya tienes una solicitud pendiente de aprobaciÃ³n'
      });
    }
    
    // Crear solicitud
    const requestData = {
      userId,
      userEmail: userData.email,
      userName: userData.displayName,
      userPhotoUrl: userData.photoURL || null,
      accountType,
      personalInfo: {
        displayName: personalInfo.displayName.trim(),
        phone: personalInfo.phone.trim(),
        bio: personalInfo.bio?.trim() || null
      },
      professional: {
        specialties: professional.specialties,
        licenseNumber: professional.licenseNumber?.trim() || null,
        university: professional.university?.trim() || null,
        yearsExperience: professional.yearsExperience || 0,
        certifications: professional.certifications || []
      },
      documents, // Array de URLs de documentos subidos
      status: 'pending', // pending, approved, rejected
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const requestRef = await db.collection('professionalRequests').add(requestData);
    
    console.log(`âœ… [PROFESSIONAL-REQUEST] Solicitud creada: ${requestRef.id} - ${userData.email}`);
    
    // TODO: Enviar notificaciÃ³n a admins
    
    res.json({
      success: true,
      message: 'Solicitud enviada exitosamente. Te notificaremos cuando sea revisada.',
      data: {
        requestId: requestRef.id,
        status: 'pending',
        createdAt: requestData.createdAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [PROFESSIONAL-REQUEST] Error creando solicitud:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando solicitud',
      error: error.message
    });
  }
});

/**
 * Listar solicitudes de perfiles profesionales (Admin)
 * GET /api/admin/professional-requests
 */
app.get('/api/admin/professional-requests', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status, accountType, page = 1, limit = 20, search } = req.query;
    
    let query = db.collection('professionalRequests');
    
    // Filtros
    if (status) {
      query = query.where('status', '==', status);
    }
    
    if (accountType) {
      query = query.where('accountType', '==', accountType);
    }
    
    query = query.orderBy('createdAt', 'desc');
    
    const snapshot = await query.get();
    
    let requests = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      
      // Filtro de bÃºsqueda
      if (search) {
        const searchLower = search.toLowerCase();
        const matchesName = data.personalInfo?.displayName?.toLowerCase().includes(searchLower);
        const matchesEmail = data.userEmail?.toLowerCase().includes(searchLower);
        if (!matchesName && !matchesEmail) {
          return;
        }
      }
      
      requests.push({
        id: doc.id,
        userId: data.userId,
        userEmail: data.userEmail,
        userName: data.userName,
        userPhotoUrl: data.userPhotoUrl,
        accountType: data.accountType,
        personalInfo: data.personalInfo,
        professional: data.professional,
        documents: data.documents,
        status: data.status,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
        reviewedAt: data.reviewedAt?.toDate?.() || data.reviewedAt,
        reviewedBy: data.reviewedBy || null,
        rejectionReason: data.rejectionReason || null
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedRequests = requests.slice(startIndex, endIndex);
    
    // EstadÃ­sticas
    const stats = {
      pending: requests.filter(r => r.status === 'pending').length,
      approved: requests.filter(r => r.status === 'approved').length,
      rejected: requests.filter(r => r.status === 'rejected').length
    };
    
    console.log(`âœ… [ADMIN] Solicitudes profesionales listadas: ${requests.length} total`);
    
    res.json({
      success: true,
      data: paginatedRequests,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: requests.length,
        totalPages: Math.ceil(requests.length / limitNum)
      },
      stats
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error listando solicitudes:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando solicitudes',
      error: error.message
    });
  }
});

/**
 * Aprobar solicitud de perfil profesional (Admin)
 * POST /api/admin/professional-requests/:requestId/approve
 */
app.post('/api/admin/professional-requests/:requestId/approve', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { requestId } = req.params;
    const { pricing } = req.body;
    
    const requestDoc = await db.collection('professionalRequests').doc(requestId).get();
    
    if (!requestDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Solicitud no encontrada'
      });
    }
    
    const requestData = requestDoc.data();
    
    if (requestData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `La solicitud ya fue ${requestData.status === 'approved' ? 'aprobada' : 'rechazada'}`
      });
    }
    
    // Crear perfil profesional unificado
    const professionalData = {
      // Estructura compatible con professionals existentes
      name: requestData.personalInfo.displayName,
      headline: `${requestData.professional.specialties[0]} especializado`,
      bio: requestData.personalInfo.bio || '',
      photoUrl: requestData.userPhotoUrl || null,
      contactEmail: requestData.userEmail,
      contactPhone: requestData.personalInfo.phone || '',
      website: '',
      location: '',
      specialties: requestData.professional.specialties || [],
      tags: requestData.professional.specialties || [],
      
      // Campos para consultas mÃ©dicas
      accountType: requestData.accountType,
      canAcceptConsultations: true,
      
      professionalInfo: {
        licenseNumber: requestData.professional.licenseNumber || null,
        university: requestData.professional.university || null,
        yearsExperience: requestData.professional.yearsExperience || 0,
        certifications: requestData.professional.certifications || []
      },
      
      availability: {
        schedule: {},
        timezone: 'America/Guayaquil',
        maxConsultationsPerDay: 10
      },
      
      consultationPricing: {
        chatConsultation: pricing?.chatConsultation || 25,
        videoConsultation: pricing?.videoConsultation || 40,
        currency: pricing?.currency || 'USD',
        acceptsFreeConsultations: pricing?.acceptsFreeConsultations || false
      },
      
      consultationStats: {
        totalConsultations: 0,
        averageRating: 0,
        responseTime: 0,
        completionRate: 100
      },
      
      linkedUserId: requestData.userId,
      userId: requestData.userId,  // Para compatibilidad
      
      permissions: {
        canAcceptConsultations: true,
        canPrescribe: requestData.accountType === 'specialist',
        canDiagnose: ['specialist', 'psychologist'].includes(requestData.accountType),
        canSellProducts: ['nutritionist', 'coach'].includes(requestData.accountType),
        canCreateMealPlans: requestData.accountType === 'nutritionist',
        canWriteArticles: true
      },
      
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const professionalRef = await db.collection('professionals').add(professionalData);
    
    // Actualizar usuario con professionalProfile
    await db.collection('users').doc(requestData.userId).update({
      professionalProfile: {
        isActive: true,
        specialistId: professionalRef.id,
        accountType: requestData.accountType,
        verifiedAt: new Date()
      },
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Actualizar solicitud
    await db.collection('professionalRequests').doc(requestId).update({
      status: 'approved',
      reviewedAt: new Date(),
      reviewedBy: req.user.email || req.user.uid,
      specialistId: professionalRef.id,
      updatedAt: new Date()
    });
    
    console.log(`âœ… [ADMIN] Solicitud aprobada: ${requestId} -> Profesional ${professionalRef.id}`);
    
    // TODO: Enviar email de aprobaciÃ³n al usuario
    // TODO: Enviar notificaciÃ³n push
    
    res.json({
      success: true,
      message: 'Solicitud aprobada exitosamente. El usuario ahora es un profesional verificado.',
      data: {
        requestId,
        specialistId: professionalRef.id,
        userId: requestData.userId,
        userEmail: requestData.userEmail
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error aprobando solicitud:', error);
    res.status(500).json({
      success: false,
      message: 'Error aprobando solicitud',
      error: error.message
    });
  }
});

/**
 * Rechazar solicitud de perfil profesional (Admin)
 * POST /api/admin/professional-requests/:requestId/reject
 */
app.post('/api/admin/professional-requests/:requestId/reject', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { requestId } = req.params;
    const { reason } = req.body;
    
    if (!reason || reason.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe proporcionar una razÃ³n para el rechazo'
      });
    }
    
    const requestDoc = await db.collection('professionalRequests').doc(requestId).get();
    
    if (!requestDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Solicitud no encontrada'
      });
    }
    
    const requestData = requestDoc.data();
    
    if (requestData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `La solicitud ya fue ${requestData.status === 'approved' ? 'aprobada' : 'rechazada'}`
      });
    }
    
    // Actualizar solicitud
    await db.collection('professionalRequests').doc(requestId).update({
      status: 'rejected',
      reviewedAt: new Date(),
      reviewedBy: req.user.email || req.user.uid,
      rejectionReason: reason.trim(),
      updatedAt: new Date()
    });
    
    console.log(`âœ… [ADMIN] Solicitud rechazada: ${requestId} - RazÃ³n: ${reason}`);
    
    // TODO: Enviar email de rechazo al usuario con la razÃ³n
    // TODO: Enviar notificaciÃ³n push
    
    res.json({
      success: true,
      message: 'Solicitud rechazada',
      data: {
        requestId,
        userId: requestData.userId,
        userEmail: requestData.userEmail,
        reason: reason.trim()
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error rechazando solicitud:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando solicitud',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE PERFILES PROFESIONALES - PANEL DEL ESPECIALISTA
// ============================================================================

/**
 * Obtener consultas asignadas al especialista (App - Modo Profesional)
 * GET /api/specialist/consultations
 */
app.get('/api/specialist/consultations', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { status, page = 1, limit = 20, urgency, type } = req.query;
    
    // Verificar que el usuario tiene perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userData = userDoc.data();
    
    if (!userData.professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userData.professionalProfile.specialistId;
    
    // Construir query
    let query = db.collection('consultations')
      .where('specialistId', '==', specialistId);
    
    if (status) {
      query = query.where('status', '==', status);
    }
    
    query = query.orderBy('createdAt', 'desc');
    
    const snapshot = await query.get();
    
    // Filtrar y enriquecer datos
    const consultations = [];
    
    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Filtros adicionales
      if (urgency && data.request?.urgency !== urgency) continue;
      if (type && data.type !== type) continue;
      
      // Obtener info del niÃ±o
      let childInfo = null;
      if (data.childId) {
        const childDoc = await db.collection('children').doc(data.childId).get();
        if (childDoc.exists) {
          const childData = childDoc.data();
          const birthDate = parseDateSafe(childData.birthDate);
          const ageMonths = birthDate ? calculateMonthsFromBirthDate(birthDate) : null;
          
          childInfo = {
            name: childData.name,
            age: ageMonths ? `${Math.floor(ageMonths / 12)} aÃ±os ${ageMonths % 12} meses` : 'N/A',
            photoUrl: childData.photoUrl || null
          };
        }
      }
      
      // Obtener info del padre
      let parentInfo = null;
      if (data.parentId) {
        const parentDoc = await db.collection('users').doc(data.parentId).get();
        if (parentDoc.exists) {
          const parentData = parentDoc.data();
          parentInfo = {
            name: parentData.displayName || 'Usuario',
            photoUrl: parentData.photoURL || null
          };
        }
      }
      
      consultations.push({
        id: doc.id,
        childName: childInfo?.name || 'N/A',
        childAge: childInfo?.age || 'N/A',
        childPhotoUrl: childInfo?.photoUrl,
        parent: parentInfo,
        type: data.type,
        status: data.status,
        request: {
          description: data.request?.description,
          photos: data.request?.photos || [],
          symptomDetails: data.request?.symptomDetails || [],
          urgency: data.request?.urgency
        },
        pricing: {
          finalPrice: data.pricing?.finalPrice || 0,
          isFree: data.pricing?.finalPrice === 0
        },
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        scheduledFor: data.scheduledFor?.toDate?.() || data.scheduledFor,
        acceptedAt: data.acceptedAt?.toDate?.() || data.acceptedAt
      });
    }
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedConsultations = consultations.slice(startIndex, endIndex);
    
    // Calcular estadÃ­sticas
    const stats = {
      pending: consultations.filter(c => c.status === 'pending').length,
      accepted: consultations.filter(c => c.status === 'accepted').length,
      in_progress: consultations.filter(c => c.status === 'in_progress').length,
      completed: consultations.filter(c => c.status === 'completed').length
    };
    
    console.log(`âœ… [SPECIALIST] Consultas listadas: ${consultations.length} para ${specialistId}`);
    
    res.json({
      success: true,
      data: paginatedConsultations,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: consultations.length,
        totalPages: Math.ceil(consultations.length / limitNum)
      },
      stats
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error listando consultas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando consultas',
      error: error.message
    });
  }
});

/**
 * Obtener detalles de consulta (Especialista)
 * GET /api/specialist/consultations/:consultationId
 */
app.get('/api/specialist/consultations/:consultationId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { consultationId } = req.params;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const data = consultationDoc.data();
    
    // Verificar que la consulta pertenece a este especialista
    if (data.specialistId !== specialistId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta consulta'
      });
    }
    
    // Obtener info completa del niÃ±o
    let childInfo = null;
    if (data.childId) {
      const childDoc = await db.collection('children').doc(data.childId).get();
      if (childDoc.exists) {
        childInfo = {
          id: childDoc.id,
          ...childDoc.data(),
          birthDate: childDoc.data().birthDate?.toDate?.() || childDoc.data().birthDate
        };
      }
    }
    
    // Obtener info del padre
    let parentInfo = null;
    if (data.parentId) {
      const parentDoc = await db.collection('users').doc(data.parentId).get();
      if (parentDoc.exists) {
        const parentData = parentDoc.data();
        parentInfo = {
          id: parentDoc.id,
          name: parentData.displayName,
          email: parentData.email,
          photoUrl: parentData.photoURL,
          phone: parentData.phone
        };
      }
    }
    
    // Obtener mensajes del chat
    const messagesSnapshot = await db.collection('consultations')
      .doc(consultationId)
      .collection('messages')
      .orderBy('sentAt', 'asc')
      .get();
    
    const messages = [];
    messagesSnapshot.forEach(msgDoc => {
      const msgData = msgDoc.data();
      messages.push({
        id: msgDoc.id,
        ...msgData,
        sentAt: msgData.sentAt?.toDate?.() || msgData.sentAt
      });
    });
    
    res.json({
      success: true,
      data: {
        id: consultationDoc.id,
        ...data,
        child: childInfo,
        parent: parentInfo,
        messages,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        acceptedAt: data.acceptedAt?.toDate?.() || data.acceptedAt,
        startedAt: data.startedAt?.toDate?.() || data.startedAt,
        completedAt: data.completedAt?.toDate?.() || data.completedAt,
        scheduledFor: data.scheduledFor?.toDate?.() || data.scheduledFor
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error obteniendo consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo consulta',
      error: error.message
    });
  }
});

/**
 * Aceptar consulta (Especialista)
 * POST /api/specialist/consultations/:consultationId/accept
 */
app.post('/api/specialist/consultations/:consultationId/accept', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { consultationId } = req.params;
    const { scheduledFor, estimatedResponseTime } = req.body;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const data = consultationDoc.data();
    
    if (data.specialistId !== specialistId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta consulta'
      });
    }
    
    if (data.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `La consulta ya estÃ¡ en estado: ${data.status}`
      });
    }
    
    // Actualizar consulta
    const updateData = {
      status: 'accepted',
      acceptedAt: new Date(),
      updatedAt: new Date()
    };
    
    if (scheduledFor) {
      updateData.scheduledFor = new Date(scheduledFor);
    }
    
    if (estimatedResponseTime) {
      updateData.estimatedResponseTime = parseInt(estimatedResponseTime);
    }
    
    await db.collection('consultations').doc(consultationId).update(updateData);
    
    console.log(`âœ… [SPECIALIST] Consulta aceptada: ${consultationId} por ${specialistId}`);
    
    // TODO: Enviar notificaciÃ³n push al padre
    
    res.json({
      success: true,
      message: 'Consulta aceptada exitosamente',
      data: {
        status: 'accepted',
        acceptedAt: updateData.acceptedAt,
        scheduledFor: updateData.scheduledFor,
        estimatedResponseTime: updateData.estimatedResponseTime
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error aceptando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error aceptando consulta',
      error: error.message
    });
  }
});

/**
 * Rechazar consulta (Especialista)
 * POST /api/specialist/consultations/:consultationId/reject
 */
app.post('/api/specialist/consultations/:consultationId/reject', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { consultationId } = req.params;
    const { reason } = req.body;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const data = consultationDoc.data();
    
    if (data.specialistId !== specialistId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta consulta'
      });
    }
    
    if (data.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `La consulta ya estÃ¡ en estado: ${data.status}`
      });
    }
    
    await db.collection('consultations').doc(consultationId).update({
      status: 'rejected',
      rejectedAt: new Date(),
      rejectionReason: reason || 'No especificado',
      updatedAt: new Date()
    });
    
    console.log(`âœ… [SPECIALIST] Consulta rechazada: ${consultationId} por ${specialistId}`);
    
    // TODO: Enviar notificaciÃ³n push al padre
    // TODO: Reasignar a otro especialista disponible
    
    res.json({
      success: true,
      message: 'Consulta rechazada',
      data: {
        status: 'rejected',
        reason: reason || 'No especificado'
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error rechazando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando consulta',
      error: error.message
    });
  }
});

/**
 * Iniciar consulta (Especialista)
 * POST /api/specialist/consultations/:consultationId/start
 */
app.post('/api/specialist/consultations/:consultationId/start', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { consultationId } = req.params;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const data = consultationDoc.data();
    
    if (data.specialistId !== specialistId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta consulta'
      });
    }
    
    if (data.status !== 'accepted') {
      return res.status(400).json({
        success: false,
        message: `La consulta debe estar aceptada. Estado actual: ${data.status}`
      });
    }
    
    await db.collection('consultations').doc(consultationId).update({
      status: 'in_progress',
      startedAt: new Date(),
      updatedAt: new Date()
    });
    
    console.log(`âœ… [SPECIALIST] Consulta iniciada: ${consultationId} por ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Consulta iniciada exitosamente',
      data: {
        status: 'in_progress',
        startedAt: new Date()
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error iniciando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error iniciando consulta',
      error: error.message
    });
  }
});

/**
 * Completar consulta (Especialista)
 * POST /api/specialist/consultations/:consultationId/complete
 */
app.post('/api/specialist/consultations/:consultationId/complete', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { consultationId } = req.params;
    const { diagnosis, treatment, prescriptions, notes, followUpRequired, followUpDate } = req.body;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const data = consultationDoc.data();
    
    if (data.specialistId !== specialistId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta consulta'
      });
    }
    
    if (data.status !== 'in_progress') {
      return res.status(400).json({
        success: false,
        message: `La consulta debe estar en progreso. Estado actual: ${data.status}`
      });
    }
    
    if (!diagnosis || !treatment) {
      return res.status(400).json({
        success: false,
        message: 'DiagnÃ³stico y tratamiento son requeridos'
      });
    }
    
    const completedAt = new Date();
    const startedAt = data.startedAt?.toDate?.() || data.startedAt;
    const duration = startedAt ? Math.floor((completedAt - new Date(startedAt)) / 60000) : null; // minutos
    
    const updateData = {
      status: 'completed',
      completedAt,
      duration,
      result: {
        diagnosis: diagnosis.trim(),
        treatment: treatment.trim(),
        prescriptions: prescriptions || [],
        notes: notes?.trim() || null,
        followUpRequired: followUpRequired || false,
        followUpDate: followUpDate ? new Date(followUpDate) : null
      },
      updatedAt: new Date()
    };
    
    await db.collection('consultations').doc(consultationId).update(updateData);
    
    // Actualizar stats del especialista
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    if (specialistDoc.exists) {
      const specialistData = specialistDoc.data();
      const totalConsultations = (specialistData.stats?.totalConsultations || 0) + 1;
      
      await db.collection('professionals').doc(specialistId).update({
        'stats.totalConsultations': totalConsultations,
        updatedAt: new Date()
      });
    }
    
    console.log(`âœ… [SPECIALIST] Consulta completada: ${consultationId} por ${specialistId} (${duration} min)`);
    
    // TODO: Enviar notificaciÃ³n push al padre
    
    res.json({
      success: true,
      message: 'Consulta completada exitosamente',
      data: {
        status: 'completed',
        completedAt,
        duration
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error completando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error completando consulta',
      error: error.message
    });
  }
});

/**
 * EstadÃ­sticas del especialista (App - Modo Profesional)
 * GET /api/specialist/stats
 */
app.get('/api/specialist/stats', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { period = 'month' } = req.query; // month, week, all
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    // Calcular fechas segÃºn el periodo
    const now = new Date();
    let startDate;
    
    if (period === 'week') {
      startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
    } else if (period === 'month') {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
    } else {
      startDate = new Date(0); // All time
    }
    
    // Obtener todas las consultas del especialista
    const consultationsSnapshot = await db.collection('consultations')
      .where('specialistId', '==', specialistId)
      .get();
    
    const allConsultations = [];
    const periodConsultations = [];
    
    consultationsSnapshot.forEach(doc => {
      const data = doc.data();
      const createdAt = data.createdAt?.toDate?.() || data.createdAt;
      
      allConsultations.push(data);
      
      if (new Date(createdAt) >= startDate) {
        periodConsultations.push(data);
      }
    });
    
    // Calcular mÃ©tricas del periodo
    const completed = periodConsultations.filter(c => c.status === 'completed');
    const revenue = completed.reduce((sum, c) => sum + (c.pricing?.finalPrice || 0), 0);
    
    // Calcular promedio de rating
    const ratings = completed.filter(c => c.rating?.score).map(c => c.rating.score);
    const averageRating = ratings.length > 0 
      ? (ratings.reduce((sum, r) => sum + r, 0) / ratings.length).toFixed(1)
      : 0;
    
    // Calcular tiempo de respuesta promedio (en minutos)
    const responseTimes = completed
      .filter(c => c.acceptedAt && c.createdAt)
      .map(c => {
        const created = new Date(c.createdAt?.toDate?.() || c.createdAt);
        const accepted = new Date(c.acceptedAt?.toDate?.() || c.acceptedAt);
        return Math.floor((accepted - created) / 60000);
      });
    
    const averageResponseTime = responseTimes.length > 0
      ? Math.floor(responseTimes.reduce((sum, t) => sum + t, 0) / responseTimes.length)
      : 0;
    
    // Calcular tasa de completaciÃ³n
    const acceptedCount = periodConsultations.filter(c => 
      ['accepted', 'in_progress', 'completed'].includes(c.status)
    ).length;
    
    const completionRate = acceptedCount > 0
      ? Math.floor((completed.length / acceptedCount) * 100)
      : 100;
    
    // Reviews recientes
    const recentReviews = completed
      .filter(c => c.rating?.comment)
      .slice(-5)
      .map(c => ({
        rating: c.rating.score,
        comment: c.rating.comment,
        date: c.completedAt?.toDate?.() || c.completedAt
      }));
    
    // EstadÃ­sticas por tipo
    const byType = {
      chat: periodConsultations.filter(c => c.type === 'chat').length,
      video: periodConsultations.filter(c => c.type === 'online').length
    };
    
    // EstadÃ­sticas totales (all time)
    const allCompleted = allConsultations.filter(c => c.status === 'completed');
    const allRevenue = allCompleted.reduce((sum, c) => sum + (c.pricing?.finalPrice || 0), 0);
    const allRatings = allCompleted.filter(c => c.rating?.score).map(c => c.rating.score);
    const allAverageRating = allRatings.length > 0
      ? (allRatings.reduce((sum, r) => sum + r, 0) / allRatings.length).toFixed(1)
      : 0;
    
    res.json({
      success: true,
      data: {
        period: period === 'month' ? 'Este Mes' : period === 'week' ? 'Esta Semana' : 'Todo el Tiempo',
        thisPeriod: {
          consultations: periodConsultations.length,
          revenue,
          averageRating: parseFloat(averageRating),
          averageResponseTime,
          completionRate
        },
        allTime: {
          totalConsultations: allConsultations.length,
          totalRevenue: allRevenue,
          averageRating: parseFloat(allAverageRating)
        },
        byType,
        recentReviews
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

/**
 * Actualizar disponibilidad (Especialista)
 * PUT /api/specialist/availability
 */
app.put('/api/specialist/availability', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { schedule, maxConsultationsPerDay } = req.body;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const updateData = {
      updatedAt: new Date()
    };
    
    if (schedule) {
      updateData['availability.schedule'] = schedule;
    }
    
    if (maxConsultationsPerDay) {
      updateData['availability.maxConsultationsPerDay'] = parseInt(maxConsultationsPerDay);
    }
    
    await db.collection('professionals').doc(specialistId).update(updateData);
    
    console.log(`âœ… [SPECIALIST] Disponibilidad actualizada: ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Disponibilidad actualizada exitosamente',
      data: {
        schedule,
        maxConsultationsPerDay
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error actualizando disponibilidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando disponibilidad',
      error: error.message
    });
  }
});

/**
 * Actualizar precios (Especialista)
 * PUT /api/specialist/pricing
 */
app.put('/api/specialist/pricing', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { chatConsultation, videoConsultation } = req.body;
    
    // Verificar perfil profesional
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists || !userDoc.data().professionalProfile?.isActive) {
      return res.status(403).json({
        success: false,
        message: 'No tienes un perfil profesional activo'
      });
    }
    
    const specialistId = userDoc.data().professionalProfile.specialistId;
    
    const updateData = {
      updatedAt: new Date()
    };
    
    if (chatConsultation !== undefined) {
      updateData['pricing.chatConsultation'] = parseFloat(chatConsultation);
    }
    
    if (videoConsultation !== undefined) {
      updateData['pricing.videoConsultation'] = parseFloat(videoConsultation);
    }
    
    await db.collection('professionals').doc(specialistId).update(updateData);
    
    console.log(`âœ… [SPECIALIST] Precios actualizados: ${specialistId}`);
    
    res.json({
      success: true,
      message: 'Precios actualizados exitosamente',
      data: {
        chatConsultation,
        videoConsultation
      }
    });
    
  } catch (error) {
    console.error('âŒ [SPECIALIST] Error actualizando precios:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando precios',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - CUPONES DE DESCUENTO
// ============================================================================

/**
 * Helper: Buscar el mejor cupÃ³n auto-aplicable para un usuario
 */
async function findBestAutoApplyCoupon(userId, type, specialistId) {
  try {
    const now = new Date();
    
    console.log(`ðŸ” [COUPON] Buscando cupÃ³n auto-aplicable para usuario ${userId}`);
    console.log(`   â€¢ Tipo: ${type}`);
    console.log(`   â€¢ Especialista: ${specialistId}`);
    
    // Obtener usuario para verificar condiciones
    const userDoc = await db.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      console.log(`   âŒ Usuario no encontrado`);
      return null;
    }
    
    const userData = userDoc.data();
    
    // Obtener historial de consultas del usuario
    const consultationsSnapshot = await db.collection('consultations')
      .where('parentId', '==', userId)
      .get();
    
    const userConsultations = consultationsSnapshot.size;
    const hasCompletedConsultation = consultationsSnapshot.docs.some(
      doc => doc.data().status === 'completed'
    );
    
    console.log(`   â€¢ Consultas totales: ${userConsultations}`);
    console.log(`   â€¢ Tiene consulta completada: ${hasCompletedConsultation}`);
    
    // Verificar si tiene hijos
    const childrenSnapshot = await db.collection('users')
      .doc(userId)
      .collection('children')
      .get();
    const hasChildren = !childrenSnapshot.empty;
    
    console.log(`   â€¢ Tiene hijos: ${hasChildren} (${childrenSnapshot.size})`);
    
    // Obtener cupones auto-aplicables activos
    const couponsSnapshot = await db.collection('discountCoupons')
      .where('autoApply', '==', true)
      .where('isActive', '==', true)
      .get();
    
    console.log(`   â€¢ Cupones auto-aplicables encontrados: ${couponsSnapshot.size}`);
    
    const eligibleCoupons = [];
    
    couponsSnapshot.forEach(doc => {
      const coupon = { id: doc.id, ...doc.data() };
      
      console.log(`   ðŸ“Œ Evaluando cupÃ³n: ${coupon.code}`);
      
      // Validar fechas
      if (coupon.validFrom && coupon.validFrom.toDate() > now) {
        console.log(`      âŒ AÃºn no estÃ¡ vigente (inicia: ${coupon.validFrom.toDate()})`);
        return;
      }
      if (coupon.validUntil && coupon.validUntil.toDate() < now) {
        console.log(`      âŒ Ya expirÃ³ (expirÃ³: ${coupon.validUntil.toDate()})`);
        return;
      }
      
      // Validar usos mÃ¡ximos
      if (coupon.maxUses && coupon.usedCount >= coupon.maxUses) {
        console.log(`      âŒ AlcanzÃ³ el mÃ¡ximo de usos (${coupon.usedCount}/${coupon.maxUses})`);
        return;
      }
      
      // Validar tipo de consulta
      if (coupon.applicableTo !== 'all' && coupon.applicableTo !== type) {
        console.log(`      âŒ No aplica a este tipo (requiere: ${coupon.applicableTo}, actual: ${type})`);
        return;
      }
      
      // Validar especialista
      if (coupon.specialistId && coupon.specialistId !== specialistId) {
        console.log(`      âŒ No aplica a este especialista`);
        return;
      }
      
      // Validar condiciones de auto-aplicaciÃ³n
      const conditions = coupon.autoApplyConditions || {};
      
      console.log(`      âœ“ Validando condiciones...`);
      
      // Primera consulta
      if (conditions.firstConsultation && hasCompletedConsultation) {
        console.log(`      âŒ Requiere primera consulta pero usuario ya tiene consulta completada`);
        return;
      }
      
      // Nuevo usuario (sin consultas completadas)
      if (conditions.newUser && hasCompletedConsultation) {
        console.log(`      âŒ Requiere usuario nuevo pero ya tiene consulta completada`);
        return;
      }
      
      // MÃ­nimo de consultas
      if (conditions.minConsultations && userConsultations < conditions.minConsultations) {
        console.log(`      âŒ Requiere mÃ­nimo ${conditions.minConsultations} consultas pero tiene ${userConsultations}`);
        return;
      }
      
      // MÃ¡ximo de consultas
      if (conditions.maxConsultations !== null && conditions.maxConsultations !== undefined && userConsultations > conditions.maxConsultations) {
        console.log(`      âŒ Requiere mÃ¡ximo ${conditions.maxConsultations} consultas pero tiene ${userConsultations}`);
        return;
      }
      
      // Debe tener hijos registrados
      if (conditions.userHasChildren && !hasChildren) {
        console.log(`      âŒ Requiere tener hijos registrados pero no tiene`);
        return;
      }
      
      // DÃ­as especÃ­ficos
      if (conditions.specificDays && conditions.specificDays.length > 0) {
        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const today = dayNames[now.getDay()];
        if (!conditions.specificDays.includes(today)) {
          console.log(`      âŒ Requiere dÃ­a especÃ­fico (${conditions.specificDays.join(', ')}) pero hoy es ${today}`);
          return;
        }
      }
      
      console.log(`      âœ… CupÃ³n ELEGIBLE! (priority: ${coupon.priority || 0})`);
      eligibleCoupons.push(coupon);
    });
    
    if (eligibleCoupons.length === 0) {
      console.log(`   âŒ No hay cupones elegibles`);
      return null;
    }
    
    console.log(`   âœ… ${eligibleCoupons.length} cupÃ³n(es) elegible(s)`);
    
    // Ordenar por prioridad (mayor primero) y luego por descuento
    eligibleCoupons.sort((a, b) => {
      if (b.priority !== a.priority) {
        return b.priority - a.priority;
      }
      // Si son del mismo tipo free, son iguales
      if (a.type === 'free' && b.type === 'free') return 0;
      if (a.type === 'free') return -1;
      if (b.type === 'free') return 1;
      
      // Comparar valores
      return b.value - a.value;
    });
    
    console.log(`   ðŸŽ CupÃ³n seleccionado: ${eligibleCoupons[0].code} (${eligibleCoupons[0].type}, value: ${eligibleCoupons[0].value})`);
    
    return eligibleCoupons[0];
    
  } catch (error) {
    console.error('âŒ Error buscando cupÃ³n auto-aplicable:', error);
    return null;
  }
}

/**
 * Crear cupÃ³n de descuento (Admin)
 * POST /api/admin/coupons
 */
app.post('/api/admin/coupons', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { 
      code, 
      type, 
      value, 
      maxUses, 
      validFrom, 
      validUntil, 
      applicableTo, 
      specialistId,
      autoApply,
      autoApplyConditions
    } = req.body;
    
    if (!code || !type || value === undefined) {
      return res.status(400).json({
        success: false,
        message: 'CÃ³digo, tipo y valor son requeridos'
      });
    }
    
    const validTypes = ['percentage', 'fixed', 'free'];
    if (!validTypes.includes(type)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo invÃ¡lido',
        validTypes
      });
    }
    
    // Verificar si el cÃ³digo ya existe
    const existingCoupon = await db.collection('discountCoupons')
      .where('code', '==', code.toUpperCase())
      .limit(1)
      .get();
    
    if (!existingCoupon.empty) {
      return res.status(400).json({
        success: false,
        message: 'El cÃ³digo de cupÃ³n ya existe'
      });
    }
    
    const couponData = {
      code: code.toUpperCase().trim(),
      type,
      value: parseFloat(value),
      maxUses: maxUses || null,
      usedCount: 0,
      validFrom: validFrom ? new Date(validFrom) : new Date(),
      validUntil: validUntil ? new Date(validUntil) : null,
      applicableTo: applicableTo || 'all',
      specialistId: specialistId || null,
      autoApply: autoApply || false,
      autoApplyConditions: autoApplyConditions || {
        firstConsultation: false,
        newUser: false,
        minConsultations: null,
        maxConsultations: null,
        userHasChildren: false,
        specificDays: null // ["monday", "tuesday", ...]
      },
      priority: autoApply ? (autoApplyConditions?.priority || 0) : 0,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const couponRef = await db.collection('discountCoupons').add(couponData);
    
    console.log(`âœ… [ADMIN] CupÃ³n creado: ${code} ${autoApply ? '(Auto-aplicable)' : ''}`);
    
    res.json({
      success: true,
      message: 'CupÃ³n creado exitosamente',
      data: {
        id: couponRef.id,
        ...couponData
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error creando cupÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando cupÃ³n',
      error: error.message
    });
  }
});

/**
 * Listar cupones (Admin)
 * GET /api/admin/coupons
 */
app.get('/api/admin/coupons', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { isActive, page = 1, limit = 20 } = req.query;
    
    let query = db.collection('discountCoupons');
    
    if (isActive !== undefined) {
      query = query.where('isActive', '==', isActive === 'true');
    }
    
    query = query.orderBy('createdAt', 'desc');
    
    const snapshot = await query.get();
    
    const coupons = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      coupons.push({
        id: doc.id,
        ...data,
        validFrom: data.validFrom?.toDate?.() || data.validFrom,
        validUntil: data.validUntil?.toDate?.() || data.validUntil,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedCoupons = coupons.slice(startIndex, endIndex);
    
    console.log(`âœ… [ADMIN] Cupones listados: ${coupons.length} total`);
    
    res.json({
      success: true,
      data: paginatedCoupons,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: coupons.length,
        totalPages: Math.ceil(coupons.length / limitNum)
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error listando cupones:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando cupones',
      error: error.message
    });
  }
});

/**
 * Actualizar cupÃ³n (Admin)
 * PUT /api/admin/coupons/:couponId
 */
app.put('/api/admin/coupons/:couponId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { couponId } = req.params;
    const updates = req.body;
    
    const couponDoc = await db.collection('discountCoupons').doc(couponId).get();
    
    if (!couponDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'CupÃ³n no encontrado'
      });
    }
    
    const updateData = {
      ...updates,
      updatedAt: new Date()
    };
    
    // Convertir fechas si existen
    if (updates.validFrom) updateData.validFrom = new Date(updates.validFrom);
    if (updates.validUntil) updateData.validUntil = new Date(updates.validUntil);
    
    await db.collection('discountCoupons').doc(couponId).update(updateData);
    
    console.log(`âœ… [ADMIN] CupÃ³n actualizado: ${couponId}`);
    
    res.json({
      success: true,
      message: 'CupÃ³n actualizado exitosamente'
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando cupÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando cupÃ³n',
      error: error.message
    });
  }
});

/**
 * Verificar cupÃ³n (App)
 * GET /api/coupons/verify/:code
 */
app.get('/api/coupons/verify/:code', authenticateToken, async (req, res) => {
  try {
    const { code } = req.params;
    const { type, specialistId } = req.query;
    
    const couponSnapshot = await db.collection('discountCoupons')
      .where('code', '==', code.toUpperCase())
      .where('isActive', '==', true)
      .limit(1)
      .get();
    
    if (couponSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'CupÃ³n no vÃ¡lido'
      });
    }
    
    const couponDoc = couponSnapshot.docs[0];
    const coupon = couponDoc.data();
    
    // Verificar fecha de validez
    const now = new Date();
    if (coupon.validFrom && coupon.validFrom.toDate() > now) {
      return res.status(400).json({
        success: false,
        message: 'El cupÃ³n aÃºn no estÃ¡ vigente'
      });
    }
    
    if (coupon.validUntil && coupon.validUntil.toDate() < now) {
      return res.status(400).json({
        success: false,
        message: 'El cupÃ³n ha expirado'
      });
    }
    
    // Verificar usos mÃ¡ximos
    if (coupon.maxUses && coupon.usedCount >= coupon.maxUses) {
      return res.status(400).json({
        success: false,
        message: 'El cupÃ³n ha alcanzado el lÃ­mite de usos'
      });
    }
    
    // Verificar aplicabilidad
    if (coupon.applicableTo !== 'all') {
      if (type && coupon.applicableTo !== type) {
        return res.status(400).json({
          success: false,
          message: `Este cupÃ³n solo aplica para consultas tipo ${coupon.applicableTo}`
        });
      }
      
      if (coupon.specialistId && specialistId && coupon.specialistId !== specialistId) {
        return res.status(400).json({
          success: false,
          message: 'Este cupÃ³n no aplica para este especialista'
        });
      }
    }
    
    res.json({
      success: true,
      data: {
        id: couponDoc.id,
        code: coupon.code,
        type: coupon.type,
        value: coupon.value,
        applicableTo: coupon.applicableTo
      }
    });
    
  } catch (error) {
    console.error('âŒ [COUPONS] Error verificando cupÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando cupÃ³n',
      error: error.message
    });
  }
});

/**
 * Calcular precio con descuento (App)
 * POST /api/consultations/calculate-price
 */
app.post('/api/consultations/calculate-price', authenticateToken, async (req, res) => {
  try {
    const { type, specialistId, couponCode } = req.body;
    const userId = req.user.uid;
    
    if (!type || !specialistId) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de consulta y especialista son requeridos'
      });
    }
    
    // Obtener precio del especialista
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Especialista no encontrado'
      });
    }
    
    const specialist = specialistDoc.data();
    const basePrice = type === 'chat' 
      ? specialist.pricing.chatConsultation 
      : specialist.pricing.videoConsultation;
    
    let discount = 0;
    let couponData = null;
    let appliedCoupon = null;
    
    // 1. Primero intentar con el cupÃ³n ingresado manualmente (si existe)
    if (couponCode) {
      const couponSnapshot = await db.collection('discountCoupons')
        .where('code', '==', couponCode.toUpperCase())
        .where('isActive', '==', true)
        .limit(1)
        .get();
      
      if (!couponSnapshot.empty) {
        const coupon = couponSnapshot.docs[0].data();
        
        // Validar cupÃ³n
        const now = new Date();
        const isValid = 
          (!coupon.validFrom || coupon.validFrom.toDate() <= now) &&
          (!coupon.validUntil || coupon.validUntil.toDate() >= now) &&
          (!coupon.maxUses || coupon.usedCount < coupon.maxUses) &&
          (coupon.applicableTo === 'all' || coupon.applicableTo === type) &&
          (!coupon.specialistId || coupon.specialistId === specialistId);
        
        if (isValid) {
          appliedCoupon = coupon;
        }
      }
    }
    
    // 2. Si no hay cupÃ³n manual, buscar cupones auto-aplicables
    if (!appliedCoupon) {
      appliedCoupon = await findBestAutoApplyCoupon(userId, type, specialistId);
    }
    
    // Calcular descuento si hay cupÃ³n aplicable
    if (appliedCoupon) {
      if (appliedCoupon.type === 'percentage') {
        discount = basePrice * (appliedCoupon.value / 100);
      } else if (appliedCoupon.type === 'fixed') {
        discount = appliedCoupon.value;
      } else if (appliedCoupon.type === 'free') {
        discount = basePrice;
      }
      
      couponData = {
        code: appliedCoupon.code,
        type: appliedCoupon.type,
        value: appliedCoupon.value,
        autoApplied: !couponCode && appliedCoupon.autoApply
      };
    }
    
    const finalPrice = Math.max(0, basePrice - discount);
    
    res.json({
      success: true,
      data: {
        basePrice,
        discount: Math.round(discount * 100) / 100,
        finalPrice: Math.round(finalPrice * 100) / 100,
        currency: specialist.pricing.currency,
        coupon: couponData,
        isFree: finalPrice === 0
      }
    });
    
  } catch (error) {
    console.error('âŒ [CONSULTATIONS] Error calculando precio:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando precio',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - CONSULTAS
// ============================================================================

/**
 * Crear consulta mÃ©dica (App)
 * POST /api/children/:childId/consultations
 */
app.post('/api/children/:childId/consultations', authenticateToken, async (req, res) => {
  try {
    const { childId } = req.params;
    const userId = req.user.uid;
    const { 
      description, 
      photos = [], 
      symptoms = [], 
      type, 
      urgency = 'normal',
      preferredSpecialistId,
      couponCode 
    } = req.body;
    
    if (!description || !type) {
      return res.status(400).json({
        success: false,
        message: 'DescripciÃ³n y tipo de consulta son requeridos'
      });
    }
    
    if (!['chat', 'video'].includes(type)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de consulta invÃ¡lido. Debe ser "chat" o "video"'
      });
    }
    
    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }
    
    const childData = childDoc.data();
    
    // Verificar que el usuario es el padre o tiene acceso compartido
    const hasAccess = childData.parentId === userId || 
                      (childData.sharedWith && childData.sharedWith.includes(userId));
    
    if (!hasAccess) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para crear consultas para este hijo'
      });
    }
    
    // Buscar especialista disponible
    let specialistId = preferredSpecialistId;
    
    if (!specialistId) {
      // Buscar especialista activo con mejor rating
      const specialistsSnapshot = await db.collection('professionals')
        .where('status', '==', 'active')
        .orderBy('stats.averageRating', 'desc')
        .limit(1)
        .get();
      
      if (specialistsSnapshot.empty) {
        return res.status(503).json({
          success: false,
          message: 'No hay especialistas disponibles en este momento'
        });
      }
      
      specialistId = specialistsSnapshot.docs[0].id;
    }
    
    const specialistDoc = await db.collection('professionals').doc(specialistId).get();
    
    if (!specialistDoc.exists || specialistDoc.data().status !== 'active') {
      return res.status(404).json({
        success: false,
        message: 'Especialista no disponible'
      });
    }
    
    const specialist = specialistDoc.data();
    
    // Calcular precio
    const basePrice = type === 'chat' 
      ? specialist.pricing.chatConsultation 
      : specialist.pricing.videoConsultation;
    
    let discount = 0;
    let finalCouponCode = null;
    let finalCouponId = null;
    let isFree = false;
    let autoApplied = false;
    
    // 1. Primero intentar con el cupÃ³n ingresado manualmente (si existe)
    let appliedCoupon = null;
    let appliedCouponDocId = null;
    
    if (couponCode) {
      const couponSnapshot = await db.collection('discountCoupons')
        .where('code', '==', couponCode.toUpperCase())
        .where('isActive', '==', true)
        .limit(1)
        .get();
      
      if (!couponSnapshot.empty) {
        const couponDoc = couponSnapshot.docs[0];
        const coupon = couponDoc.data();
        
        // Validar cupÃ³n
        const now = new Date();
        const isValid = 
          (!coupon.validFrom || coupon.validFrom.toDate() <= now) &&
          (!coupon.validUntil || coupon.validUntil.toDate() >= now) &&
          (!coupon.maxUses || coupon.usedCount < coupon.maxUses) &&
          (coupon.applicableTo === 'all' || coupon.applicableTo === type) &&
          (!coupon.specialistId || coupon.specialistId === specialistId);
        
        if (isValid) {
          appliedCoupon = coupon;
          appliedCouponDocId = couponDoc.id;
        }
      }
    }
    
    // 2. Si no hay cupÃ³n manual, buscar cupones auto-aplicables
    if (!appliedCoupon) {
      const autoCoupon = await findBestAutoApplyCoupon(userId, type, specialistId);
      if (autoCoupon) {
        appliedCoupon = autoCoupon;
        appliedCouponDocId = autoCoupon.id;
        autoApplied = true;
      }
    }
    
    // Calcular descuento y actualizar contador si hay cupÃ³n aplicable
    if (appliedCoupon) {
      if (appliedCoupon.type === 'percentage') {
        discount = basePrice * (appliedCoupon.value / 100);
      } else if (appliedCoupon.type === 'fixed') {
        discount = appliedCoupon.value;
      } else if (appliedCoupon.type === 'free') {
        discount = basePrice;
        isFree = true;
      }
      
      finalCouponCode = appliedCoupon.code;
      
      // Incrementar contador de usos
      await db.collection('discountCoupons').doc(appliedCouponDocId).update({
        usedCount: admin.firestore.FieldValue.increment(1)
      });
      
      console.log(`âœ… CupÃ³n aplicado: ${finalCouponCode} ${autoApplied ? '(automÃ¡tico)' : '(manual)'}`);
    }
    
    const finalPrice = Math.max(0, basePrice - discount);
    
    // Crear consulta
    const consultationData = {
      parentId: userId,
      childId,
      childName: childData.name,
      childAge: childData.age || null,
      specialistId,
      specialistName: specialist.personalInfo.displayName,
      type,
      status: isFree ? 'pending' : 'awaiting_payment',
      request: {
        description: description.trim(),
        photos: photos || [],
        symptoms: symptoms || [],
        urgency: urgency || 'normal'
      },
      pricing: {
        basePrice,
        discount: Math.round(discount * 100) / 100,
        finalPrice: Math.round(finalPrice * 100) / 100,
        couponCode: finalCouponCode,
        isFree
      },
      payment: {
        method: null,
        transactionId: null,
        status: isFree ? 'free' : 'pending',
        paidAt: isFree ? new Date() : null
      },
      schedule: {
        requestedAt: new Date(),
        acceptedAt: null,
        scheduledFor: null,
        startedAt: null,
        completedAt: null
      },
      chat: {
        channelId: null,
        messageCount: 0
      },
      video: {
        roomId: null,
        duration: 0,
        recording: null
      },
      outcome: {
        diagnosis: null,
        treatment: null,
        prescriptions: [],
        notes: null,
        followUpRequired: false
      },
      rating: {
        score: null,
        comment: null,
        ratedAt: null
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const consultationRef = await db.collection('consultations').add(consultationData);
    
    console.log(`âœ… [CONSULTATION] Nueva consulta creada: ${consultationRef.id} - ${type} - $${finalPrice}`);
    
    // Obtener detalles de los sÃ­ntomas para el response
    const symptomDetails = [];
    if (symptoms && symptoms.length > 0) {
      for (const symptomId of symptoms) {
        try {
          const symptomDoc = await db.collection('symptoms').doc(symptomId).get();
          if (symptomDoc.exists) {
            const symptomData = symptomDoc.data();
            symptomDetails.push({
              id: symptomDoc.id,
              name: symptomData.name,
              description: symptomData.description,
              category: symptomData.category,
              severity: symptomData.severity
            });
          }
        } catch (err) {
          console.warn(`âš ï¸ Error obteniendo sÃ­ntoma ${symptomId}:`, err.message);
        }
      }
    }
    
    // Notificar al especialista (solo si estÃ¡ pagada o es gratis)
    if (isFree) {
      // TODO: Enviar notificaciÃ³n push al especialista
      console.log(`ðŸ“± Notificando al especialista ${specialistId} sobre nueva consulta`);
    }
    
    res.json({
      success: true,
      message: 'Consulta creada exitosamente',
      data: {
        consultationId: consultationRef.id,
        ...consultationData,
        request: {
          ...consultationData.request,
          symptomDetails  // Agregar detalles de los sÃ­ntomas
        },
        paymentRequired: !isFree
      }
    });
    
  } catch (error) {
    console.error('âŒ [CONSULTATION] Error creando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando consulta',
      error: error.message
    });
  }
});

/**
 * Listar consultas del usuario (App)
 * GET /api/consultations
 */
app.get('/api/consultations', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { status, childId, page = 1, limit = 20 } = req.query;
    
    let query = db.collection('consultations')
      .where('parentId', '==', userId);
    
    if (status) {
      query = query.where('status', '==', status);
    }
    
    if (childId) {
      query = query.where('childId', '==', childId);
    }
    
    query = query.orderBy('createdAt', 'desc');
    
    const snapshot = await query.get();
    
    const consultations = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      consultations.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedConsultations = consultations.slice(startIndex, endIndex);
    
    console.log(`âœ… [CONSULTATIONS] Consultas listadas: ${consultations.length} total para usuario ${userId}`);
    
    res.json({
      success: true,
      data: paginatedConsultations,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: consultations.length,
        totalPages: Math.ceil(consultations.length / limitNum)
      }
    });
    
  } catch (error) {
    console.error('âŒ [CONSULTATIONS] Error listando consultas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando consultas',
      error: error.message
    });
  }
});

/**
 * Obtener detalles de consulta (App)
 * GET /api/consultations/:consultationId
 */
app.get('/api/consultations/:consultationId', authenticateToken, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const userId = req.user.uid;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    // Verificar que el usuario es el dueÃ±o de la consulta
    if (consultation.parentId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para ver esta consulta'
      });
    }
    
    // Obtener informaciÃ³n del especialista
    const specialistDoc = await db.collection('professionals').doc(consultation.specialistId).get();
    const specialist = specialistDoc.exists ? specialistDoc.data() : null;
    
    // Obtener detalles de los sÃ­ntomas
    const symptomDetails = [];
    if (consultation.request?.symptoms && consultation.request.symptoms.length > 0) {
      for (const symptomId of consultation.request.symptoms) {
        try {
          const symptomDoc = await db.collection('symptoms').doc(symptomId).get();
          if (symptomDoc.exists) {
            const symptomData = symptomDoc.data();
            symptomDetails.push({
              id: symptomDoc.id,
              name: symptomData.name,
              description: symptomData.description,
              category: symptomData.category,
              severity: symptomData.severity
            });
          }
        } catch (err) {
          console.warn(`âš ï¸ Error obteniendo sÃ­ntoma ${symptomId}:`, err.message);
        }
      }
    }
    
    res.json({
      success: true,
      data: {
        id: consultationDoc.id,
        ...consultation,
        request: {
          ...consultation.request,
          symptomDetails  // Agregar detalles de los sÃ­ntomas
        },
        specialist: specialist ? {
          id: consultation.specialistId,
          displayName: specialist.personalInfo.displayName,
          photoUrl: specialist.personalInfo.photoUrl,
          specialties: specialist.professional.specialties
        } : null,
        createdAt: consultation.createdAt?.toDate?.() || consultation.createdAt,
        updatedAt: consultation.updatedAt?.toDate?.() || consultation.updatedAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [CONSULTATIONS] Error obteniendo consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo consulta',
      error: error.message
    });
  }
});

/**
 * Cancelar consulta (App)
 * DELETE /api/consultations/:consultationId
 */
app.delete('/api/consultations/:consultationId', authenticateToken, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const userId = req.user.uid;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    // Verificar que el usuario es el dueÃ±o
    if (consultation.parentId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para cancelar esta consulta'
      });
    }
    
    // No se puede cancelar si ya estÃ¡ completada
    if (consultation.status === 'completed') {
      return res.status(400).json({
        success: false,
        message: 'No se puede cancelar una consulta completada'
      });
    }
    
    // No se puede cancelar si ya estÃ¡ en progreso
    if (consultation.status === 'in_progress') {
      return res.status(400).json({
        success: false,
        message: 'No se puede cancelar una consulta en progreso'
      });
    }
    
    await db.collection('consultations').doc(consultationId).update({
      status: 'cancelled',
      updatedAt: new Date()
    });
    
    console.log(`âœ… [CONSULTATION] Consulta cancelada: ${consultationId}`);
    
    // TODO: Notificar al especialista
    // TODO: Procesar reembolso si aplica
    
    res.json({
      success: true,
      message: 'Consulta cancelada exitosamente'
    });
    
  } catch (error) {
    console.error('âŒ [CONSULTATIONS] Error cancelando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando consulta',
      error: error.message
    });
  }
});

/**
 * Procesar pago de consulta (App)
 * POST /api/consultations/:consultationId/payment
 */
app.post('/api/consultations/:consultationId/payment', authenticateToken, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const userId = req.user.uid;
    const { paymentMethod, paymentToken } = req.body;
    
    if (!paymentMethod || !paymentToken) {
      return res.status(400).json({
        success: false,
        message: 'MÃ©todo de pago y token son requeridos'
      });
    }
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    if (consultation.parentId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para pagar esta consulta'
      });
    }
    
    if (consultation.payment.status === 'completed') {
      return res.status(400).json({
        success: false,
        message: 'Esta consulta ya ha sido pagada'
      });
    }
    
    // TODO: Integrar con Stripe/PayPhone para procesar el pago
    // Por ahora, simulamos un pago exitoso
    
    const transactionId = `txn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    await db.collection('consultations').doc(consultationId).update({
      'payment.method': paymentMethod,
      'payment.transactionId': transactionId,
      'payment.status': 'completed',
      'payment.paidAt': new Date(),
      status: 'pending',
      updatedAt: new Date()
    });
    
    console.log(`âœ… [PAYMENT] Pago procesado para consulta ${consultationId}: $${consultation.pricing.finalPrice}`);
    
    // TODO: Notificar al especialista sobre la nueva consulta pagada
    
    res.json({
      success: true,
      message: 'Pago procesado exitosamente',
      data: {
        transactionId,
        amount: consultation.pricing.finalPrice,
        currency: 'USD'
      }
    });
    
  } catch (error) {
    console.error('âŒ [PAYMENT] Error procesando pago:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando pago',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - CHAT
// ============================================================================

/**
 * Enviar mensaje en consulta (App)
 * POST /api/consultations/:consultationId/messages
 */
app.post('/api/consultations/:consultationId/messages', authenticateToken, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const userId = req.user.uid;
    const { message, attachments = [] } = req.body;
    
    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje no puede estar vacÃ­o'
      });
    }
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    // Verificar que el usuario es parte de la consulta
    if (consultation.parentId !== userId && consultation.specialistId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para enviar mensajes en esta consulta'
      });
    }
    
    const messageData = {
      senderId: userId,
      senderType: consultation.parentId === userId ? 'parent' : 'specialist',
      message: message.trim(),
      attachments: attachments || [],
      isRead: false,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const messageRef = await db.collection('consultations')
      .doc(consultationId)
      .collection('messages')
      .add(messageData);
    
    // Actualizar contador de mensajes
    await db.collection('consultations').doc(consultationId).update({
      'chat.messageCount': admin.firestore.FieldValue.increment(1),
      updatedAt: new Date()
    });
    
    console.log(`âœ… [CHAT] Mensaje enviado en consulta ${consultationId}`);
    
    // TODO: Notificar a la otra parte
    
    res.json({
      success: true,
      message: 'Mensaje enviado exitosamente',
      data: {
        id: messageRef.id,
        ...messageData
      }
    });
    
  } catch (error) {
    console.error('âŒ [CHAT] Error enviando mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando mensaje',
      error: error.message
    });
  }
});

/**
 * Obtener mensajes de consulta (App)
 * GET /api/consultations/:consultationId/messages
 */
app.get('/api/consultations/:consultationId/messages', authenticateToken, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const userId = req.user.uid;
    const { limit = 50, before } = req.query;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    if (consultation.parentId !== userId && consultation.specialistId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para ver estos mensajes'
      });
    }
    
    let query = db.collection('consultations')
      .doc(consultationId)
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit));
    
    if (before) {
      const beforeDoc = await db.collection('consultations')
        .doc(consultationId)
        .collection('messages')
        .doc(before)
        .get();
      
      if (beforeDoc.exists) {
        query = query.startAfter(beforeDoc);
      }
    }
    
    const snapshot = await query.get();
    
    const messages = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      messages.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
      });
    });
    
    // Ordenar cronolÃ³gicamente (mÃ¡s antiguo primero)
    messages.reverse();
    
    res.json({
      success: true,
      data: messages,
      total: messages.length
    });
    
  } catch (error) {
    console.error('âŒ [CHAT] Error obteniendo mensajes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

/**
 * Marcar mensaje como leÃ­do (App)
 * PATCH /api/consultations/:consultationId/messages/:messageId/read
 */
app.patch('/api/consultations/:consultationId/messages/:messageId/read', authenticateToken, async (req, res) => {
  try {
    const { consultationId, messageId } = req.params;
    const userId = req.user.uid;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    if (consultation.parentId !== userId && consultation.specialistId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }
    
    await db.collection('consultations')
      .doc(consultationId)
      .collection('messages')
      .doc(messageId)
      .update({
        isRead: true,
        updatedAt: new Date()
      });
    
    res.json({
      success: true,
      message: 'Mensaje marcado como leÃ­do'
    });
    
  } catch (error) {
    console.error('âŒ [CHAT] Error marcando mensaje como leÃ­do:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando mensaje como leÃ­do',
      error: error.message
    });
  }
});

// ============================================================================
// SISTEMA DE CONSULTAS MÃ‰DICAS - ADMIN DASHBOARD
// ============================================================================

/**
 * EstadÃ­sticas de consultas (Admin)
 * GET /api/admin/consultations/stats
 * NOTA: Esta ruta debe ir ANTES de /:consultationId para que funcione
 */
app.get('/api/admin/consultations/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { startDate, endDate, specialistId } = req.query;
    
    let query = db.collection('consultations');
    
    if (specialistId) {
      query = query.where('specialistId', '==', specialistId);
    }
    
    const snapshot = await query.get();
    
    const stats = {
      total: 0,
      byStatus: {
        awaiting_payment: 0,
        pending: 0,
        accepted: 0,
        in_progress: 0,
        completed: 0,
        cancelled: 0
      },
      byType: {
        chat: 0,
        video: 0
      },
      byUrgency: {
        low: 0,
        normal: 0,
        high: 0
      },
      revenue: {
        total: 0,
        pending: 0,
        completed: 0,
        free: 0
      },
      averagePrice: 0,
      couponsUsed: 0,
      consultationsWithPhotos: 0,
      averageResponseTime: 0,
      completionRate: 0
    };
    
    const consultations = [];
    let totalResponseTime = 0;
    let consultationsWithResponse = 0;
    
    snapshot.forEach(doc => {
      const data = doc.data();
      const createdAt = data.createdAt?.toDate?.() || new Date(data.createdAt);
      
      // Filtro por fecha
      if (startDate && createdAt < new Date(startDate)) return;
      if (endDate && createdAt > new Date(endDate)) return;
      
      consultations.push(data);
      stats.total++;
      
      // Por estado
      stats.byStatus[data.status] = (stats.byStatus[data.status] || 0) + 1;
      
      // Por tipo
      stats.byType[data.type] = (stats.byType[data.type] || 0) + 1;
      
      // Por urgencia
      stats.byUrgency[data.request.urgency] = (stats.byUrgency[data.request.urgency] || 0) + 1;
      
      // Revenue
      if (data.consultationPricing.isFree) {
        stats.revenue.free += 1;
      } else if (data.payment.status === 'completed') {
        stats.revenue.completed += data.consultationPricing.finalPrice;
      } else {
        stats.revenue.pending += data.consultationPricing.finalPrice;
      }
      stats.revenue.total += data.consultationPricing.finalPrice || 0;
      
      // Cupones
      if (data.consultationPricing.couponCode) {
        stats.couponsUsed++;
      }
      
      // Fotos
      if (data.request.photos && data.request.photos.length > 0) {
        stats.consultationsWithPhotos++;
      }
      
      // Tiempo de respuesta
      if (data.schedule.acceptedAt && data.schedule.requestedAt) {
        const requested = data.schedule.requestedAt.toDate?.() || new Date(data.schedule.requestedAt);
        const accepted = data.schedule.acceptedAt.toDate?.() || new Date(data.schedule.acceptedAt);
        const responseTime = (accepted - requested) / (1000 * 60); // minutos
        totalResponseTime += responseTime;
        consultationsWithResponse++;
      }
    });
    
    // Calcular promedios
    if (stats.total > 0) {
      stats.averagePrice = Math.round((stats.revenue.total / stats.total) * 100) / 100;
      stats.completionRate = Math.round((stats.byStatus.completed / stats.total) * 100);
    }
    
    if (consultationsWithResponse > 0) {
      stats.averageResponseTime = Math.round(totalResponseTime / consultationsWithResponse);
    }
    
    // Top especialistas
    const specialistCounts = {};
    consultations.forEach(c => {
      specialistCounts[c.specialistId] = (specialistCounts[c.specialistId] || 0) + 1;
    });
    
    const topSpecialists = Object.entries(specialistCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([id, count]) => ({ specialistId: id, consultations: count }));
    
    stats.topSpecialists = topSpecialists;
    
    console.log(`âœ… [ADMIN] EstadÃ­sticas calculadas: ${stats.total} consultas`);
    
    res.json({
      success: true,
      data: stats
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo estadÃ­sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estadÃ­sticas',
      error: error.message
    });
  }
});

/**
 * Obtener ingresos por periodo (Admin)
 * GET /api/admin/consultations/revenue
 * NOTA: Esta ruta debe ir ANTES de /:consultationId para que funcione
 */
app.get('/api/admin/consultations/revenue', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { period = 'month', year, month } = req.query;
    
    const snapshot = await db.collection('consultations')
      .where('payment.status', '==', 'completed')
      .get();
    
    const revenueByPeriod = {};
    let totalRevenue = 0;
    let totalConsultations = 0;
    
    snapshot.forEach(doc => {
      const data = doc.data();
      const paidAt = data.payment.paidAt?.toDate?.() || new Date(data.payment.paidAt);
      
      let periodKey;
      if (period === 'day') {
        periodKey = paidAt.toISOString().split('T')[0]; // YYYY-MM-DD
      } else if (period === 'month') {
        periodKey = `${paidAt.getFullYear()}-${String(paidAt.getMonth() + 1).padStart(2, '0')}`; // YYYY-MM
      } else if (period === 'year') {
        periodKey = `${paidAt.getFullYear()}`; // YYYY
      }
      
      if (!revenueByPeriod[periodKey]) {
        revenueByPeriod[periodKey] = {
          revenue: 0,
          consultations: 0,
          byType: { chat: 0, video: 0 }
        };
      }
      
      revenueByPeriod[periodKey].revenue += data.consultationPricing.finalPrice;
      revenueByPeriod[periodKey].consultations += 1;
      revenueByPeriod[periodKey].byType[data.type] += 1;
      
      totalRevenue += data.consultationPricing.finalPrice;
      totalConsultations += 1;
    });
    
    // Convertir a array y ordenar
    const revenueArray = Object.entries(revenueByPeriod)
      .map(([period, data]) => ({
        period,
        ...data,
        revenue: Math.round(data.revenue * 100) / 100
      }))
      .sort((a, b) => a.period.localeCompare(b.period));
    
    console.log(`âœ… [ADMIN] Ingresos calculados: $${totalRevenue} de ${totalConsultations} consultas`);
    
    res.json({
      success: true,
      data: {
        byPeriod: revenueArray,
        totals: {
          revenue: Math.round(totalRevenue * 100) / 100,
          consultations: totalConsultations,
          averageRevenue: totalConsultations > 0 ? Math.round((totalRevenue / totalConsultations) * 100) / 100 : 0
        }
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo ingresos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo ingresos',
      error: error.message
    });
  }
});

/**
 * Listar todas las consultas (Admin)
 * GET /api/admin/consultations
 */
app.get('/api/admin/consultations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status, type, specialistId, parentId, childId, page = 1, limit = 20, search } = req.query;
    
    let query = db.collection('consultations');
    
    // Filtros
    if (status) {
      query = query.where('status', '==', status);
    }
    
    if (type) {
      query = query.where('type', '==', type);
    }
    
    if (specialistId) {
      query = query.where('specialistId', '==', specialistId);
    }
    
    if (parentId) {
      query = query.where('parentId', '==', parentId);
    }
    
    if (childId) {
      query = query.where('childId', '==', childId);
    }
    
    query = query.orderBy('createdAt', 'desc');
    
    const snapshot = await query.get();
    
    let consultations = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      
      // Filtro de bÃºsqueda en memoria
      if (search) {
        const searchLower = search.toLowerCase();
        const matchesDescription = data.request.description.toLowerCase().includes(searchLower);
        const matchesChild = data.childName.toLowerCase().includes(searchLower);
        const matchesSpecialist = data.specialistName.toLowerCase().includes(searchLower);
        
        if (!matchesDescription && !matchesChild && !matchesSpecialist) {
          return;
        }
      }
      
      consultations.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
        'schedule.requestedAt': data.schedule?.requestedAt?.toDate?.() || data.schedule?.requestedAt,
        'schedule.acceptedAt': data.schedule?.acceptedAt?.toDate?.() || data.schedule?.acceptedAt,
        'schedule.completedAt': data.schedule?.completedAt?.toDate?.() || data.schedule?.completedAt
      });
    });
    
    // PaginaciÃ³n
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedConsultations = consultations.slice(startIndex, endIndex);
    
    // Calcular estadÃ­sticas
    const stats = {
      total: consultations.length,
      byStatus: {},
      byType: {},
      totalRevenue: 0
    };
    
    consultations.forEach(c => {
      stats.byStatus[c.status] = (stats.byStatus[c.status] || 0) + 1;
      stats.byType[c.type] = (stats.byType[c.type] || 0) + 1;
      if (c.payment.status === 'completed') {
        stats.totalRevenue += c.pricing.finalPrice || 0;
      }
    });
    
    console.log(`âœ… [ADMIN] Consultas listadas: ${consultations.length} total`);
    
    res.json({
      success: true,
      data: paginatedConsultations,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: consultations.length,
        totalPages: Math.ceil(consultations.length / limitNum)
      },
      stats
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error listando consultas:', error);
    res.status(500).json({
      success: false,
      message: 'Error listando consultas',
      error: error.message
    });
  }
});

/**
 * Obtener detalles de consulta (Admin)
 * GET /api/admin/consultations/:consultationId
 */
app.get('/api/admin/consultations/:consultationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { consultationId } = req.params;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    // Obtener informaciÃ³n del especialista
    const specialistDoc = await db.collection('professionals').doc(consultation.specialistId).get();
    const specialist = specialistDoc.exists ? specialistDoc.data() : null;
    
    // Obtener informaciÃ³n del padre/usuario
    const parentDoc = await db.collection('users').doc(consultation.parentId).get();
    const parent = parentDoc.exists ? parentDoc.data() : null;
    
    // Obtener mensajes del chat
    const messagesSnapshot = await db.collection('consultations')
      .doc(consultationId)
      .collection('messages')
      .orderBy('createdAt', 'asc')
      .limit(50)
      .get();
    
    const messages = [];
    messagesSnapshot.forEach(doc => {
      const data = doc.data();
      messages.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || data.createdAt
      });
    });
    
    res.json({
      success: true,
      data: {
        id: consultationDoc.id,
        ...consultation,
        specialist: specialist ? {
          id: consultation.specialistId,
          displayName: specialist.personalInfo.displayName,
          email: specialist.personalInfo.email,
          photoUrl: specialist.personalInfo.photoUrl,
          specialties: specialist.professional.specialties,
          phone: specialist.personalInfo.phone
        } : null,
        parent: parent ? {
          id: consultation.parentId,
          displayName: parent.displayName || parent.name,
          email: parent.email,
          photoURL: parent.photoURL
        } : null,
        messages,
        createdAt: consultation.createdAt?.toDate?.() || consultation.createdAt,
        updatedAt: consultation.updatedAt?.toDate?.() || consultation.updatedAt
      }
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error obteniendo consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo consulta',
      error: error.message
    });
  }
});

/**
 * Actualizar estado de consulta (Admin)
 * PATCH /api/admin/consultations/:consultationId
 */
app.patch('/api/admin/consultations/:consultationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const { status, notes } = req.body;
    
    if (!status) {
      return res.status(400).json({
        success: false,
        message: 'Estado es requerido'
      });
    }
    
    const validStatuses = ['awaiting_payment', 'pending', 'accepted', 'in_progress', 'completed', 'cancelled'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Estado invÃ¡lido',
        validStatuses
      });
    }
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const updateData = {
      status,
      updatedAt: new Date()
    };
    
    if (notes) {
      updateData['outcome.notes'] = notes;
    }
    
    await db.collection('consultations').doc(consultationId).update(updateData);
    
    console.log(`âœ… [ADMIN] Consulta actualizada: ${consultationId} â†’ ${status}`);
    
    res.json({
      success: true,
      message: 'Consulta actualizada exitosamente'
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error actualizando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando consulta',
      error: error.message
    });
  }
});

/**
 * Cancelar consulta (Admin)
 * DELETE /api/admin/consultations/:consultationId
 */
app.delete('/api/admin/consultations/:consultationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { consultationId } = req.params;
    const { reason } = req.body;
    
    const consultationDoc = await db.collection('consultations').doc(consultationId).get();
    
    if (!consultationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Consulta no encontrada'
      });
    }
    
    const consultation = consultationDoc.data();
    
    await db.collection('consultations').doc(consultationId).update({
      status: 'cancelled',
      'outcome.notes': reason || 'Cancelada por administrador',
      updatedAt: new Date()
    });
    
    console.log(`âœ… [ADMIN] Consulta cancelada: ${consultationId}`);
    
    // TODO: Notificar al usuario y especialista
    // TODO: Procesar reembolso si aplica
    
    res.json({
      success: true,
      message: 'Consulta cancelada exitosamente'
    });
    
  } catch (error) {
    console.error('âŒ [ADMIN] Error cancelando consulta:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando consulta',
      error: error.message
    });
  }
});

// ============================================================================
// âš ï¸ MIDDLEWARE CATCH-ALL - DEBE ESTAR AL FINAL
// ============================================================================

// Middleware para rutas no encontradas (DEBE estar despuÃ©s de todas las rutas)
app.use('*', (req, res) => {
  console.log('âš ï¸ [404] Ruta no encontrada:', req.method, req.originalUrl);
  res.status(404).json({
    success: false,
    message: 'Ruta no encontrada',
    path: req.originalUrl,
    method: req.method
  });
});

