// Cargar variables de entorno desde archivo .env
require('dotenv').config();

// Funci√≥n para validar URL
const isValidUrl = (string) => {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
};

// Cache simple en memoria para respuestas pesadas (24h)
const RESPONSE_CACHE = new Map();
const CACHE_TTL_MS_24H = 24 * 60 * 60 * 1000;

const buildCacheKey = (req) => {
  const keys = Object.keys(req.query || {}).sort();
  const queryString = keys.map(key => `${key}=${String(req.query[key])}`).join('&');
  return `${req.path}?${queryString}`;
};

const getCachedResponse = (key) => {
  const entry = RESPONSE_CACHE.get(key);
  if (!entry) return null;
  const ttlMs = entry.ttlMs || CACHE_TTL_MS_24H;
  if (Date.now() - entry.timestamp > ttlMs) {
    RESPONSE_CACHE.delete(key);
    return null;
  }
  return entry.payload;
};

const setCachedResponse = (key, payload, ttlMs = null) => {
  RESPONSE_CACHE.set(key, { timestamp: Date.now(), payload, ttlMs });
};

const parseDateSafe = (value) => {
  if (!value) return null;
  if (value instanceof Date) return value;
  if (typeof value === 'object') {
    if (typeof value.toDate === 'function') {
      const converted = value.toDate();
      return isNaN(converted.getTime()) ? null : converted;
    }
    if (typeof value._seconds === 'number') {
      const converted = new Date(value._seconds * 1000);
      return isNaN(converted.getTime()) ? null : converted;
    }
    if (typeof value.seconds === 'number') {
      const converted = new Date(value.seconds * 1000);
      return isNaN(converted.getTime()) ? null : converted;
    }
  }
  const date = new Date(value);
  return isNaN(date.getTime()) ? null : date;
};

const calculateWeeksFromBirthDate = (birthDate) => {
  const start = parseDateSafe(birthDate);
  if (!start) return null;
  const now = new Date();
  const diffMs = now.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  const weeks = Math.floor(diffDays / 7) + 1;
  return Math.max(1, weeks);
};

const calculateMonthsFromBirthDate = (birthDate) => {
  const start = parseDateSafe(birthDate);
  if (!start) return null;
  const now = new Date();
  const diffMs = now.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  const months = Math.floor(diffDays / 30.44);
  return Math.max(0, months);
};

const calculateAgeInMonthsAtDate = (birthDate, targetDate) => {
  const birth = parseDateSafe(birthDate);
  const target = parseDateSafe(targetDate);
  if (!birth || !target) return null;
  let years = target.getFullYear() - birth.getFullYear();
  let months = target.getMonth() - birth.getMonth();
  if (target.getDate() < birth.getDate()) {
    months--;
  }
  if (months < 0) {
    years--;
    months += 12;
  }
  return Math.max(0, years * 12 + months);
};

const addMonthsToDate = (date, months) => {
  const base = parseDateSafe(date);
  if (!base || !Number.isFinite(months)) return null;
  const result = new Date(base.getTime());
  const targetMonth = result.getMonth() + months;
  result.setMonth(targetMonth);
  return result;
};

const addWeeksToDate = (date, weeks) => {
  const base = parseDateSafe(date);
  if (!base || !Number.isFinite(weeks)) return null;
  return new Date(base.getTime() + weeks * 7 * 24 * 60 * 60 * 1000);
};

const getTodayDateKey = () => new Date().toISOString().slice(0, 10);

const stripUndefined = (payload) => {
  if (!payload || typeof payload !== 'object') return payload;
  return Object.fromEntries(Object.entries(payload).filter(([, value]) => value !== undefined));
};

const TEETH_DEFINITIONS = [
  { id: 'upper-central-incisor-left', name: 'Central incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [8, 12], shedRangeYears: [6, 7] },
  { id: 'upper-central-incisor-right', name: 'Central incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [8, 12], shedRangeYears: [6, 7] },
  { id: 'upper-lateral-incisor-left', name: 'Lateral incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [9, 13], shedRangeYears: [7, 8] },
  { id: 'upper-lateral-incisor-right', name: 'Lateral incisor', arch: 'upper', type: 'incisor', eruptRangeMonths: [9, 13], shedRangeYears: [7, 8] },
  { id: 'upper-canine-left', name: 'Canine (cuspid)', arch: 'upper', type: 'canine', eruptRangeMonths: [16, 22], shedRangeYears: [10, 12] },
  { id: 'upper-canine-right', name: 'Canine (cuspid)', arch: 'upper', type: 'canine', eruptRangeMonths: [16, 22], shedRangeYears: [10, 12] },
  { id: 'upper-first-molar-left', name: 'First molar', arch: 'upper', type: 'molar', eruptRangeMonths: [13, 19], shedRangeYears: [9, 11] },
  { id: 'upper-first-molar-right', name: 'First molar', arch: 'upper', type: 'molar', eruptRangeMonths: [13, 19], shedRangeYears: [9, 11] },
  { id: 'upper-second-molar-left', name: 'Second molar', arch: 'upper', type: 'molar', eruptRangeMonths: [25, 33], shedRangeYears: [10, 12] },
  { id: 'upper-second-molar-right', name: 'Second molar', arch: 'upper', type: 'molar', eruptRangeMonths: [25, 33], shedRangeYears: [10, 12] },
  { id: 'lower-central-incisor-left', name: 'Central incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [6, 10], shedRangeYears: [6, 7] },
  { id: 'lower-central-incisor-right', name: 'Central incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [6, 10], shedRangeYears: [6, 7] },
  { id: 'lower-lateral-incisor-left', name: 'Lateral incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [10, 16], shedRangeYears: [7, 8] },
  { id: 'lower-lateral-incisor-right', name: 'Lateral incisor', arch: 'lower', type: 'incisor', eruptRangeMonths: [10, 16], shedRangeYears: [7, 8] },
  { id: 'lower-canine-left', name: 'Canine (cuspid)', arch: 'lower', type: 'canine', eruptRangeMonths: [17, 23], shedRangeYears: [9, 12] },
  { id: 'lower-canine-right', name: 'Canine (cuspid)', arch: 'lower', type: 'canine', eruptRangeMonths: [17, 23], shedRangeYears: [9, 12] },
  { id: 'lower-first-molar-left', name: 'First molar', arch: 'lower', type: 'molar', eruptRangeMonths: [14, 18], shedRangeYears: [9, 11] },
  { id: 'lower-first-molar-right', name: 'First molar', arch: 'lower', type: 'molar', eruptRangeMonths: [14, 18], shedRangeYears: [9, 11] },
  { id: 'lower-second-molar-left', name: 'Second molar', arch: 'lower', type: 'molar', eruptRangeMonths: [23, 31], shedRangeYears: [10, 12] },
  { id: 'lower-second-molar-right', name: 'Second molar', arch: 'lower', type: 'molar', eruptRangeMonths: [23, 31], shedRangeYears: [10, 12] }
];

const TEETH_ALIASES = {
  'upper-incisor1-left': 'upper-central-incisor-left',
  'upper-incisor1-right': 'upper-central-incisor-right',
  'upper-incisor2-left': 'upper-lateral-incisor-left',
  'upper-incisor2-right': 'upper-lateral-incisor-right',
  'lower-incisor1-left': 'lower-central-incisor-left',
  'lower-incisor1-right': 'lower-central-incisor-right',
  'lower-incisor2-left': 'lower-lateral-incisor-left',
  'lower-incisor2-right': 'lower-lateral-incisor-right',
  'upper-molar1-left': 'upper-first-molar-left',
  'upper-molar1-right': 'upper-first-molar-right',
  'upper-molar2-left': 'upper-second-molar-left',
  'upper-molar2-right': 'upper-second-molar-right',
  'lower-molar1-left': 'lower-first-molar-left',
  'lower-molar1-right': 'lower-first-molar-right',
  'lower-molar2-left': 'lower-second-molar-left',
  'lower-molar2-right': 'lower-second-molar-right'
};

const getToothDefinition = (toothId) => {
  const resolvedId = TEETH_ALIASES[toothId] || toothId;
  return TEETH_DEFINITIONS.find((t) => t.id === resolvedId) || null;
};

const normalizeTeethingType = (rawType) => {
  if (!rawType) return null;
  const value = String(rawType).toLowerCase().trim();
  if (['erupt', 'eruption', 'erupted', 'erupcion', 'erupci√≥n', 'salio', 'sali√≥'].includes(value)) {
    return 'erupt';
  }
  if (['shed', 'fall', 'lost', 'caida', 'ca√≠da', 'cayo', 'cay√≥'].includes(value)) {
    return 'shed';
  }
  return ['erupt', 'shed'].includes(value) ? value : null;
};

const shouldSendDoulaGreeting = async (uid) => {
  if (!db) return true;
  const ref = db.collection('doula_daily_greetings').doc(uid);
  const doc = await ref.get();
  const todayKey = getTodayDateKey();
  if (doc.exists && doc.data()?.lastGreetedDate === todayKey) {
    return false;
  }
  await ref.set({ lastGreetedDate: todayKey, updatedAt: new Date() }, { merge: true });
  return true;
};

const normalizeDoulaGreeting = (text, userName, shouldGreet) => {
  if (!text) return text;
  const safeName = userName || 'Mam√°';
  const response = String(text).trim();
  if (!response) return response;
  const lines = response.split('\n');
  const firstLine = (lines[0] || '').trim();
  const hasGreeting = /^¬°?hola\b/i.test(firstLine);
  if (shouldGreet) {
    if (hasGreeting) return response;
    return `¬°Hola ${safeName}!\n\n${response}`;
  }
  if (hasGreeting) {
    lines.shift();
    while (lines.length && lines[0].trim() === '') lines.shift();
    return lines.join('\n');
  }
  return response;
};

const getWeeksFromChildData = (child) => {
  if (!child) return null;
  if (child.isUnborn) {
    const info = getChildCurrentInfo(child);
    return info.currentGestationWeeks || null;
  }
  if (child.birthDate) {
    const birthDate = child.birthDate.toDate ? child.birthDate.toDate() : child.birthDate;
    return calculateWeeksFromBirthDate(birthDate);
  }
  if (typeof child.ageInMonths === 'number') {
    return Math.max(1, Math.round(child.ageInMonths * 4.3));
  }
  const info = getChildCurrentInfo(child);
  if (info.currentAgeInMonths !== null && info.currentAgeInMonths !== undefined) {
    return Math.max(1, Math.round(info.currentAgeInMonths * 4.3));
  }
  return null;
};

const getMonthsFromChildData = (child) => {
  if (!child) return null;
  if (child.isUnborn) return null;
  if (child.birthDate) {
    const birthDate = child.birthDate.toDate ? child.birthDate.toDate() : child.birthDate;
    return calculateMonthsFromBirthDate(birthDate);
  }
  if (typeof child.ageInMonths === 'number') {
    return Math.max(0, Math.floor(child.ageInMonths));
  }
  const info = getChildCurrentInfo(child);
  if (info.currentAgeInMonths !== null && info.currentAgeInMonths !== undefined) {
    return Math.max(0, Math.floor(info.currentAgeInMonths));
  }
  return null;
};

const express = require('express');
const cors = require('cors');
const compression = require('compression');
const multer = require('multer');
const path = require('path');
const jwt = require('jsonwebtoken');
const OpenAI = require('openai');
const { format } = require('date-fns');

const app = express();
const PORT = process.env.PORT || 3000;

// JWT Secret para tokens de admin
const JWT_SECRET = process.env.JWT_SECRET || 'munpa-secret-key-2025-change-in-production';

// Configuraci√≥n de CORS mejorada
const allowedOrigins = [
  // Producci√≥n
  'https://munpa.online', 
  'https://www.munpa.online',
  'https://munpa.app',
  'https://www.munpa.app',
  'https://dash.munpa.online',
  'https://dashboardmunpa-ey7a5gscn-mishu-lojans-projects.vercel.app',
  // Desarrollo
  'http://localhost:3000', 
  'http://localhost:3001', 
  'http://localhost:4200', 
  'http://localhost:5173', 
  'http://localhost:8081', 
  'http://localhost:19006'
];

app.use(cors({
  origin: (origin, callback) => {
    // Permitir requests sin origin (como mobile apps o curl)
    if (!origin) return callback(null, true);
    
    // Verificar si el origin est√° en la lista permitida
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    // Verificar si coincide con el patr√≥n de Vercel preview
    if (/^https:\/\/dashboardmunpa-[a-z0-9]+-mishu-lojans-projects\.vercel\.app$/.test(origin)) {
      return callback(null, true);
    }
    
    // Rechazar otros origins
    callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept', 'X-Requested-With'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  preflightContinue: false,
  optionsSuccessStatus: 204
}));

// Compresi√≥n para respuestas m√°s r√°pidas
app.use(compression());

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Configuraci√≥n de multer para subida de archivos en memoria (compatible con Vercel)
const upload = multer({ 
  storage: multer.memoryStorage(), // Usar memoria en lugar de disco
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB m√°ximo
  },
  fileFilter: function (req, file, cb) {
    // Solo permitir im√°genes
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen'), false);
    }
  }
});

// Middleware para manejar peticiones OPTIONS (preflight)
app.options('*', cors());

// Middleware de logging (ligero por defecto)
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  if (process.env.LOG_HEADERS === 'true') {
    console.log('üìã Headers recibidos:', req.headers);
  }
  res.on('finish', () => {
    const ms = Date.now() - start;
    if (ms >= 1000) {
      console.log(`‚è±Ô∏è [SLOW] ${req.method} ${req.path} - ${ms}ms`);
    }
  });
  next();
});

// Configurar Firebase usando el archivo JSON
let auth = null;
let db = null;
let admin = null;
let FieldValue = null;
let firebaseStatus = 'No inicializado';

// Configurar OpenAI
let openai = null;
let openaiStatus = 'No inicializado';

// Middleware de autenticaci√≥n (declarado antes de su uso)
const authenticateToken = async (req, res, next) => {
  try {
    console.log('üîç [AUTH] Iniciando verificaci√≥n de token para:', req.path);
    
    if (!auth) {
      console.log('‚ùå [AUTH] Firebase no est√° configurado');
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado'
      });
    }
    
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      console.log('‚ùå [AUTH] No se encontr√≥ token en headers');
      return res.status(401).json({
        success: false,
        message: 'Token de acceso requerido'
      });
    }

    console.log('üîë [AUTH] Token encontrado, longitud:', token.length);

    try {
      // PRIMERO intentar verificar como JWT del admin dashboard
      console.log('üîÑ [AUTH] Intentando verificar como JWT admin...');
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        console.log('‚úÖ [AUTH] JWT admin verificado exitosamente:', decoded);
        
        req.user = { 
          uid: decoded.uid,
          email: decoded.email,
          role: decoded.role
        };
        console.log('‚úÖ [AUTH] req.user configurado desde JWT:', req.user);
        next();
        return;
      } catch (jwtError) {
        console.log('‚ùå [AUTH] No es un JWT v√°lido:', jwtError.message);
      }

      // SEGUNDO intentar extraer uid del customToken JWT
      console.log('üîÑ [AUTH] Intentando extraer UID del customToken...');
      const tokenParts = token.split('.');
      
      if (tokenParts.length === 3) {
        try {
          const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());
          console.log('üîç [AUTH] Payload del token:', payload);
          
          if (payload.uid) {
            console.log('‚úÖ [AUTH] UID extra√≠do del customToken:', payload.uid);
            
            req.user = { uid: payload.uid };
            console.log('‚úÖ [AUTH] req.user configurado:', req.user);
            next();
            return;
          }
        } catch (decodeError) {
          console.log('‚ùå [AUTH] Error decodificando customToken:', decodeError.message);
        }
      }
      
      // TERCERO intentar como idToken
      console.log('üîÑ [AUTH] Intentando verificar como idToken...');
      const decodedIdToken = await auth.verifyIdToken(token);
      console.log('‚úÖ [AUTH] IdToken verificado exitosamente');
      
      req.user = decodedIdToken;
      console.log('‚úÖ [AUTH] req.user configurado:', req.user);
      next();
      
    } catch (idTokenError) {
      console.log('‚ùå [AUTH] Error verificando idToken:', idTokenError.message);
      return res.status(403).json({
        success: false,
        message: 'Token inv√°lido o expirado'
      });
    }
  } catch (error) {
    console.error('‚ùå [AUTH] Error general en autenticaci√≥n:', error);
    return res.status(403).json({
      success: false,
      message: 'Token inv√°lido o expirado'
    });
  }
};

const setupFirebase = () => {
  try {
    console.log('üî• Configurando Firebase con variables de entorno...');
    
    admin = require('firebase-admin');
    
    // Verificar que las variables de entorno est√©n disponibles
    const requiredEnvVars = [
      'FIREBASE_TYPE',
      'FIREBASE_PROJECT_ID',
      'FIREBASE_PRIVATE_KEY_ID',
      'FIREBASE_PRIVATE_KEY',
      'FIREBASE_CLIENT_EMAIL',
      'FIREBASE_CLIENT_ID',
      'FIREBASE_AUTH_URI',
      'FIREBASE_TOKEN_URI',
      'FIREBASE_AUTH_PROVIDER_X509_CERT_URL',
      'FIREBASE_CLIENT_X509_CERT_URL'
    ];

    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
    
    if (missingVars.length > 0) {
      throw new Error(`Variables de entorno faltantes: ${missingVars.join(', ')}`);
    }

    // Crear objeto de configuraci√≥n desde variables de entorno
    const serviceAccount = {
      type: process.env.FIREBASE_TYPE,
      project_id: process.env.FIREBASE_PROJECT_ID,
      private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
      private_key: process.env.FIREBASE_PRIVATE_KEY
        .replace(/\\n/g, '\n')
        .replace(/"/g, '')
        .trim(),
      client_email: process.env.FIREBASE_CLIENT_EMAIL,
      client_id: process.env.FIREBASE_CLIENT_ID,
      auth_uri: process.env.FIREBASE_AUTH_URI,
      token_uri: process.env.FIREBASE_TOKEN_URI,
      auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL,
      client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL
    };
    
    console.log('‚úÖ Variables de entorno cargadas correctamente');

    // Inicializar Firebase
    if (!admin.apps.length) {
      admin.initializeApp({
        credential: admin.credential.cert(serviceAccount),
        storageBucket: 'mumpabackend.firebasestorage.app'
      });
      console.log('‚úÖ Firebase Admin inicializado con Storage Bucket: mumpabackend.firebasestorage.app');
    } else {
      console.log('‚úÖ Firebase Admin ya estaba inicializado');
    }
    
    auth = admin.auth();
    db = admin.firestore();
    FieldValue = admin.firestore.FieldValue;
    
    console.log('‚úÖ Firebase Auth y Firestore configurados');
    firebaseStatus = 'Configurado correctamente';
    return true;
  } catch (error) {
    console.error('‚ùå Error configurando Firebase:', error.message);
    firebaseStatus = `Error: ${error.message}`;
    return false;
  }
};

// Funci√≥n para validar si un mensaje es relevante al tema de doula
const isRelevantToDoulaScope = (message) => {
  const lowerMessage = message.toLowerCase();
  
  // Palabras clave relacionadas con el √°mbito de doula (embarazo, parto, crianza)
  const onTopicKeywords = [
    'embarazo', 'embarazada', 'gestaci√≥n', 'beb√©', 'bebe', 'hijo', 'hija', 'ni√±o', 'ni√±a',
    'parto', 'dar a luz', 'contracciones', 'posparto', 'postparto', 'recuperaci√≥n',
    'lactancia', 'amamantar', 'leche materna', 'pecho', 'teta',
    'reci√©n nacido', 'recien nacido', 'neonato', 'cuidados',
    'trimestre', 'semana', 'mes', 'desarrollo', 'crecimiento',
    'pa√±al', 'panal', 'ba√±o', 'sue√±o', 'dormir', 'alimentaci√≥n', 'alimentacion',
    'maternidad', 'paternidad', 'crianza', 'familia',
    's√≠ntoma', 'sintoma', 'dolor', 'malestar', 'n√°usea', 'nausea', 'v√≥mito', 'vomito',
    'vitamina', '√°cido f√≥lico', 'acido folico', 'hierro', 'calcio',
    'ecograf√≠a', 'ecografia', 'ultrasonido', 'ginec√≥logo', 'ginecologo', 'obstetra', 'matrona',
    'ces√°rea', 'cesarea', 'parto natural', 'epidural',
    'depresi√≥n posparto', 'depresion posparto', 'ansiedad', 'estr√©s', 'estres',
    'cord√≥n umbilical', 'cordon umbilical', 'placenta', '√∫tero', 'utero',
    'movimientos fetales', 'patadas', 'feto', 'embri√≥n', 'embrion'
  ];
  
  // Palabras clave ALTAMENTE prohibidas (siempre rechazar, incluso si menciona embarazo)
  const strictlyOffTopicKeywords = [
    'taco', 'tacos', 'pizza', 'hamburguesa', 'burrito', 'enchilada', 'quesadilla',
    'programaci√≥n', 'programacion', 'c√≥digo', 'codigo', 'javascript', 'python', 'html', 'css', 'desarrollo web', 'software',
    'f√∫tbol', 'futbol', 'basketball', 'basquetbol', 'partido de', 'equipo deportivo',
    'pel√≠cula', 'pelicula', 'serie', 'netflix', 'cine', 'actor', 'actriz',
    'videojuegos', 'gaming', 'consola', 'playstation', 'xbox', 'nintendo',
    'autom√≥vil', 'automovil', 'carro', 'coche', 'auto mec√°nica', 'mec√°nico automotriz', 'arreglo carro'
  ];
  
  // Palabras clave fuera del √°mbito (rechazar solo si NO hay palabras de embarazo)
  const generalOffTopicKeywords = [
    'finanzas', 'dinero', 'inversi√≥n', 'inversion', 'banco', 'cr√©dito', 'credito', 'pr√©stamo', 'prestamo', 'econom√≠a', 'economia',
    'derecho', 'ley', 'legal', 'abogado', 'contrato', 'tr√°mite', 'tramite', 'notario',
    'tecnolog√≠a', 'tecnologia', 'computadora', 'smartphone', 'internet', 'redes sociales', 'facebook', 'instagram',
    'cocina general', 'cocinar', 'chef', 'restaurante', 'men√∫ restaurante', 'menu restaurante',
    'gimnasio', 'musculaci√≥n', 'musculacion', 'pesas', 'entrenamiento deportivo',
    'pol√≠tica', 'politica', 'elecciones', 'gobierno', 'presidente', 'partido pol√≠tico', 'partido politico',
    'viajes', 'turismo', 'hotel', 'avi√≥n', 'avion', 'crucero',
    'm√∫sica concierto', 'musica concierto', 'festival musical'
  ];
  
  // Patrones de preguntas claramente sobre comida no relacionada con embarazo
  const foodPatterns = [
    /receta de (taco|pizza|hamburguesa|pasta|postre|pastel|torta)/i,
    /c√≥mo (hacer|preparar|cocinar) (taco|pizza|hamburguesa|pasta)/i,
    /como (hacer|preparar|cocinar) (taco|pizza|hamburguesa|pasta)/i,
    /ingredientes (para|de) (taco|pizza|hamburguesa|pasta)/i,
    /(d√≥nde|donde) (comprar|comer|encontrar) (taco|pizza|hamburguesa)/i
  ];
  
  // Verificar patrones de comida prohibidos
  const matchesFoodPattern = foodPatterns.some(pattern => pattern.test(message));
  
  // Verificar palabras estrictamente prohibidas
  const hasStrictlyOffTopicKeyword = strictlyOffTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // Verificar palabras generalmente fuera de tema
  const hasGeneralOffTopicKeyword = generalOffTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // Verificar si contiene palabras relacionadas con el tema
  const hasOnTopicKeyword = onTopicKeywords.some(keyword => lowerMessage.includes(keyword));
  
  // L√≥gica de validaci√≥n:
  // 1. Si coincide con patrones de comida prohibidos -> RECHAZAR
  // 2. Si tiene palabras estrictamente prohibidas -> RECHAZAR siempre
  // 3. Si tiene palabras generalmente fuera de tema Y NO tiene palabras de embarazo -> RECHAZAR
  // 4. De lo contrario -> PERMITIR
  
  if (matchesFoodPattern) {
    return false; // Rechazar recetas de comida
  }
  
  if (hasStrictlyOffTopicKeyword) {
    return false; // Rechazar temas estrictamente prohibidos
  }
  
  if (hasGeneralOffTopicKeyword && !hasOnTopicKeyword) {
    return false; // Rechazar temas generales fuera del √°mbito si no menciona embarazo
  }
  
  return true; // Permitir el resto
};

// Funci√≥n para generar respuestas de doula predefinidas
const generateDoulaResponse = (message, userContext, childrenInfo, userName = 'Mam√°') => {
  const lowerMessage = message.toLowerCase();
  
  // Verificar si el tema es relevante
  const isOffTopic = !isRelevantToDoulaScope(message);
  
  if (isOffTopic) {
    return `Soy Douli, tu asistente de Munpa especializada en acompa√±amiento durante el embarazo, parto y crianza temprana.

ü§± **Mi especialidad es:**
‚Ä¢ Embarazo y preparaci√≥n al parto
‚Ä¢ Lactancia y cuidados del beb√©
‚Ä¢ Apoyo emocional para familias
‚Ä¢ Se√±ales de alarma y cu√°ndo consultar

üìû **Para tu consulta sobre ${message}, te recomiendo:**
‚Ä¢ Consultar con un profesional especializado
‚Ä¢ Buscar informaci√≥n en fuentes oficiales
‚Ä¢ Contactar servicios espec√≠ficos para ese tema

¬øHay algo relacionado con tu embarazo, parto o crianza en lo que pueda ayudarte? üíù`;
  }
  
  // Extraer informaci√≥n de los hijos del contexto
  let childrenContext = '';
  let hasUnbornChildren = false;
  let hasYoungChildren = false;
  let hasMultipleChildren = false;
  let childrenNames = [];
  let unbornChildrenNames = [];
  let youngChildrenNames = [];
  
  if (childrenInfo) {
    const childrenMatch = childrenInfo.match(/Hijos nacidos: (\d+)/);
    const unbornMatch = childrenInfo.match(/Hijos por nacer: (\d+)/);
    
    if (childrenMatch && unbornMatch) {
      const bornCount = parseInt(childrenMatch[1]);
      const unbornCount = parseInt(unbornMatch[1]);
      
      hasUnbornChildren = unbornCount > 0;
      hasMultipleChildren = (bornCount + unbornCount) > 1;
      
      // Extraer nombres de los hijos
      const nameMatches = childrenInfo.matchAll(/- ([^:]+):/g);
      for (const match of nameMatches) {
        const name = match[1].trim();
        childrenNames.push(name);
        
        // Determinar si es hijo por nacer o nacido
        const lineAfterName = childrenInfo.substring(match.index).split('\n')[0];
        if (lineAfterName.includes('Por nacer')) {
          unbornChildrenNames.push(name);
        } else if (lineAfterName.includes('mes') || lineAfterName.includes('a√±o')) {
          youngChildrenNames.push(name);
        }
      }
      
      // Determinar si tiene hijos peque√±os (menos de 3 a√±os)
      if (childrenInfo.includes('mes') || childrenInfo.includes('a√±o')) {
        hasYoungChildren = true;
      }
    }
  }
  
  // Respuestas para s√≠ntomas del primer trimestre
  if (lowerMessage.includes('s√≠ntoma') || lowerMessage.includes('primer trimestre') || lowerMessage.includes('n√°usea')) {
    let personalizedIntro = `Soy Douli, tu asistente de Munpa. Te puedo ayudar con los s√≠ntomas del primer trimestre.`;
    
    if (hasUnbornChildren) {
      const unbornNames = unbornChildrenNames.join(' y ');
      personalizedIntro += ` Veo que tienes a ${unbornNames} en camino, ¬°qu√© emoci√≥n!`;
    } else if (hasYoungChildren) {
      const youngNames = youngChildrenNames.join(' y ');
      personalizedIntro += ` Como ya has pasado por esto antes con ${youngNames}, sabes que cada embarazo es diferente.`;
    } else if (hasMultipleChildren) {
      const allNames = childrenNames.join(' y ');
      personalizedIntro += ` Con tu experiencia como madre de ${allNames}, sabes que cada embarazo tiene sus particularidades.`;
    }
    
    return `${personalizedIntro}

ü§∞ **S√≠ntomas normales:**
‚Ä¢ N√°useas matutinas
‚Ä¢ Fatiga
‚Ä¢ Sensibilidad en senos
‚Ä¢ Cambios de humor

üí° **Para las n√°useas:**
‚Ä¢ Come poco y frecuente
‚Ä¢ Galletas saladas en la cama
‚Ä¢ Bebe mucha agua
‚Ä¢ Evita comidas grasosas

‚ö†Ô∏è **Consulta al m√©dico si:**
‚Ä¢ N√°useas muy intensas
‚Ä¢ Fiebre alta
‚Ä¢ Sangrado

¬øQu√© s√≠ntoma te preocupa m√°s?`;
  }
  
  // Respuestas para ejercicios durante el embarazo
  if (lowerMessage.includes('ejercicio') || lowerMessage.includes('actividad f√≠sica') || lowerMessage.includes('deporte')) {
    return `¬°Excelente pregunta! Soy Douli, tu asistente de Munpa. Te recomiendo mantenerte activa durante el embarazo, pero con precauci√≥n:

üèÉ‚Äç‚ôÄÔ∏è **Ejercicios seguros durante el embarazo:**
‚Ä¢ Caminar (30 minutos diarios)
‚Ä¢ Yoga prenatal
‚Ä¢ Nataci√≥n
‚Ä¢ Pilates adaptado
‚Ä¢ Ejercicios de Kegel
‚Ä¢ Estiramientos suaves

‚ö†Ô∏è **Ejercicios a evitar:**
‚Ä¢ Deportes de contacto
‚Ä¢ Ejercicios que requieran acostarse boca arriba despu√©s del primer trimestre
‚Ä¢ Actividades con riesgo de ca√≠da
‚Ä¢ Levantar pesos pesados

üí° **Consejos importantes:**
‚Ä¢ Escucha a tu cuerpo
‚Ä¢ Mant√©n una respiraci√≥n constante
‚Ä¢ Bebe mucha agua
‚Ä¢ Detente si sientes dolor o mareos
‚Ä¢ Consulta con tu m√©dico antes de comenzar

¬øQu√© tipo de actividad f√≠sica te gustar√≠a practicar?`;
  }
  
  // Respuestas para preparaci√≥n al parto
  if (lowerMessage.includes('parto') || lowerMessage.includes('dar a luz') || lowerMessage.includes('preparar')) {
    return `¬°Qu√© emoci√≥n! Soy Douli, tu asistente de Munpa.

ü§± **Preparaci√≥n f√≠sica:**
‚Ä¢ Ejercicios de respiraci√≥n
‚Ä¢ T√©cnicas de relajaci√≥n
‚Ä¢ Fortalece suelo p√©lvico
‚Ä¢ Buena postura

üßò‚Äç‚ôÄÔ∏è **Preparaci√≥n mental:**
‚Ä¢ Lee sobre el parto
‚Ä¢ Visualiza tu parto ideal
‚Ä¢ Practica meditaci√≥n
‚Ä¢ Conf√≠a en tu cuerpo

üìã **Preparaci√≥n pr√°ctica:**
‚Ä¢ Maleta para hospital
‚Ä¢ Plan de parto
‚Ä¢ Apoyo postparto
‚Ä¢ Todo listo en casa

¬øEn qu√© aspecto necesitas ayuda?`;
  }
  
  // Respuestas para lactancia
  if (lowerMessage.includes('lactancia') || lowerMessage.includes('amamantar') || lowerMessage.includes('leche materna')) {
    return `¬°La lactancia es maravillosa! Soy Douli, tu asistente de Munpa.

ü§± **Beneficios:**
‚Ä¢ Nutrici√≥n perfecta
‚Ä¢ Fortalece sistema inmune
‚Ä¢ Crea v√≠nculo especial
‚Ä¢ Ayuda recuperaci√≥n

üí° **Consejos:**
‚Ä¢ Contacto piel con piel
‚Ä¢ Amamanta a demanda
‚Ä¢ Buen agarre
‚Ä¢ Posici√≥n c√≥moda

‚ö†Ô∏è **Alerta si:**
‚Ä¢ Dolor intenso
‚Ä¢ Grietas en pezones
‚Ä¢ Fiebre
‚Ä¢ Beb√© no gana peso

¬øQu√© te preocupa espec√≠ficamente?`;
  }
  
  // Respuestas para alimentaci√≥n durante el embarazo
  if (lowerMessage.includes('comida') || lowerMessage.includes('alimentaci√≥n') || lowerMessage.includes('dieta') || lowerMessage.includes('nutrici√≥n')) {
    return `¬°La nutrici√≥n es fundamental! Soy Douli, tu asistente de Munpa.

ü•ó **Come:**
‚Ä¢ Frutas y verduras
‚Ä¢ Prote√≠nas magras
‚Ä¢ Granos enteros
‚Ä¢ L√°cteos bajos en grasa

‚ö†Ô∏è **Evita:**
‚Ä¢ Pescado alto en mercurio
‚Ä¢ Carne cruda
‚Ä¢ Quesos sin pasteurizar
‚Ä¢ Alcohol y cafe√≠na

üí° **Consejos:**
‚Ä¢ 5-6 comidas peque√±as
‚Ä¢ 8-10 vasos de agua
‚Ä¢ Vitaminas prenatales
‚Ä¢ Escucha tu cuerpo

¬øQu√© alimento te preocupa?`;
  }
  
  // Respuestas para el postparto
  if (lowerMessage.includes('postparto') || lowerMessage.includes('despu√©s del parto') || lowerMessage.includes('recuperaci√≥n')) {
    return `¬°El postparto es un per√≠odo muy importante! Soy Douli, tu asistente de Munpa. Te preparo para esta etapa:

ü§± **Primeras semanas postparto:**
‚Ä¢ Descansa cuando el beb√© duerma
‚Ä¢ Pide ayuda a familiares y amigos
‚Ä¢ Come alimentos nutritivos
‚Ä¢ Bebe mucha agua
‚Ä¢ No te presiones por "volver a la normalidad"

üíô **Cuidado emocional:**
‚Ä¢ Es normal sentir emociones intensas
‚Ä¢ Habla sobre tus sentimientos
‚Ä¢ Busca apoyo si te sientes abrumada
‚Ä¢ No te compares con otras madres
‚Ä¢ Celebra cada peque√±o logro

üè• **Alerta si:**
‚Ä¢ Fiebre alta
‚Ä¢ Sangrado excesivo
‚Ä¢ Dolor intenso
‚Ä¢ Tristeza profunda

üí° **Consejos:**
‚Ä¢ Comidas preparadas
‚Ä¢ Organiza visitas
‚Ä¢ Acepta ayuda
‚Ä¢ No te olvides de ti

¬øC√≥mo te sientes?`;
  }
  
  // Verificar si pregunta por un hijo espec√≠fico o sobre edades
  const askedChildName = childrenNames.find(name => 
    lowerMessage.includes(name.toLowerCase())
  );
  
  // Verificar si pregunta sobre edad espec√≠fica
  if (askedChildName && (lowerMessage.includes('a√±o') || lowerMessage.includes('edad') || lowerMessage.includes('cu√°nto') || lowerMessage.includes('cuantos'))) {
    // Buscar la informaci√≥n espec√≠fica del hijo en childrenInfo
    const childLine = childrenInfo.split('\n').find(line => line.includes(askedChildName));
    
    if (childLine) {
      if (childLine.includes('Por nacer')) {
        const gestationMatch = childLine.match(/\((\d+) semanas de gestaci√≥n\)/);
        const weeks = gestationMatch ? gestationMatch[1] : 'desconocidas';
        return `Soy Douli, tu asistente de Munpa. 

ü§± **${askedChildName}:**
${askedChildName} est√° por nacer (${weeks} semanas de gestaci√≥n).

üí° **Pr√≥ximos pasos:**
‚Ä¢ Prepara la maleta para el hospital
‚Ä¢ Ten todo listo en casa
‚Ä¢ Practica t√©cnicas de respiraci√≥n

¬øNecesitas ayuda con la preparaci√≥n?`;
      } else {
        // Extraer edad del texto
        const ageMatch = childLine.match(/: (.+?) de edad/);
        if (ageMatch) {
          const age = ageMatch[1];
          return `Soy Douli, tu asistente de Munpa. 

üë∂ **${askedChildName}:**
${askedChildName} tiene ${age}.

üí° **Consejos para esta edad:**
‚Ä¢ Mant√©n rutinas estables
‚Ä¢ Celebra sus logros
‚Ä¢ Dedica tiempo individual

¬øQu√© aspecto espec√≠fico te preocupa?`;
        }
      }
    }
  }
  
  // Verificar si pregunta por un hijo espec√≠fico (sin edad)
  if (askedChildName) {
    const isUnborn = unbornChildrenNames.includes(askedChildName);
    const isYoung = youngChildrenNames.includes(askedChildName);
    
    if (isUnborn) {
      return `Soy Douli, tu asistente de Munpa.

ü§± **${askedChildName}:**
${askedChildName} est√° por nacer.

üí° **Preparaci√≥n:**
‚Ä¢ Todo listo para su llegada
‚Ä¢ Prepara a tus otros hijos
‚Ä¢ Maleta para hospital
‚Ä¢ T√©cnicas de respiraci√≥n

¬øQu√© necesitas saber espec√≠ficamente?`;
    } else if (isYoung) {
      return `Soy Douli, tu asistente de Munpa.

üë∂ **${askedChildName}:**
${askedChildName} est√° en etapa de desarrollo.

üí° **Consejos:**
‚Ä¢ Rutina estable
‚Ä¢ Tiempo individual
‚Ä¢ Celebra logros
‚Ä¢ Paciencia

¬øQu√© te preocupa espec√≠ficamente?`;
    } else {
      return `Soy Douli, tu asistente de Munpa.

üë∂ **${askedChildName}:**
${askedChildName} es parte de tu familia.

üí° **Consejos:**
‚Ä¢ Necesidades √∫nicas
‚Ä¢ Tiempo individual
‚Ä¢ Celebra logros
‚Ä¢ Comunicaci√≥n abierta

¬øQu√© necesitas saber?`;
    }
  }
  
  // Respuesta general para cualquier otra pregunta
  let personalizedIntro = `Soy Douli, tu asistente de Munpa.`;
  
  if (hasUnbornChildren) {
    const unbornNames = unbornChildrenNames.join(' y ');
    personalizedIntro += ` Veo que tienes a ${unbornNames} en camino. ¬°Qu√© momento tan especial!`;
  } else if (hasYoungChildren) {
    const youngNames = youngChildrenNames.join(' y ');
    personalizedIntro += ` Como madre experimentada con ${youngNames}, sabes que cada d√≠a trae nuevos aprendizajes.`;
  } else if (hasMultipleChildren) {
    const allNames = childrenNames.join(' y ');
    personalizedIntro += ` Con tu experiencia criando a ${allNames}, eres una madre sabia.`;
  } else {
    personalizedIntro += ` Estoy aqu√≠ para acompa√±arte en este hermoso viaje del embarazo y la maternidad.`;
  }
  
  // Respuestas para preguntas sobre el nombre del usuario
  if (lowerMessage.includes('nombre') || lowerMessage.includes('llamas') || lowerMessage.includes('sabes mi nombre')) {
    return `¬°Hola ${userName}! Soy Douli, tu asistente de Munpa.

üíù **Sobre tu nombre:**
Tu nombre es ${userName} y es hermoso. Me encanta poder llamarte por tu nombre para hacer nuestra conversaci√≥n m√°s personal y cercana.

ü§± **Como tu asistente:**
Estoy aqu√≠ para acompa√±arte en tu viaje de maternidad, ${userName}. Puedo ayudarte con consejos sobre embarazo, parto, lactancia y crianza.

¬øEn qu√© puedo ayudarte hoy ${userName}?`;
  }
  
  // Respuestas para preguntas generales sobre hijos
  if (lowerMessage.includes('hijo') || lowerMessage.includes('hijos') || lowerMessage.includes('cu√°ntos') || lowerMessage.includes('nombres')) {
    if (childrenNames.length > 0) {
      const bornChildren = childrenNames.filter(name => !unbornChildrenNames.includes(name));
      const unbornChildren = unbornChildrenNames;
      
      let response = `Soy Douli, tu asistente de Munpa. 

üë∂ **Tu familia:**
Tienes ${childrenNames.length} hijo${childrenNames.length > 1 ? 's' : ''}.`;

      if (bornChildren.length > 0) {
        response += `\n\nüë∂ **Nacidos:**
${bornChildren.map(name => `‚Ä¢ ${name}`).join('\n')}`;
      }
      
      if (unbornChildren.length > 0) {
        response += `\n\nü§± **Por nacer:**
${unbornChildren.map(name => `‚Ä¢ ${name}`).join('\n')}`;
      }
      
      response += `\n\nüí° **Puedo ayudarte con:**
‚Ä¢ Consejos espec√≠ficos por edad
‚Ä¢ Preparaci√≥n para nuevos beb√©s
‚Ä¢ Manejo de m√∫ltiples hijos

¬øSobre cu√°l necesitas ayuda?`;
      
      return response;
    } else {
      return `¬°Hola ${userName}! Soy Douli, tu asistente de Munpa. 

üë∂ **Sobre tu familia:**
Actualmente no tienes hijos registrados en el sistema, pero estoy aqu√≠ para acompa√±arte en tu viaje hacia la maternidad.

üíù **Puedo ayudarte con:**
‚Ä¢ Preparaci√≥n para el embarazo
‚Ä¢ Informaci√≥n sobre el parto
‚Ä¢ Cuidado postparto
‚Ä¢ Lactancia materna
‚Ä¢ Apoyo emocional

¬øTe gustar√≠a que te ayude con alg√∫n tema espec√≠fico ${userName}?`;
    }
  }
  
  return `${personalizedIntro}

üí° **Puedo ayudarte con:**
‚Ä¢ Embarazo y parto
‚Ä¢ Lactancia
‚Ä¢ Cuidado postparto
‚Ä¢ Apoyo emocional
${hasMultipleChildren ? '‚Ä¢ M√∫ltiples hijos' : ''}
${hasYoungChildren ? '‚Ä¢ Ni√±os peque√±os' : ''}
${hasUnbornChildren ? '‚Ä¢ Preparaci√≥n beb√©' : ''}

¬øEn qu√© necesitas ayuda espec√≠ficamente ${userName}?`;
};

// Funci√≥n para configurar OpenAI
const setupOpenAI = () => {
  try {
    console.log('ü§ñ Configurando OpenAI...');
    
    if (!process.env.OPENAI_API_KEY) {
      console.log('‚ö†Ô∏è OPENAI_API_KEY no est√° configurada - OpenAI ser√° opcional');
      openaiStatus = 'No configurado (opcional)';
      return false;
    }

    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    console.log('‚úÖ OpenAI configurado correctamente');
    openaiStatus = 'Configurado correctamente';
    return true;
  } catch (error) {
    console.error('‚ùå Error configurando OpenAI:', error.message);
    openaiStatus = `Error: ${error.message}`;
    return false;
  }
};

// Inicializar Firebase
const firebaseReady = setupFirebase();

// Inicializar OpenAI
const openaiReady = setupOpenAI();

// Ruta de salud
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Servidor funcionando correctamente',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    firebase: {
      status: firebaseStatus,
      ready: firebaseReady,
      hasAuth: !!auth,
      hasDb: !!db,
      hasAdmin: !!admin,
      hasStorage: !!(admin && admin.storage)
    },
    openai: {
      status: openaiStatus,
      ready: openaiReady,
      hasClient: !!openai
    }
  });
});

// Endpoint de la Doula Virtual
app.post('/api/doula/chat', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { message, context } = req.body;

    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje es requerido'
      });
    }

    // ‚ö†Ô∏è VALIDACI√ìN DE TEMA: Verificar si el mensaje es relevante al √°mbito de doula
    if (!isRelevantToDoulaScope(message)) {
      console.log('‚ö†Ô∏è [DOULA] Mensaje fuera del √°mbito detectado:', message.substring(0, 50));
      
      // Obtener nombre del usuario para personalizar la respuesta
      let userName = 'Mam√°';
      if (db) {
        try {
          const userDoc = await db.collection('users').doc(uid).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userName = userData.displayName || userData.name || 'Mam√°';
            
            if (!userName || userName === 'Mam√°') {
              try {
                const authUser = await auth.getUser(uid);
                userName = authUser.displayName || authUser.email?.split('@')[0] || 'Mam√°';
              } catch (authError) {
                console.log('‚ö†Ô∏è [DOULA] No se pudo obtener nombre de Firebase Auth');
              }
            }
          }
        } catch (error) {
          console.log('‚ö†Ô∏è [DOULA] Error obteniendo nombre de usuario:', error.message);
        }
      }
      
      const offTopicResponse = `¬°Hola ${userName}! üëã Soy Douli, tu asistente de Munpa especializada en acompa√±amiento durante el embarazo, parto y crianza temprana.

ü§± **Mi especialidad es ayudarte con:**
‚Ä¢ Embarazo y preparaci√≥n al parto
‚Ä¢ Lactancia y cuidados del beb√©
‚Ä¢ Apoyo emocional para familias
‚Ä¢ Desarrollo infantil y crianza
‚Ä¢ Se√±ales de alarma y cu√°ndo consultar al m√©dico

üí¨ **Tu pregunta parece estar fuera de mi √°rea de especialidad.** Estoy aqu√≠ exclusivamente para acompa√±arte en temas relacionados con el embarazo, parto y crianza.

¬øHay algo relacionado con tu embarazo, tu beb√© o tu experiencia como madre/padre en lo que pueda ayudarte? üíù`;

      const shouldGreet = await shouldSendDoulaGreeting(uid);
      const finalResponse = normalizeDoulaGreeting(offTopicResponse, userName, shouldGreet);
      return res.json({
        success: true,
        message: 'Respuesta de la doula virtual',
        data: {
          response: finalResponse,
          timestamp: new Date().toISOString(),
          usedFallback: true,
          source: 'off-topic-filter',
          filtered: true
        }
      });
    }

    // Verificar que OpenAI est√© configurado
    if (!openai) {
      return res.status(500).json({
        success: false,
        message: 'Servicio de IA no disponible'
      });
    }

    // Obtener informaci√≥n del usuario y sus hijos para contexto personalizado
    let userContext = '';
    let childrenInfo = '';
    let userName = '';
    let userMemory = null;
    let relevantKnowledge = [];
    const shouldGreet = await shouldSendDoulaGreeting(uid);
    
    if (db) {
      try {
        // Obtener datos del usuario desde Firestore
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          // Obtener nombre del usuario
          userName = userData.displayName || userData.name || 'Mam√°';
          
          // Si no hay nombre en Firestore, intentar obtenerlo de Firebase Auth
          if (!userName || userName === 'Mam√°') {
            try {
              const authUser = await auth.getUser(uid);
              userName = authUser.displayName || authUser.email?.split('@')[0] || 'Mam√°';
              console.log('üìã [DOULA] Nombre obtenido de Firebase Auth:', {
                authDisplayName: authUser.displayName,
                authEmail: authUser.email,
                userNameFinal: userName
              });
            } catch (authError) {
              console.log('‚ö†Ô∏è [DOULA] No se pudo obtener nombre de Firebase Auth:', authError.message);
            }
          }
          console.log('üìã [DOULA] Nombre del usuario obtenido:', {
            displayName: userData.displayName,
            name: userData.name,
            userNameFinal: userName,
            userDataKeys: Object.keys(userData)
          });
          
          // Obtener memoria del usuario
          userMemory = await getUserMemory(uid);
          
          // Determinar filtros para el conocimiento basado en el contexto del usuario
          let knowledgeFilters = { language: 'es' };
          if (userData.isPregnant) {
            knowledgeFilters.stage = 'embarazo';
          } else if (userData.childrenCount > 0) {
            knowledgeFilters.stage = 'posparto';
          }
          
          // Recuperar conocimiento relevante
          relevantKnowledge = await retrieveKnowledge(message, knowledgeFilters);
          
          // Obtener informaci√≥n actualizada de los hijos con edades calculadas
          const childrenSnapshot = await db.collection('children')
            .where('parentId', '==', uid)
            .orderBy('createdAt', 'desc')
            .get();
          
          const children = [];
          childrenSnapshot.forEach(doc => {
            const childData = doc.data();
            const currentInfo = getChildCurrentInfo(childData);
            children.push({
              id: doc.id,
              name: childData.name,
              ageInMonths: childData.ageInMonths,
              currentAgeInMonths: currentInfo.currentAgeInMonths,
              isUnborn: childData.isUnborn,
              gestationWeeks: childData.gestationWeeks,
              currentGestationWeeks: currentInfo.currentGestationWeeks,
              createdAt: childData.createdAt,
              registeredAt: childData.registeredAt,
              daysSinceRegistration: currentInfo.daysSinceRegistration
            });
          });
          
          // Crear contexto personalizado del usuario con semanas actualizadas
          let userGestationWeeks = userData.gestationWeeks;
          
          // Si el usuario est√° embarazada y tiene semanas registradas, calcular las actuales
          if (userData.isPregnant && userData.gestationWeeks && userData.createdAt) {
            const now = new Date();
            const createdDate = new Date(userData.createdAt);
            const diffTime = now - createdDate;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            const diffWeeks = Math.floor(diffDays / 7);
            const currentWeeks = userData.gestationWeeks + diffWeeks;
            
            // Aplicar l√≠mites
            if (currentWeeks > 42) {
              userGestationWeeks = 40; // T√©rmino completo
            } else if (currentWeeks < 4) {
              userGestationWeeks = 4; // M√≠nimo
            } else {
              userGestationWeeks = currentWeeks;
            }
            
            console.log(`üìä [USER GESTATION] Usuario: ${userData.gestationWeeks} semanas + ${diffWeeks} semanas = ${userGestationWeeks} semanas (${diffDays} d√≠as desde creaci√≥n)`);
          }
          
          userContext = `
            Informaci√≥n del usuario:
            - G√©nero: ${userData.gender === 'F' ? 'Mujer' : 'Hombre'}
            - N√∫mero de hijos: ${userData.childrenCount || 0}
            - Embarazada: ${userData.isPregnant ? 'S√≠' : 'No'}
            ${userGestationWeeks ? `- Semanas de gestaci√≥n: ${userGestationWeeks} (calculadas autom√°ticamente)` : ''}
          `;
          
          // Crear contexto detallado de los hijos con edades actualizadas
          if (children.length > 0) {
            childrenInfo = `
            Informaci√≥n de los hijos (edades actualizadas autom√°ticamente):
            ${children.map((child, index) => {
              if (child.isUnborn) {
                return `- ${child.name}: Por nacer (${child.currentGestationWeeks} semanas de gestaci√≥n, registrado con ${child.gestationWeeks} semanas hace ${child.daysSinceCreation} d√≠as)`;
              } else {
                const years = Math.floor(child.currentAgeInMonths / 12);
                const months = child.currentAgeInMonths % 12;
                const ageText = years > 0 
                  ? `${years} a√±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
                  : `${months} mes${months > 1 ? 'es' : ''}`;
                return `- ${child.name}: ${ageText} de edad (registrado con ${child.ageInMonths} meses hace ${child.daysSinceCreation} d√≠as)`;
              }
            }).join('\n            ')}
            
            Hijos nacidos: ${children.filter(c => !c.isUnborn).length}
            Hijos por nacer: ${children.filter(c => c.isUnborn).length}
            `;
          }
          
          console.log('üìã [DOULA] Contexto del usuario obtenido:', {
            userData: {
              gender: userData.gender,
              childrenCount: userData.childrenCount,
              isPregnant: userData.isPregnant,
              gestationWeeks: userData.gestationWeeks
            },
            children: children.map(c => ({
              name: c.name,
              registeredAge: c.isUnborn ? c.gestationWeeks + ' semanas' : c.ageInMonths + ' meses',
              currentAge: c.isUnborn ? c.currentGestationWeeks + ' semanas' : c.currentAgeInMonths + ' meses',
              isUnborn: c.isUnborn,
              daysSinceCreation: c.daysSinceCreation
            }))
          });
        }
      } catch (error) {
        console.log('‚ö†Ô∏è No se pudo obtener contexto del usuario:', error.message);
      }
    }

    // Crear contexto de conocimiento relevante
    let knowledgeContext = '';
    if (relevantKnowledge.length > 0) {
      knowledgeContext = `
üìö **CONOCIMIENTO RELEVANTE PARA ESTA CONSULTA:**
${relevantKnowledge.map((k, index) => `${index + 1}. ${k.text}`).join('\n')}
`;
    }
    
    // Crear contexto de memoria del usuario
    let memoryContext = '';
    if (userMemory) {
      memoryContext = `
üß† **MEMORIA DE CONVERSACIONES ANTERIORES:**
${userMemory.notes.length > 0 ? `Notas importantes: ${userMemory.notes.join(', ')}` : ''}
${userMemory.preferences ? `Preferencias: ${JSON.stringify(userMemory.preferences)}` : ''}
`;
    }
    
    // Crear el prompt para la doula virtual
    const systemPrompt = `Eres una doula virtual experta y compasiva llamada "Douli, asistente de Munpa". Tu misi√≥n es acompa√±ar a padres y madres durante el embarazo, parto y crianza temprana con amor, sabidur√≠a y profesionalismo.

üéØ **TU IDENTIDAD COMO DOULA:**
- Eres c√°lida, emp√°tica y siempre comprensiva
- Hablas con el coraz√≥n de una madre experimentada
- Proporcionas informaci√≥n basada en evidencia m√©dica
- Eres profesional pero cercana, como una amiga sabia
- Eres parte de la familia Munpa, dedicada a apoyar a las familias

üíù **TU ESTILO DE COMUNICACI√ìN:**
- Usa emojis para hacer las respuestas m√°s c√°lidas
- S√© espec√≠fica y pr√°ctica en tus consejos
- Siempre ofrece apoyo emocional
- Usa un tono maternal y protector
- S√© alentadora y positiva
- Pres√©ntate como "Douli, tu asistente de Munpa"
- Responde en espa√±ol neutro, usa bullets cuando convenga
- Finaliza con una sugerencia pr√°ctica

üìö **√ÅMBITO PERMITIDO - SOLO PUEDES RESPONDER SOBRE:**
- Embarazo (s√≠ntomas, cambios, cuidados)
- Preparaci√≥n al parto (f√≠sica y mental)
- Trabajo de parto (t√©cnicas, respiraci√≥n)
- Parto (proceso, acompa√±amiento)
- Posparto (recuperaci√≥n, adaptaci√≥n)
- Lactancia (t√©cnicas, problemas comunes)
- Cuidados del reci√©n nacido
- Apoyo emocional y de pareja
- Crianza temprana (cuidados, alimentaci√≥n, desarrollo)
- Alimentaci√≥n (lactancia)
- Salud mental (depresi√≥n, ansiedad, estr√©s)
- Maternidad (acompa√±amiento, recuperaci√≥n, adaptaci√≥n)
- Embarazo y parto (acompa√±amiento, recuperaci√≥n, adaptaci√≥n)
- Se√±ales de alarma para derivar a profesionales de salud

üö´ **POL√çTICA DE ALCANCE ESTRICTA - NUNCA RESPONDAS SOBRE:**
- Comida general (tacos, pizza, recetas de cocina, restaurantes)
- Finanzas, programaci√≥n, tecnolog√≠a
- Diagn√≥stico m√©dico detallado
- Radiolog√≠a, interpretaci√≥n de estudios
- Recetas de medicamentos espec√≠ficos
- Derecho, tr√°mites legales
- Deportes, entretenimiento, viajes
- Pol√≠tica, autom√≥viles, m√∫sica
- Cualquier tema fuera del √°mbito de doula

‚ö†Ô∏è **SI LA PREGUNTA NO EST√Å RELACIONADA CON EMBARAZO, PARTO O CRIANZA:**

**DEBES RESPONDER EXACTAMENTE AS√ç (NO RESPONDAS LA PREGUNTA ORIGINAL):**

"¬°Hola ${userName}! üëã Soy Douli, tu asistente de Munpa especializada en acompa√±amiento durante el embarazo, parto y crianza temprana.

ü§± **Mi especialidad es ayudarte con:**
‚Ä¢ Embarazo y preparaci√≥n al parto
‚Ä¢ Lactancia y cuidados del beb√©
‚Ä¢ Apoyo emocional para familias
‚Ä¢ Desarrollo infantil y crianza
‚Ä¢ Se√±ales de alarma y cu√°ndo consultar al m√©dico

üí¨ **Tu pregunta parece estar fuera de mi √°rea de especialidad.** Estoy aqu√≠ exclusivamente para acompa√±arte en temas relacionados con el embarazo, parto y crianza.

¬øHay algo relacionado con tu embarazo, tu beb√© o tu experiencia como madre/padre en lo que pueda ayudarte? üíù"

**IMPORTANTE:** NO respondas preguntas sobre comida, tacos, cocina, tecnolog√≠a, deportes, o cualquier tema no relacionado con embarazo/parto/crianza. Si la pregunta no est√° relacionada, usa la respuesta anterior SIN EXCEPCI√ìN.

‚ö†Ô∏è **LIMITACIONES M√âDICAS:**
- NO haces diagn√≥stico m√©dico
- NO indicas f√°rmacos
- NO interpretas estudios cl√≠nicos
- SIEMPRE aclara que no eres m√©dico
- Si no sabes algo, sugiere hablar con gine/obstetra o matrona

üö® **SEGURIDAD - URGENCIAS M√âDICAS:**
Ante cualquier s√≠ntoma de urgencia (sangrado abundante, disminuci√≥n marcada de movimientos fetales, dolor intenso, fiebre alta, convulsiones, p√©rdida de conocimiento):
**"¬°BUSCA ATENCI√ìN M√âDICA INMEDIATA! Llama a servicios de emergencia o ve al hospital m√°s cercano."**

${userContext}
${childrenInfo}
${knowledgeContext}
${memoryContext}

IMPORTANTE: 
- Usa esta informaci√≥n para personalizar tus respuestas
- Si hay conocimiento relevante, √∫salo para mejorar tu respuesta
- Si hay memoria del usuario, considera sus preferencias y notas anteriores
- Si tiene hijos peque√±os, da consejos espec√≠ficos para esa edad
- Si est√° embarazada, enf√≥cate en esa etapa espec√≠fica
- SIEMPRE usa los nombres espec√≠ficos de sus hijos cuando sea apropiado
- NO inventes datos; si no sabes, dilo y sugiere hablar con su gine/obstetra o matrona

Responde como Douli, tu asistente de Munpa, con amor, sabidur√≠a y el coraz√≥n de una madre que ha acompa√±ado a muchas mujeres en este hermoso viaje.`;

    console.log('ü§ñ [DOULA] Enviando mensaje a OpenAI:', message.substring(0, 100) + '...');

    // Enviar mensaje a OpenAI
    let response;
    let usedFallback = false;
    
    try {
      console.log('ü§ñ [DOULA] Enviando a OpenAI...');
      
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: message }
        ],
        max_tokens: 800, // M√°s tokens para respuestas m√°s completas
        temperature: 0.8, // M√°s creatividad pero manteniendo coherencia
        presence_penalty: 0.1, // Evita repeticiones
        frequency_penalty: 0.1, // Variedad en las respuestas
        top_p: 0.9 // Mantiene respuestas coherentes
      });

      response = completion.choices[0].message.content;
      console.log('‚úÖ [DOULA] Respuesta de OpenAI recibida');
      
    } catch (openaiError) {
      console.error('‚ùå [DOULA] Error de OpenAI:', openaiError.message);
      
      // Fallback cuando se agota la cuota - Respuestas de doula predefinidas
      if (openaiError.message.includes('quota') || openaiError.message.includes('429')) {
        console.log('‚ö†Ô∏è [DOULA] Usando fallback por cuota agotada');
        response = generateDoulaResponse(message, userContext, childrenInfo, userName);
        usedFallback = true;
      } else {
        console.log('‚ùå [DOULA] Error no relacionado con cuota, usando fallback');
        response = generateDoulaResponse(message, userContext, childrenInfo, userName);
        usedFallback = true;
      }
    }

    // Guardar la conversaci√≥n en Firestore (opcional)
    if (db) {
      try {
        await db.collection('doula_conversations').add({
          userId: uid,
          userMessage: message,
          doulaResponse: response,
          timestamp: new Date(),
          context: context || null
        });
        console.log('üíæ [DOULA] Conversaci√≥n guardada en Firestore');
      } catch (error) {
        console.log('‚ö†Ô∏è [DOULA] No se pudo guardar la conversaci√≥n:', error.message);
      }
    }

    const finalResponse = normalizeDoulaGreeting(response, userName, shouldGreet);
    res.json({
      success: true,
      message: 'Respuesta de la doula virtual',
      data: {
        response: finalResponse,
        timestamp: new Date().toISOString(),
        usedFallback: usedFallback,
        source: usedFallback ? 'fallback' : 'openai'
      }
    });

  } catch (error) {
    console.error('‚ùå [DOULA] Error en chat con doula:', error);
    res.status(500).json({
      success: false,
      message: 'Error al procesar la consulta',
      error: error.message
    });
  }
});

// Endpoint para obtener historial de conversaciones
app.get('/api/doula/history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const conversationsSnapshot = await db.collection('doula_conversations')
      .where('userId', '==', uid)
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();

    const conversations = [];
    conversationsSnapshot.forEach(doc => {
      conversations.push({
        id: doc.id,
        ...doc.data(),
        timestamp: doc.data().timestamp.toDate().toISOString()
      });
    });

    res.json({
      success: true,
      data: conversations
    });

  } catch (error) {
    console.error('‚ùå [DOULA] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// Endpoint para debug de datos del usuario
app.get('/api/debug/user-data', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }
    
    // Obtener datos de Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    let firestoreData = null;
    if (userDoc.exists) {
      firestoreData = userDoc.data();
    }
    
    // Obtener datos de Firebase Auth
    let authData = null;
    try {
      const authUser = await auth.getUser(uid);
      authData = {
        displayName: authUser.displayName,
        email: authUser.email,
        uid: authUser.uid
      };
    } catch (authError) {
      console.log('‚ö†Ô∏è Error obteniendo datos de Auth:', authError.message);
    }
    
    res.json({
      success: true,
      data: {
        uid,
        firestore: firestoreData,
        auth: authData,
        timestamp: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error en debug user-data:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo datos de debug',
      error: error.message
    });
  }
});

// Endpoint para verificar Firebase Storage
app.get('/api/firebase/status', (req, res) => {
  try {
    if (!admin) {
      return res.json({
        success: false,
        message: 'Firebase Admin no est√° inicializado',
        admin: false,
        storage: false
      });
    }

    if (!admin.storage) {
      return res.json({
        success: false,
        message: 'Firebase Storage no est√° disponible',
        admin: true,
        storage: false
      });
    }

    const bucket = admin.storage().bucket();
    res.json({
      success: true,
      message: 'Firebase Storage est√° funcionando correctamente',
      admin: true,
      storage: true,
      bucketName: bucket.name,
      projectId: process.env.FIREBASE_PROJECT_ID,
      storageBucket: 'mumpabackend.firebasestorage.app'
    });
  } catch (error) {
    res.json({
      success: false,
      message: 'Error verificando Firebase Storage',
      error: error.message,
      admin: admin ? true : false,
      storage: false
    });
  }
});

// Ruta ra√≠z
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'API de Autenticaci√≥n con Firebase',
    version: '1.0.0',
    firebase: {
      status: firebaseStatus,
      ready: firebaseReady
    },
    endpoints: {
      health: '/health',
      signup: '/api/auth/signup',
      login: '/api/auth/login',
      profile: '/api/auth/profile (requiere auth)',
      'update-profile': '/api/auth/profile (PUT, requiere auth)',
      'change-password': '/api/auth/change-password (requiere auth)',
      'delete-account': '/api/auth/account (DELETE, requiere auth)',
      'verify-token': '/api/auth/verify-token (requiere auth)'
    }
  });
});

// Endpoint de registro
app.post('/api/auth/signup', async (req, res) => {
  try {
    const { email, password, displayName, gender, childrenCount, isPregnant, gestationWeeks } = req.body;

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    console.log('üìù Intentando registrar usuario:', email, 'G√©nero:', gender, 'Hijos:', childrenCount, 'Embarazada:', isPregnant, 'Semanas:', gestationWeeks);

    // Verificar si el usuario ya existe
    try {
      const existingUser = await auth.getUserByEmail(email);
      return res.status(400).json({
        success: false,
        message: 'El usuario ya existe con este email'
      });
    } catch (error) {
      // El usuario no existe, continuar con el registro
      console.log('‚úÖ Usuario no existe, procediendo con registro');
    }

    // Validar gestaci√≥n si es mujer
    if (gender === 'F' && isPregnant) {
      if (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42) {
        return res.status(400).json({
          success: false,
          message: 'Para mujeres embarazadas, las semanas de gestaci√≥n deben estar entre 1 y 42'
        });
      }
    }

    // Crear usuario en Firebase Auth
    const userRecord = await auth.createUser({
      email,
      password,
      displayName,
      emailVerified: false
    });

    console.log('‚úÖ Usuario creado en Firebase Auth:', userRecord.uid);

    // Crear documento adicional en Firestore
    if (db) {
      const defaultLocation = await getDefaultUserLocation();
      await db.collection('users').doc(userRecord.uid).set({
        email,
        displayName,
        gender: gender || null, // Campo para M o F
        childrenCount: childrenCount || 0, // Contador de hijos
        isPregnant: gender === 'F' ? (isPregnant || false) : false, // Solo mujeres pueden estar embarazadas
        gestationWeeks: gender === 'F' && isPregnant ? gestationWeeks : null, // Semanas de gestaci√≥n
        ...defaultLocation,
        createdAt: new Date(),
        updatedAt: new Date(),
        isActive: true
      });
      console.log('‚úÖ Documento creado en Firestore con datos:', {
      email,
      displayName,
      gender,
      childrenCount,
        isPregnant: gender === 'F' ? (isPregnant || false) : false,
        gestationWeeks: gender === 'F' && isPregnant ? gestationWeeks : null
    });
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(userRecord.uid);
    console.log('‚úÖ Token personalizado generado');

    res.status(201).json({
      success: true,
      message: 'Usuario registrado exitosamente',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        customToken
      }
    });

  } catch (error) {
    console.error('‚ùå Error en signup:', error);
    res.status(500).json({
      success: false,
      message: 'Error al registrar usuario',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// Endpoint de login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    console.log('üîê Intentando login para:', email);

    // Buscar usuario por email
    const userRecord = await auth.getUserByEmail(email);
    console.log('‚úÖ Usuario encontrado:', userRecord.uid);
    
    // Verificar que el usuario est√© activo
    let userProfile = null;
    if (db) {
      const userDoc = await db.collection('users').doc(userRecord.uid).get();
      
      if (!userDoc.exists || !userDoc.data().isActive) {
        return res.status(401).json({
          success: false,
          message: 'Usuario inactivo o no encontrado'
        });
      }
      userProfile = userDoc.data();
      console.log('‚úÖ Usuario verificado en Firestore');
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(userRecord.uid);
    console.log('‚úÖ Token personalizado generado para login');

    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || userRecord.photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: safeProfile.displayName,
        customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('‚ùå Error en login:', error);
    res.status(401).json({
      success: false,
      message: 'Credenciales inv√°lidas',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// ==========================================
// üîê LOGIN CON GOOGLE (Social Sign-In)
// ==========================================

app.post('/api/auth/google', async (req, res) => {
  try {
    const { idToken } = req.body;

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado',
        error: 'Auth service not available',
        firebaseStatus: firebaseStatus
      });
    }

    if (!idToken) {
      return res.status(400).json({
        success: false,
        message: 'idToken de Google es requerido'
      });
    }

    console.log('üîê [GOOGLE] Verificando token de Google...');

    // Verificar el token de Google con Firebase Admin
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(idToken);
      console.log('‚úÖ [GOOGLE] Token verificado exitosamente para:', decodedToken.email);
    } catch (error) {
      console.error('‚ùå [GOOGLE] Error verificando token:', error.message);
      return res.status(401).json({
        success: false,
        message: 'Token de Google inv√°lido',
        error: error.message
      });
    }

    const { uid, email, name, picture } = decodedToken;

    // Verificar si el usuario ya existe en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    let userData;

    if (userDoc.exists) {
      // Usuario existente
      userData = userDoc.data();
      console.log('‚úÖ [GOOGLE] Usuario existente encontrado:', email);

      // Verificar que est√© activo
      if (!userData.isActive) {
        return res.status(401).json({
          success: false,
          message: 'Usuario inactivo'
        });
      }

      // Actualizar √∫ltima conexi√≥n y foto si cambi√≥
      await userDocRef.update({
        lastLogin: new Date(),
        photoUrl: picture || userData.photoUrl,
        updatedAt: new Date()
      });

      console.log('‚úÖ [GOOGLE] Datos del usuario actualizados');
    } else {
      // Usuario nuevo - crear perfil
      console.log('üìù [GOOGLE] Creando nuevo usuario desde Google:', email);

      userData = {
        email,
        displayName: name || email.split('@')[0],
        name: name || email.split('@')[0],
        photoUrl: picture || null,
        provider: 'google',
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        createdAt: new Date(),
        updatedAt: new Date(),
        lastLogin: new Date(),
        isActive: true,
        fcmTokens: []
      };

      await userDocRef.set(userData);
      console.log('‚úÖ [GOOGLE] Usuario creado en Firestore');
    }

    // Generar custom token para la app
    const customToken = await auth.createCustomToken(uid);
    console.log('‚úÖ [GOOGLE] Custom token generado');

    res.json({
      success: true,
      message: 'Login con Google exitoso',
      data: {
        uid,
        email,
        displayName: userData.displayName || name,
        photoUrl: userData.photoUrl || picture,
        customToken,
        isNewUser: !userDoc.exists
      }
    });

  } catch (error) {
    console.error('‚ùå [GOOGLE] Error en login con Google:', error);
    res.status(500).json({
      success: false,
      message: 'Error al autenticar con Google',
      error: error.message,
      firebaseStatus: firebaseStatus
    });
  }
});

// ==========================================
// üîê LOGIN PARA DASHBOARD ADMIN (retorna JWT)
// ==========================================

app.post('/api/auth/admin-login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado'
      });
    }

    console.log('üîê [ADMIN-LOGIN] Intentando login para:', email);

    // Buscar usuario por email
    let userRecord;
    try {
      userRecord = await auth.getUserByEmail(email);
    } catch (error) {
      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    console.log('‚úÖ [ADMIN-LOGIN] Usuario encontrado:', userRecord.uid);
    
    // Obtener datos del usuario de Firestore
    const userDoc = await db.collection('users').doc(userRecord.uid).get();
    
    if (!userDoc.exists) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no encontrado en la base de datos'
      });
    }

    const userData = userDoc.data();

    // Verificar que el usuario est√© activo
    if (userData.isActive === false) {
      return res.status(401).json({
        success: false,
        message: 'Usuario inactivo'
      });
    }

    // Verificar que sea admin
    if (userData.role !== 'admin' && userData.isAdmin !== true) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos de administrador'
      });
    }

    console.log('‚úÖ [ADMIN-LOGIN] Usuario verificado como admin');

    // Generar JWT token
    const token = jwt.sign(
      { 
        uid: userRecord.uid,
        email: userRecord.email,
        role: userData.role || 'admin'
      },
      JWT_SECRET,
      { expiresIn: '7d' } // Token v√°lido por 7 d√≠as
    );

    // Actualizar √∫ltima conexi√≥n
    await db.collection('users').doc(userRecord.uid).update({
      lastLoginAt: new Date(),
      updatedAt: new Date()
    });

    console.log('‚úÖ [ADMIN-LOGIN] Login exitoso, token JWT generado');

    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        token: token,
        user: {
          uid: userRecord.uid,
          email: userRecord.email,
          displayName: userData.displayName || userRecord.displayName,
          photoURL: userData.photoURL || userRecord.photoURL,
          role: userData.role || 'admin',
          isAdmin: true
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN-LOGIN] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en el servidor',
      error: error.message
    });
  }
});

// ==========================================
// üîê LOGIN CON GOOGLE
// ==========================================

// Endpoint para login/registro con Google
app.post('/api/auth/google-login', async (req, res) => {
  try {
    const { idToken, googleIdToken, email, displayName, photoURL } = req.body;

    if (!idToken && !googleIdToken) {
      return res.status(400).json({
        success: false,
        message: 'Token es requerido (idToken o googleIdToken)'
      });
    }

    if (!auth) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado'
      });
    }

    console.log('üîê [GOOGLE-LOGIN] Iniciando proceso de autenticaci√≥n...');
    
    let uid, userRecord;

    // Intentar verificar como Firebase ID Token primero
    try {
      const tokenToVerify = idToken || googleIdToken;
      console.log('üîê [GOOGLE-LOGIN] Verificando token (primeros 50 chars):', tokenToVerify.substring(0, 50));
      
      const decodedToken = await auth.verifyIdToken(tokenToVerify);
      uid = decodedToken.uid;
      
      console.log('‚úÖ [GOOGLE-LOGIN] Token Firebase verificado para UID:', uid);
      
      // Obtener informaci√≥n del usuario de Firebase Auth
      userRecord = await auth.getUser(uid);
    } catch (verifyError) {
      console.log('‚ö†Ô∏è [GOOGLE-LOGIN] No es un token Firebase v√°lido, intentando crear usuario...');
      console.log('Error de verificaci√≥n:', verifyError.message);
      
      // Si falla, intentar crear/obtener usuario por email
      if (email) {
        try {
          // Intentar obtener usuario por email
          userRecord = await auth.getUserByEmail(email);
          uid = userRecord.uid;
          console.log('‚úÖ [GOOGLE-LOGIN] Usuario encontrado por email:', uid);
        } catch (getUserError) {
          // Si no existe, crear nuevo usuario
          if (getUserError.code === 'auth/user-not-found') {
            console.log('üìù [GOOGLE-LOGIN] Creando nuevo usuario en Firebase Auth...');
            
            const newUser = await auth.createUser({
              email: email,
              displayName: displayName || '',
              photoURL: photoURL || '',
              emailVerified: true,
              disabled: false
            });
            
            uid = newUser.uid;
            userRecord = newUser;
            console.log('‚úÖ [GOOGLE-LOGIN] Nuevo usuario creado en Firebase Auth:', uid);
          } else {
            throw getUserError;
          }
        }
      } else {
        throw new Error('Token inv√°lido y no se proporcion√≥ email para crear usuario');
      }
    }

    // Verificar si el usuario existe en Firestore
    let userDoc = null;
    let isNewUser = false;

    if (db) {
      userDoc = await db.collection('users').doc(uid).get();
      
      if (!userDoc.exists) {
        // Crear nuevo usuario en Firestore
        isNewUser = true;
        const defaultLocation = await getDefaultUserLocation();
        const newUserData = {
          uid: uid,
          email: userRecord.email,
          displayName: userRecord.displayName || '',
          photoURL: userRecord.photoURL || '',
          emailVerified: userRecord.emailVerified,
          provider: 'google',
          gender: null,
          childrenCount: 0,
          isPregnant: false,
          gestationWeeks: null,
          ...defaultLocation,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        };

        await db.collection('users').doc(uid).set(newUserData);
        console.log('‚úÖ [GOOGLE-LOGIN] Nuevo usuario creado en Firestore:', uid);
      } else {
        // Actualizar √∫ltima conexi√≥n y datos de Google
        const updateData = {
          updatedAt: new Date(),
          lastLoginAt: new Date()
        };
        
        // Actualizar displayName y photoURL desde Firebase Auth si est√°n disponibles
        if (userRecord.displayName) {
          updateData.displayName = userRecord.displayName;
        } else if (displayName) {
          updateData.displayName = displayName;
        }
        
        if (userRecord.photoURL) {
          updateData.photoURL = userRecord.photoURL;
        } else if (photoURL) {
          updateData.photoURL = photoURL;
        }
        
        // Actualizar provider
        const existingUserData = userDoc.data();
        if (!existingUserData.provider || existingUserData.provider !== 'google') {
          updateData.provider = 'google';
        }
        
        await db.collection('users').doc(uid).update(updateData);
        console.log('‚úÖ [GOOGLE-LOGIN] Usuario existente actualizado:', updateData);
      }
    }

    // Generar token personalizado para el cliente
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc?.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || userRecord.email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || userRecord.photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        emailVerified: userRecord.emailVerified,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('‚ùå [GOOGLE-LOGIN] Error:', error);
    
    if (error.code === 'auth/id-token-expired') {
      return res.status(401).json({
        success: false,
        message: 'Token de Google expirado. Por favor, inicia sesi√≥n nuevamente.'
      });
    }

    if (error.code === 'auth/argument-error') {
      return res.status(400).json({
        success: false,
        message: 'Token de Google inv√°lido'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error en autenticaci√≥n con Google',
      error: error.message
    });
  }
});

// ==========================================
// üîê LOGIN CON GOOGLE - VERSI√ìN SIMPLE
// ==========================================

// Endpoint simplificado para login con Google (solo requiere datos del usuario)
app.post('/api/auth/google-login-simple', async (req, res) => {
  try {
    const { email, displayName, photoURL, googleId } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: 'Email es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado'
      });
    }

    console.log('üîê [GOOGLE-LOGIN-SIMPLE] Login para:', email);

    let uid, userRecord, isNewUser = false;

    try {
      // Intentar obtener usuario existente por email
      userRecord = await auth.getUserByEmail(email);
      uid = userRecord.uid;
      console.log('‚úÖ [GOOGLE-LOGIN-SIMPLE] Usuario encontrado:', uid);
      
      // Actualizar Firebase Auth con los datos m√°s recientes de Google
      const authUpdateData = {};
      if (displayName && displayName !== userRecord.displayName) {
        authUpdateData.displayName = displayName;
      }
      if (photoURL && photoURL !== userRecord.photoURL) {
        authUpdateData.photoURL = photoURL;
      }
      
      // Si hay datos para actualizar en Auth
      if (Object.keys(authUpdateData).length > 0) {
        await auth.updateUser(uid, authUpdateData);
        console.log('‚úÖ [GOOGLE-LOGIN-SIMPLE] Firebase Auth actualizado:', authUpdateData);
        // Recargar el userRecord para tener los datos actualizados
        userRecord = await auth.getUser(uid);
      }
    } catch (error) {
      if (error.code === 'auth/user-not-found') {
        // Crear nuevo usuario en Firebase Auth
        console.log('üìù [GOOGLE-LOGIN-SIMPLE] Creando nuevo usuario...');
        
        userRecord = await auth.createUser({
          email: email,
          displayName: displayName || '',
          photoURL: photoURL || '',
          emailVerified: true,
          disabled: false,
          providerData: [{
            providerId: 'google.com',
            uid: googleId || email,
            displayName: displayName || '',
            email: email,
            photoURL: photoURL || ''
          }]
        });
        
        uid = userRecord.uid;
        isNewUser = true;
        console.log('‚úÖ [GOOGLE-LOGIN-SIMPLE] Usuario creado en Auth:', uid);
      } else {
        throw error;
      }
    }

    // Verificar/crear en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      // Crear en Firestore
      const defaultLocation = await getDefaultUserLocation();
      const newUserData = {
        uid: uid,
        email: email,
        displayName: displayName || '',
        photoURL: photoURL || '',
        emailVerified: true,
        provider: 'google',
        googleId: googleId || '',
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        ...defaultLocation,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await userDocRef.set(newUserData);
      isNewUser = true;
      console.log('‚úÖ [GOOGLE-LOGIN-SIMPLE] Usuario creado en Firestore');
    } else {
      // Actualizar √∫ltima conexi√≥n y datos de Google (siempre sobrescribir con datos actuales)
      const updateData = {
        updatedAt: new Date(),
        lastLoginAt: new Date()
      };
      
      // Actualizar displayName si viene de Google
      if (displayName) {
        updateData.displayName = displayName;
      }
      
      // Actualizar photoURL si viene de Google
      if (photoURL) {
        updateData.photoURL = photoURL;
      }
      
      // Actualizar provider si no est√° establecido
      const currentData = userDoc.data();
      if (!currentData.provider || currentData.provider !== 'google') {
        updateData.provider = 'google';
      }
      
      // Actualizar googleId si viene
      if (googleId && (!currentData.googleId || currentData.googleId !== googleId)) {
        updateData.googleId = googleId;
      }
      
      await userDocRef.update(updateData);
      console.log('‚úÖ [GOOGLE-LOGIN-SIMPLE] Usuario actualizado en Firestore:', updateData);
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || displayName || email?.split('@')[0],
      name: userProfile?.name || userProfile?.displayName || displayName || email?.split('@')[0],
      photoUrl: userProfile?.photoUrl || photoURL || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: uid,
        email: email,
        displayName: displayName || '',
        photoURL: photoURL || '',
        emailVerified: true,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('‚ùå [GOOGLE-LOGIN-SIMPLE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en autenticaci√≥n con Google',
      error: error.message
    });
  }
});

// ==========================================
// üçé LOGIN CON APPLE
// ==========================================

// Endpoint para login/registro con Apple
app.post('/api/auth/apple-login', async (req, res) => {
  try {
    const { identityToken, user, email, fullName, appleUserId } = req.body;

    console.log('üçé [APPLE-LOGIN] Datos recibidos:', {
      hasIdentityToken: !!identityToken,
      hasEmail: !!email,
      hasFullName: !!fullName,
      hasUser: !!user,
      hasAppleUserId: !!appleUserId
    });

    // Apple User ID es requerido para identificar al usuario
    const appleId = user || appleUserId;
    
    if (!appleId) {
      return res.status(400).json({
        success: false,
        message: 'Apple User ID es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Firebase no est√° configurado'
      });
    }

    console.log('üçé [APPLE-LOGIN] Iniciando login con Apple...');
    console.log('üçé [APPLE-LOGIN] Apple ID:', appleId);
    console.log('üçé [APPLE-LOGIN] Email:', email);
    console.log('üçé [APPLE-LOGIN] Full Name:', fullName);

    let uid, userRecord, isNewUser = false;

    // Paso 1: Buscar usuario existente por Apple ID en Firestore
    console.log('üîç [APPLE-LOGIN] Buscando usuario por Apple ID en Firestore...');
    
    const usersSnapshot = await db.collection('users')
      .where('appleUserId', '==', appleId)
      .limit(1)
      .get();
    
    if (!usersSnapshot.empty) {
      // Usuario existente encontrado
      const userDoc = usersSnapshot.docs[0];
      uid = userDoc.id;
      const userData = userDoc.data();
      console.log('‚úÖ [APPLE-LOGIN] Usuario encontrado por Apple ID:', uid);
      
      // Obtener/recrear en Firebase Auth si es necesario
      try {
        userRecord = await auth.getUser(uid);
      } catch (authError) {
        console.log('‚ö†Ô∏è [APPLE-LOGIN] Usuario no existe en Auth, recreando...');
        userRecord = await auth.createUser({
          uid: uid,
          email: email || userData.email,
          displayName: userData.displayName || '',
          emailVerified: true
        });
      }
    } else {
      // Usuario nuevo - crear en Firebase Auth
      console.log('üìù [APPLE-LOGIN] Usuario nuevo, creando...');
      isNewUser = true;
      
      // Preparar displayName
      const displayName = fullName 
        ? (fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '')
        : '';
      
      // Crear en Firebase Auth
      // Nota: Si no hay email, usar el Apple ID como identificador temporal
      const userEmail = email || `${appleId}@apple.privaterelay.com`;
      
      userRecord = await auth.createUser({
        email: userEmail,
        displayName: displayName,
        emailVerified: true, // Apple verifica los emails
        disabled: false
      });
      
      uid = userRecord.uid;
      console.log('‚úÖ [APPLE-LOGIN] Usuario creado en Firebase Auth:', uid);
    }

    // Verificar/crear en Firestore
    const userDocRef = db.collection('users').doc(uid);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      // Crear en Firestore
      const displayName = fullName 
        ? (fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '')
        : userRecord.displayName || '';

      const defaultLocation = await getDefaultUserLocation();
      const newUserData = {
        uid: uid,
        email: email || userRecord.email,
        displayName: displayName,
        photoURL: null, // Apple no proporciona foto
        emailVerified: true,
        provider: 'apple',
        appleUserId: appleId, // Guardar el Apple ID
        gender: null,
        childrenCount: 0,
        isPregnant: false,
        gestationWeeks: null,
        ...defaultLocation,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      await userDocRef.set(newUserData);
      console.log('‚úÖ [APPLE-LOGIN] Usuario creado en Firestore');
    } else {
      // Actualizar √∫ltima conexi√≥n y datos de Apple
      const updateData = {
        updatedAt: new Date(),
        lastLoginAt: new Date()
      };
      
      // Actualizar displayName si viene de Apple (solo primera vez, Apple solo lo env√≠a una vez)
      if (fullName) {
        const displayName = fullName.givenName && fullName.familyName
          ? `${fullName.givenName} ${fullName.familyName}`
          : fullName.givenName || fullName.familyName || '';
        
        if (displayName) {
          updateData.displayName = displayName;
        }
      }
      
      // Actualizar provider si no est√° establecido
      const currentData = userDoc.data();
      if (!currentData.provider || currentData.provider !== 'apple') {
        updateData.provider = 'apple';
      }
      
      // Actualizar appleUserId si no est√° o es diferente
      if (!currentData.appleUserId || currentData.appleUserId !== appleId) {
        updateData.appleUserId = appleId;
      }
      
      // Actualizar email si viene y no est√°
      if (email && (!currentData.email || currentData.email.includes('@apple.privaterelay.com'))) {
        updateData.email = email;
      }
      
      await userDocRef.update(updateData);
      console.log('‚úÖ [APPLE-LOGIN] Usuario actualizado en Firestore:', updateData);
    }

    // Generar token personalizado
    const customToken = await auth.createCustomToken(uid);

    const userProfile = userDoc.exists ? userDoc.data() : null;
    const safeProfile = {
      displayName: userProfile?.displayName || userRecord.displayName || (email || userRecord.email || '').split('@')[0],
      name: userProfile?.name || userProfile?.displayName || userRecord.displayName || (email || userRecord.email || '').split('@')[0],
      photoUrl: userProfile?.photoUrl || null,
      gender: userProfile?.gender || null,
      childrenCount: userProfile?.childrenCount || 0,
      isPregnant: userProfile?.isPregnant || false,
      gestationWeeks: userProfile?.gestationWeeks || null
    };

    res.json({
      success: true,
      message: isNewUser ? 'Cuenta creada exitosamente' : 'Login exitoso',
      isNewUser: isNewUser,
      data: {
        uid: uid,
        email: email || userRecord.email,
        displayName: userRecord.displayName || '',
        photoURL: null,
        emailVerified: true,
        customToken: customToken,
        isPregnant: safeProfile.isPregnant,
        gestationWeeks: safeProfile.gestationWeeks,
        childrenCount: safeProfile.childrenCount,
        gender: safeProfile.gender,
        profile: safeProfile
      }
    });

  } catch (error) {
    console.error('‚ùå [APPLE-LOGIN] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en autenticaci√≥n con Apple',
      error: error.message
    });
  }
});

// ==========================================
// üëë ADMIN DASHBOARD - ENDPOINTS DE ADMINISTRACI√ìN
// ==========================================

// Middleware para verificar que el usuario es admin
const isAdmin = async (req, res, next) => {
  try {
    const { uid } = req.user;
    
    // Obtener usuario de Firestore
    const userDoc = await db.collection('users').doc(uid).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userData = userDoc.data();
    
    // Verificar si es admin
    if (userData.role !== 'admin' && userData.isAdmin !== true) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos de administrador'
      });
    }
    
    next();
  } catch (error) {
    console.error('‚ùå [ADMIN] Error verificando permisos:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando permisos de administrador'
    });
  }
};

// ========== ESTAD√çSTICAS GENERALES ==========

// Obtener estad√≠sticas del dashboard
app.get('/api/admin/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('üìä [ADMIN] Obteniendo estad√≠sticas...');

    // Contar usuarios
    const usersSnapshot = await db.collection('users').get();
    const totalUsers = usersSnapshot.size;
    
    // Usuarios activos (√∫ltimos 30 d√≠as)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const activeUsers = usersSnapshot.docs.filter(doc => {
      const data = doc.data();
      return data.lastLoginAt && data.lastLoginAt.toDate() > thirtyDaysAgo;
    }).length;

    // Contar hijos
    const childrenSnapshot = await db.collection('children').get();
    const totalChildren = childrenSnapshot.size;

    // Contar comunidades
    const communitiesSnapshot = await db.collection('communities').get();
    const totalCommunities = communitiesSnapshot.size;

    // Contar posts
    const postsSnapshot = await db.collection('posts').get();
    const totalPosts = postsSnapshot.size;

    // Contar listas
    const listsSnapshot = await db.collection('lists').get();
    const totalLists = listsSnapshot.size;

    // Posts de √∫ltimos 7 d√≠as
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const recentPosts = postsSnapshot.docs.filter(doc => {
      const data = doc.data();
      return data.createdAt && data.createdAt.toDate() > sevenDaysAgo;
    }).length;

    res.json({
      success: true,
      data: {
        users: {
          total: totalUsers,
          active: activeUsers,
          inactive: totalUsers - activeUsers
        },
        children: {
          total: totalChildren
        },
        communities: {
          total: totalCommunities
        },
        posts: {
          total: totalPosts,
          lastWeek: recentPosts
        },
        lists: {
          total: totalLists
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE USUARIOS ==========

// Obtener todos los usuarios (con paginaci√≥n)
app.get('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', orderBy = 'createdAt', order = 'desc' } = req.query;
    
    console.log('üë• [ADMIN] Obteniendo usuarios:', { page, limit, search, orderBy, order });

    let query = db.collection('users');

    // Aplicar ordenamiento
    query = query.orderBy(orderBy, order);

    // Obtener todos los documentos
    const snapshot = await query.get();
    
    // Filtrar por b√∫squeda si existe
    let users = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate(),
      lastLoginAt: doc.data().lastLoginAt?.toDate()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      users = users.filter(user => 
        user.email?.toLowerCase().includes(searchLower) ||
        user.displayName?.toLowerCase().includes(searchLower)
      );
    }

    // Aplicar paginaci√≥n manual
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedUsers = users.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedUsers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: users.length,
        totalPages: Math.ceil(users.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo usuarios',
      error: error.message
    });
  }
});

// Crear nuevo usuario administrador
app.post('/api/admin/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { email, password, displayName, role = 'admin', isAdmin: isAdminUser = true } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nuevo usuario administrador:', email);

    // Validaciones
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email y contrase√±a son requeridos'
      });
    }

    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'La contrase√±a debe tener al menos 6 caracteres'
      });
    }

    // Validar formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Email inv√°lido'
      });
    }

    // Verificar si el email ya existe
    try {
      const existingUser = await auth.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'El email ya est√° registrado'
        });
      }
    } catch (error) {
      // Si no existe, continuar (esto es lo esperado)
      if (error.code !== 'auth/user-not-found') {
        throw error;
      }
    }

    // Crear usuario en Firebase Auth
    const userRecord = await auth.createUser({
      email,
      password,
      displayName: displayName || email.split('@')[0],
      emailVerified: false
    });

    console.log('‚úÖ [ADMIN] Usuario creado en Firebase Auth:', userRecord.uid);

    // Crear documento en Firestore
    const defaultLocation = await getDefaultUserLocation();
    const userData = {
      email,
      displayName: displayName || email.split('@')[0],
      role: role, // 'admin' por defecto
      isAdmin: isAdminUser, // true por defecto
      isActive: true,
      photoURL: null,
      childrenCount: 0,
      ...defaultLocation,
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLoginAt: null
    };

    await db.collection('users').doc(userRecord.uid).set(userData);

    console.log('‚úÖ [ADMIN] Usuario creado en Firestore');

    res.json({
      success: true,
      message: 'Usuario administrador creado exitosamente',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userData.displayName,
        role: userData.role,
        isAdmin: userData.isAdmin,
        createdAt: userData.createdAt
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando usuario:', error);
    
    let errorMessage = 'Error creando usuario';
    if (error.code === 'auth/email-already-exists') {
      errorMessage = 'El email ya est√° registrado';
    } else if (error.code === 'auth/invalid-email') {
      errorMessage = 'Email inv√°lido';
    } else if (error.code === 'auth/weak-password') {
      errorMessage = 'La contrase√±a es muy d√©bil';
    }

    res.status(500).json({
      success: false,
      message: errorMessage,
      error: error.message
    });
  }
});

// Obtener detalle de un usuario espec√≠fico
app.get('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    
    console.log('üë§ [ADMIN] Obteniendo detalle del usuario:', userId);

    // Obtener usuario de Firestore
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Obtener hijos del usuario
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', userId)
      .get();
    
    const children = childrenSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Obtener comunidades del usuario
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', userId)
      .get();
    
    const communities = communitiesSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name
    }));

    // Obtener posts del usuario
    const postsSnapshot = await db.collection('posts')
      .where('authorId', '==', userId)
      .orderBy('createdAt', 'desc')
      .limit(10)
      .get();
    
    const posts = postsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: {
        user: {
          id: userDoc.id,
          ...userDoc.data(),
          createdAt: userDoc.data().createdAt?.toDate(),
          updatedAt: userDoc.data().updatedAt?.toDate(),
          lastLoginAt: userDoc.data().lastLoginAt?.toDate()
        },
        children,
        communities,
        posts,
        stats: {
          childrenCount: children.length,
          communitiesCount: communities.length,
          postsCount: postsSnapshot.size
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalle del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle del usuario',
      error: error.message
    });
  }
});

// Actualizar usuario (admin puede modificar cualquier campo)
app.put('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const updates = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Actualizando usuario:', userId, updates);

    // Verificar que el usuario existe
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Preparar datos de actualizaci√≥n
    const updateData = {
      ...updates,
      updatedAt: new Date()
    };

    // No permitir actualizar ciertos campos cr√≠ticos
    delete updateData.uid;
    delete updateData.createdAt;

    // Actualizar en Firestore
    await db.collection('users').doc(userId).update(updateData);

    // Si se actualiza el email o displayName, tambi√©n actualizar en Firebase Auth
    if (updates.email || updates.displayName) {
      const authUpdates = {};
      if (updates.email) authUpdates.email = updates.email;
      if (updates.displayName) authUpdates.displayName = updates.displayName;
      
      try {
        await auth.updateUser(userId, authUpdates);
      } catch (authError) {
        console.log('‚ö†Ô∏è [ADMIN] No se pudo actualizar Firebase Auth:', authError.message);
      }
    }

    res.json({
      success: true,
      message: 'Usuario actualizado exitosamente',
      data: {
        id: userId,
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando usuario',
      error: error.message
    });
  }
});

// Desactivar/activar usuario
app.patch('/api/admin/users/:userId/toggle-active', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    
    console.log('üîÑ [ADMIN] Cambiando estado del usuario:', userId);

    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const currentState = userDoc.data().isActive !== false; // Por defecto true
    const newState = !currentState;

    // Actualizar en Firestore
    await db.collection('users').doc(userId).update({
      isActive: newState,
      updatedAt: new Date()
    });

    // Actualizar en Firebase Auth
    try {
      await auth.updateUser(userId, {
        disabled: !newState
      });
    } catch (authError) {
      console.log('‚ö†Ô∏è [ADMIN] No se pudo actualizar Firebase Auth:', authError.message);
    }

    res.json({
      success: true,
      message: `Usuario ${newState ? 'activado' : 'desactivado'} exitosamente`,
      data: {
        isActive: newState
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error cambiando estado del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error cambiando estado del usuario',
      error: error.message
    });
  }
});

// Eliminar usuario (soft delete)
app.delete('/api/admin/users/:userId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userId } = req.params;
    const { permanent = false } = req.query;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando usuario:', userId, 'Permanente:', permanent);

    if (permanent === 'true') {
      // Eliminaci√≥n permanente
      await db.collection('users').doc(userId).delete();
      
      try {
        await auth.deleteUser(userId);
      } catch (authError) {
        console.log('‚ö†Ô∏è [ADMIN] No se pudo eliminar de Firebase Auth:', authError.message);
      }
      
      res.json({
        success: true,
        message: 'Usuario eliminado permanentemente'
      });
    } else {
      // Soft delete
      await db.collection('users').doc(userId).update({
        isActive: false,
        deletedAt: new Date(),
        updatedAt: new Date()
      });
      
      res.json({
        success: true,
        message: 'Usuario desactivado (soft delete)'
      });
    }

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando usuario',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE COMUNIDADES ==========

// Obtener todas las comunidades
app.get('/api/admin/communities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('üèòÔ∏è [ADMIN] Obteniendo comunidades');

    const snapshot = await db.collection('communities')
      .orderBy('createdAt', 'desc')
      .get();
    
    let communities = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      communities = communities.filter(comm => 
        comm.name?.toLowerCase().includes(searchLower) ||
        comm.description?.toLowerCase().includes(searchLower)
      );
    }

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedCommunities = communities.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedCommunities,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: communities.length,
        totalPages: Math.ceil(communities.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo comunidades:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades',
      error: error.message
    });
  }
});

// Crear nueva comunidad
app.post('/api/admin/communities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, imageUrl, isPrivate = false } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nueva comunidad:', name);

    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la comunidad es requerido'
      });
    }

    const communityData = {
      name,
      description: description || '',
      imageUrl: imageUrl || null,
      isPrivate,
      members: [req.user.uid], // El admin es el primer miembro
      createdBy: req.user.uid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      memberCount: 1,
      postCount: 0
    };

    const communityRef = await db.collection('communities').add(communityData);

    res.json({
      success: true,
      message: 'Comunidad creada exitosamente',
      data: {
        id: communityRef.id,
        ...communityData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comunidad',
      error: error.message
    });
  }
});

// Editar comunidad
app.put('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { name, description, imageUrl, isPrivate } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Editando comunidad:', communityId);

    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isPrivate !== undefined) updateData.isPrivate = isPrivate;

    await communityRef.update(updateData);

    res.json({
      success: true,
      message: 'Comunidad actualizada exitosamente',
      data: {
        id: communityId,
        ...communityDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error editando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando comunidad',
      error: error.message
    });
  }
});

// Obtener detalle de una comunidad espec√≠fica con sus posts
app.get('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('üèòÔ∏è [ADMIN] Obteniendo detalle de comunidad:', communityId);

    // Obtener datos de la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    // Obtener posts de la comunidad
    const postsSnapshot = await db.collection('posts')
      .where('communityId', '==', communityId)
      .orderBy('createdAt', 'desc')
      .get();
    
    const allPosts = postsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedPosts = allPosts.slice(startIndex, endIndex);

    // Obtener informaci√≥n de miembros
    const communityData = communityDoc.data();
    const memberCount = communityData.members?.length || 0;

    res.json({
      success: true,
      data: {
        community: {
          id: communityDoc.id,
          ...communityData,
          createdAt: communityData.createdAt?.toDate(),
          updatedAt: communityData.updatedAt?.toDate()
        },
        posts: paginatedPosts,
        stats: {
          totalPosts: allPosts.length,
          memberCount: memberCount
        },
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: allPosts.length,
          totalPages: Math.ceil(allPosts.length / limit)
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalle de comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de comunidad',
      error: error.message
    });
  }
});

// Obtener miembros de una comunidad
app.get('/api/admin/communities/:communityId/members', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('üë• [ADMIN] Obteniendo miembros de comunidad:', communityId);

    // Obtener la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    const memberIds = communityData.members || [];

    if (memberIds.length === 0) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          page: 1,
          limit: parseInt(limit),
          total: 0,
          totalPages: 0
        }
      });
    }

    // Obtener informaci√≥n detallada de cada miembro
    const memberPromises = memberIds.map(async (memberId) => {
      try {
        const userDoc = await db.collection('users').doc(memberId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          return {
            id: userDoc.id,
            displayName: userData.displayName || 'Sin nombre',
            email: userData.email || null,
            photoURL: userData.photoURL || null,
            isActive: userData.isActive !== false,
            createdAt: userData.createdAt?.toDate(),
            lastLoginAt: userData.lastLoginAt?.toDate()
          };
        }
        return null;
      } catch (error) {
        console.error(`Error obteniendo usuario ${memberId}:`, error);
        return null;
      }
    });

    const allMembers = (await Promise.all(memberPromises)).filter(m => m !== null);

    // Ordenar por displayName
    allMembers.sort((a, b) => {
      const nameA = a.displayName?.toLowerCase() || '';
      const nameB = b.displayName?.toLowerCase() || '';
      return nameA.localeCompare(nameB);
    });

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedMembers = allMembers.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedMembers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: allMembers.length,
        totalPages: Math.ceil(allMembers.length / limit)
      },
      communityInfo: {
        id: communityId,
        name: communityData.name,
        memberCount: allMembers.length
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo miembros:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo miembros de la comunidad',
      error: error.message
    });
  }
});

// Eliminar comunidad
app.delete('/api/admin/communities/:communityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { communityId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando comunidad:', communityId);

    await db.collection('communities').doc(communityId).delete();

    res.json({
      success: true,
      message: 'Comunidad eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comunidad',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE HIJOS ==========

// Obtener todos los hijos
app.get('/api/admin/children', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('üë∂ [ADMIN] Obteniendo hijos');

    const snapshot = await db.collection('children')
      .orderBy('createdAt', 'desc')
      .get();
    
    let children = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate(),
      registeredAt: doc.data().registeredAt?.toDate()
    }));

    // Filtrar por b√∫squeda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      children = children.filter(child => 
        child.name?.toLowerCase().includes(searchLower) ||
        child.parentId?.toLowerCase().includes(searchLower)
      );
    }

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedChildren = children.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedChildren,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: children.length,
        totalPages: Math.ceil(children.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hijos',
      error: error.message
    });
  }
});

// Obtener un hijo espec√≠fico
app.get('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    
    console.log('üë∂ [ADMIN] Obteniendo hijo:', childId);

    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();

    // Obtener informaci√≥n del padre
    let parentInfo = null;
    if (childData.parentId) {
      try {
        const parentDoc = await db.collection('users').doc(childData.parentId).get();
        if (parentDoc.exists) {
          const parentData = parentDoc.data();
          parentInfo = {
            uid: childData.parentId,
            displayName: parentData.displayName || 'Usuario',
            email: parentData.email,
            photoURL: parentData.photoURL || null
          };
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [ADMIN] Error obteniendo info del padre:', childData.parentId);
      }
    }

    res.json({
      success: true,
      data: {
        id: childDoc.id,
        ...childData,
        parent: parentInfo,
        createdAt: childData.createdAt?.toDate(),
        updatedAt: childData.updatedAt?.toDate(),
        registeredAt: childData.registeredAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hijo',
      error: error.message
    });
  }
});

// Editar hijo (admin puede editar cualquier hijo)
app.put('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento
      dueDate,          // Nuevo: fecha esperada de parto
      isUnborn, 
      photoUrl,
      // Legacy
      ageInMonths, 
      gestationWeeks 
    } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Editando hijo:', childId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const currentData = childDoc.data();
    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (photoUrl !== undefined) updateData.photoUrl = photoUrl;
    if (isUnborn !== undefined) updateData.isUnborn = isUnborn;

    // Determinar el estado final de isUnborn
    const finalIsUnborn = isUnborn !== undefined ? isUnborn : currentData.isUnborn;

    // Manejar actualizaci√≥n de fechas/edades seg√∫n el estado
    if (finalIsUnborn) {
      // Es un beb√© no nacido
      if (dueDate) {
        updateData.dueDate = new Date(dueDate);
        updateData.gestationWeeks = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
      } else if (gestationWeeks !== undefined) {
        // Legacy: usar semanas de gestaci√≥n
        if (gestationWeeks < 1 || gestationWeeks > 42) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaci√≥n deben estar entre 1 y 42'
      });
    }
        updateData.gestationWeeks = parseInt(gestationWeeks);
        updateData.dueDate = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
        updateData.registeredAt = new Date();
      }
    } else {
      // Es un beb√© nacido
      if (birthDate) {
        updateData.birthDate = new Date(birthDate);
        updateData.ageInMonths = null;
        updateData.dueDate = null;
        updateData.gestationWeeks = null;
      } else if (ageInMonths !== undefined) {
        // Legacy: usar edad en meses
        if (ageInMonths < 0) {
      return res.status(400).json({
        success: false,
        message: 'La edad en meses debe ser mayor o igual a 0'
      });
    }
        updateData.ageInMonths = parseInt(ageInMonths);
        updateData.birthDate = null;
        updateData.dueDate = null;
      updateData.gestationWeeks = null;
        updateData.registeredAt = new Date();
      }
    }

    await db.collection('children').doc(childId).update(updateData);

    // Obtener el hijo actualizado con informaci√≥n calculada
    const updatedChildDoc = await db.collection('children').doc(childId).get();
    const updatedChild = getChildCurrentInfo({ id: childId, ...updatedChildDoc.data() });

    res.json({
      success: true,
      message: 'Hijo actualizado exitosamente',
      data: updatedChild
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error editando hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando hijo',
      error: error.message
    });
  }
});

// Eliminar hijo (admin puede eliminar cualquier hijo)
app.delete('/api/admin/children/:childId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { childId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando hijo:', childId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    const parentId = childData.parentId;

    // Eliminar el hijo
    await db.collection('children').doc(childId).delete();

    // Actualizar el contador de hijos del padre (solo si el padre existe)
    if (parentId) {
      try {
        // Verificar que el usuario padre existe
        const parentDoc = await db.collection('users').doc(parentId).get();
        
        if (parentDoc.exists) {
          const childrenSnapshot = await db.collection('children')
            .where('parentId', '==', parentId)
            .get();
          
          const actualChildrenCount = childrenSnapshot.size;
          
          await db.collection('users').doc(parentId).update({
            childrenCount: actualChildrenCount,
            updatedAt: new Date()
          });
          
          console.log(`‚úÖ [ADMIN] Contador de hijos actualizado para usuario ${parentId}: ${actualChildrenCount}`);
        } else {
          console.log(`‚ö†Ô∏è [ADMIN] Usuario padre ${parentId} no encontrado, no se actualizar√° el contador`);
        }
      } catch (updateError) {
        // Si falla la actualizaci√≥n del padre, solo lo registramos pero no fallamos la operaci√≥n
        console.error('‚ö†Ô∏è [ADMIN] Error actualizando contador del padre:', updateError.message);
      }
    }

    res.json({
      success: true,
      message: 'Hijo eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hijo',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE POSTS ==========

// Obtener todos los posts
app.get('/api/admin/posts', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    
    console.log('üìù [ADMIN] Obteniendo posts');

    const snapshot = await db.collection('posts')
      .orderBy('createdAt', 'desc')
      .get();
    
    const posts = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedPosts = posts.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedPosts,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: posts.length,
        totalPages: Math.ceil(posts.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo posts:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo posts',
      error: error.message
    });
  }
});

// Crear nuevo post
app.post('/api/admin/posts', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { content, imageUrl, communityId, attachedLists = [] } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nuevo post');

    if (!content) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del post es requerido'
      });
    }

    if (!communityId) {
      return res.status(400).json({
        success: false,
        message: 'El ID de la comunidad es requerido'
      });
    }

    // Verificar que la comunidad existe
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    // Validar y verificar que las listas existen
    const validatedLists = [];
    if (attachedLists && Array.isArray(attachedLists) && attachedLists.length > 0) {
      console.log(`üìã [ADMIN] Validando ${attachedLists.length} listas adjuntas`);
      
      for (const listId of attachedLists) {
        try {
          const listDoc = await db.collection('lists').doc(listId).get();
          
          if (!listDoc.exists) {
            console.warn(`‚ö†Ô∏è [ADMIN] Lista no encontrada: ${listId}`);
            continue;
          }

          const listData = listDoc.data();
          validatedLists.push({
            id: listId,
            title: listData.title,
            description: listData.description || '',
            imageUrl: listData.imageUrl || null,
            isPublic: listData.isPublic,
            totalItems: listData.totalItems || 0,
            completedItems: listData.completedItems || 0
          });
          console.log(`‚úÖ [ADMIN] Lista validada: ${listData.title}`);
        } catch (error) {
          console.error(`‚ùå [ADMIN] Error validando lista ${listId}:`, error.message);
        }
      }
    }

    const postData = {
      content,
      authorId: req.user.uid,
      communityId,
      isPinned: false,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      likes: [],
      commentCount: 0
    };

    // Solo agregar imageUrl si se proporciona
    if (imageUrl) {
      postData.imageUrl = imageUrl;
    }

    // Agregar listas adjuntas si hay
    if (validatedLists.length > 0) {
      postData.attachedLists = validatedLists;
      console.log(`üìã [ADMIN] ${validatedLists.length} listas adjuntadas al post`);
    }

    const postRef = await db.collection('posts').add(postData);

    // Incrementar el contador de posts en la comunidad
    await db.collection('communities').doc(communityId).update({
      postCount: admin.firestore.FieldValue.increment(1)
    });

    console.log('‚úÖ [ADMIN] Post creado exitosamente:', postRef.id);

    // Enviar notificaciones push a todos los miembros de la comunidad
    try {
      const communityData = communityDoc.data();
      const authorDoc = await db.collection('users').doc(req.user.uid).get();
      const authorData = authorDoc.exists ? authorDoc.data() : {};
      const authorName = authorData.displayName || authorData.name || 'Administrador';
      const communityName = communityData.name || 'la comunidad';

      // Obtener tokens de todos los miembros (incluyendo al admin autor, si es miembro)
      const membersToNotify = communityData.members || [];
      
      if (membersToNotify.length > 0) {
        console.log(`üì§ [ADMIN] Enviando notificaci√≥n de nueva publicaci√≥n a ${membersToNotify.length} miembros`);
        
        const tokensPromises = membersToNotify.map(async (memberId) => {
          try {
            const memberDoc = await db.collection('users').doc(memberId).get();
            if (memberDoc.exists) {
              const memberData = memberDoc.data();
              return { userId: memberId, tokens: memberData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo tokens del miembro ${memberId}:`, error.message);
          }
          return { userId: memberId, tokens: [] };
        });
        
        const usersWithTokens = await Promise.all(tokensPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);
        
        if (allTokens.length > 0) {
          const notification = {
            title: `üì¢ ${authorName} public√≥ en ${communityName}`,
            body: content.length > 100 ? content.substring(0, 100) + '...' : content
          };

          const notificationData = {
            type: 'community_post',
            postId: postRef.id,
            communityId: communityId,
            communityName: communityName,
            authorId: req.user.uid,
            authorName: authorName,
            screen: 'CommunityPostScreen'
          };

          const pushResult = await sendPushNotification(allTokens, notification, notificationData);
          console.log(`‚úÖ [ADMIN] Notificaciones enviadas: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

          // Guardar notificaciones en Firestore para cada usuario
          const batch = db.batch();
          usersWithTokens.forEach(userWithTokens => {
            if (userWithTokens.tokens.length > 0) {
              const notifRef = db.collection('notifications').doc();
              batch.set(notifRef, {
                userId: userWithTokens.userId,
                type: 'community_post',
                title: notification.title,
                body: notification.body,
                data: notificationData,
                read: false,
                createdAt: admin.firestore.Timestamp.fromDate(new Date())
              });
            }
          });
          await batch.commit();
          console.log(`‚úÖ [ADMIN] ${membersToNotify.length} notificaciones guardadas en Firestore`);
        } else {
          console.log('‚ö†Ô∏è [ADMIN] Ning√∫n miembro tiene tokens FCM registrados');
        }
      } else {
        console.log('‚ö†Ô∏è [ADMIN] La comunidad no tiene miembros para notificar');
      }
    } catch (notificationError) {
      console.error('‚ùå [ADMIN] Error enviando notificaciones de nueva publicaci√≥n:', notificationError);
      // No fallar la creaci√≥n del post si falla la notificaci√≥n
    }

    res.json({
      success: true,
      message: 'Post creado exitosamente',
      data: {
        id: postRef.id,
        ...postData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando post',
      error: error.message
    });
  }
});

// Editar post
app.put('/api/admin/posts/:postId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { content, imageUrl, attachedLists } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Editando post:', postId);

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (content !== undefined) updateData.content = content;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;

    // Actualizar listas adjuntas si se env√≠an
    if (attachedLists !== undefined) {
      console.log(`üìã [ADMIN] attachedLists recibido:`, attachedLists);
      
      if (attachedLists === null || (Array.isArray(attachedLists) && attachedLists.length === 0)) {
        // Remover listas si se env√≠a null o array vac√≠o
        updateData.attachedLists = admin.firestore.FieldValue.delete();
        console.log('üóëÔ∏è [ADMIN] Removiendo listas adjuntas del post');
      } else if (Array.isArray(attachedLists)) {
        // Validar y verificar que las listas existen
        const validatedLists = [];
        console.log(`üìã [ADMIN] Validando ${attachedLists.length} listas adjuntas`);
        
        for (const listId of attachedLists) {
          console.log(`üîç [ADMIN] Buscando lista: ${listId}`);
          try {
            const listDoc = await db.collection('lists').doc(listId).get();
            
            if (!listDoc.exists) {
              console.warn(`‚ö†Ô∏è [ADMIN] Lista no encontrada: ${listId}`);
              continue;
            }

            const listData = listDoc.data();
            validatedLists.push({
              id: listId,
              title: listData.title,
              description: listData.description || '',
              imageUrl: listData.imageUrl || null,
              isPublic: listData.isPublic,
              totalItems: listData.totalItems || 0,
              completedItems: listData.completedItems || 0
            });
            console.log(`‚úÖ [ADMIN] Lista validada: ${listData.title}`);
          } catch (error) {
            console.error(`‚ùå [ADMIN] Error validando lista ${listId}:`, error.message);
          }
        }
        
        if (validatedLists.length > 0) {
          updateData.attachedLists = validatedLists;
          console.log(`üìã [ADMIN] ${validatedLists.length} listas ser√°n actualizadas en el post`);
        } else {
          console.warn(`‚ö†Ô∏è [ADMIN] Ninguna lista fue validada. No se actualizar√°n listas.`);
        }
      }
    }

    console.log(`üíæ [ADMIN] Actualizando post con datos:`, JSON.stringify(updateData, null, 2));
    await postRef.update(updateData);

    // Obtener el documento actualizado
    const updatedPostDoc = await postRef.get();
    const updatedData = updatedPostDoc.data();

    console.log(`‚úÖ [ADMIN] Post actualizado. attachedLists:`, updatedData.attachedLists);

    res.json({
      success: true,
      message: 'Post actualizado exitosamente',
      data: {
        id: postId,
        ...updatedData,
        createdAt: updatedData.createdAt?.toDate?.(),
        updatedAt: updatedData.updatedAt?.toDate?.()
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error editando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando post',
      error: error.message
    });
  }
});

// Eliminar post
app.delete('/api/admin/posts/:postId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando post:', postId);

    await db.collection('posts').doc(postId).delete();

    res.json({
      success: true,
      message: 'Post eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando post',
      error: error.message
    });
  }
});

// Fijar/Desfijar post (Pin/Unpin)
app.patch('/api/admin/posts/:postId/pin', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { isPinned } = req.body;
    
    if (isPinned === undefined) {
      return res.status(400).json({
        success: false,
        message: 'El campo isPinned es requerido'
      });
    }

    console.log(`üìå [ADMIN] ${isPinned ? 'Fijando' : 'Desfijando'} post:`, postId);

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    await postRef.update({
      isPinned: isPinned,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    console.log(`‚úÖ [ADMIN] Post ${isPinned ? 'fijado' : 'desfijado'} exitosamente`);

    res.json({
      success: true,
      message: `Post ${isPinned ? 'fijado' : 'desfijado'} exitosamente`,
      data: {
        id: postId,
        isPinned: isPinned
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error fijando/desfijando post:', error);
    res.status(500).json({
      success: false,
      message: 'Error al fijar/desfijar post',
      error: error.message
    });
  }
});

// Obtener comentarios de un post
app.get('/api/admin/posts/:postId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('üí¨ [ADMIN] Obteniendo comentarios del post:', postId);

    // Obtener todos los comentarios del post
    const commentsSnapshot = await db.collection('comments')
      .where('postId', '==', postId)
      .get();

    const comments = [];
    for (const doc of commentsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaci√≥n del autor del comentario
      let authorInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.authorId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          authorInfo = {
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [ADMIN] Error obteniendo info del autor:', data.authorId);
        authorInfo = {
          displayName: 'Usuario',
          email: null,
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        postId: data.postId,
        authorId: data.authorId,
        author: authorInfo,
        content: data.content,
        likeCount: data.likeCount || 0,
        likes: data.likes || [],
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (m√°s recientes primero)
    comments.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = comments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: comments.length,
        totalPages: Math.ceil(comments.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo comentarios del post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Obtener likes de un post
app.get('/api/admin/posts/:postId/likes', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('‚ù§Ô∏è [ADMIN] Obteniendo likes del post:', postId);

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();
    
    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Post no encontrado'
      });
    }

    const postData = postDoc.data();
    const likes = postData.likes || [];
    const likeCount = postData.likeCount || 0;

    console.log('üìä [ADMIN] Total likes:', likeCount);

    // Obtener informaci√≥n de los usuarios que dieron like
    const likesWithUserInfo = [];
    for (const userId of likes) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          likesWithUserInfo.push({
            userId: userId,
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          });
        } else {
          likesWithUserInfo.push({
            userId: userId,
            displayName: 'Usuario desconocido',
            email: null,
            photoURL: null
          });
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [ADMIN] Error obteniendo info del usuario:', userId);
        likesWithUserInfo.push({
          userId: userId,
          displayName: 'Usuario',
          email: null,
          photoURL: null
        });
      }
    }

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedLikes = likesWithUserInfo.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedLikes,
      stats: {
        totalLikes: likeCount
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: likesWithUserInfo.length,
        totalPages: Math.ceil(likesWithUserInfo.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo likes del post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo likes',
      error: error.message
    });
  }
});

// Eliminar comentario de un post
app.delete('/api/admin/posts/:postId/comments/:commentId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { postId, commentId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando comentario:', commentId, 'del post:', postId);

    // Eliminar el comentario
    await db.collection('comments').doc(commentId).delete();

    // Decrementar el contador de comentarios en el post
    const postRef = db.collection('posts').doc(postId);
    await postRef.update({
      commentCount: admin.firestore.FieldValue.increment(-1)
    });

    res.json({
      success: true,
      message: 'Comentario eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comentario',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE CATEGOR√çAS ==========

// ===== ENDPOINTS PARA LA APP =====

// ============================================================================
// üåé LOCATIONS (PA√çSES Y CIUDADES)
// ============================================================================

const resolveCountryCity = async (countryId, cityId) => {
  const resolved = {
    countryId: countryId ? String(countryId).trim() : null,
    countryName: null,
    cityId: cityId ? String(cityId).trim() : null,
    cityName: null
  };

  let countryDoc = null;
  if (resolved.countryId) {
    countryDoc = await db.collection('countries').doc(resolved.countryId).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      throw new Error('Pa√≠s no encontrado o inactivo');
    }
    resolved.countryName = countryDoc.data().name || null;
  }

  if (resolved.cityId) {
    const cityDoc = await db.collection('cities').doc(resolved.cityId).get();
    if (!cityDoc.exists || cityDoc.data().isActive === false) {
      throw new Error('Ciudad no encontrada o inactiva');
    }
    const cityData = cityDoc.data();
    resolved.cityName = cityData.name || null;
    if (cityData.countryId) {
      if (resolved.countryId && cityData.countryId !== resolved.countryId) {
        throw new Error('La ciudad no pertenece al pa√≠s seleccionado');
      }
      resolved.countryId = cityData.countryId;
      if (!resolved.countryName) {
        const derivedCountryDoc = await db.collection('countries').doc(cityData.countryId).get();
        if (!derivedCountryDoc.exists || derivedCountryDoc.data().isActive === false) {
          throw new Error('Pa√≠s no encontrado o inactivo');
        }
        resolved.countryName = derivedCountryDoc.data().name || null;
      }
    }
  }

  return resolved;
};

const buildLocationFields = (data) => ({
  countryId: data.countryId || null,
  countryName: data.countryName || null,
  cityId: data.cityId || null,
  cityName: data.cityName || null
});

const DEFAULT_COUNTRY_NAME = 'Ecuador';
const DEFAULT_CITY_NAME = 'Quito';

const getDefaultUserLocation = async () => {
  if (!db) {
    return {
      countryId: null,
      countryName: DEFAULT_COUNTRY_NAME,
      cityId: null,
      cityName: DEFAULT_CITY_NAME
    };
  }

  let countryId = null;
  let cityId = null;
  let countryName = DEFAULT_COUNTRY_NAME;
  let cityName = DEFAULT_CITY_NAME;

  const countrySnapshot = await db.collection('countries')
    .where('name', '==', DEFAULT_COUNTRY_NAME)
    .limit(1)
    .get();
  if (!countrySnapshot.empty) {
    countryId = countrySnapshot.docs[0].id;
  } else {
    const ref = await db.collection('countries').add({
      name: DEFAULT_COUNTRY_NAME,
      isActive: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    countryId = ref.id;
  }

  const citySnapshot = await db.collection('cities')
    .where('name', '==', DEFAULT_CITY_NAME)
    .where('countryId', '==', countryId)
    .limit(1)
    .get();
  if (!citySnapshot.empty) {
    cityId = citySnapshot.docs[0].id;
  } else {
    const ref = await db.collection('cities').add({
      name: DEFAULT_CITY_NAME,
      countryId,
      isActive: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    cityId = ref.id;
  }

  return {
    countryId,
    countryName,
    cityId,
    cityName
  };
};

const filterRecommendationsByLocation = ({
  items,
  userLat,
  userLng,
  cityId,
  countryId,
  maxDistanceKm = 100
}) => {
  const normalizedCityId = cityId ? String(cityId).trim() : null;
  const normalizedCountryId = countryId ? String(countryId).trim() : null;
  const cappedMax = Math.min(Math.max(Number(maxDistanceKm) || 100, 1), 100);
  const hasCoords = Number.isFinite(userLat) && Number.isFinite(userLng);

  const withDistance = hasCoords
    ? items.map(item => {
        if (item.latitude && item.longitude) {
          const distance = calculateDistance(userLat, userLng, item.latitude, item.longitude);
          return {
            ...item,
            distance: Math.round(distance * 10) / 10
          };
        }
        return { ...item };
      })
    : items.map(item => ({ ...item }));

  const baseList = items;
  const isGlobal = (item) => !item.countryId;
  const isCountryMatch = (item) => normalizedCountryId && String(item.countryId || '') === normalizedCountryId;
  const isCityMatch = (item) => normalizedCityId && String(item.cityId || '') === normalizedCityId;
  if (hasCoords) {
    const nearby = withDistance.filter(item => typeof item.distance === 'number' && item.distance <= cappedMax);
    if (nearby.length > 0) {
      const ids = new Set(nearby.map(item => item.id));
      let extra = [];
      if (normalizedCityId) {
        extra = baseList.filter(item =>
          !ids.has(item.id) && (isCityMatch(item) || (!item.cityId && isCountryMatch(item)) || isGlobal(item))
        );
      } else if (normalizedCountryId) {
        extra = baseList.filter(item =>
          !ids.has(item.id) && (isCountryMatch(item) || isGlobal(item))
        );
      } else {
        extra = baseList.filter(item => !ids.has(item.id) && isGlobal(item));
      }
      return nearby.concat(extra);
    }
  }

  if (normalizedCityId) {
    const cityMatches = baseList.filter(item =>
      isCityMatch(item) || (!item.cityId && isCountryMatch(item)) || isGlobal(item)
    );
    if (cityMatches.length > 0) return cityMatches;
  }

  if (normalizedCountryId) {
    const countryMatches = baseList.filter(item => isCountryMatch(item) || isGlobal(item));
    if (countryMatches.length > 0) return countryMatches;
  }

  return [];
};

const reverseGeocode = async (latitude, longitude) => {
  const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(latitude)}&lon=${encodeURIComponent(longitude)}&zoom=10&addressdetails=1`;
  const response = await fetch(url, {
    headers: {
      'User-Agent': 'munpa-backend/1.0 (support@munpa.online)'
    }
  });
  if (!response.ok) {
    throw new Error('No se pudo resolver la ubicaci√≥n');
  }
  const data = await response.json();
  const address = data.address || {};
  const city = address.city || address.town || address.village || address.municipality || address.state_district || null;
  const country = address.country || null;
  return { city, country, raw: address };
};

const getUserLocationFromProfile = async (userId) => {
  if (!db) return {};
  const userDoc = await db.collection('users').doc(userId).get();
  if (!userDoc.exists) return {};
  const data = userDoc.data();
  const baseLocation = {
    latitude: data.latitude ?? null,
    longitude: data.longitude ?? null,
    cityId: data.cityId || null,
    countryId: data.countryId || null
  };
  if (!baseLocation.countryId || !baseLocation.cityId) {
    const defaultLocation = await getDefaultUserLocation();
    return {
      ...baseLocation,
      countryId: baseLocation.countryId || defaultLocation.countryId,
      cityId: baseLocation.cityId || defaultLocation.cityId,
      countryName: data.countryName || defaultLocation.countryName,
      cityName: data.cityName || defaultLocation.cityName
    };
  }
  return baseLocation;
};

const getUserCountryForMarketplace = async (userId) => {
  const location = await getUserLocationFromProfile(userId);
  if (!location.countryId) {
    const defaultLocation = await getDefaultUserLocation();
    return defaultLocation;
  }
  return location;
};

const normalizeMarketplaceLocation = (data) => {
  const location = data.location ? { ...data.location } : null;
  if (location) {
    if (data.cityName) location.city = data.cityName;
    if (data.countryName) location.country = data.countryName;
  }
  return location;
};

const getCategoriesMap = async () => {
  if (!db) return new Map();
  const cacheKey = 'categories_map';
  const cached = getCachedResponse(cacheKey);
  if (cached) return cached;

  const snapshot = await db.collection('categories').get();
  const map = new Map();
  snapshot.forEach(doc => {
    const data = doc.data();
    map.set(doc.id, {
      id: doc.id,
      name: data.name,
      icon: data.icon,
      imageUrl: data.imageUrl
    });
  });

  setCachedResponse(cacheKey, map, 10 * 60 * 1000);
  return map;
};

// ===== ENDPOINTS APP (LECTURA) =====

app.get('/api/locations/countries', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('countries')
      .where('isActive', '==', true)
      .orderBy('name', 'asc')
      .get();

    const countries = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name
    }));

    res.json({ success: true, data: countries });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error obteniendo pa√≠ses:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo pa√≠ses', error: error.message });
  }
});

app.get('/api/locations/cities', authenticateToken, async (req, res) => {
  try {
    const { countryId } = req.query;
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const snapshot = await db.collection('cities')
      .where('countryId', '==', String(countryId))
      .where('isActive', '==', true)
      .orderBy('name', 'asc')
      .get();

    const cities = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      countryId: doc.data().countryId
    }));

    res.json({ success: true, data: cities });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error obteniendo ciudades:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo ciudades', error: error.message });
  }
});

// Resolver ciudad y pa√≠s desde lat/long (app)
app.get('/api/locations/reverse', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude } = req.query;
    if (!latitude || !longitude) {
      return res.status(400).json({ success: false, message: 'latitude y longitude son requeridos' });
    }

    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      return res.status(400).json({ success: false, message: 'latitude y longitude deben ser n√∫meros v√°lidos' });
    }

    const result = await reverseGeocode(lat, lng);
    res.json({
      success: true,
      data: {
        latitude: lat,
        longitude: lng,
        city: result.city,
        country: result.country
      }
    });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error reverse geocode:', error);
    res.status(500).json({ success: false, message: 'Error resolviendo ubicaci√≥n', error: error.message });
  }
});

// ===== ENDPOINTS ADMIN (CRUD) =====

app.post('/api/admin/locations/countries', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, isActive = true } = req.body;
    if (!name || !String(name).trim()) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }

    const now = admin.firestore.FieldValue.serverTimestamp();
    const payload = {
      name: String(name).trim(),
      isActive: isActive === true || isActive === 'true',
      createdAt: now,
      updatedAt: now
    };

    const ref = await db.collection('countries').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error creando pa√≠s:', error);
    res.status(500).json({ success: false, message: 'Error creando pa√≠s', error: error.message });
  }
});

app.get('/api/admin/locations/countries', authenticateToken, isAdmin, async (req, res) => {
  try {
    const snapshot = await db.collection('countries').orderBy('name', 'asc').get();
    const countries = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: countries });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error obteniendo pa√≠ses (admin):', error);
    res.status(500).json({ success: false, message: 'Error obteniendo pa√≠ses', error: error.message });
  }
});

app.put('/api/admin/locations/countries/:countryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId } = req.params;
    const { name, isActive } = req.body;

    const ref = db.collection('countries').doc(countryId);
    const doc = await ref.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Pa√≠s no encontrado' });
    }

    const update = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };
    if (name !== undefined) update.name = String(name).trim();
    if (isActive !== undefined) update.isActive = isActive === true || isActive === 'true';

    await ref.update(update);
    res.json({ success: true, message: 'Pa√≠s actualizado' });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error actualizando pa√≠s:', error);
    res.status(500).json({ success: false, message: 'Error actualizando pa√≠s', error: error.message });
  }
});

app.post('/api/admin/locations/cities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, countryId, isActive = true } = req.body;
    if (!name || !String(name).trim()) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const countryDoc = await db.collection('countries').doc(String(countryId)).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      return res.status(400).json({ success: false, message: 'Pa√≠s no encontrado o inactivo' });
    }

    const now = admin.firestore.FieldValue.serverTimestamp();
    const payload = {
      name: String(name).trim(),
      countryId: String(countryId),
      isActive: isActive === true || isActive === 'true',
      createdAt: now,
      updatedAt: now
    };

    const ref = await db.collection('cities').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error creando ciudad:', error);
    res.status(500).json({ success: false, message: 'Error creando ciudad', error: error.message });
  }
});

app.get('/api/admin/locations/cities', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId } = req.query;
    let query = db.collection('cities');
    if (countryId) query = query.where('countryId', '==', String(countryId));
    const snapshot = await query.orderBy('name', 'asc').get();
    const cities = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: cities });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error obteniendo ciudades (admin):', error);
    res.status(500).json({ success: false, message: 'Error obteniendo ciudades', error: error.message });
  }
});

app.put('/api/admin/locations/cities/:cityId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { cityId } = req.params;
    const { name, countryId, isActive } = req.body;

    const ref = db.collection('cities').doc(cityId);
    const doc = await ref.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Ciudad no encontrada' });
    }

    const update = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };
    if (name !== undefined) update.name = String(name).trim();
    if (countryId !== undefined) {
      const countryDoc = await db.collection('countries').doc(String(countryId)).get();
      if (!countryDoc.exists || countryDoc.data().isActive === false) {
        return res.status(400).json({ success: false, message: 'Pa√≠s no encontrado o inactivo' });
      }
      update.countryId = String(countryId);
    }
    if (isActive !== undefined) update.isActive = isActive === true || isActive === 'true';

    await ref.update(update);
    res.json({ success: true, message: 'Ciudad actualizada' });
  } catch (error) {
    console.error('‚ùå [LOCATIONS] Error actualizando ciudad:', error);
    res.status(500).json({ success: false, message: 'Error actualizando ciudad', error: error.message });
  }
});

// Crear recomendaci√≥n (usuario app) - queda pendiente de aprobaci√≥n
app.post('/api/recommendations', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      countryId,
      cityId
    } = req.body;

    if (!categoryId || !name) {
      return res.status(400).json({
        success: false,
        message: 'categoryId y name son requeridos'
      });
    }

    // Verificar que la categor√≠a existe y est√° activa
    const categoryDoc = await db.collection('categories').doc(categoryId).get();
    if (!categoryDoc.exists || !categoryDoc.data().isActive) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a seleccionada no existe o est√° inactiva'
      });
    }

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({
        success: false,
        message: err.message
      });
    }

    const recommendationData = {
      categoryId,
      name: name.trim(),
      description: description ? description.trim() : '',
      address: address ? address.trim() : '',
      latitude: latitude !== undefined && latitude !== null ? parseFloat(latitude) : null,
      longitude: longitude !== undefined && longitude !== null ? parseFloat(longitude) : null,
      phone: phone ? phone.trim() : '',
      email: email ? email.trim() : '',
      website: website ? website.trim() : '',
      facebook: facebook ? facebook.trim() : '',
      instagram: instagram ? instagram.trim() : '',
      twitter: twitter ? twitter.trim() : '',
      whatsapp: whatsapp ? whatsapp.trim() : '',
      imageUrl: imageUrl || null,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      // Campos de control/moderaci√≥n
      isActive: false, // pendiente de aprobaci√≥n
      verified: false,
      status: 'pending',
      submittedBy: userId,
      submittedAt: admin.firestore.FieldValue.serverTimestamp(),
      // Stats iniciales
      totalReviews: 0,
      averageRating: 0,
      // Badges y features por defecto
      badges: [],
      features: {
        hasChangingTable: false,
        hasNursingRoom: false,
        hasParking: false,
        isStrollerAccessible: false,
        acceptsEmergencies: false,
        is24Hours: false
      },
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    const recRef = await db.collection('recommendations').add(recommendationData);

    console.log('‚úÖ [APP] Recomendaci√≥n creada (pending):', recRef.id);

    res.status(201).json({
      success: true,
      message: 'Recomendaci√≥n enviada para revisi√≥n',
      data: {
        id: recRef.id,
        ...recommendationData
      }
    });
  } catch (error) {
    console.error('‚ùå [APP] Error creando recomendaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando recomendaci√≥n',
      error: error.message
    });
  }
});

// ===== ENDPOINTS PARA LA APP (SOLO LECTURA) =====

// Obtener todas las categor√≠as activas (para la app)
app.get('/api/categories', authenticateToken, async (req, res) => {
  try {
    console.log('üìÇ [APP] Obteniendo categor√≠as');

    const snapshot = await db.collection('categories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .get();

    const categories = snapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      description: doc.data().description,
      imageUrl: doc.data().imageUrl,
      order: doc.data().order,
      icon: doc.data().icon
    }));

    res.json({
      success: true,
      data: categories
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Obtener una categor√≠a espec√≠fica (para la app)
app.get('/api/categories/:categoryId', authenticateToken, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('üìÇ [APP] Obteniendo categor√≠a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const categoryData = categoryDoc.data();

    if (!categoryData.isActive) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no disponible'
      });
    }

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        name: categoryData.name,
        description: categoryData.description,
        imageUrl: categoryData.imageUrl,
        order: categoryData.order,
        icon: categoryData.icon
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠a',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN (CRUD COMPLETO) =====

// Obtener todas las categor√≠as (admin)
app.get('/api/admin/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('üìÇ [ADMIN] Obteniendo categor√≠as');

    const snapshot = await db.collection('categories')
      .orderBy('order', 'asc')
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate(),
      updatedAt: doc.data().updatedAt?.toDate()
    }));

    // Filtrar por b√∫squeda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(category => 
        category.name?.toLowerCase().includes(searchLower) ||
        category.description?.toLowerCase().includes(searchLower)
      );
    }

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedCategories = categories.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedCategories,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: categories.length,
        totalPages: Math.ceil(categories.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Obtener una categor√≠a espec√≠fica (admin)
app.get('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('üìÇ [ADMIN] Obteniendo categor√≠a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const categoryData = categoryDoc.data();

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        ...categoryData,
        createdAt: categoryData.createdAt?.toDate(),
        updatedAt: categoryData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠a',
      error: error.message
    });
  }
});

// Crear nueva categor√≠a (admin)
app.post('/api/admin/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, imageUrl, icon, order, isActive = true } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nueva categor√≠a:', name);

    // Validaciones
    if (!name || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la categor√≠a es requerido'
      });
    }

    // Si no se proporciona orden, obtener el siguiente n√∫mero
    let categoryOrder = order;
    if (categoryOrder === undefined || categoryOrder === null) {
      const snapshot = await db.collection('categories').get();
      categoryOrder = snapshot.size;
    }

    const categoryData = {
      name: name.trim(),
      description: description ? description.trim() : '',
      imageUrl: imageUrl || null,
      icon: icon || null,
      order: parseInt(categoryOrder),
      isActive: isActive === true || isActive === 'true',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const categoryRef = await db.collection('categories').add(categoryData);

    console.log('‚úÖ [ADMIN] Categor√≠a creada:', categoryRef.id);

    res.json({
      success: true,
      message: 'Categor√≠a creada exitosamente',
      data: {
        id: categoryRef.id,
        ...categoryData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categor√≠a',
      error: error.message
    });
  }
});

// Actualizar categor√≠a (admin)
app.put('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const { name, description, imageUrl, icon, order, isActive } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Actualizando categor√≠a:', categoryId);

    const categoryRef = db.collection('categories').doc(categoryId);
    const categoryDoc = await categoryRef.get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (icon !== undefined) updateData.icon = icon;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive === true || isActive === 'true';

    await categoryRef.update(updateData);

    console.log('‚úÖ [ADMIN] Categor√≠a actualizada');

    res.json({
      success: true,
      message: 'Categor√≠a actualizada exitosamente',
      data: {
        id: categoryId,
        ...categoryDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categor√≠a',
      error: error.message
    });
  }
});

// Eliminar categor√≠a (admin)
app.delete('/api/admin/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando categor√≠a:', categoryId);

    const categoryDoc = await db.collection('categories').doc(categoryId).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    await db.collection('categories').doc(categoryId).delete();

    console.log('‚úÖ [ADMIN] Categor√≠a eliminada');

    res.json({
      success: true,
      message: 'Categor√≠a eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categor√≠a',
      error: error.message
    });
  }
});

// Reordenar categor√≠as (admin)
app.patch('/api/admin/categories/reorder', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categories } = req.body; // Array de { id, order }
    
    console.log('üîÑ [ADMIN] Reordenando categor√≠as');

    if (!Array.isArray(categories)) {
      return res.status(400).json({
        success: false,
        message: 'Se requiere un array de categor√≠as'
      });
    }

    const batch = db.batch();

    categories.forEach(({ id, order }) => {
      const categoryRef = db.collection('categories').doc(id);
      batch.update(categoryRef, { 
        order: parseInt(order),
        updatedAt: new Date()
      });
    });

    await batch.commit();

    console.log('‚úÖ [ADMIN] Categor√≠as reordenadas:', categories.length);

    res.json({
      success: true,
      message: 'Categor√≠as reordenadas exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error reordenando categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error reordenando categor√≠as',
      error: error.message
    });
  }
});

// ============================================================================
// üîó SISTEMA DE COMPARTIR - Links para Posts, Recomendaciones y Listas
// ============================================================================

// ===== ENDPOINTS P√öBLICOS PARA LINKS COMPARTIDOS =====

// Ver post compartido (p√∫blico - sin autenticaci√≥n)
app.get('/post/:postId', async (req, res) => {
  try {
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Obtener info del autor
    let authorName = 'Usuario';
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo autor:', error);
    }

    // Obtener info de la comunidad
    let communityName = 'Munpa';
    try {
      const communityDoc = await db.collection('communities').doc(postData.communityId).get();
      if (communityDoc.exists) {
        communityName = communityDoc.data().name || 'Munpa';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo comunidad:', error);
    }

    // Generar HTML para mostrar
    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${authorName} en ${communityName} - Munpa</title>
    <meta property="og:title" content="${authorName} en ${communityName}">
    <meta property="og:description" content="${postData.content.substring(0, 200)}">
    ${postData.imageUrl ? `<meta property="og:image" content="${postData.imageUrl}">` : ''}
    <meta property="og:type" content="article">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        .logo {
            font-size: 32px;
            margin-right: 12px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .community {
            color: #666;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .author {
            font-weight: 600;
            color: #6366f1;
            margin-bottom: 16px;
        }
        .content {
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }
        .image {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .button {
            display: inline-block;
            background: #6366f1;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: background 0.2s;
        }
        .button:hover {
            background: #4f46e5;
        }
        .stats {
            color: #666;
            font-size: 14px;
            margin-top: 16px;
        }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                // Intent scheme para Android
                window.location.href = 'intent://post/${postId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                // Deep link para iOS
                window.location.href = 'munpa://post/${postId}';
                // Fallback a App Store si no tiene la app
                setTimeout(() => {
                    // Si sigue aqu√≠ despu√©s de 2s, no tiene la app
                    // window.location.href = 'https://apps.apple.com/app/munpa/idXXXXXX';
                }, 2000);
            } else {
                // Desktop o desconocido
                window.location.href = 'munpa://post/${postId}';
            }
        }
        
        // Intentar abrir autom√°ticamente al cargar
        window.onload = function() {
            // Mostrar el bot√≥n inmediatamente y hacer auto-redirect
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üë∂</div>
            <div class="title">Munpa</div>
        </div>
        <div class="community">üì¢ ${communityName}</div>
        <div class="author">Por ${authorName}</div>
        ${postData.imageUrl ? `<img src="${postData.imageUrl}" alt="Imagen del post" class="image">` : ''}
        <div class="content">${postData.content}</div>
        <div class="stats">
            ‚ù§Ô∏è ${postData.likeCount || 0} likes ¬∑ üí¨ ${postData.commentCount || 0} comentarios
        </div>
        <br>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Abrir en Munpa üì±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('‚ùå [SHARE] Error mostrando post:', error);
    res.status(500).send(`
      <html>
        <body style="font-family: Arial; padding: 20px; text-align: center;">
          <h2>üòï Ups, algo sali√≥ mal</h2>
          <p>No pudimos cargar esta publicaci√≥n.</p>
          <a href="https://munpa.online" style="color: #6366f1;">Ir a Munpa</a>
        </body>
      </html>
    `);
  }
});

// Ver recomendaci√≥n compartida (p√∫blico)
app.get('/recommendation/:recommendationId', async (req, res) => {
  try {
    const { recommendationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendaci√≥n no encontrada'
      });
    }

    const recData = recommendationDoc.data();

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${recData.name || 'Recomendaci√≥n'} - Munpa</title>
    <meta property="og:title" content="${recData.name}">
    <meta property="og:description" content="${recData.description?.substring(0, 200) || 'Lugar recomendado'}">
    ${recData.imageUrl ? `<meta property="og:image" content="${recData.imageUrl}">` : ''}
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .logo { font-size: 32px; margin-bottom: 16px; }
        .title { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 8px; }
        .category { color: #6366f1; font-size: 14px; margin-bottom: 16px; }
        .image { width: 100%; border-radius: 8px; margin-bottom: 20px; }
        .description { font-size: 16px; line-height: 1.6; color: #555; margin-bottom: 20px; }
        .info { color: #666; font-size: 14px; margin: 8px 0; }
        .button { display: inline-block; background: #6366f1; color: white; padding: 12px 24px;
                 border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 16px; }
        .button:hover { background: #4f46e5; }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://recommendation/${recommendationId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://recommendation/${recommendationId}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://recommendation/${recommendationId}';
            }
        }
        
        window.onload = function() {
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">üë∂ Munpa</div>
        <div class="title">${recData.name || 'Recomendaci√≥n'}</div>
        <div class="category">üìç ${recData.categoryName || 'Lugar'}</div>
        ${recData.imageUrl ? `<img src="${recData.imageUrl}" alt="${recData.name}" class="image">` : ''}
        <div class="description">${recData.description || 'Lugar recomendado en Munpa'}</div>
        ${recData.address ? `<div class="info">üìç ${recData.address}</div>` : ''}
        ${recData.phone ? `<div class="info">üìû ${recData.phone}</div>` : ''}
        <div class="info">‚≠ê ${recData.averageRating || 0} (${recData.totalReviews || 0} rese√±as)</div>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Abrir en Munpa üì±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('‚ùå [SHARE] Error mostrando recomendaci√≥n:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// Ver invitaci√≥n para compartir hijo (p√∫blico)
app.get('/share-child/:token', async (req, res) => {
  try {
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaci√≥n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).send(`
        <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Invitaci√≥n no encontrada - Munpa</title>
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                     margin: 0; padding: 20px; background: #f5f5f5; display: flex; justify-content: center;
                     align-items: center; min-height: 100vh; text-align: center; }
              .container { max-width: 400px; background: white; border-radius: 12px; padding: 40px;
                           box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
              .emoji { font-size: 64px; margin-bottom: 20px; }
              h2 { color: #333; margin-bottom: 12px; }
              p { color: #666; line-height: 1.6; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="emoji">üòï</div>
              <h2>Invitaci√≥n no encontrada</h2>
              <p>Esta invitaci√≥n no existe o ya expir√≥.</p>
            </div>
          </body>
        </html>
      `);
    }

    const invitationData = invitationsSnapshot.docs[0].data();

    // Verificar si ya fue usada o expir√≥
    const now = new Date();
    const expiresAt = invitationData.expiresAt?.toDate?.() || invitationData.expiresAt;
    const isExpired = expiresAt && now > expiresAt;
    const isUsed = invitationData.status !== 'pending';

    // Obtener info del usuario que invit√≥
    let inviterName = 'Usuario';
    try {
      const inviterDoc = await db.collection('users').doc(invitationData.invitedBy).get();
      if (inviterDoc.exists) {
        const inviterData = inviterDoc.data();
        inviterName = inviterData.displayName || inviterData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo invitador:', error);
    }

    // Obtener info del hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    let childPhotoUrl = null;
    let childGender = null;
    if (childDoc.exists) {
      const childData = childDoc.data();
      childPhotoUrl = childData.photoUrl || null;
      childGender = childData.gender || null;
    }

    // Elegir emoji seg√∫n g√©nero o rol
    const defaultEmoji = childGender === 'ni√±a' ? 'üëß' : childGender === 'ni√±o' ? 'üë¶' : 'üë∂';
    const roleEmojis = {
      padre: 'üë®',
      madre: 'üë©',
      cuidadora: 'üë©‚Äç‚öïÔ∏è',
      familiar: 'üëµ',
      otro: 'üë§'
    };
    const roleEmoji = roleEmojis[invitationData.role] || 'üë§';

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${inviterName} te invit√≥ a ver el perfil de ${invitationData.childName} - Munpa</title>
    <meta property="og:title" content="${inviterName} te invit√≥ a Munpa">
    <meta property="og:description" content="Quiere compartir el perfil de ${invitationData.childName} contigo">
    ${childPhotoUrl ? `<meta property="og:image" content="${childPhotoUrl}">` : ''}
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 400px;
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
        }
        .logo { font-size: 48px; margin-bottom: 20px; }
        .child-photo {
            width: 120px;
            height: 120px;
            border-radius: 60px;
            object-fit: cover;
            margin: 20px auto;
            border: 4px solid #667eea;
        }
        .child-emoji { font-size: 80px; margin: 20px 0; }
        .inviter {
            color: #667eea;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        .child-name {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin: 16px 0;
        }
        .role {
            display: inline-block;
            background: #f0f0f0;
            color: #666;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            margin: 12px 0;
        }
        .message {
            color: #555;
            font-size: 16px;
            line-height: 1.6;
            margin: 20px 0;
        }
        .button {
            display: block;
            width: 100%;
            background: #667eea;
            color: white;
            padding: 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 24px;
            text-decoration: none;
            box-sizing: border-box;
        }
        .button:hover {
            background: #5568d3;
        }
        .expired {
            background: #ef4444;
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
        }
        .status {
            font-size: 14px;
            color: #888;
            margin-top: 16px;
        }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://share-child/${token}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://share-child/${token}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://share-child/${token}';
            }
        }
        
        window.onload = function() {
            ${!isExpired && !isUsed ? 'setTimeout(openInApp, 100);' : ''}
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">üë∂ Munpa</div>
        
        ${childPhotoUrl ? 
          `<img src="${childPhotoUrl}" alt="${invitationData.childName}" class="child-photo">` : 
          `<div class="child-emoji">${defaultEmoji}</div>`
        }
        
        <div class="inviter">${roleEmoji} ${inviterName}</div>
        <div class="child-name">${invitationData.childName}</div>
        <div class="role">Como ${invitationData.role}</div>
        
        <div class="message">
            Te ha invitado a ver y compartir el perfil de su ${childGender === 'ni√±a' ? 'hija' : childGender === 'ni√±o' ? 'hijo' : 'beb√©'} en Munpa.
        </div>
        
        ${isExpired ? 
          '<div class="expired">‚è∞ Esta invitaci√≥n ha expirado</div>' : 
          isUsed ?
            '<div class="expired">‚úÖ Esta invitaci√≥n ya fue utilizada</div>' :
            '<button onclick="openInApp()" class="button">Aceptar invitaci√≥n en Munpa üì±</button>'
        }
        
        <div class="status">
            ${!isExpired && !isUsed ? 
              `V√°lida hasta: ${expiresAt ? new Date(expiresAt).toLocaleDateString('es-MX', { 
                day: 'numeric', 
                month: 'long', 
                year: 'numeric' 
              }) : 'Sin l√≠mite'}` : 
              ''
            }
        </div>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('‚ùå [SHARE] Error mostrando invitaci√≥n:', error);
    res.status(500).send(`
      <html>
        <body style="font-family: Arial; padding: 20px; text-align: center;">
          <h2>üòï Ups, algo sali√≥ mal</h2>
          <p>No pudimos cargar esta invitaci√≥n.</p>
          <a href="https://munpa.online" style="color: #6366f1;">Ir a Munpa</a>
        </body>
      </html>
    `);
  }
});

// Ver producto del marketplace compartido (p√∫blico)
app.get('/marketplace/product/:productId', async (req, res) => {
  try {
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(productId).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    
    let priceText = '';
    if (productData.type === 'venta' && productData.price) {
      priceText = `<div class="price">$${productData.price.toLocaleString('es-MX')}</div>`;
    } else if (productData.type === 'donacion') {
      priceText = '<div class="price" style="color: #10b981;">¬°Gratis!</div>';
    } else if (productData.type === 'trueque') {
      priceText = '<div class="price" style="color: #f59e0b;">Intercambio</div>';
    }

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${productData.title} - Munpa Marketplace</title>
    <meta property="og:title" content="${productData.title}">
    <meta property="og:description" content="${productData.description?.substring(0, 200) || ''}">
    ${productData.photos?.[0] ? `<meta property="og:image" content="${productData.photos[0]}">` : ''}
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0;
               padding: 20px; background: #f5f5f5; display: flex; justify-content: center; min-height: 100vh; }
        .container { max-width: 600px; background: white; border-radius: 12px; padding: 24px;
                     box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .logo { font-size: 32px; margin-bottom: 16px; }
        .title { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 8px; }
        .price { font-size: 28px; font-weight: bold; color: #6366f1; margin-bottom: 16px; }
        .image { width: 100%; border-radius: 8px; margin-bottom: 20px; }
        .description { font-size: 16px; line-height: 1.6; color: #555; margin-bottom: 20px; }
        .info { color: #666; font-size: 14px; margin: 8px 0; }
        .button { display: inline-block; background: #6366f1; color: white; padding: 12px 24px;
                 border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 16px; }
    </style>
    <script>
        function openInApp() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isAndroid) {
                window.location.href = 'intent://marketplace/product/${productId}#Intent;scheme=munpa;package=com.munpa.app;end';
            } else if (isIOS) {
                window.location.href = 'munpa://marketplace/product/${productId}';
                setTimeout(() => {}, 2000);
            } else {
                window.location.href = 'munpa://marketplace/product/${productId}';
            }
        }
        
        window.onload = function() {
            setTimeout(openInApp, 100);
        };
    </script>
</head>
<body>
    <div class="container">
        <div class="logo">üõçÔ∏è Munpa Marketplace</div>
        <div class="title">${productData.title}</div>
        ${priceText}
        ${productData.photos?.[0] ? `<img src="${productData.photos[0]}" alt="${productData.title}" class="image">` : ''}
        <div class="description">${productData.description || ''}</div>
        <div class="info">üì¶ ${productData.condition || 'Condici√≥n no especificada'}</div>
        <div class="info">üìç ${productData.location?.city || ''}, ${productData.location?.state || ''}</div>
        <button onclick="openInApp()" class="button" style="border: none; cursor: pointer;">Ver en Munpa üì±</button>
    </div>
</body>
</html>
    `;

    res.send(html);

  } catch (error) {
    console.error('‚ùå [SHARE] Error mostrando producto:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// ===== ENDPOINTS PARA GENERAR LINKS =====

// Compartir art√≠culo (landing con deeplink)
app.get('/article/:articleId', async (req, res) => {
  try {
    const { articleId } = req.params;

    if (!db) {
      return res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Base de datos no disponible</h2></body></html>');
    }

    const articleDoc = await db.collection('articles').doc(articleId).get();
    if (!articleDoc.exists) {
      return res.status(404).send('<html><body style="padding:20px;text-align:center;"><h2>Art√≠culo no encontrado</h2></body></html>');
    }

    const articleData = articleDoc.data();
    const title = articleData.title || 'Art√≠culo en Munpa';
    const description = articleData.summary || stripHtml(articleData.htmlContent || '').substring(0, 200) || '';
    const imageUrl = articleData.coverImageUrl || '';

    const html = `
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <meta property="og:title" content="${title}">
  <meta property="og:description" content="${description}">
  ${imageUrl ? `<meta property="og:image" content="${imageUrl}">` : ''}
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 640px; margin: 0 auto; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .title { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
    .description { font-size: 15px; line-height: 1.6; color: #555; margin-bottom: 16px; }
    .button { display: inline-block; background: #6366f1; color: white; padding: 12px 20px; border-radius: 8px; text-decoration: none; font-weight: 600; }
  </style>
  <script>
    function openInApp() {
      const isAndroid = /Android/i.test(navigator.userAgent);
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (isAndroid) {
        window.location.href = 'intent://article/${articleId}#Intent;scheme=munpa;package=com.munpa.app;end';
      } else if (isIOS) {
        window.location.href = 'munpa://article/${articleId}';
        setTimeout(() => {}, 2000);
      } else {
        window.location.href = 'munpa://article/${articleId}';
      }
    }
    window.onload = function() { setTimeout(openInApp, 100); };
  </script>
</head>
<body>
  <div class="container">
    <div class="title">${title}</div>
    <div class="description">${description}</div>
    <a class="button" href="munpa://article/${articleId}">Abrir en Munpa</a>
  </div>
</body>
</html>
    `;

    res.send(html);
  } catch (error) {
    console.error('‚ùå [SHARE] Error mostrando art√≠culo:', error);
    res.status(500).send('<html><body style="padding:20px;text-align:center;"><h2>Error al cargar</h2></body></html>');
  }
});

// Compartir post de comunidad
app.get('/api/posts/:postId/share', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Obtener info del autor
    let authorName = 'Usuario';
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo autor:', error);
    }

    // Obtener info de la comunidad
    let communityName = 'Munpa';
    try {
      const communityDoc = await db.collection('communities').doc(postData.communityId).get();
      if (communityDoc.exists) {
        communityName = communityDoc.data().name || 'Munpa';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo comunidad:', error);
    }

    // Generar links
    const shareUrl = `munpa://post/${postId}`;
    const webUrl = `https://munpa.online/post/${postId}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `${authorName} en ${communityName}`,
      description: postData.content?.substring(0, 200) || 'Ver publicaci√≥n en Munpa',
      imageUrl: postData.imageUrl || null,
      metadata: {
        postId,
        authorName,
        communityName,
        communityId: postData.communityId,
        likes: postData.likeCount || 0,
        comments: postData.commentCount || 0
      }
    };

    console.log(`‚úÖ [SHARE] Link generado para post: ${postId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error generando link de post:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir recomendaci√≥n
app.get('/api/recommendations/:recommendationId/share', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la recomendaci√≥n
    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendaci√≥n no encontrada'
      });
    }

    const recommendationData = recommendationDoc.data();

    // Obtener info de la categor√≠a
    let categoryName = 'Lugar';
    try {
      if (recommendationData.categoryId) {
        const categoryDoc = await db.collection('categories').doc(recommendationData.categoryId).get();
        if (categoryDoc.exists) {
          categoryName = categoryDoc.data().name || 'Lugar';
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo categor√≠a:', error);
    }

    // Generar links
    const shareUrl = `munpa://recommendation/${recommendationId}`;
    const webUrl = `https://munpa.online/recommendation/${recommendationId}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: recommendationData.name || 'Recomendaci√≥n en Munpa',
      description: recommendationData.description?.substring(0, 200) || `${categoryName} recomendado en Munpa`,
      imageUrl: recommendationData.imageUrl || null,
      metadata: {
        recommendationId,
        categoryName,
        categoryId: recommendationData.categoryId,
        address: recommendationData.address,
        phone: recommendationData.phone,
        averageRating: recommendationData.averageRating || 0,
        totalReviews: recommendationData.totalReviews || 0,
        verified: recommendationData.verified || false
      }
    };

    console.log(`‚úÖ [SHARE] Link generado para recomendaci√≥n: ${recommendationId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error generando link de recomendaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir producto del marketplace
app.get('/api/marketplace/products/:productId/share', authenticateToken, async (req, res) => {
  try {
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el producto
    const productDoc = await db.collection('marketplace_products').doc(productId).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();

    // Generar links
    const shareUrl = `munpa://marketplace/product/${productId}`;
    const webUrl = `https://munpa.online/marketplace/product/${productId}`;

    let description = productData.description?.substring(0, 200) || '';
    
    // Agregar precio si es venta
    if (productData.type === 'venta' && productData.price) {
      description = `$${productData.price.toLocaleString('es-MX')} - ${description}`;
    } else if (productData.type === 'donacion') {
      description = `¬°Gratis! ${description}`;
    } else if (productData.type === 'trueque') {
      description = `Intercambio - ${description}`;
    }

    const shareData = {
      shareUrl,
      webUrl,
      title: productData.title || 'Producto en Munpa Marketplace',
      description,
      imageUrl: productData.photos?.[0] || null,
      metadata: {
        productId,
        categoryName: productData.categoryName,
        condition: productData.condition,
        type: productData.type,
        price: productData.price,
        location: {
          city: productData.location?.city,
          state: productData.location?.state
        },
        userName: productData.userName,
        status: productData.status
      }
    };

    console.log(`‚úÖ [SHARE] Link generado para producto: ${productId}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error generando link de producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir lista de favoritos del marketplace
app.get('/api/marketplace/favorites/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener favoritos del usuario
    const favoritesSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .limit(10) // Primeros 10 para el preview
      .get();

    const favoriteCount = favoritesSnapshot.size;

    // Obtener info del usuario
    let userName = 'Usuario';
    try {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userName = userData.displayName || userData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo usuario:', error);
    }

    // Generar links
    const shareUrl = `munpa://marketplace/favorites/${uid}`;
    const webUrl = `https://munpa.online/marketplace/favorites/${uid}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `Favoritos de ${userName} en Munpa`,
      description: `Descubre ${favoriteCount} productos favoritos de ${userName} en Munpa Marketplace`,
      imageUrl: null, // Podr√≠amos agregar una imagen compuesta de los favoritos
      metadata: {
        userId: uid,
        userName,
        favoriteCount
      }
    };

    console.log(`‚úÖ [SHARE] Link generado para lista de favoritos de: ${uid}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error generando link de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// Compartir lista de recomendaciones favoritas
app.get('/api/recommendations/favorites/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener favoritos del usuario
    const favoritesSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', uid)
      .limit(10) // Primeros 10 para el preview
      .get();

    const favoriteCount = favoritesSnapshot.size;

    // Obtener info del usuario
    let userName = 'Usuario';
    try {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userName = userData.displayName || userData.name || 'Usuario';
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo usuario:', error);
    }

    // Generar links
    const shareUrl = `munpa://recommendations/favorites/${uid}`;
    const webUrl = `https://munpa.online/recommendations/favorites/${uid}`;

    const shareData = {
      shareUrl,
      webUrl,
      title: `Lugares favoritos de ${userName}`,
      description: `Descubre ${favoriteCount} lugares recomendados por ${userName} en Munpa`,
      imageUrl: null,
      metadata: {
        userId: uid,
        userName,
        favoriteCount
      }
    };

    console.log(`‚úÖ [SHARE] Link generado para favoritos de recomendaciones de: ${uid}`);

    res.json({
      success: true,
      data: shareData
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error generando link de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando link para compartir',
      error: error.message
    });
  }
});

// ========== GESTI√ìN DE RECOMENDADOS ==========

// ===== ENDPOINTS PARA LA APP (SOLO LECTURA) =====

// Obtener todos los recomendados activos (para la app)
app.get('/api/recommendations', authenticateToken, async (req, res) => {
  try {
    const { categoryId, page = 1, limit = 20, latitude, longitude, cityId, countryId, maxDistanceKm = 100 } = req.query;
    
    const pageNumber = parseInt(page);
    const limitNumber = parseInt(limit);
    
    console.log('‚≠ê [APP] Obteniendo recomendados', categoryId ? `para categor√≠a: ${categoryId}` : '', `(p√°gina ${pageNumber}, l√≠mite ${limitNumber})`);

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'Ubicaci√≥n no disponible. Env√≠a latitude/longitude o actualiza tu perfil.'
        });
      }
    }

      const cacheKey = `${req.path}?uid=${req.user.uid}&categoryId=${categoryId || ''}&page=${pageNumber}&limit=${limitNumber}&lat=${Number.isFinite(userLat) ? userLat : ''}&lng=${Number.isFinite(userLng) ? userLng : ''}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}&maxDistanceKm=${maxDistanceKm}`;
      const cached = getCachedResponse(cacheKey);
      if (cached) {
        return res.json(cached);
      }

      let query = db.collection('recommendations')
        .where('isActive', '==', true);
      if (effectiveCountryId) {
        query = query.where('countryId', '==', effectiveCountryId);
      }
      if (categoryId) {
        query = query.where('categoryId', '==', categoryId);
      }

      const snapshot = await query.get();
      const categoriesMap = await getCategoriesMap();
      const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
        const data = doc.data();
        const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          facebook: data.facebook,
          instagram: data.instagram,
          twitter: data.twitter,
          whatsapp: data.whatsapp,
          imageUrl: data.imageUrl,
          totalReviews: data.totalReviews || 0,
          averageRating: data.averageRating || 0,
          category: categoryInfo,
          ...buildLocationFields(data),
          // Badges y features
          verified: data.verified || false,
          badges: data.badges || [],
          features: data.features || {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          }
        };
      }));

      const filtered = filterRecommendationsByLocation({
        items: baseList,
        userLat: Number.isFinite(userLat) ? userLat : null,
        userLng: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm
      }).sort((a, b) => {
        const aDist = typeof a.distance === 'number' ? a.distance : Number.POSITIVE_INFINITY;
        const bDist = typeof b.distance === 'number' ? b.distance : Number.POSITIVE_INFINITY;
        return aDist - bDist;
      });

      const total = filtered.length;
      const startIndex = (pageNumber - 1) * limitNumber;
      const endIndex = startIndex + limitNumber;
      const paginated = filtered.slice(startIndex, endIndex);

      const responsePayload = {
        success: true,
        data: paginated,
        pagination: {
          total,
          page: pageNumber,
          limit: limitNumber,
          totalPages: Math.ceil(total / limitNumber),
          hasNextPage: pageNumber * limitNumber < total,
          hasPreviousPage: pageNumber > 1
        },
        meta: {
          latitude: Number.isFinite(userLat) ? userLat : null,
          longitude: Number.isFinite(userLng) ? userLng : null,
          cityId: effectiveCityId,
          countryId: effectiveCountryId,
          maxDistanceKm: Math.min(Math.max(Number(maxDistanceKm) || 100, 1), 100)
        }
      };

      setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
      return res.json(responsePayload);

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendados',
      error: error.message
    });
  }
});

// Buscar recomendados por texto (APP)
app.get('/api/recommendations/search', authenticateToken, async (req, res) => {
  try {
    const { q, categoryId, page = 1, limit = 20 } = req.query;

    if (!q || !String(q).trim()) {
      return res.status(400).json({
        success: false,
        message: 'q es requerido'
      });
    }

    const pageNumber = parseInt(page);
    const limitNumber = parseInt(limit);

    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = Number.isFinite(parseFloat(profileLocation.latitude)) ? parseFloat(profileLocation.latitude) : null;
    const userLng = Number.isFinite(parseFloat(profileLocation.longitude)) ? parseFloat(profileLocation.longitude) : null;
    const effectiveCityId = profileLocation.cityId || null;
    const effectiveCountryId = profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'Ubicaci√≥n no disponible. Actualiza tu perfil antes de buscar.'
        });
      }
    }

    const cacheKey = `${req.path}?uid=${req.user.uid}&q=${String(q).trim().toLowerCase()}&categoryId=${categoryId || ''}&page=${pageNumber}&limit=${limitNumber}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }
    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();
    const searchText = String(q).trim().toLowerCase();

    const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

      return {
        id: doc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        facebook: data.facebook,
        instagram: data.instagram,
        twitter: data.twitter,
        whatsapp: data.whatsapp,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    const textMatches = baseList.filter(item => {
      const haystack = [
        item.name,
        item.description,
        item.address
      ]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      return haystack.includes(searchText);
    });

    const filtered = filterRecommendationsByLocation({
      items: textMatches,
      userLat: Number.isFinite(userLat) ? userLat : null,
      userLng: Number.isFinite(userLng) ? userLng : null,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: 100
    }).sort((a, b) => {
      const aDist = Number.isFinite(a.distance) ? a.distance : Number.POSITIVE_INFINITY;
      const bDist = Number.isFinite(b.distance) ? b.distance : Number.POSITIVE_INFINITY;
      return aDist - bDist;
    });

    const total = filtered.length;
    const startIndex = (pageNumber - 1) * limitNumber;
    const endIndex = startIndex + limitNumber;
    const paginated = filtered.slice(startIndex, endIndex);

    const responsePayload = {
      success: true,
      data: paginated,
      pagination: {
        total,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(total / limitNumber),
        hasNextPage: pageNumber * limitNumber < total,
        hasPreviousPage: pageNumber > 1
      },
      meta: {
        query: searchText,
        latitude: Number.isFinite(userLat) ? userLat : null,
        longitude: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm: 100
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå [APP] Error buscando recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error buscando recomendados',
      error: error.message
    });
  }
});

// ===== ENDPOINTS DE FAVORITOS (DEBEN IR ANTES DE :recommendationId) =====

// Obtener recomendaciones cercanas ordenadas por distancia (APP)
app.get('/api/recommendations/nearby', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude, radius = 10, categoryId, limit = 20, cityId, countryId } = req.query;
    
    console.log('üìç [APP] Obteniendo recomendaciones cercanas:', { latitude, longitude, radius });

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'Ubicaci√≥n no disponible. Actualiza tu perfil antes de buscar.'
      });
    }

    const maxRadius = Math.min(parseFloat(radius), 100);

    // Obtener recomendaciones activas (filtrar por categor√≠a si se proporciona)
    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();

    // Calcular distancia para cada recomendaci√≥n y filtrar por radio
    const recommendationsWithDistance = await Promise.all(
      snapshot.docs.map(async (doc) => {
        const data = doc.data();
        let distance = null;
        let estimatedTime = null;
        if (data.latitude && data.longitude) {
          distance = calculateDistance(
            userLat,
            userLng,
            data.latitude,
            data.longitude
          );
          estimatedTime = calculateEstimatedTime(distance);
        }

          // Obtener informaci√≥n de la categor√≠a
          const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          imageUrl: data.imageUrl,
          totalReviews: data.totalReviews || 0,
          averageRating: data.averageRating || 0,
          distance: typeof distance === 'number' ? Math.round(distance * 10) / 10 : null,
          estimatedTime,
          category: categoryInfo,
          ...buildLocationFields(data),
          // Badges y features
          verified: data.verified || false,
          badges: data.badges || [],
          features: data.features || {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          }
        };
      })
    );

    const baseList = recommendationsWithDistance.filter(rec => rec !== null);
    const filtered = filterRecommendationsByLocation({
      items: baseList,
      userLat,
      userLng,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: maxRadius
    }).sort((a, b) => {
      const aDist = typeof a.distance === 'number' ? a.distance : Number.POSITIVE_INFINITY;
      const bDist = typeof b.distance === 'number' ? b.distance : Number.POSITIVE_INFINITY;
      return aDist - bDist;
    });

    const validRecommendations = filtered.slice(0, parseInt(limit));

    res.json({
      success: true,
      data: validRecommendations,
      metadata: {
        userLocation: {
          latitude: userLat,
          longitude: userLng
        },
        radius: maxRadius,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        found: validRecommendations.length
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo recomendaciones cercanas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones cercanas',
      error: error.message
    });
  }
});

// Obtener top 3 recomendaciones mejor calificadas y cercanas (APP)
app.get('/api/recommendations/nearby/top', authenticateToken, async (req, res) => {
  try {
    const { latitude, longitude, radius = 10, categoryId, limit = 3, minReviews = 0, minRating = 0, cityId, countryId } = req.query;
    
    console.log('‚≠êüìç [APP] Top recomendaciones cercanas:', { latitude, longitude, radius });

    const hasCoords = latitude !== undefined && longitude !== undefined;
    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = hasCoords ? parseFloat(latitude) : parseFloat(profileLocation.latitude);
    const userLng = hasCoords ? parseFloat(longitude) : parseFloat(profileLocation.longitude);
    const effectiveCityId = cityId || profileLocation.cityId || null;
    const effectiveCountryId = countryId || profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'Ubicaci√≥n no disponible. Actualiza tu perfil antes de buscar.'
      });
    }

    const cacheKey = `${req.path}?uid=${req.user.uid}&lat=${userLat}&lng=${userLng}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}&radius=${radius}&categoryId=${categoryId || ''}&limit=${limit}&minReviews=${minReviews}&minRating=${minRating}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }
    const maxRadius = Math.min(parseFloat(radius), 100);
    const limitNumber = Math.min(parseInt(limit), 10);
    const minReviewsNumber = Math.max(parseInt(minReviews), 0);
    const minRatingNumber = Math.max(parseFloat(minRating), 0);

    if (isNaN(userLat) || isNaN(userLng)) {
      return res.status(400).json({
        success: false,
        message: 'Latitude y longitude deben ser n√∫meros v√°lidos'
      });
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();
    const categoriesMap = await getCategoriesMap();

    const recommendationsWithDistance = await Promise.all(
      snapshot.docs.map(async (doc) => {
        const data = doc.data();
        let distance = null;
        if (data.latitude && data.longitude) {
          distance = calculateDistance(
            userLat,
            userLng,
            data.latitude,
            data.longitude
          );
        }

        const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

        const totalReviews = data.totalReviews || 0;
        const averageRating = data.averageRating || 0;

        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          address: data.address,
          latitude: data.latitude,
          longitude: data.longitude,
          phone: data.phone,
          email: data.email,
          website: data.website,
          imageUrl: data.imageUrl,
          totalReviews: totalReviews,
          averageRating: averageRating,
          rating: averageRating,
          reviews: totalReviews,
          distance: typeof distance === 'number' ? Math.round(distance * 10) / 10 : null,
          category: categoryInfo,
          ...buildLocationFields(data),
          verified: data.verified || false,
          badges: data.badges || []
        };
      })
    );

    const baseList = recommendationsWithDistance.filter(rec => rec !== null);
    const locationFiltered = filterRecommendationsByLocation({
      items: baseList,
      userLat,
      userLng,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: maxRadius
    });

    const preferDistance = minReviewsNumber === 0 && minRatingNumber === 0;
    const allSorted = locationFiltered
      .sort((a, b) => {
        if (preferDistance) {
          if (a.distance !== b.distance) return a.distance - b.distance;
          if (b.averageRating !== a.averageRating) return b.averageRating - a.averageRating;
          return b.totalReviews - a.totalReviews;
        }
        if (b.averageRating !== a.averageRating) return b.averageRating - a.averageRating;
        if (a.distance !== b.distance) return a.distance - b.distance;
        return b.totalReviews - a.totalReviews;
      });

    const radiusSteps = [maxRadius];
    let usedFallback = false;
    let validRecommendations = [];

    const ratedOnly = allSorted
      .filter(rec => rec.totalReviews >= minReviewsNumber && rec.averageRating >= minRatingNumber);

    for (const stepRadius of radiusSteps) {
      const baseList = preferDistance ? allSorted : ratedOnly;
      const withinRadius = baseList.filter(rec => rec.distance <= stepRadius);
      validRecommendations = withinRadius.slice(0, limitNumber);
      if (validRecommendations.length >= limitNumber) break;
    }

    if (validRecommendations.length < limitNumber) {
      usedFallback = true;
    }

    const responsePayload = {
      success: true,
      data: validRecommendations,
      meta: {
        latitude: userLat,
        longitude: userLng,
        radius: maxRadius,
        limit: limitNumber,
        minReviews: minReviewsNumber,
        minRating: minRatingNumber,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        filledWithFallback: usedFallback
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo top recomendaciones cercanas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones cercanas',
      error: error.message
    });
  }
});

// Funci√≥n auxiliar para calcular distancia usando f√≥rmula de Haversine
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radio de la Tierra en km
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;
  
  return distance;
}

// Funci√≥n auxiliar para convertir grados a radianes
function toRad(degrees) {
  return degrees * (Math.PI / 180);
}

// Funci√≥n auxiliar para calcular tiempo estimado
function calculateEstimatedTime(distanceKm) {
  const avgSpeedKmH = 40; // Velocidad promedio en ciudad (km/h)
  const timeInHours = distanceKm / avgSpeedKmH;
  const timeInMinutes = Math.round(timeInHours * 60);
  
  if (timeInMinutes < 1) {
    return "menos de 1 min";
  } else if (timeInMinutes < 60) {
    return `${timeInMinutes} min`;
  } else {
    const hours = Math.floor(timeInMinutes / 60);
    const minutes = timeInMinutes % 60;
    if (minutes === 0) {
      return `${hours} ${hours === 1 ? 'hora' : 'horas'}`;
    }
    return `${hours} h ${minutes} min`;
  }
}

// Obtener las 10 recomendaciones m√°s recientes (APP)
app.get('/api/recommendations/recent', authenticateToken, async (req, res) => {
  try {
    const { limit = 10 } = req.query;
    
    console.log('üÜï [APP] Obteniendo recomendaciones recientes');

    const profileLocation = await getUserLocationFromProfile(req.user.uid);
    const userLat = Number.isFinite(parseFloat(profileLocation.latitude)) ? parseFloat(profileLocation.latitude) : null;
    const userLng = Number.isFinite(parseFloat(profileLocation.longitude)) ? parseFloat(profileLocation.longitude) : null;
    const effectiveCityId = profileLocation.cityId || null;
    const effectiveCountryId = profileLocation.countryId || null;

    if (!Number.isFinite(userLat) || !Number.isFinite(userLng)) {
      if (!effectiveCityId && !effectiveCountryId) {
        return res.status(400).json({
          success: false,
          message: 'Ubicaci√≥n no disponible. Actualiza tu perfil antes de buscar.'
        });
      }
    }

    const limitNumber = Math.max(parseInt(limit), 1);
    const fetchLimit = Math.min(Math.max(limitNumber * 5, limitNumber), 100);

    const cacheKey = `${req.path}?uid=${req.user.uid}&limit=${limitNumber}&lat=${Number.isFinite(userLat) ? userLat : ''}&lng=${Number.isFinite(userLng) ? userLng : ''}&cityId=${effectiveCityId || ''}&countryId=${effectiveCountryId || ''}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    let query = db.collection('recommendations')
      .where('isActive', '==', true);
    if (effectiveCountryId) {
      query = query.where('countryId', '==', effectiveCountryId);
    }

    // Obtener las recomendaciones m√°s recientes ordenadas por createdAt
    const snapshot = await query
      .orderBy('createdAt', 'desc')
      .limit(fetchLimit)
      .get();

    const categoriesMap = await getCategoriesMap();
    const baseList = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      
      // Obtener informaci√≥n de la categor√≠a
      const categoryInfo = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;

      // Contar comentarios de reviews
      const reviewsSnapshot = await db.collection('recommendationReviews')
        .where('recommendationId', '==', doc.id)
        .get();

      const commentsCount = reviewsSnapshot.docs.filter(reviewDoc => {
        const reviewData = reviewDoc.data();
        return reviewData.comment && reviewData.comment.trim().length > 0;
      }).length;

      return {
        id: doc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        commentsCount: commentsCount,
        category: categoryInfo,
        ...buildLocationFields(data),
        createdAt: data.createdAt?.toDate(),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    const filtered = filterRecommendationsByLocation({
      items: baseList,
      userLat: Number.isFinite(userLat) ? userLat : null,
      userLng: Number.isFinite(userLng) ? userLng : null,
      cityId: effectiveCityId,
      countryId: effectiveCountryId,
      maxDistanceKm: 100
    });

    const recommendations = filtered.slice(0, limitNumber);

    const responsePayload = {
      success: true,
      data: recommendations,
      meta: {
        latitude: Number.isFinite(userLat) ? userLat : null,
        longitude: Number.isFinite(userLng) ? userLng : null,
        cityId: effectiveCityId,
        countryId: effectiveCountryId,
        maxDistanceKm: 100
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 60 * 1000);
    res.json(responsePayload);

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo recomendaciones recientes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendaciones recientes',
      error: error.message
    });
  }
});

// Obtener mis recomendados favoritos (APP)
app.get('/api/recommendations/favorites', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    
    console.log('‚ù§Ô∏è [APP] Obteniendo favoritos del usuario:', userId);

    // Obtener IDs de favoritos del usuario
    const favoritesSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .get();

    if (favoritesSnapshot.empty) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener los recomendados completos
    const recommendationIds = favoritesSnapshot.docs.map(doc => doc.data().recommendationId);
    
    const recommendations = await Promise.all(recommendationIds.map(async (recId) => {
      const recDoc = await db.collection('recommendations').doc(recId).get();
      
      if (!recDoc.exists) return null;
      
      const data = recDoc.data();
      
      // Obtener informaci√≥n de la categor√≠a
      let categoryInfo = null;
      if (data.categoryId) {
        const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name,
            icon: catData.icon
          };
        }
      }

      return {
        id: recDoc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        isFavorite: true,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      };
    }));

    // Filtrar nulls (recomendados que ya no existen)
    const validRecommendations = recommendations.filter(rec => rec !== null);

    res.json({
      success: true,
      data: validRecommendations
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo favoritos',
      error: error.message
    });
  }
});

// Verificar si un recomendado es favorito (APP)
app.get('/api/recommendations/:recommendationId/favorite', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('‚ù§Ô∏è [APP] Verificando si es favorito:', recommendationId);

    const favoriteSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    res.json({
      success: true,
      isFavorite: !favoriteSnapshot.empty
    });

  } catch (error) {
    console.error('‚ùå [APP] Error verificando favorito:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando favorito',
      error: error.message
    });
  }
});

// Agregar/quitar recomendado de favoritos (toggle) (APP)
app.post('/api/recommendations/:recommendationId/favorite', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('‚ù§Ô∏è [APP] Toggle favorito para recomendado:', recommendationId);

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si ya es favorito
    const favoriteSnapshot = await db.collection('recommendationFavorites')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (favoriteSnapshot.empty) {
      // Agregar a favoritos
      await db.collection('recommendationFavorites').add({
        userId,
        recommendationId,
        createdAt: new Date()
      });

      console.log('‚úÖ [APP] Agregado a favoritos');

      res.json({
        success: true,
        message: 'Agregado a favoritos',
        isFavorite: true
      });
    } else {
      // Quitar de favoritos
      await favoriteSnapshot.docs[0].ref.delete();

      console.log('‚úÖ [APP] Eliminado de favoritos');

      res.json({
        success: true,
        message: 'Eliminado de favoritos',
        isFavorite: false
      });
    }

  } catch (error) {
    console.error('‚ùå [APP] Error con favorito:', error);
    res.status(500).json({
      success: false,
      message: 'Error al marcar como favorito',
      error: error.message
    });
  }
});

// ===== ENDPOINTS DE WISHLIST (LISTA DE DESEOS) =====

// Agregar a wishlist (APP)
app.post('/api/recommendations/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { recommendationId, notes, priority = 'medium' } = req.body;

    console.log('üíù [APP] Agregando a wishlist:', recommendationId);

    // Validaciones
    if (!recommendationId) {
      return res.status(400).json({
        success: false,
        message: 'El recommendationId es requerido'
      });
    }

    if (priority && !['high', 'medium', 'low'].includes(priority)) {
      return res.status(400).json({
        success: false,
        message: 'La prioridad debe ser: high, medium o low'
      });
    }

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si ya est√° en la wishlist
    const existingWishlist = await db.collection('recommendationWishlist')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (!existingWishlist.empty) {
      return res.status(400).json({
        success: false,
        message: 'Este recomendado ya est√° en tu lista de deseos'
      });
    }

    // Agregar a wishlist
    const wishlistData = {
      userId,
      recommendationId,
      notes: notes || '',
      priority: priority || 'medium',
      addedAt: new Date(),
      createdAt: new Date()
    };

    const wishlistRef = await db.collection('recommendationWishlist').add(wishlistData);

    console.log('‚úÖ [APP] Agregado a wishlist:', wishlistRef.id);

    res.json({
      success: true,
      message: 'Agregado a tu lista de deseos',
      data: {
        id: wishlistRef.id,
        ...wishlistData
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error agregando a wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando a lista de deseos',
      error: error.message
    });
  }
});

// Obtener mi wishlist (APP)
app.get('/api/recommendations/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { priority } = req.query;

    console.log('üíù [APP] Obteniendo wishlist del usuario:', userId);

    // Query base
    let query = db.collection('recommendationWishlist')
      .where('userId', '==', userId);

    // Filtrar por prioridad si se especifica
    if (priority) {
      if (!['high', 'medium', 'low'].includes(priority)) {
        return res.status(400).json({
          success: false,
          message: 'La prioridad debe ser: high, medium o low'
        });
      }
      query = query.where('priority', '==', priority);
    }

    const wishlistSnapshot = await query.get();

    if (wishlistSnapshot.empty) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener los recomendados completos
    const wishlistItems = await Promise.all(wishlistSnapshot.docs.map(async (doc) => {
      const wishlistData = doc.data();
      const recDoc = await db.collection('recommendations').doc(wishlistData.recommendationId).get();

      if (!recDoc.exists) return null;

      const recData = recDoc.data();

      // Solo incluir recomendados activos
      if (!recData.isActive) return null;

      // Obtener informaci√≥n de la categor√≠a
      let categoryInfo = null;
      if (recData.categoryId) {
        const categoryDoc = await db.collection('categories').doc(recData.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name,
            icon: catData.icon,
            imageUrl: catData.imageUrl
          };
        }
      }

      return {
        // Datos del recomendado
        id: recDoc.id,
        name: recData.name,
        description: recData.description,
        address: recData.address,
        latitude: recData.latitude,
        longitude: recData.longitude,
        phone: recData.phone,
        email: recData.email,
        website: recData.website,
        facebook: recData.facebook,
        instagram: recData.instagram,
        twitter: recData.twitter,
        whatsapp: recData.whatsapp,
        imageUrl: recData.imageUrl,
        totalReviews: recData.totalReviews || 0,
        averageRating: recData.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(recData),
        verified: recData.verified || false,
        badges: recData.badges || [],
        features: recData.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        },
        // Datos de la wishlist
        wishlistId: doc.id,
        addedAt: wishlistData.addedAt?.toDate(),
        notes: wishlistData.notes || '',
        priority: wishlistData.priority || 'medium'
      };
    }));

    // Filtrar nulls (recomendados que ya no existen o no est√°n activos)
    const validItems = wishlistItems.filter(item => item !== null);

    // Ordenar por prioridad (high > medium > low) y luego por fecha
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    validItems.sort((a, b) => {
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return (b.addedAt?.getTime() || 0) - (a.addedAt?.getTime() || 0);
    });

    res.json({
      success: true,
      data: validItems,
      metadata: {
        total: validItems.length,
        byPriority: {
          high: validItems.filter(i => i.priority === 'high').length,
          medium: validItems.filter(i => i.priority === 'medium').length,
          low: validItems.filter(i => i.priority === 'low').length
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo lista de deseos',
      error: error.message
    });
  }
});

// Actualizar item de wishlist (APP)
app.put('/api/recommendations/wishlist/:wishlistId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { wishlistId } = req.params;
    const { notes, priority } = req.body;

    console.log('‚úèÔ∏è [APP] Actualizando wishlist item:', wishlistId);

    // Validaciones
    if (priority && !['high', 'medium', 'low'].includes(priority)) {
      return res.status(400).json({
        success: false,
        message: 'La prioridad debe ser: high, medium o low'
      });
    }

    const wishlistRef = db.collection('recommendationWishlist').doc(wishlistId);
    const wishlistDoc = await wishlistRef.get();

    if (!wishlistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Item de wishlist no encontrado'
      });
    }

    const wishlistData = wishlistDoc.data();

    // Verificar que el usuario es el due√±o
    if (wishlistData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para modificar este item'
      });
    }

    // Actualizar
    const updateData = {
      updatedAt: new Date()
    };

    if (notes !== undefined) updateData.notes = notes;
    if (priority !== undefined) updateData.priority = priority;

    await wishlistRef.update(updateData);

    console.log('‚úÖ [APP] Wishlist item actualizado');

    res.json({
      success: true,
      message: 'Item actualizado exitosamente',
      data: {
        id: wishlistId,
        ...wishlistData,
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error actualizando wishlist item:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando item de wishlist',
      error: error.message
    });
  }
});

// Eliminar de wishlist (APP)
app.delete('/api/recommendations/wishlist/:wishlistId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { wishlistId } = req.params;

    console.log('üóëÔ∏è [APP] Eliminando de wishlist:', wishlistId);

    const wishlistRef = db.collection('recommendationWishlist').doc(wishlistId);
    const wishlistDoc = await wishlistRef.get();

    if (!wishlistDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Item de wishlist no encontrado'
      });
    }

    const wishlistData = wishlistDoc.data();

    // Verificar que el usuario es el due√±o
    if (wishlistData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar este item'
      });
    }

    await wishlistRef.delete();

    console.log('‚úÖ [APP] Eliminado de wishlist');

    res.json({
      success: true,
      message: 'Eliminado de tu lista de deseos'
    });

  } catch (error) {
    console.error('‚ùå [APP] Error eliminando de wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando de lista de deseos',
      error: error.message
    });
  }
});

// Verificar si un recomendado est√° en wishlist (APP)
app.get('/api/recommendations/:recommendationId/wishlist', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { recommendationId } = req.params;

    console.log('üíù [APP] Verificando si est√° en wishlist:', recommendationId);

    const wishlistSnapshot = await db.collection('recommendationWishlist')
      .where('userId', '==', userId)
      .where('recommendationId', '==', recommendationId)
      .get();

    if (wishlistSnapshot.empty) {
      return res.json({
        success: true,
        data: {
          inWishlist: false
        }
      });
    }

    const wishlistDoc = wishlistSnapshot.docs[0];
    const wishlistData = wishlistDoc.data();

    res.json({
      success: true,
      data: {
        inWishlist: true,
        wishlistId: wishlistDoc.id,
        addedAt: wishlistData.addedAt?.toDate(),
        notes: wishlistData.notes || '',
        priority: wishlistData.priority || 'medium'
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error verificando wishlist:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando lista de deseos',
      error: error.message
    });
  }
});

// Obtener un recomendado espec√≠fico (para la app)
app.get('/api/recommendations/:recommendationId', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('‚≠ê [APP] Obteniendo recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    const data = recDoc.data();

    if (!data.isActive) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no disponible'
      });
    }

    // Obtener informaci√≥n de la categor√≠a
    let categoryInfo = null;
    if (data.categoryId) {
      const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
      if (categoryDoc.exists) {
        const catData = categoryDoc.data();
        categoryInfo = {
          id: categoryDoc.id,
          name: catData.name,
          icon: catData.icon,
          imageUrl: catData.imageUrl
        };
      }
    }

    res.json({
      success: true,
      data: {
        id: recDoc.id,
        name: data.name,
        description: data.description,
        address: data.address,
        latitude: data.latitude,
        longitude: data.longitude,
        phone: data.phone,
        email: data.email,
        website: data.website,
        facebook: data.facebook,
        instagram: data.instagram,
        twitter: data.twitter,
        whatsapp: data.whatsapp,
        imageUrl: data.imageUrl,
        totalReviews: data.totalReviews || 0,
        averageRating: data.averageRating || 0,
        category: categoryInfo,
        ...buildLocationFields(data),
        // Badges y features
        verified: data.verified || false,
        badges: data.badges || [],
        features: data.features || {
          hasChangingTable: false,
          hasNursingRoom: false,
          hasParking: false,
          isStrollerAccessible: false,
          acceptsEmergencies: false,
          is24Hours: false
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendado',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN (CRUD COMPLETO) =====

// Obtener todos los recomendados (admin)
app.get('/api/admin/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', categoryId } = req.query;
    
    console.log('‚≠ê [ADMIN] Obteniendo recomendados');

    let query = db.collection('recommendations');

    if (categoryId) {
      query = query.where('categoryId', '==', categoryId);
    }

    const snapshot = await query.get();

    let recommendations = await Promise.all(snapshot.docs.map(async (doc) => {
      const data = doc.data();
      
      // Obtener informaci√≥n de la categor√≠a
      let categoryInfo = null;
      if (data.categoryId) {
        const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
        if (categoryDoc.exists) {
          const catData = categoryDoc.data();
          categoryInfo = {
            id: categoryDoc.id,
            name: catData.name
          };
        }
      }

      return {
        id: doc.id,
        ...data,
        category: categoryInfo,
        createdAt: data.createdAt?.toDate(),
        updatedAt: data.updatedAt?.toDate()
      };
    }));

    // Filtrar por b√∫squeda si existe
    if (search) {
      const searchLower = search.toLowerCase();
      recommendations = recommendations.filter(rec => 
        rec.name?.toLowerCase().includes(searchLower) ||
        rec.description?.toLowerCase().includes(searchLower) ||
        rec.address?.toLowerCase().includes(searchLower)
      );
    }

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedRecommendations = recommendations.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedRecommendations,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: recommendations.length,
        totalPages: Math.ceil(recommendations.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo recomendados:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendados',
      error: error.message
    });
  }
});

// Obtener un recomendado espec√≠fico (admin)
app.get('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('‚≠ê [ADMIN] Obteniendo recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    const data = recDoc.data();

    // Obtener informaci√≥n de la categor√≠a
    let categoryInfo = null;
    if (data.categoryId) {
      const categoryDoc = await db.collection('categories').doc(data.categoryId).get();
      if (categoryDoc.exists) {
        const catData = categoryDoc.data();
        categoryInfo = {
          id: categoryDoc.id,
          name: catData.name,
          imageUrl: catData.imageUrl
        };
      }
    }

    res.json({
      success: true,
      data: {
        id: recDoc.id,
        ...data,
        category: categoryInfo,
        createdAt: data.createdAt?.toDate(),
        updatedAt: data.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo recomendado',
      error: error.message
    });
  }
});

// Crear nuevo recomendado (admin)
app.post('/api/admin/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      isActive = true,
      countryId,
      cityId,
      // Badges y features
      verified = false,
      badges = [],
      features = {}
    } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nuevo recomendado:', name);
    console.log('üìã [DEBUG] verified recibido:', verified, 'tipo:', typeof verified);

    // Validaciones
    if (!name || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido'
      });
    }

    if (!categoryId) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a es requerida'
      });
    }

    // Verificar que la categor√≠a existe
    const categoryDoc = await db.collection('categories').doc(categoryId).get();
    if (!categoryDoc.exists) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a seleccionada no existe'
      });
    }

    // Procesar features con valores por defecto
    const processedFeatures = {
      hasChangingTable: features.hasChangingTable === true,
      hasNursingRoom: features.hasNursingRoom === true,
      hasParking: features.hasParking === true,
      isStrollerAccessible: features.isStrollerAccessible === true,
      acceptsEmergencies: features.acceptsEmergencies === true,
      is24Hours: features.is24Hours === true
    };

    // Generar badges autom√°ticamente basados en features
    const autoBadges = [];
    if (processedFeatures.hasChangingTable) autoBadges.push('changing_table');
    if (processedFeatures.hasNursingRoom) autoBadges.push('nursing_room');
    if (processedFeatures.hasParking) autoBadges.push('parking');
    if (processedFeatures.isStrollerAccessible) autoBadges.push('stroller_accessible');
    if (processedFeatures.acceptsEmergencies) autoBadges.push('emergency_24_7');
    if (processedFeatures.is24Hours) autoBadges.push('24_hours');

    // Badge "baby_friendly" si tiene al menos 3 features
    const featuresCount = Object.values(processedFeatures).filter(v => v === true).length;
    if (featuresCount >= 3) {
      autoBadges.push('baby_friendly');
    }

    // Combinar badges manuales con auto-generados (sin duplicados)
    const allBadges = Array.isArray(badges) ? badges : [];
    const finalBadges = [...new Set([...allBadges, ...autoBadges])];

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({
        success: false,
        message: err.message
      });
    }

    const recommendationData = {
      categoryId,
      name: name.trim(),
      description: description ? description.trim() : '',
      address: address ? address.trim() : '',
      latitude: latitude ? parseFloat(latitude) : null,
      longitude: longitude ? parseFloat(longitude) : null,
      phone: phone ? phone.trim() : '',
      email: email ? email.trim() : '',
      website: website ? website.trim() : '',
      facebook: facebook ? facebook.trim() : '',
      instagram: instagram ? instagram.trim() : '',
      twitter: twitter ? twitter.trim() : '',
      whatsapp: whatsapp ? whatsapp.trim() : '',
      imageUrl: imageUrl || null,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      isActive: isActive === true || isActive === 'true',
      // Badges y features
      verified: verified === true || verified === 'true' || verified === '1' || verified === 1,
      badges: finalBadges,
      features: processedFeatures,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    console.log('üìã [DEBUG] recommendationData.verified final:', recommendationData.verified);

    const recRef = await db.collection('recommendations').add(recommendationData);

    console.log('‚úÖ [ADMIN] Recomendado creado:', recRef.id);

    res.json({
      success: true,
      message: 'Recomendado creado exitosamente',
      data: {
        id: recRef.id,
        ...recommendationData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando recomendado',
      error: error.message
    });
  }
});

// Actualizar recomendado (admin)
app.put('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      categoryId,
      name,
      description,
      address,
      latitude,
      longitude,
      phone,
      email,
      website,
      facebook,
      instagram,
      twitter,
      whatsapp,
      imageUrl,
      isActive,
      countryId,
      cityId,
      // Badges y features
      verified,
      badges,
      features
    } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Actualizando recomendado:', recommendationId);

    const recRef = db.collection('recommendations').doc(recommendationId);
    const recDoc = await recRef.get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Si se cambia la categor√≠a, verificar que existe
    if (categoryId !== undefined) {
      const categoryDoc = await db.collection('categories').doc(categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'La categor√≠a seleccionada no existe'
        });
      }
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (categoryId !== undefined) updateData.categoryId = categoryId;
    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (address !== undefined) updateData.address = address.trim();
    if (latitude !== undefined) updateData.latitude = latitude ? parseFloat(latitude) : null;
    if (longitude !== undefined) updateData.longitude = longitude ? parseFloat(longitude) : null;
    if (phone !== undefined) updateData.phone = phone.trim();
    if (email !== undefined) updateData.email = email.trim();
    if (website !== undefined) updateData.website = website.trim();
    if (facebook !== undefined) updateData.facebook = facebook.trim();
    if (instagram !== undefined) updateData.instagram = instagram.trim();
    if (twitter !== undefined) updateData.twitter = twitter.trim();
    if (whatsapp !== undefined) updateData.whatsapp = whatsapp.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isActive !== undefined) updateData.isActive = isActive === true || isActive === 'true';

    const hasLocationUpdate = Object.prototype.hasOwnProperty.call(req.body, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body, 'cityId');
    if (hasLocationUpdate) {
      const normalizedCountryId = countryId ? String(countryId).trim() : null;
      const normalizedCityId = cityId ? String(cityId).trim() : null;
      try {
        const locationData = await resolveCountryCity(normalizedCountryId, normalizedCityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    // Actualizar badges y features
    if (verified !== undefined) {
      console.log('üìã [DEBUG UPDATE] verified recibido:', verified, 'tipo:', typeof verified);
      updateData.verified = verified === true || verified === 'true' || verified === '1' || verified === 1;
      console.log('üìã [DEBUG UPDATE] verified final:', updateData.verified);
    }

    if (features !== undefined) {
      // Procesar features con valores por defecto
      const processedFeatures = {
        hasChangingTable: features.hasChangingTable === true,
        hasNursingRoom: features.hasNursingRoom === true,
        hasParking: features.hasParking === true,
        isStrollerAccessible: features.isStrollerAccessible === true,
        acceptsEmergencies: features.acceptsEmergencies === true,
        is24Hours: features.is24Hours === true
      };

      // Generar badges autom√°ticamente basados en features
      const autoBadges = [];
      if (processedFeatures.hasChangingTable) autoBadges.push('changing_table');
      if (processedFeatures.hasNursingRoom) autoBadges.push('nursing_room');
      if (processedFeatures.hasParking) autoBadges.push('parking');
      if (processedFeatures.isStrollerAccessible) autoBadges.push('stroller_accessible');
      if (processedFeatures.acceptsEmergencies) autoBadges.push('emergency_24_7');
      if (processedFeatures.is24Hours) autoBadges.push('24_hours');

      // Badge "baby_friendly" si tiene al menos 3 features
      const featuresCount = Object.values(processedFeatures).filter(v => v === true).length;
      if (featuresCount >= 3) {
        autoBadges.push('baby_friendly');
      }

      // Combinar badges manuales con auto-generados (sin duplicados)
      const manualBadges = Array.isArray(badges) ? badges : (recDoc.data().badges || []);
      const finalBadges = [...new Set([...manualBadges, ...autoBadges])];

      updateData.features = processedFeatures;
      updateData.badges = finalBadges;
    } else if (badges !== undefined) {
      // Solo se actualizan badges manualmente sin features
      updateData.badges = Array.isArray(badges) ? badges : [];
    }

    await recRef.update(updateData);

    console.log('‚úÖ [ADMIN] Recomendado actualizado');

    res.json({
      success: true,
      message: 'Recomendado actualizado exitosamente',
      data: {
        id: recommendationId,
        ...recDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando recomendado',
      error: error.message
    });
  }
});

// Migraci√≥n: Agregar campos verified, badges y features a recomendados existentes (admin)
app.post('/api/admin/recommendations/migrate-badges', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('üîÑ [ADMIN] Iniciando migraci√≥n de badges...');

    const snapshot = await db.collection('recommendations').get();
    
    let updated = 0;
    let skipped = 0;
    const updates = [];

    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Solo actualizar si no tiene los nuevos campos
      if (data.verified === undefined || data.badges === undefined || data.features === undefined) {
        const updateData = {};
        
        // Agregar verified si no existe
        if (data.verified === undefined) {
          updateData.verified = false;
        }
        
        // Agregar badges si no existe
        if (data.badges === undefined) {
          updateData.badges = [];
        }
        
        // Agregar features si no existe
        if (data.features === undefined) {
          updateData.features = {
            hasChangingTable: false,
            hasNursingRoom: false,
            hasParking: false,
            isStrollerAccessible: false,
            acceptsEmergencies: false,
            is24Hours: false
          };
        }
        
        if (Object.keys(updateData).length > 0) {
          updates.push(
            db.collection('recommendations').doc(doc.id).update(updateData)
          );
          updated++;
        }
      } else {
        skipped++;
      }
    }

    // Ejecutar todas las actualizaciones en paralelo
    if (updates.length > 0) {
      await Promise.all(updates);
    }

    console.log(`‚úÖ [ADMIN] Migraci√≥n completada: ${updated} actualizados, ${skipped} omitidos`);

    res.json({
      success: true,
      message: 'Migraci√≥n completada exitosamente',
      data: {
        total: snapshot.size,
        updated,
        skipped
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en migraci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error ejecutando migraci√≥n',
      error: error.message
    });
  }
});

// Eliminar recomendado (admin)
app.delete('/api/admin/recommendations/:recommendationId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando recomendado:', recommendationId);

    const recDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    await db.collection('recommendations').doc(recommendationId).delete();

    console.log('‚úÖ [ADMIN] Recomendado eliminado');

    res.json({
      success: true,
      message: 'Recomendado eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando recomendado:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando recomendado',
      error: error.message
    });
  }
});

// ========== REVIEWS DE RECOMENDADOS ==========

// ===== ENDPOINTS PARA LA APP =====

// Obtener reviews de un recomendado (APP)
app.get('/api/recommendations/:recommendationId/reviews', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('‚≠ê [APP] Obteniendo reviews para recomendado:', recommendationId);

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Obtener reviews
    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    const userId = req.user?.uid; // Usuario actual para saber si marc√≥ como √∫til

    let reviews = await Promise.all(reviewsSnapshot.docs.map(async (doc) => {
      const reviewData = doc.data();
      
      // Obtener informaci√≥n del usuario
      let userInfo = null;
      if (reviewData.userId) {
        const userDoc = await db.collection('users').doc(reviewData.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            id: userDoc.id,
            displayName: userData.displayName || 'Usuario',
            photoURL: userData.photoURL || null
          };
        }
      }

      // Verificar si el usuario actual marc√≥ como √∫til
      const helpfulBy = reviewData.helpfulBy || [];
      const isHelpfulByMe = userId ? helpfulBy.includes(userId) : false;

      return {
        id: doc.id,
        userId: reviewData.userId,
        userName: userInfo?.displayName || 'Usuario',
        userAvatar: userInfo?.photoURL || null,
        rating: reviewData.rating,
        comment: reviewData.comment,
        // Nuevos campos
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        isHelpfulByMe,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      };
    }));

    // Ordenar por fecha (m√°s recientes primero)
    reviews.sort((a, b) => {
      const dateA = a.createdAt || new Date(0);
      const dateB = b.createdAt || new Date(0);
      return dateB - dateA;
    });

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedReviews = reviews.slice(startIndex, endIndex);

    // Calcular estad√≠sticas
    const totalReviews = reviews.length;
    const averageRating = totalReviews > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews 
      : 0;

    res.json({
      success: true,
      data: paginatedReviews,
      stats: {
        totalReviews,
        averageRating: Math.round(averageRating * 10) / 10 // Redondear a 1 decimal
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReviews,
        totalPages: Math.ceil(totalReviews / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reviews',
      error: error.message
    });
  }
});

// Crear o actualizar review de un recomendado (APP)
app.post('/api/recommendations/:recommendationId/reviews', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { rating, comment, photos = [], childAge, visitedWith } = req.body;
    const userId = req.user.uid;
    
    console.log('‚≠ê [APP] Creando/actualizando review para recomendado:', recommendationId);

    // Validaciones
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({
        success: false,
        message: 'La calificaci√≥n debe ser entre 1 y 5 estrellas'
      });
    }

    // Validar visitedWith si se proporciona
    const validVisitedWith = ['Solo', 'Pareja', 'Familia', 'Amigos'];
    if (visitedWith && !validVisitedWith.includes(visitedWith)) {
      return res.status(400).json({
        success: false,
        message: `visitedWith debe ser uno de: ${validVisitedWith.join(', ')}`
      });
    }

    // Validar fotos (m√°ximo 5)
    if (photos && photos.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'M√°ximo 5 fotos por review'
      });
    }

    // Verificar que el recomendado existe
    const recDoc = await db.collection('recommendations').doc(recommendationId).get();
    if (!recDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendado no encontrado'
      });
    }

    // Verificar si el usuario ya tiene una review para este recomendado
    const existingReviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    let reviewRef;
    let isNew = true;

    if (!existingReviewSnapshot.empty) {
      // Actualizar review existente
      reviewRef = existingReviewSnapshot.docs[0].ref;
      isNew = false;
      
      const updateData = {
        rating: parseInt(rating),
        comment: comment ? comment.trim() : '',
        updatedAt: new Date()
      };

      // Actualizar campos opcionales si se proporcionan
      if (photos !== undefined) updateData.photos = Array.isArray(photos) ? photos : [];
      if (childAge !== undefined) updateData.childAge = childAge ? childAge.trim() : '';
      if (visitedWith !== undefined) updateData.visitedWith = visitedWith || '';

      await reviewRef.update(updateData);

      console.log('‚úÖ [APP] Review actualizada');
    } else {
      // Crear nueva review
      const reviewData = {
        recommendationId,
        userId,
        rating: parseInt(rating),
        comment: comment ? comment.trim() : '',
        photos: Array.isArray(photos) ? photos : [],
        childAge: childAge ? childAge.trim() : '',
        visitedWith: visitedWith || '',
        helpfulCount: 0,
        helpfulBy: [], // Array de userIds que marcaron como √∫til
        createdAt: new Date(),
        updatedAt: new Date()
      };

      reviewRef = await db.collection('recommendationReviews').add(reviewData);

      console.log('‚úÖ [APP] Review creada');
    }

    // Recalcular estad√≠sticas del recomendado
    await updateRecommendationStats(recommendationId);

    // Obtener la review actualizada con info del usuario
    const reviewDoc = await reviewRef.get();
    const reviewData = reviewDoc.data();
    
    const userDoc = await db.collection('users').doc(userId).get();
    const userData = userDoc.data();

    res.json({
      success: true,
      message: isNew ? 'Review creada exitosamente' : 'Review actualizada exitosamente',
      data: {
        id: reviewDoc.id,
        userId,
        userName: userData.displayName || 'Usuario',
        userAvatar: userData.photoURL || null,
        rating: reviewData.rating,
        comment: reviewData.comment,
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error creando/actualizando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando review',
      error: error.message
    });
  }
});

// Subir fotos para reviews (APP) - Una sola foto
app.post('/api/recommendations/:recommendationId/reviews/upload-photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;

    console.log('üì∏ [APP] Subiendo foto de review para:', recommendationId);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna foto'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `review-${recommendationId}-${userId}-${timestamp}-${file.originalname}`;
    
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`reviews/${recommendationId}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype,
        metadata: {
          uploadedBy: userId,
          recommendationId: recommendationId
        }
      }
    });

    blobStream.on('error', (error) => {
      console.error('‚ùå [APP] Error subiendo foto:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo foto',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const photoUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        console.log('‚úÖ [APP] Foto subida:', photoUrl);

        res.json({
          success: true,
          message: 'Foto subida exitosamente',
          data: {
            photoUrl
          }
        });
      } catch (error) {
        console.error('‚ùå [APP] Error haciendo p√∫blica la foto:', error);
        res.status(500).json({
          success: false,
          message: 'Error procesando foto',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('‚ùå [APP] Error en upload de foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});

// Subir m√∫ltiples fotos para reviews (APP) - Hasta 5 fotos
app.post('/api/recommendations/:recommendationId/reviews/upload-photos', authenticateToken, upload.array('photos', 5), async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;

    console.log('üì∏ [APP] Subiendo fotos de review (m√∫ltiples) para:', recommendationId);

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionaron fotos'
      });
    }

    if (req.files.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'M√°ximo 5 fotos por vez'
      });
    }

    const bucket = admin.storage().bucket();
    const uploadPromises = req.files.map((file) => {
      return new Promise((resolve, reject) => {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(7);
        const fileName = `review-${recommendationId}-${userId}-${timestamp}-${random}-${file.originalname}`;
        
        const blob = bucket.file(`reviews/${recommendationId}/${fileName}`);
        
        const blobStream = blob.createWriteStream({
          metadata: {
            contentType: file.mimetype,
            metadata: {
              uploadedBy: userId,
              recommendationId: recommendationId
            }
          }
        });

        blobStream.on('error', (error) => {
          reject(error);
        });

        blobStream.on('finish', async () => {
          try {
            await blob.makePublic();
            const photoUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
            resolve(photoUrl);
          } catch (error) {
            reject(error);
          }
        });

        blobStream.end(file.buffer);
      });
    });

    const photoUrls = await Promise.all(uploadPromises);

    console.log('‚úÖ [APP] Fotos subidas:', photoUrls.length);

    res.json({
      success: true,
      message: `${photoUrls.length} foto(s) subida(s) exitosamente`,
      data: {
        photoUrls
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error subiendo fotos:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo fotos',
      error: error.message
    });
  }
});

// Marcar/desmarcar review como √∫til (APP)
app.post('/api/recommendations/:recommendationId/reviews/:reviewId/helpful', authenticateToken, async (req, res) => {
  try {
    const { recommendationId, reviewId } = req.params;
    const userId = req.user.uid;

    console.log('üëç [APP] Toggle √∫til en review:', reviewId);

    const reviewRef = db.collection('recommendationReviews').doc(reviewId);
    const reviewDoc = await reviewRef.get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    const reviewData = reviewDoc.data();
    const helpfulBy = reviewData.helpfulBy || [];

    let isHelpful;
    let newHelpfulBy;

    if (helpfulBy.includes(userId)) {
      // Ya marcado, quitar
      newHelpfulBy = helpfulBy.filter(id => id !== userId);
      isHelpful = false;
    } else {
      // No marcado, agregar
      newHelpfulBy = [...helpfulBy, userId];
      isHelpful = true;
    }

    await reviewRef.update({
      helpfulBy: newHelpfulBy,
      helpfulCount: newHelpfulBy.length
    });

    console.log(`‚úÖ [APP] Review marcada como ${isHelpful ? '√∫til' : 'no √∫til'}`);

    res.json({
      success: true,
      isHelpful,
      helpfulCount: newHelpfulBy.length
    });

  } catch (error) {
    console.error('‚ùå [APP] Error marcando review como √∫til:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando review',
      error: error.message
    });
  }
});

// Verificar si el usuario marc√≥ una review como √∫til (APP)
app.get('/api/recommendations/:recommendationId/reviews/:reviewId/helpful', authenticateToken, async (req, res) => {
  try {
    const { reviewId } = req.params;
    const userId = req.user.uid;

    console.log('‚ùì [APP] Verificando √∫til en review:', reviewId);

    const reviewDoc = await db.collection('recommendationReviews').doc(reviewId).get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    const reviewData = reviewDoc.data();
    const helpfulBy = reviewData.helpfulBy || [];
    const isHelpful = helpfulBy.includes(userId);

    res.json({
      success: true,
      data: {
        isHelpful
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error verificando √∫til:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando review',
      error: error.message
    });
  }
});

// Obtener la review del usuario actual para un recomendado (APP)
app.get('/api/recommendations/:recommendationId/reviews/my-review', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('‚≠ê [APP] Obteniendo mi review para recomendado:', recommendationId);

    const reviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    if (reviewSnapshot.empty) {
      return res.json({
        success: true,
        data: null
      });
    }

    const reviewDoc = reviewSnapshot.docs[0];
    const reviewData = reviewDoc.data();

    res.json({
      success: true,
      data: {
        id: reviewDoc.id,
        rating: reviewData.rating,
        comment: reviewData.comment,
        photos: reviewData.photos || [],
        childAge: reviewData.childAge || '',
        visitedWith: reviewData.visitedWith || '',
        helpfulCount: reviewData.helpfulCount || 0,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo mi review:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo review',
      error: error.message
    });
  }
});

// Eliminar review propia (APP)
app.delete('/api/recommendations/:recommendationId/reviews/my-review', authenticateToken, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const userId = req.user.uid;
    
    console.log('üóëÔ∏è [APP] Eliminando mi review para recomendado:', recommendationId);

    const reviewSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .where('userId', '==', userId)
      .get();

    if (reviewSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'No tienes una review para este recomendado'
      });
    }

    await reviewSnapshot.docs[0].ref.delete();

    // Recalcular estad√≠sticas del recomendado
    await updateRecommendationStats(recommendationId);

    console.log('‚úÖ [APP] Review eliminada');

    res.json({
      success: true,
      message: 'Review eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [APP] Error eliminando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando review',
      error: error.message
    });
  }
});

// ===== ENDPOINTS ADMIN =====

// Obtener todas las reviews de un recomendado (ADMIN)
app.get('/api/admin/recommendations/:recommendationId/reviews', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('‚≠ê [ADMIN] Obteniendo reviews para recomendado:', recommendationId);

    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    let reviews = await Promise.all(reviewsSnapshot.docs.map(async (doc) => {
      const reviewData = doc.data();
      
      // Obtener informaci√≥n del usuario
      let userInfo = null;
      if (reviewData.userId) {
        const userDoc = await db.collection('users').doc(reviewData.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            id: userDoc.id,
            displayName: userData.displayName,
            email: userData.email,
            photoURL: userData.photoURL
          };
        }
      }

      return {
        id: doc.id,
        recommendationId: reviewData.recommendationId,
        rating: reviewData.rating,
        comment: reviewData.comment,
        user: userInfo,
        createdAt: reviewData.createdAt?.toDate(),
        updatedAt: reviewData.updatedAt?.toDate()
      };
    }));

    // Ordenar por fecha
    reviews.sort((a, b) => (b.createdAt || new Date(0)) - (a.createdAt || new Date(0)));

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedReviews = reviews.slice(startIndex, endIndex);

    // Estad√≠sticas
    const totalReviews = reviews.length;
    const averageRating = totalReviews > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews 
      : 0;

    res.json({
      success: true,
      data: paginatedReviews,
      stats: {
        totalReviews,
        averageRating: Math.round(averageRating * 10) / 10
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReviews,
        totalPages: Math.ceil(totalReviews / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reviews',
      error: error.message
    });
  }
});

// Eliminar una review (ADMIN)
app.delete('/api/admin/recommendations/:recommendationId/reviews/:reviewId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { recommendationId, reviewId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando review:', reviewId);

    const reviewDoc = await db.collection('recommendationReviews').doc(reviewId).get();

    if (!reviewDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Review no encontrada'
      });
    }

    await db.collection('recommendationReviews').doc(reviewId).delete();

    // Recalcular estad√≠sticas del recomendado
    await updateRecommendationStats(recommendationId);

    console.log('‚úÖ [ADMIN] Review eliminada');

    res.json({
      success: true,
      message: 'Review eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando review:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando review',
      error: error.message
    });
  }
});

// Migraci√≥n: Agregar nuevos campos a reviews existentes (ADMIN)
app.post('/api/admin/reviews/migrate-fields', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('üîÑ [ADMIN] Iniciando migraci√≥n de reviews...');

    const snapshot = await db.collection('recommendationReviews').get();
    
    let updated = 0;
    let skipped = 0;
    const updates = [];

    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Solo actualizar si no tiene los nuevos campos
      if (data.photos === undefined || data.helpfulCount === undefined || data.helpfulBy === undefined) {
        const updateData = {};
        
        // Agregar photos si no existe
        if (data.photos === undefined) {
          updateData.photos = [];
        }
        
        // Agregar childAge si no existe
        if (data.childAge === undefined) {
          updateData.childAge = '';
        }
        
        // Agregar visitedWith si no existe
        if (data.visitedWith === undefined) {
          updateData.visitedWith = '';
        }
        
        // Agregar helpfulCount si no existe
        if (data.helpfulCount === undefined) {
          updateData.helpfulCount = 0;
        }
        
        // Agregar helpfulBy si no existe
        if (data.helpfulBy === undefined) {
          updateData.helpfulBy = [];
        }
        
        if (Object.keys(updateData).length > 0) {
          updates.push(
            db.collection('recommendationReviews').doc(doc.id).update(updateData)
          );
          updated++;
        }
      } else {
        skipped++;
      }
    }

    // Ejecutar todas las actualizaciones en paralelo
    if (updates.length > 0) {
      await Promise.all(updates);
    }

    console.log(`‚úÖ [ADMIN] Migraci√≥n completada: ${updated} reviews actualizadas, ${skipped} omitidas`);

    res.json({
      success: true,
      message: 'Migraci√≥n de reviews completada exitosamente',
      data: {
        total: snapshot.size,
        updated,
        skipped
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en migraci√≥n de reviews:', error);
    res.status(500).json({
      success: false,
      message: 'Error ejecutando migraci√≥n',
      error: error.message
    });
  }
});

// Funci√≥n auxiliar para recalcular estad√≠sticas de un recomendado
async function updateRecommendationStats(recommendationId) {
  try {
    const reviewsSnapshot = await db.collection('recommendationReviews')
      .where('recommendationId', '==', recommendationId)
      .get();

    const totalReviews = reviewsSnapshot.size;
    let averageRating = 0;

    if (totalReviews > 0) {
      const totalRating = reviewsSnapshot.docs.reduce((sum, doc) => {
        return sum + (doc.data().rating || 0);
      }, 0);
      averageRating = totalRating / totalReviews;
    }

    // Actualizar el recomendado con las estad√≠sticas
    await db.collection('recommendations').doc(recommendationId).update({
      totalReviews,
      averageRating: Math.round(averageRating * 10) / 10,
      updatedAt: new Date()
    });

    console.log('‚úÖ Estad√≠sticas actualizadas para recomendado:', recommendationId);
  } catch (error) {
    console.error('‚ùå Error actualizando estad√≠sticas:', error);
  }
}

// ========== GESTI√ìN DE LISTAS ==========

// Obtener todas las listas
app.get('/api/admin/lists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '' } = req.query;
    
    console.log('üìã [ADMIN] Obteniendo listas');

    const snapshot = await db.collection('lists')
      .orderBy('createdAt', 'desc')
      .get();
    
    // Obtener informaci√≥n de los usuarios due√±os de las listas
    const listsWithOwners = await Promise.all(snapshot.docs.map(async (doc) => {
      const listData = doc.data();
      let ownerInfo = null;

      // Buscar el due√±o usando userId o creatorId (compatibilidad con ambos formatos)
      const ownerId = listData.userId || listData.creatorId;

      if (ownerId) {
        try {
          const userDoc = await db.collection('users').doc(ownerId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            ownerInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario sin nombre',
              email: userData.email || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${ownerId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...listData,
        owner: ownerInfo,
        createdAt: listData.createdAt?.toDate(),
        updatedAt: listData.updatedAt?.toDate()
      };
    }));

    // Filtrar por b√∫squeda si existe
    let lists = listsWithOwners;
    if (search) {
      const searchLower = search.toLowerCase();
      lists = listsWithOwners.filter(list => 
        list.title?.toLowerCase().includes(searchLower) ||
        list.description?.toLowerCase().includes(searchLower) ||
        list.owner?.displayName?.toLowerCase().includes(searchLower) ||
        list.owner?.email?.toLowerCase().includes(searchLower)
      );
    }

    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedLists = lists.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedLists,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: lists.length,
        totalPages: Math.ceil(lists.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo listas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas',
      error: error.message
    });
  }
});

// Obtener detalle de una lista espec√≠fica
app.get('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('üìã [ADMIN] Obteniendo detalle de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    let ownerInfo = null;

    // Obtener informaci√≥n del due√±o (compatibilidad con userId y creatorId)
    const ownerId = listData.userId || listData.creatorId;

    if (ownerId) {
      try {
        const userDoc = await db.collection('users').doc(ownerId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          ownerInfo = {
            id: userDoc.id,
            displayName: userData.displayName || 'Usuario sin nombre',
            email: userData.email || null,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.error(`Error obteniendo usuario ${ownerId}:`, error);
      }
    }

    res.json({
      success: true,
      data: {
        id: listDoc.id,
        ...listData,
        owner: ownerInfo,
        createdAt: listData.createdAt?.toDate(),
        updatedAt: listData.updatedAt?.toDate()
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalle de lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de lista',
      error: error.message
    });
  }
});

// Crear nueva lista
app.post('/api/admin/lists', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, description, items = [], isPublic = true, imageUrl } = req.body;
    
    console.log('‚ûï [ADMIN] Creando nueva lista:', title);

    if (!title) {
      return res.status(400).json({
        success: false,
        message: 'El t√≠tulo de la lista es requerido'
      });
    }

    // Procesar items con estructura completa
    const processedItems = items.map((item, index) => ({
      id: item.id || `item_${Date.now()}_${index}`,
      text: item.text ? item.text.trim() : '',
      imageUrl: item.imageUrl || null,
      priority: item.priority || 'medium',
      details: item.details || '',
      brand: item.brand || '',
      store: item.store || '',
      approximatePrice: item.approximatePrice || null,
      completed: item.completed || false,
      createdAt: item.createdAt || new Date()
    }));

    const listData = {
      title: title.trim(),
      description: description ? description.trim() : '',
      imageUrl: imageUrl || null,
      items: processedItems,
      isPublic,
      userId: req.user.uid,
      creatorId: req.user.uid, // Agregar tambi√©n creatorId para compatibilidad
      completedItems: processedItems.filter(item => item.completed).length,
      totalItems: processedItems.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const listRef = await db.collection('lists').add(listData);

    console.log('‚úÖ [ADMIN] Lista creada con', processedItems.length, 'items');

    res.json({
      success: true,
      message: 'Lista creada exitosamente',
      data: {
        id: listRef.id,
        ...listData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando lista',
      error: error.message
    });
  }
});

// Editar lista
app.put('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    const { title, description, items, isPublic, imageUrl } = req.body;
    
    console.log('‚úèÔ∏è [ADMIN] Editando lista:', listId);

    const listRef = db.collection('lists').doc(listId);
    const listDoc = await listRef.get();

    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const oldListData = listDoc.data();
    const updateData = {
      updatedAt: new Date()
    };

    if (title !== undefined) updateData.title = title.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (isPublic !== undefined) updateData.isPublic = isPublic;
    
    // Si se est√°n actualizando los items, procesarlos con estructura completa
    if (items !== undefined) {
      const oldItems = oldListData.items || [];
      const itemIdMapping = {}; // Mapeo de itemId viejo -> itemId nuevo
      
      const processedItems = items.map((item, index) => {
        // Si el item ya tiene un ID, conservarlo sin cambios
        if (item.id) {
          return {
            id: item.id, // Mantener el ID existente
            text: item.text ? item.text.trim() : '',
            imageUrl: item.imageUrl || null,
            priority: item.priority || 'medium',
            details: item.details || '',
            brand: item.brand || '',
            store: item.store || '',
            approximatePrice: item.approximatePrice || null,
            completed: item.completed || false,
            createdAt: item.createdAt || new Date()
          };
        }
        
        // Si no tiene ID, intentar encontrar el item anterior por texto
        const newItemId = `item_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
        
        if (item.text) {
          const oldItem = oldItems.find(old => 
            old.text && old.text.toLowerCase().trim() === item.text.toLowerCase().trim()
          );
          
          if (oldItem && oldItem.id) {
            // Usar el ID del item anterior si se encuentra por texto
            console.log(`üîó [ADMIN] Reutilizando itemId existente: ${oldItem.id} para "${item.text}"`);
            return {
              id: oldItem.id, // Reutilizar ID existente
              text: item.text.trim(),
              imageUrl: item.imageUrl || null,
              priority: item.priority || 'medium',
              details: item.details || '',
              brand: item.brand || '',
              store: item.store || '',
              approximatePrice: item.approximatePrice || null,
              completed: item.completed || false,
              createdAt: item.createdAt || oldItem.createdAt || new Date()
            };
          }
        }
        
        // Generar nuevo ID solo si es un item completamente nuevo
        console.log(`‚ú® [ADMIN] Generando nuevo itemId: ${newItemId} para "${item.text}"`);
        return {
          id: newItemId,
          text: item.text ? item.text.trim() : '',
          imageUrl: item.imageUrl || null,
          priority: item.priority || 'medium',
          details: item.details || '',
          brand: item.brand || '',
          store: item.store || '',
          approximatePrice: item.approximatePrice || null,
          completed: item.completed || false,
          createdAt: item.createdAt || new Date()
        };
      });
      
      updateData.items = processedItems;
      updateData.completedItems = processedItems.filter(item => item.completed).length;
      updateData.totalItems = processedItems.length;
      
      console.log('‚úÖ [ADMIN] Items procesados:', processedItems.length);
      
      // Actualizar itemId en comentarios y ratings si hay mapeos
      if (Object.keys(itemIdMapping).length > 0) {
        console.log('üîÑ [ADMIN] Actualizando itemIds en comentarios y ratings...');
        
        // Actualizar comentarios
        const commentsSnapshot = await db.collection('listComments')
          .where('listId', '==', listId)
          .get();
        
        const commentUpdates = [];
        commentsSnapshot.forEach(doc => {
          const oldItemId = doc.data().itemId;
          if (itemIdMapping[oldItemId]) {
            commentUpdates.push(
              doc.ref.update({ itemId: itemIdMapping[oldItemId] })
            );
            console.log(`  ‚úì Comentario ${doc.id}: ${oldItemId} -> ${itemIdMapping[oldItemId]}`);
          }
        });
        
        // Actualizar ratings
        const ratingsSnapshot = await db.collection('itemRatings')
          .where('listId', '==', listId)
          .get();
        
        const ratingUpdates = [];
        ratingsSnapshot.forEach(doc => {
          const oldItemId = doc.data().itemId;
          if (itemIdMapping[oldItemId]) {
            ratingUpdates.push(
              doc.ref.update({ itemId: itemIdMapping[oldItemId] })
            );
            console.log(`  ‚úì Rating ${doc.id}: ${oldItemId} -> ${itemIdMapping[oldItemId]}`);
          }
        });
        
        // Ejecutar todas las actualizaciones
        await Promise.all([...commentUpdates, ...ratingUpdates]);
        console.log(`‚úÖ [ADMIN] Actualizados ${commentUpdates.length} comentarios y ${ratingUpdates.length} ratings`);
      }
    }

    await listRef.update(updateData);

    res.json({
      success: true,
      message: 'Lista actualizada exitosamente',
      data: {
        id: listId,
        ...listDoc.data(),
        ...updateData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error editando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error editando lista',
      error: error.message
    });
  }
});

// Endpoint para sincronizar itemIds en comentarios y ratings con los items actuales de la lista
app.post('/api/admin/lists/:listId/sync-item-ids', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('üîÑ [ADMIN] Sincronizando itemIds para lista:', listId);

    // Obtener la lista
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    const currentItems = listData.items || [];
    
    if (currentItems.length === 0) {
      return res.json({
        success: true,
        message: 'La lista no tiene items',
        data: {
          commentsUpdated: 0,
          ratingsUpdated: 0
        }
      });
    }

    // Crear mapeo de texto -> itemId actual
    const textToIdMap = {};
    currentItems.forEach(item => {
      if (item.text && item.id) {
        const normalizedText = item.text.toLowerCase().trim();
        textToIdMap[normalizedText] = item.id;
      }
    });

    console.log('üìã [ADMIN] Items encontrados:', currentItems.length);
    console.log('üó∫Ô∏è [ADMIN] Mapeo de texto a ID:', Object.keys(textToIdMap).length);

    // Obtener todos los comentarios de esta lista
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .get();

    // Obtener todos los ratings de esta lista
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();

    console.log('üí¨ [ADMIN] Comentarios encontrados:', commentsSnapshot.size);
    console.log('‚≠ê [ADMIN] Ratings encontrados:', ratingsSnapshot.size);

    const commentUpdates = [];
    const ratingUpdates = [];
    let commentsUpdated = 0;
    let ratingsUpdated = 0;

    // Actualizar comentarios
    for (const doc of commentsSnapshot.docs) {
      const commentData = doc.data();
      const currentItemId = commentData.itemId;
      
      // Buscar el item actual por su ID antiguo
      const matchingItem = currentItems.find(item => {
        // Intentar match por texto
        if (commentData.itemId && item.text) {
          // Buscar el item por itemId en el texto normalizado
          const normalizedText = item.text.toLowerCase().trim();
          return textToIdMap[normalizedText] && item.id !== currentItemId;
        }
        return false;
      });

      // Si encontramos un item que coincide por texto pero tiene diferente ID
      if (matchingItem && matchingItem.id !== currentItemId) {
        commentUpdates.push(
          doc.ref.update({ itemId: matchingItem.id })
            .then(() => {
              console.log(`  ‚úì Comentario ${doc.id}: ${currentItemId} -> ${matchingItem.id}`);
              commentsUpdated++;
            })
        );
      }
    }

    // Actualizar ratings
    for (const doc of ratingsSnapshot.docs) {
      const ratingData = doc.data();
      const currentItemId = ratingData.itemId;
      
      // Buscar el item actual
      const matchingItem = currentItems.find(item => {
        if (ratingData.itemId && item.text) {
          const normalizedText = item.text.toLowerCase().trim();
          return textToIdMap[normalizedText] && item.id !== currentItemId;
        }
        return false;
      });

      if (matchingItem && matchingItem.id !== currentItemId) {
        ratingUpdates.push(
          doc.ref.update({ itemId: matchingItem.id })
            .then(() => {
              console.log(`  ‚úì Rating ${doc.id}: ${currentItemId} -> ${matchingItem.id}`);
              ratingsUpdated++;
            })
        );
      }
    }

    // Ejecutar todas las actualizaciones
    await Promise.all([...commentUpdates, ...ratingUpdates]);

    console.log(`‚úÖ [ADMIN] Sincronizaci√≥n completada: ${commentsUpdated} comentarios, ${ratingsUpdated} ratings`);

    res.json({
      success: true,
      message: 'ItemIds sincronizados exitosamente',
      data: {
        totalItems: currentItems.length,
        totalComments: commentsSnapshot.size,
        totalRatings: ratingsSnapshot.size,
        commentsUpdated,
        ratingsUpdated
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error sincronizando itemIds:', error);
    res.status(500).json({
      success: false,
      message: 'Error sincronizando itemIds',
      error: error.message
    });
  }
});

// Endpoint para sincronizar TODAS las listas (migraci√≥n masiva)
app.post('/api/admin/lists/sync-all-item-ids', authenticateToken, isAdmin, async (req, res) => {
  try {
    console.log('üîÑ [ADMIN] Sincronizando itemIds para TODAS las listas...');

    // Obtener todas las listas
    const listsSnapshot = await db.collection('lists').get();
    
    console.log('üìã [ADMIN] Total listas:', listsSnapshot.size);

    const results = [];
    
    for (const listDoc of listsSnapshot.docs) {
      const listId = listDoc.id;
      const listData = listDoc.data();
      const currentItems = listData.items || [];
      
      if (currentItems.length === 0) continue;

      // Crear mapeo de texto -> itemId actual
      const textToIdMap = {};
      currentItems.forEach(item => {
        if (item.text && item.id) {
          const normalizedText = item.text.toLowerCase().trim();
          textToIdMap[normalizedText] = item.id;
        }
      });

      // Obtener comentarios y ratings de esta lista
      const [commentsSnapshot, ratingsSnapshot] = await Promise.all([
        db.collection('listComments').where('listId', '==', listId).get(),
        db.collection('itemRatings').where('listId', '==', listId).get()
      ]);

      let commentsUpdated = 0;
      let ratingsUpdated = 0;
      const updates = [];

      // Procesar comentarios
      commentsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId) {
          // Buscar item por texto del comentario (necesitar√≠amos el texto del item)
          const matchingItem = currentItems.find(item => item.id === data.itemId);
          if (!matchingItem && currentItems.length > 0) {
            // Si no coincide, intentar encontrar por √≠ndice o primer item
            const firstItem = currentItems[0];
            if (firstItem && firstItem.id !== data.itemId) {
              updates.push(
                doc.ref.update({ itemId: firstItem.id }).then(() => commentsUpdated++)
              );
            }
          }
        }
      });

      // Procesar ratings
      ratingsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId) {
          const matchingItem = currentItems.find(item => item.id === data.itemId);
          if (!matchingItem && currentItems.length > 0) {
            const firstItem = currentItems[0];
            if (firstItem && firstItem.id !== data.itemId) {
              updates.push(
                doc.ref.update({ itemId: firstItem.id }).then(() => ratingsUpdated++)
              );
            }
          }
        }
      });

      await Promise.all(updates);

      if (commentsUpdated > 0 || ratingsUpdated > 0) {
        results.push({
          listId,
          listTitle: listData.title,
          commentsUpdated,
          ratingsUpdated
        });
        console.log(`  ‚úì Lista "${listData.title}": ${commentsUpdated} comentarios, ${ratingsUpdated} ratings actualizados`);
      }
    }

    console.log(`‚úÖ [ADMIN] Sincronizaci√≥n masiva completada: ${results.length} listas procesadas`);

    res.json({
      success: true,
      message: 'Sincronizaci√≥n masiva completada',
      data: {
        totalLists: listsSnapshot.size,
        listsUpdated: results.length,
        details: results
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en sincronizaci√≥n masiva:', error);
    res.status(500).json({
      success: false,
      message: 'Error en sincronizaci√≥n masiva',
      error: error.message
    });
  }
});

// Eliminar lista
app.delete('/api/admin/lists/:listId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    await db.collection('lists').doc(listId).delete();

    res.json({
      success: true,
      message: 'Lista eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando lista',
      error: error.message
    });
  }
});

// Obtener calificaciones de una lista (items)
app.get('/api/admin/lists/:listId/ratings', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    
    console.log('‚≠ê [ADMIN] Obteniendo calificaciones de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    // Obtener todas las calificaciones de items de esta lista
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();

    const ratings = await Promise.all(ratingsSnapshot.docs.map(async (doc) => {
      const ratingData = doc.data();
      let userInfo = null;

      // Obtener informaci√≥n del usuario que calific√≥
      if (ratingData.userId) {
        try {
          const userDoc = await db.collection('users').doc(ratingData.userId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario',
              email: userData.email || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${ratingData.userId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...ratingData,
        user: userInfo,
        createdAt: ratingData.createdAt?.toDate()
      };
    }));

    // Calcular estad√≠sticas por item
    const itemStats = {};
    ratings.forEach(rating => {
      if (!itemStats[rating.itemId]) {
        itemStats[rating.itemId] = {
          itemId: rating.itemId,
          totalRatings: 0,
          sumRatings: 0,
          averageRating: 0
        };
      }
      itemStats[rating.itemId].totalRatings++;
      itemStats[rating.itemId].sumRatings += rating.rating;
    });

    // Calcular promedios
    Object.keys(itemStats).forEach(itemId => {
      const stats = itemStats[itemId];
      stats.averageRating = parseFloat((stats.sumRatings / stats.totalRatings).toFixed(1));
    });

    res.json({
      success: true,
      data: {
        ratings: ratings,
        stats: Object.values(itemStats),
        totalRatings: ratings.length
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo calificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones',
      error: error.message
    });
  }
});

// Obtener comentarios de una lista (items)
app.get('/api/admin/lists/:listId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    console.log('üí¨ [ADMIN] Obteniendo comentarios de lista:', listId);

    const listDoc = await db.collection('lists').doc(listId).get();
    
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    // Obtener todos los comentarios de items de esta lista
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .orderBy('createdAt', 'desc')
      .get();

    const allComments = await Promise.all(commentsSnapshot.docs.map(async (doc) => {
      const commentData = doc.data();
      let userInfo = null;

      // Obtener informaci√≥n del usuario que coment√≥
      if (commentData.userId) {
        try {
          const userDoc = await db.collection('users').doc(commentData.userId).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            userInfo = {
              id: userDoc.id,
              displayName: userData.displayName || 'Usuario',
              email: userData.email || null,
              photoURL: userData.photoURL || null
            };
          }
        } catch (error) {
          console.error(`Error obteniendo usuario ${commentData.userId}:`, error);
        }
      }

      return {
        id: doc.id,
        ...commentData,
        user: userInfo,
        createdAt: commentData.createdAt?.toDate()
      };
    }));

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = allComments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: allComments.length,
        totalPages: Math.ceil(allComments.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Eliminar calificaci√≥n
app.delete('/api/admin/lists/:listId/ratings/:ratingId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { ratingId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando calificaci√≥n:', ratingId);

    await db.collection('itemRatings').doc(ratingId).delete();

    res.json({
      success: true,
      message: 'Calificaci√≥n eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando calificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando calificaci√≥n',
      error: error.message
    });
  }
});

// Eliminar comentario
app.delete('/api/admin/lists/:listId/comments/:commentId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { commentId } = req.params;
    
    console.log('üóëÔ∏è [ADMIN] Eliminando comentario:', commentId);

    await db.collection('listComments').doc(commentId).delete();

    res.json({
      success: true,
      message: 'Comentario eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando comentario',
      error: error.message
    });
  }
});

// Obtener calificaciones de un item espec√≠fico
app.get('/api/admin/lists/:listId/items/:itemId/ratings', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId, itemId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    console.log('‚≠ê [ADMIN] Obteniendo ratings del item:', itemId, 'en lista:', listId);

    // Primero, obtener todos los ratings de la lista para debug
    const allRatingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .get();
    
    console.log('üìä [ADMIN] Total ratings en la lista:', allRatingsSnapshot.size);
    if (allRatingsSnapshot.size > 0) {
      console.log('üîç [ADMIN] Ejemplo de itemIds encontrados:', 
        allRatingsSnapshot.docs.slice(0, 3).map(doc => doc.data().itemId)
      );
    }

    // Obtener todas las calificaciones del item
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    console.log('‚úÖ [ADMIN] Ratings encontrados para itemId', itemId, ':', ratingsSnapshot.size);

    const ratings = [];
    for (const doc of ratingsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaci√≥n del usuario
      let userInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            displayName: userData.displayName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [ADMIN] Error obteniendo info del usuario:', data.userId);
      }

      ratings.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        user: userInfo,
        rating: data.rating,
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (m√°s recientes primero)
    ratings.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // Calcular estad√≠sticas
    const totalRatings = ratings.length;
    const averageRating = totalRatings > 0 
      ? (ratings.reduce((sum, r) => sum + r.rating, 0) / totalRatings).toFixed(2)
      : 0;

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedRatings = ratings.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedRatings,
      stats: {
        totalRatings,
        averageRating: parseFloat(averageRating),
        distribution: {
          5: ratings.filter(r => r.rating === 5).length,
          4: ratings.filter(r => r.rating === 4).length,
          3: ratings.filter(r => r.rating === 3).length,
          2: ratings.filter(r => r.rating === 2).length,
          1: ratings.filter(r => r.rating === 1).length
        }
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalRatings,
        totalPages: Math.ceil(totalRatings / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo ratings del item:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones del item',
      error: error.message
    });
  }
});

// Obtener comentarios de un item espec√≠fico
app.get('/api/admin/lists/:listId/items/:itemId/comments', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { listId } = req.params;
    let { itemId } = req.params;
    const { page = 1, limit = 20 } = req.query;
    
    // Decodificar el itemId por si viene con URL encoding
    itemId = decodeURIComponent(itemId);
    
    console.log('üí¨ [ADMIN] Obteniendo comentarios del item');
    console.log('   - ItemId recibido:', itemId);
    console.log('   - ItemId length:', itemId.length);
    console.log('   - ListId:', listId);

    // Primero, obtener todos los comentarios de la lista para debug
    const allCommentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .get();
    
    console.log('üìä [ADMIN] Total comentarios en la lista:', allCommentsSnapshot.size);
    
    if (allCommentsSnapshot.size > 0) {
      const exampleItemIds = allCommentsSnapshot.docs.slice(0, 5).map(doc => {
        const itemId = doc.data().itemId;
        return {
          id: itemId,
          length: itemId?.length,
          type: typeof itemId
        };
      });
      console.log('üîç [ADMIN] Ejemplos de itemIds en Firestore:', JSON.stringify(exampleItemIds, null, 2));
    }

    // Obtener todos los comentarios del item
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    console.log('‚úÖ [ADMIN] Comentarios encontrados para itemId exacto:', commentsSnapshot.size);
    
    // Si no se encontraron, intentar buscar con comparaci√≥n flexible
    let allComments = [];
    if (commentsSnapshot.size === 0 && allCommentsSnapshot.size > 0) {
      console.log('‚ö†Ô∏è [ADMIN] No se encontr√≥ match exacto, buscando similares...');
      allCommentsSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.itemId && data.itemId.toString() === itemId.toString()) {
          allComments.push({ id: doc.id, data });
          console.log('‚úÖ [ADMIN] Match encontrado con conversi√≥n a string');
        }
      });
    }

    // Usar los comentarios encontrados (exactos o flexibles)
    const docsToProcess = commentsSnapshot.size > 0 
      ? commentsSnapshot.docs 
      : allComments.map(c => ({ id: c.id, data: () => c.data }));

    const comments = [];
    for (const doc of docsToProcess) {
      const data = typeof doc.data === 'function' ? doc.data() : doc.data;
      
      // Obtener informaci√≥n del usuario con foto
      let userInfo = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userInfo = {
            displayName: userData.displayName || data.userName || 'Usuario',
            email: userData.email,
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [ADMIN] Error obteniendo info del usuario:', data.userId);
        userInfo = {
          displayName: data.userName || 'Usuario',
          email: null,
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        user: userInfo,
        content: data.content,
        createdAt: data.createdAt
      });
    }

    // Ordenar por fecha (m√°s recientes primero)
    comments.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt);
      const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt);
      return dateB - dateA;
    });

    // Paginaci√≥n
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedComments = comments.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedComments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: comments.length,
        totalPages: Math.ceil(comments.length / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo comentarios del item:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios del item',
      error: error.message
    });
  }
});

// ==========================================
// üì∏ SUBIDA DE IM√ÅGENES GENERAL
// ==========================================

// Endpoint general para subir im√°genes (usuarios autenticados)
app.post('/api/upload/image', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'general' } = req.body; // tipo: list, item, community, profile, etc.

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `${type}-${uid}-${timestamp}-${file.originalname}`;
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`images/${type}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype
      }
    });

    blobStream.on('error', (error) => {
      console.error('Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error al subir la imagen',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const publicUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        res.json({
          success: true,
          message: 'Imagen subida exitosamente',
          imageUrl: publicUrl
        });
      } catch (error) {
        console.error('Error haciendo la imagen p√∫blica:', error);
        res.status(500).json({
          success: false,
          message: 'Error al hacer p√∫blica la imagen',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Endpoint para subir im√°genes desde el admin dashboard
app.post('/api/admin/upload/image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'general' } = req.body; // tipo: list, item, community, profile, etc.

    console.log('üì§ [ADMIN] Subiendo imagen, tipo:', type);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    const file = req.file;
    const timestamp = Date.now();
    const fileName = `${type}-admin-${uid}-${timestamp}-${file.originalname}`;
    const bucket = admin.storage().bucket();
    const blob = bucket.file(`images/${type}/${fileName}`);
    
    const blobStream = blob.createWriteStream({
      metadata: {
        contentType: file.mimetype
      }
    });

    blobStream.on('error', (error) => {
      console.error('‚ùå [ADMIN] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error al subir la imagen',
        error: error.message
      });
    });

    blobStream.on('finish', async () => {
      try {
        await blob.makePublic();
        const publicUrl = `https://storage.googleapis.com/${bucket.name}/${blob.name}`;
        
        console.log('‚úÖ [ADMIN] Imagen subida exitosamente:', publicUrl);
        
        res.json({
          success: true,
          message: 'Imagen subida exitosamente',
          imageUrl: publicUrl
        });
      } catch (error) {
        console.error('‚ùå [ADMIN] Error haciendo la imagen p√∫blica:', error);
        res.status(500).json({
          success: false,
          message: 'Error al hacer p√∫blica la imagen',
          error: error.message
        });
      }
    });

    blobStream.end(file.buffer);

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// ==========================================
// üì∏ FOTO DE PERFIL DEL USUARIO
// ==========================================

// Endpoint para subir/actualizar foto de perfil del usuario
app.post('/api/auth/profile/photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { uid } = req.user;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna foto'
      });
    }

    console.log('üì∏ [PROFILE-PHOTO] Subiendo foto de perfil para usuario:', uid);
    console.log('üì∏ [PROFILE-PHOTO] Archivo:', req.file.originalname, req.file.size, 'bytes');

    // Subir a Firebase Storage
    const bucket = admin.storage().bucket();
    const fileName = `profile-photos/${uid}/${Date.now()}_${req.file.originalname}`;
    const file = bucket.file(fileName);

    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
        metadata: {
          firebaseStorageDownloadTokens: uid
        }
      }
    });

    // Hacer el archivo p√∫blico y obtener la URL
    await file.makePublic();
    const photoURL = `https://storage.googleapis.com/${bucket.name}/${fileName}`;

    console.log('‚úÖ [PROFILE-PHOTO] Foto subida:', photoURL);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: photoURL
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: photoURL,
      updatedAt: new Date()
    });

    console.log('‚úÖ [PROFILE-PHOTO] Perfil actualizado en Auth y Firestore');

    res.json({
      success: true,
      message: 'Foto de perfil actualizada exitosamente',
      data: {
        photoURL: photoURL
      }
    });

  } catch (error) {
    console.error('‚ùå [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al subir la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint para actualizar foto de perfil con URL externa (Google, Apple, etc.)
app.put('/api/auth/profile/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { photoURL } = req.body;

    if (!photoURL) {
      return res.status(400).json({
        success: false,
        message: 'URL de la foto es requerida'
      });
    }

    console.log('üì∏ [PROFILE-PHOTO] Actualizando foto de perfil para usuario:', uid);
    console.log('üì∏ [PROFILE-PHOTO] Nueva URL:', photoURL);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: photoURL
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: photoURL,
      updatedAt: new Date()
    });

    console.log('‚úÖ [PROFILE-PHOTO] Foto de perfil actualizada');

    res.json({
      success: true,
      message: 'Foto de perfil actualizada exitosamente',
      data: {
        photoURL: photoURL
      }
    });

  } catch (error) {
    console.error('‚ùå [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint para eliminar foto de perfil
app.delete('/api/auth/profile/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    console.log('üóëÔ∏è [PROFILE-PHOTO] Eliminando foto de perfil para usuario:', uid);

    // Obtener la foto actual
    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();
    const currentPhotoURL = userData?.photoURL;

    // Si la foto est√° en Firebase Storage, eliminarla
    if (currentPhotoURL && currentPhotoURL.includes('storage.googleapis.com')) {
      try {
        const bucket = admin.storage().bucket();
        // Extraer el nombre del archivo de la URL
        const filePathMatch = currentPhotoURL.match(/profile-photos\/.+/);
        if (filePathMatch) {
          const filePath = decodeURIComponent(filePathMatch[0]);
          const file = bucket.file(filePath);
          await file.delete();
          console.log('‚úÖ [PROFILE-PHOTO] Archivo eliminado de Storage:', filePath);
        }
      } catch (storageError) {
        console.log('‚ö†Ô∏è [PROFILE-PHOTO] Error al eliminar de Storage (continuando):', storageError.message);
      }
    }

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      photoURL: null
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      photoURL: null,
      updatedAt: new Date()
    });

    console.log('‚úÖ [PROFILE-PHOTO] Foto de perfil eliminada');

    res.json({
      success: true,
      message: 'Foto de perfil eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [PROFILE-PHOTO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la foto de perfil',
      error: error.message
    });
  }
});

// Endpoint protegido - Perfil del usuario
app.get('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const userRecord = await auth.getUser(uid);
    
    let userData = {
      uid: userRecord.uid,
      email: userRecord.email,
      displayName: userRecord.displayName,
      emailVerified: userRecord.emailVerified,
      createdAt: userRecord.metadata.creationTime,
      lastSignIn: userRecord.metadata.lastSignInTime,
      gender: null, // M o F
      childrenCount: 0,
      isPregnant: false,
      gestationWeeks: null
    };

    // Obtener datos adicionales de Firestore
    if (db) {
      const userDoc = await db.collection('users').doc(uid).get();
      if (userDoc.exists) {
        const firestoreData = userDoc.data();
        
        // Calcular semanas de gestaci√≥n actuales si est√° embarazada
        let currentGestationWeeks = firestoreData.gestationWeeks || null;
        let daysSinceRegistration = null;
        
        if (firestoreData.isPregnant && firestoreData.gestationWeeks && firestoreData.createdAt) {
          const now = new Date();
          const createdDate = new Date(firestoreData.createdAt);
          const diffTime = now - createdDate;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          const diffWeeks = Math.floor(diffDays / 7);
          const calculatedWeeks = firestoreData.gestationWeeks + diffWeeks;
          
          // Aplicar l√≠mites
          if (calculatedWeeks > 42) {
            currentGestationWeeks = 40; // T√©rmino completo
          } else if (calculatedWeeks < 4) {
            currentGestationWeeks = 4; // M√≠nimo
          } else {
            currentGestationWeeks = calculatedWeeks;
          }
          
          daysSinceRegistration = diffDays;
          
          console.log(`üìä [PROFILE GESTATION] Usuario: ${firestoreData.gestationWeeks} semanas + ${diffWeeks} semanas = ${currentGestationWeeks} semanas (${diffDays} d√≠as desde registro)`);
        }
        
        userData = { 
          ...userData, 
          gender: firestoreData.gender || null,
          childrenCount: firestoreData.childrenCount || 0,
          isPregnant: firestoreData.isPregnant || false,
          gestationWeeks: firestoreData.gestationWeeks || null, // Semanas registradas originales
          currentGestationWeeks: currentGestationWeeks, // Semanas calculadas autom√°ticamente
          daysSinceRegistration: daysSinceRegistration, // D√≠as desde el registro
          isActive: firestoreData.isActive || true,
          updatedAt: firestoreData.updatedAt,
          latitude: firestoreData.latitude ?? null,
          longitude: firestoreData.longitude ?? null,
          countryId: firestoreData.countryId || null,
          countryName: firestoreData.countryName || null,
          cityId: firestoreData.cityId || null,
          cityName: firestoreData.cityName || null
        };
      }
    }

    res.json({
      success: true,
      data: userData
    });

  } catch (error) {
    console.error('Error al obtener perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener perfil del usuario',
      error: error.message
    });
  }
});

// Endpoint para actualizar perfil
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { displayName, email, gender, childrenCount, isPregnant, gestationWeeks } = req.body;

    const updateData = {};
    if (displayName) updateData.displayName = displayName;
    if (email) updateData.email = email;
    if (gender) updateData.gender = gender;
    if (childrenCount !== undefined) updateData.childrenCount = childrenCount;
    if (isPregnant !== undefined) updateData.isPregnant = isPregnant;
    if (gestationWeeks !== undefined) updateData.gestationWeeks = gestationWeeks;

    // Validar gestaci√≥n solo para mujeres
    if (gender === 'F' && isPregnant && (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42)) {
      return res.status(400).json({
        success: false,
        message: 'Para mujeres embarazadas, las semanas de gestaci√≥n deben estar entre 1 y 42'
      });
    }

    // Limpiar campos de gestaci√≥n si no est√° embarazada o es hombre
    if (gender === 'M' || !isPregnant) {
      updateData.isPregnant = false;
      updateData.gestationWeeks = null;
    }

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, updateData);

    // Calcular el n√∫mero real de hijos de la base de datos
    let actualChildrenCount = 0;
    if (db) {
      const childrenSnapshot = await db.collection('children')
        .where('parentId', '==', uid)
        .get();
      
      actualChildrenCount = childrenSnapshot.size;
      console.log('üìä [PROFILE] N√∫mero real de hijos en BD:', actualChildrenCount);
    }

    // Actualizar childrenCount con el valor real
    updateData.childrenCount = actualChildrenCount;

    // Actualizar en Firestore
    if (db) {
      await db.collection('users').doc(uid).update({
        ...updateData,
        updatedAt: new Date()
      });
    }

    res.json({
      success: true,
      message: 'Perfil actualizado exitosamente',
      data: { uid, ...updateData }
    });

  } catch (error) {
    console.error('Error al actualizar perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar perfil',
      error: error.message
    });
  }
});

// Actualizar ubicaci√≥n del usuario (app)
app.put('/api/auth/location', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { latitude, longitude, countryId, cityId } = req.body || {};

    if (latitude === undefined && longitude === undefined && countryId === undefined && cityId === undefined) {
      return res.status(400).json({
        success: false,
        message: 'Debes enviar latitude/longitude o countryId/cityId'
      });
    }

    const updateData = {};
    if (latitude !== undefined) {
      const parsedLat = parseFloat(latitude);
      if (Number.isNaN(parsedLat)) {
        return res.status(400).json({ success: false, message: 'latitude inv√°lida' });
      }
      updateData.latitude = parsedLat;
    }
    if (longitude !== undefined) {
      const parsedLng = parseFloat(longitude);
      if (Number.isNaN(parsedLng)) {
        return res.status(400).json({ success: false, message: 'longitude inv√°lida' });
      }
      updateData.longitude = parsedLng;
    }

    const hasLocationIds = Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId');
    if (hasLocationIds) {
      const isBlankLocation = (value) => value === null || value === undefined || String(value).trim() === '';
      const hasNoLocationValues = isBlankLocation(countryId) && isBlankLocation(cityId);
      if (hasNoLocationValues) {
        const defaultLocation = await getDefaultUserLocation();
        updateData.countryId = defaultLocation.countryId;
        updateData.countryName = defaultLocation.countryName;
        updateData.cityId = defaultLocation.cityId;
        updateData.cityName = defaultLocation.cityName;
      } else {
      try {
        const locationData = await resolveCountryCity(countryId, cityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
      }
    }

    if (db) {
      await db.collection('users').doc(uid).set({
        ...updateData,
        updatedAt: new Date()
      }, { merge: true });
    }

    res.json({
      success: true,
      message: 'Ubicaci√≥n actualizada',
      data: { uid, ...updateData }
    });
  } catch (error) {
    console.error('‚ùå [PROFILE] Error actualizando ubicaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando ubicaci√≥n',
      error: error.message
    });
  }
});

// Endpoint para cambiar contrase√±a
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { newPassword } = req.body;

    if (!newPassword || newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'La nueva contrase√±a debe tener al menos 6 caracteres'
      });
    }

    // Actualizar contrase√±a en Firebase Auth
    await auth.updateUser(uid, { password: newPassword });

    res.json({
      success: true,
      message: 'Contrase√±a actualizada exitosamente'
    });

  } catch (error) {
    console.error('Error al cambiar contrase√±a:', error);
    res.status(500).json({
      success: false,
      message: 'Error al cambiar contrase√±a',
      error: error.message
    });
  }
});

// Endpoint para eliminar cuenta
app.delete('/api/auth/account', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Eliminar de Firestore
    if (db) {
      await db.collection('users').doc(uid).delete();
    }

    // Eliminar de Firebase Auth
    await auth.deleteUser(uid);

    res.json({
      success: true,
      message: 'Cuenta eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error al eliminar cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar cuenta',
      error: error.message
    });
  }
});

// Ruta para solicitar restablecimiento de contrase√±a
app.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: 'Email es requerido'
      });
    }

    // Verificar que Firebase Auth est√© disponible
    if (!auth) {
      console.error('‚ùå [FORGOT-PASSWORD] Firebase Auth no est√° disponible');
      return res.status(500).json({
        success: false,
        message: 'Servicio de autenticaci√≥n no disponible'
      });
    }

    console.log('üîë [FORGOT-PASSWORD] Solicitando restablecimiento para:', email);

    // Verificar si el usuario existe
    try {
      const userRecord = await auth.getUserByEmail(email);
      console.log('‚úÖ [FORGOT-PASSWORD] Usuario encontrado:', userRecord.uid);
    } catch (userError) {
      if (userError.code === 'auth/user-not-found') {
        return res.status(404).json({
          success: false,
          message: 'No se encontr√≥ una cuenta con este email'
        });
      }
      throw userError;
    }

    // Firebase enviar√° autom√°ticamente el email usando sus plantillas configuradas
    // Nota: Debes configurar las plantillas en Firebase Console > Authentication > Templates
    await admin.auth().generatePasswordResetLink(email);
    
    console.log('‚úÖ [FORGOT-PASSWORD] Email de restablecimiento enviado a:', email);
    
    res.json({
      success: true,
      message: 'Se ha enviado un email con instrucciones para restablecer tu contrase√±a. Revisa tu bandeja de entrada y spam.'
    });

  } catch (error) {
    console.error('‚ùå [FORGOT-PASSWORD] Error:', error);
    
    if (error.code === 'auth/user-not-found') {
      return res.status(404).json({
        success: false,
        message: 'No se encontr√≥ una cuenta con este email'
      });
    }

    if (error.code === 'auth/unauthorized-continue-uri') {
      return res.status(400).json({
        success: false,
        message: 'URL de redirecci√≥n no autorizada. Contacta al administrador.'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al procesar la solicitud de restablecimiento',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Ruta para confirmar restablecimiento de contrase√±a
app.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { oobCode, newPassword } = req.body;

    if (!oobCode || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo de restablecimiento y nueva contrase√±a son requeridos'
      });
    }

    // Verificar que Firebase Auth est√© disponible
    if (!auth) {
      console.error('‚ùå [RESET-PASSWORD] Firebase Auth no est√° disponible');
      return res.status(500).json({
        success: false,
        message: 'Servicio de autenticaci√≥n no disponible'
      });
    }

    console.log('üîë [RESET-PASSWORD] Procesando restablecimiento...');

    // Verificar el c√≥digo y cambiar la contrase√±a
    const email = await auth.verifyPasswordResetCode(oobCode);
    await auth.confirmPasswordReset(oobCode, newPassword);

    console.log('‚úÖ [RESET-PASSWORD] Contrase√±a actualizada para:', email);

    res.json({
      success: true,
      message: 'Contrase√±a actualizada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [RESET-PASSWORD] Error:', error);
    
    if (error.code === 'auth/invalid-action-code') {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo de restablecimiento inv√°lido o expirado'
      });
    }

    if (error.code === 'auth/weak-password') {
      return res.status(400).json({
        success: false,
        message: 'La contrase√±a debe tener al menos 6 caracteres'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al restablecer la contrase√±a',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Endpoint para obtener hijos del usuario
app.get('/api/auth/children', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener hijos propios (como padre principal)
    const ownChildrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    // Obtener hijos compartidos (donde el usuario est√° en sharedWith)
    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const children = [];
    const childIds = new Set(); // Para evitar duplicados

    // Procesar hijos propios
    ownChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...childData,
          isShared: false, // Este es hijo propio
          // Informaci√≥n calculada autom√°ticamente
          currentAgeInMonths: currentInfo.currentAgeInMonths,
          currentGestationWeeks: currentInfo.currentGestationWeeks,
          registeredAgeInMonths: currentInfo.registeredAgeInMonths,
          registeredGestationWeeks: currentInfo.registeredGestationWeeks,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Procesar hijos compartidos
    sharedChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...childData,
          isShared: true, // Este es hijo compartido
          // Informaci√≥n calculada autom√°ticamente
          currentAgeInMonths: currentInfo.currentAgeInMonths,
          currentGestationWeeks: currentInfo.currentGestationWeeks,
          registeredAgeInMonths: currentInfo.registeredAgeInMonths,
          registeredGestationWeeks: currentInfo.registeredGestationWeeks,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Ordenar por createdAt desc
    children.sort((a, b) => {
      const dateA = a.createdAt?.toDate?.() || a.createdAt || new Date(0);
      const dateB = b.createdAt?.toDate?.() || b.createdAt || new Date(0);
      return dateB - dateA;
    });

    res.json({
      success: true,
      data: children
    });

  } catch (error) {
    console.error('Error al obtener hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener hijos',
      error: error.message
    });
  }
});

// DEBUG: Endpoint para verificar hijos compartidos
app.get('/api/auth/children/debug', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Obtener hijos propios
    const ownChildren = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    // Obtener hijos compartidos
    const sharedChildren = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    // Obtener todos los hijos para ver el array sharedWith
    const allChildrenSnapshot = await db.collection('children').get();
    const allChildrenWithSharedInfo = allChildrenSnapshot.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name,
      parentId: doc.data().parentId,
      sharedWith: doc.data().sharedWith || []
    }));

    res.json({
      success: true,
      data: {
        currentUserId: uid,
        ownChildrenCount: ownChildren.size,
        ownChildren: ownChildren.docs.map(doc => ({
          id: doc.id,
          name: doc.data().name,
          parentId: doc.data().parentId,
          sharedWith: doc.data().sharedWith || []
        })),
        sharedChildrenCount: sharedChildren.size,
        sharedChildren: sharedChildren.docs.map(doc => ({
          id: doc.id,
          name: doc.data().name,
          parentId: doc.data().parentId,
          sharedWith: doc.data().sharedWith || []
        })),
        allChildren: allChildrenWithSharedInfo.filter(c => 
          c.parentId === uid || c.sharedWith.includes(uid)
        )
      }
    });

  } catch (error) {
    console.error('‚ùå [DEBUG] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en debug',
      error: error.message
    });
  }
});

// Endpoint para agregar un hijo
app.post('/api/auth/children', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento (para beb√©s nacidos)
      dueDate,          // Nuevo: fecha esperada de parto (para beb√©s no nacidos)
      isUnborn, 
      photoUrl,
      // Legacy (para compatibilidad con apps antiguas)
      ageInMonths, 
      gestationWeeks 
    } = req.body;

    if (!name) {
      return res.status(400).json({
        success: false,
        message: 'Nombre es requerido'
      });
    }

    // Validar que si es un beb√© no nacido, tenga fecha de parto o semanas de gestaci√≥n (legacy)
    if (isUnborn) {
      if (!dueDate && (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 42)) {
      return res.status(400).json({
        success: false,
          message: 'Para beb√©s no nacidos, la fecha esperada de parto es requerida (o semanas de gestaci√≥n entre 1 y 42)'
        });
      }
      
      // Validar que la fecha de parto sea futura (con un margen de 2 semanas para casos de parto tard√≠o)
      if (dueDate) {
        const due = new Date(dueDate);
        const now = new Date();
        const twoWeeksAgo = new Date(now.getTime() - (14 * 24 * 60 * 60 * 1000));
        
        if (due < twoWeeksAgo) {
      return res.status(400).json({
        success: false,
            message: 'La fecha esperada de parto debe ser futura o reciente (m√°ximo 2 semanas en el pasado)'
          });
        }
      }
    }

    // Validar que si es un beb√© nacido, tenga fecha de nacimiento o edad en meses (legacy)
    if (!isUnborn) {
      if (!birthDate && (ageInMonths === undefined || ageInMonths < 0)) {
        return res.status(400).json({
          success: false,
          message: 'Para beb√©s nacidos, la fecha de nacimiento es requerida (o edad en meses mayor o igual a 0)'
        });
      }
      
      // Validar que la fecha de nacimiento sea pasada y no muy lejana
      if (birthDate) {
        const birth = new Date(birthDate);
        const now = new Date();
        const maxYearsBack = 18; // M√°ximo 18 a√±os
        const minDate = new Date(now.getFullYear() - maxYearsBack, now.getMonth(), now.getDate());
        
        if (birth > now) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento debe ser en el pasado'
          });
        }
        
        if (birth < minDate) {
          return res.status(400).json({
            success: false,
            message: `La fecha de nacimiento no puede ser mayor a ${maxYearsBack} a√±os atr√°s`
          });
        }
      }
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const childData = {
      parentId: uid,
      name: name.trim(),
      isUnborn: isUnborn || false,
      photoUrl: photoUrl || null,
      createdAt: now,
      updatedAt: now
    };

    // Usar el nuevo sistema basado en fechas
    if (isUnborn) {
      if (dueDate) {
        childData.dueDate = new Date(dueDate); // Nuevo sistema
        childData.gestationWeeks = null;
      } else {
        // Fallback a sistema legacy
        childData.gestationWeeks = parseInt(gestationWeeks);
        childData.dueDate = null;
        childData.registeredAt = now; // Solo para sistema legacy
      }
      childData.birthDate = null;
      childData.ageInMonths = null;
    } else {
      if (birthDate) {
        childData.birthDate = new Date(birthDate); // Nuevo sistema
        childData.ageInMonths = null;
      } else {
        // Fallback a sistema legacy
        childData.ageInMonths = parseInt(ageInMonths);
        childData.birthDate = null;
        childData.registeredAt = now; // Solo para sistema legacy
      }
      childData.dueDate = null;
      childData.gestationWeeks = null;
    }

    const childRef = await db.collection('children').add(childData);
    
    // Calcular informaci√≥n actual del hijo
    const childDoc = await childRef.get();
    const childWithInfo = getChildCurrentInfo({ id: childRef.id, ...childDoc.data() });
    
    // Calcular el n√∫mero real de hijos despu√©s de agregar
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('üìä [CHILDREN] N√∫mero real de hijos despu√©s de agregar:', actualChildrenCount);
    
    // Actualizar contador de hijos en el perfil con el valor real
    const userRef = db.collection('users').doc(uid);
    await userRef.update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Hijo agregado exitosamente',
      data: childWithInfo
    });

  } catch (error) {
    console.error('Error al agregar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al agregar hijo',
      error: error.message
    });
  }
});

// Endpoint para actualizar un hijo
app.put('/api/auth/children/:childId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name, 
      birthDate,        // Nuevo: fecha de nacimiento
      dueDate,          // Nuevo: fecha esperada de parto
      isUnborn, 
      photoUrl,
      // Legacy
      ageInMonths, 
      gestationWeeks 
    } = req.body;

    if (!name && !birthDate && !dueDate && ageInMonths === undefined && 
        isUnborn === undefined && gestationWeeks === undefined && !photoUrl) {
      return res.status(400).json({
        success: false,
        message: 'Al menos un campo debe ser proporcionado'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    if (childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    const currentData = childDoc.data();
    const updateData = {
      updatedAt: new Date()
    };
    
    // Actualizar nombre si se proporciona
    if (name) updateData.name = name.trim();
    
    // Actualizar foto si se proporciona
    if (photoUrl !== undefined) {
    if (photoUrl && !isValidUrl(photoUrl)) {
      return res.status(400).json({
        success: false,
        message: 'URL de foto inv√°lida'
      });
      }
      updateData.photoUrl = photoUrl;
    }
    
    // Actualizar estado de embarazo si se proporciona
    if (isUnborn !== undefined) {
      updateData.isUnborn = isUnborn;
    }

    // Determinar el estado final de isUnborn
    const finalIsUnborn = isUnborn !== undefined ? isUnborn : currentData.isUnborn;

    // Manejar actualizaci√≥n de fechas/edades seg√∫n el estado
    if (finalIsUnborn) {
      // Es un beb√© no nacido
      if (dueDate) {
        // Validar fecha de parto
        const due = new Date(dueDate);
        if (isNaN(due.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha esperada de parto es inv√°lida'
          });
        }
        const now = new Date();
        const twoWeeksAgo = new Date(now.getTime() - (14 * 24 * 60 * 60 * 1000));
        
        if (due < twoWeeksAgo) {
          return res.status(400).json({
            success: false,
            message: 'La fecha esperada de parto debe ser futura o reciente (m√°ximo 2 semanas en el pasado)'
          });
        }
        
        updateData.dueDate = due;
        updateData.gestationWeeks = null;
        updateData.birthDate = null;
      updateData.ageInMonths = null;
      } else if (gestationWeeks !== undefined) {
        // Legacy: usar semanas de gestaci√≥n
        const parsedGestationWeeks = parseInt(gestationWeeks);
        if (Number.isNaN(parsedGestationWeeks) || parsedGestationWeeks < 1 || parsedGestationWeeks > 42) {
          return res.status(400).json({
            success: false,
            message: 'Las semanas de gestaci√≥n deben estar entre 1 y 42'
          });
        }
        updateData.gestationWeeks = parsedGestationWeeks;
        updateData.dueDate = null;
        updateData.birthDate = null;
        updateData.ageInMonths = null;
        updateData.registeredAt = new Date();
      }
    } else {
      // Es un beb√© nacido
      if (birthDate) {
        // Validar fecha de nacimiento
        const birth = new Date(birthDate);
        if (isNaN(birth.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento es inv√°lida'
          });
        }
        const now = new Date();
        const maxYearsBack = 18;
        const minDate = new Date(now.getFullYear() - maxYearsBack, now.getMonth(), now.getDate());
        
        if (birth > now) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de nacimiento debe ser en el pasado'
          });
        }
        
        if (birth < minDate) {
          return res.status(400).json({
            success: false,
            message: `La fecha de nacimiento no puede ser mayor a ${maxYearsBack} a√±os atr√°s`
          });
        }
        
        updateData.birthDate = birth;
        updateData.ageInMonths = null;
        updateData.dueDate = null;
      updateData.gestationWeeks = null;
      } else if (ageInMonths !== undefined) {
        // Legacy: usar edad en meses
        const parsedAgeInMonths = parseInt(ageInMonths);
        if (Number.isNaN(parsedAgeInMonths) || parsedAgeInMonths < 0) {
          return res.status(400).json({
            success: false,
            message: 'La edad en meses debe ser mayor o igual a 0'
          });
        }
        updateData.ageInMonths = parsedAgeInMonths;
        updateData.birthDate = null;
        updateData.dueDate = null;
        updateData.gestationWeeks = null;
        updateData.registeredAt = new Date();
      }
    }

    await db.collection('children').doc(childId).update(updateData);

    // Obtener el hijo actualizado con informaci√≥n calculada
    const updatedChildDoc = await db.collection('children').doc(childId).get();
    const updatedChild = getChildCurrentInfo({ id: childId, ...updatedChildDoc.data() });

    res.json({
      success: true,
      message: 'Hijo actualizado exitosamente',
      data: updatedChild
    });

  } catch (error) {
    console.error('Error al actualizar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar hijo',
      error: error.message
    });
  }
});

// Endpoint para subir foto de hijo usando Firebase Storage
app.post('/api/auth/children/upload-photo', authenticateToken, upload.single('photo'), async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.body;

    if (!childId) {
      return res.status(400).json({
        success: false,
        message: 'ID del hijo es requerido'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ning√∫n archivo'
      });
    }

    // Verificar que Firebase Admin est√© inicializado
    if (!admin) {
      console.error('‚ùå [STORAGE] Firebase Admin no est√° inicializado');
      return res.status(500).json({
        success: false,
        message: 'Error interno del servidor: Firebase no configurado'
      });
    }

    // Verificar que Firebase Storage est√© disponible
    try {
      const bucket = admin.storage().bucket();
      console.log('‚úÖ [STORAGE] Firebase Storage disponible');
      console.log('üì¶ [STORAGE] Bucket:', bucket.name);
    } catch (storageError) {
      console.error('‚ùå [STORAGE] Error accediendo a Firebase Storage:', storageError);
      return res.status(500).json({
        success: false,
        message: 'Error interno del servidor: Storage no disponible',
        error: storageError.message
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    // Subir archivo a Firebase Storage usando buffer de memoria
    console.log('üîç [STORAGE] Verificando admin:', admin ? '‚úÖ Inicializado' : '‚ùå Null');
    console.log('üîç [STORAGE] Verificando admin.storage:', admin.storage ? '‚úÖ Disponible' : '‚ùå No disponible');
    console.log('üîç [STORAGE] Project ID:', process.env.FIREBASE_PROJECT_ID);
    
    const bucket = admin.storage().bucket();
    console.log('üì¶ [STORAGE] Bucket obtenido:', bucket.name);
    
    const fileName = `children/${childId}/photo-${Date.now()}-${Math.round(Math.random() * 1E9)}${path.extname(req.file.originalname)}`;
    
    console.log('üì§ [STORAGE] Subiendo archivo a Firebase Storage:', fileName);

    // Usar el buffer de memoria directamente
    const file = bucket.file(fileName);
    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
        metadata: {
          uploadedBy: uid,
          childId: childId,
          originalName: req.file.originalname
        }
      }
    });

    // Hacer el archivo p√∫blico
    await file.makePublic();

    // Obtener URL p√∫blica
    const photoUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
    
    console.log('‚úÖ [STORAGE] Archivo subido exitosamente:', photoUrl);

    // Actualizar el hijo con la nueva foto
    await db.collection('children').doc(childId).update({
      photoUrl: photoUrl,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Foto subida exitosamente',
      data: {
        photoUrl: photoUrl,
        fileName: fileName
      }
    });

  } catch (error) {
    console.error('Error subiendo foto a Firebase Storage:', error);
    
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});



// Endpoint para sincronizar childrenCount
app.post('/api/auth/children/sync-count', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Contar hijos reales en la base de datos
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('üìä [SYNC] Sincronizando childrenCount:', actualChildrenCount);

    // Actualizar el perfil con el n√∫mero real
    await db.collection('users').doc(uid).update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'ChildrenCount sincronizado correctamente',
      data: {
        childrenCount: actualChildrenCount
      }
    });

  } catch (error) {
    console.error('Error sincronizando childrenCount:', error);
    res.status(500).json({
      success: false,
      message: 'Error sincronizando childrenCount',
      error: error.message
    });
  }
});

// Endpoint para calcular edad en meses desde fecha de nacimiento
app.post('/api/auth/children/calculate-age', authenticateToken, async (req, res) => {
  try {
    const { birthDate } = req.body;

    if (!birthDate) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de nacimiento es requerida'
      });
    }

    const ageInMonths = calculateAgeFromBirthDate(birthDate);
    const birth = new Date(birthDate);
    const today = new Date();
    const ageInDays = Math.max(0, Math.floor((today - birth) / (1000 * 60 * 60 * 24)));
    
    const years = Math.floor(ageInMonths / 12);
    const months = ageInMonths % 12;

    res.json({
      success: true,
      data: {
        ageInMonths: ageInMonths,
        ageInDays: ageInDays,
        ageInYears: years,
        monthsRemainder: months,
        formattedAge: years > 0 
          ? `${years} a√±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
          : `${months} mes${months > 1 ? 'es' : ''}`
      }
    });

  } catch (error) {
    console.error('Error calculando edad:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando edad',
      error: error.message
    });
  }
});

// Endpoint helper para calcular fecha de parto desde semanas de gestaci√≥n
app.post('/api/auth/children/calculate-due-date', authenticateToken, async (req, res) => {
  try {
    const { gestationWeeks } = req.body;

    if (!gestationWeeks || gestationWeeks < 1 || gestationWeeks > 45) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaci√≥n deben estar entre 1 y 45'
      });
    }

    const today = new Date();
    const weeksRemaining = 40 - gestationWeeks; // Embarazo completo son 40 semanas
    const daysRemaining = weeksRemaining * 7;
    
    const dueDate = new Date(today.getTime() + (daysRemaining * 24 * 60 * 60 * 1000));

    res.json({
      success: true,
      data: {
        dueDate: dueDate.toISOString().split('T')[0], // Formato YYYY-MM-DD
        currentWeeks: gestationWeeks,
        weeksRemaining: Math.max(0, weeksRemaining),
        daysRemaining: Math.max(0, daysRemaining),
        isOverdue: gestationWeeks >= 40
      }
    });
  } catch (error) {
    console.error('Error calculando fecha de parto:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando fecha de parto',
      error: error.message
    });
  }
});

// Endpoint helper para calcular semanas de gestaci√≥n desde fecha de parto
app.post('/api/auth/children/calculate-gestation-weeks', authenticateToken, async (req, res) => {
  try {
    const { dueDate } = req.body;

    if (!dueDate) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de parto es requerida'
      });
    }

    const gestationInfo = calculateGestationFromDueDate(dueDate);

    res.json({
      success: true,
      data: {
        currentWeeks: gestationInfo.weeks,
        daysUntilDue: gestationInfo.daysUntilDue,
        isOverdue: gestationInfo.isOverdue,
        dueDateFormatted: new Date(dueDate).toLocaleDateString('es-ES', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        })
      }
    });
  } catch (error) {
    console.error('Error calculando semanas de gestaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error calculando semanas de gestaci√≥n',
      error: error.message
    });
  }
});

// Endpoint para eliminar foto de hijo de Firebase Storage
app.delete('/api/auth/children/:childId/photo', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para modificar este hijo'
      });
    }

    // Si hay una foto existente, eliminarla de Firebase Storage
    if (childData.photoUrl) {
      try {
        const bucket = admin.storage().bucket();
        
        // Extraer el nombre del archivo de la URL
        const urlParts = childData.photoUrl.split('/');
        const fileName = urlParts.slice(-2).join('/'); // children/childId/filename
        
        console.log('üóëÔ∏è [STORAGE] Eliminando archivo de Firebase Storage:', fileName);
        
        await bucket.file(fileName).delete();
        console.log('‚úÖ [STORAGE] Archivo eliminado exitosamente');
      } catch (storageError) {
        console.error('‚ö†Ô∏è [STORAGE] Error eliminando archivo de Storage (continuando):', storageError);
        // Continuar aunque falle la eliminaci√≥n del archivo
      }
    }

    // Actualizar el hijo eliminando la foto
    await db.collection('children').doc(childId).update({
      photoUrl: null,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Foto eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando foto',
      error: error.message
    });
  }
});

// Endpoint para eliminar un hijo
app.delete('/api/auth/children/:childId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    if (childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar este hijo'
      });
    }

    await db.collection('children').doc(childId).delete();

    // Calcular el n√∫mero real de hijos despu√©s de eliminar
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();
    
    const actualChildrenCount = childrenSnapshot.size;
    console.log('üìä [CHILDREN] N√∫mero real de hijos despu√©s de eliminar:', actualChildrenCount);
    
    // Actualizar contador de hijos en el perfil con el valor real
    const userRef = db.collection('users').doc(uid);
    await userRef.update({
      childrenCount: actualChildrenCount,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Hijo eliminado exitosamente'
    });

  } catch (error) {
    console.error('Error al eliminar hijo:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar hijo',
      error: error.message
    });
  }
});

// ============================================================================
// ü§ù SISTEMA DE COMPARTIR HIJOS
// ============================================================================

// Generar link de invitaci√≥n para compartir un hijo
app.post('/api/auth/children/:childId/share', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { role = 'otro', expiresInDays = 7 } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe y pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid && !childData.sharedWith?.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para compartir este hijo'
      });
    }

    // Validar rol
    const validRoles = ['padre', 'madre', 'cuidadora', 'familiar', 'otro'];
    if (!validRoles.includes(role)) {
      return res.status(400).json({
        success: false,
        message: 'Rol inv√°lido. Debe ser: padre, madre, cuidadora, familiar u otro'
      });
    }

    // Generar token √∫nico
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');

    // Calcular fecha de expiraci√≥n
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + parseInt(expiresInDays));

    // Guardar invitaci√≥n
    const invitationData = {
      token,
      childId,
      childName: childData.name,
      invitedBy: uid,
      role,
      status: 'pending',
      createdAt: new Date(),
      expiresAt
    };

    await db.collection('childInvitations').add(invitationData);

    console.log(`‚úÖ [SHARE] Invitaci√≥n creada para hijo ${childId} por ${uid}`);

    // Generar link
    const invitationLink = `munpa://share-child/${token}`;

    res.json({
      success: true,
      message: 'Invitaci√≥n creada exitosamente',
      data: {
        token,
        invitationLink,
        expiresAt: expiresAt.toISOString(),
        childName: childData.name,
        role
      }
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error creando invitaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando invitaci√≥n',
      error: error.message
    });
  }
});

// Ver invitaciones pendientes del usuario
app.get('/api/auth/children/invitations', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener invitaciones pendientes (no es necesario que sean espec√≠ficas del usuario, 
    // cualquiera con el link puede aceptar)
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('status', '==', 'pending')
      .where('expiresAt', '>', new Date())
      .get();

    const invitations = [];
    for (const doc of invitationsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener info del usuario que invit√≥
      let inviterName = 'Usuario';
      try {
        const inviterDoc = await db.collection('users').doc(data.invitedBy).get();
        if (inviterDoc.exists) {
          const inviterData = inviterDoc.data();
          inviterName = inviterData.displayName || inviterData.name || 'Usuario';
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [SHARE] Error obteniendo info del invitador:', error);
      }

      invitations.push({
        id: doc.id,
        token: data.token,
        childName: data.childName,
        invitedBy: data.invitedBy,
        inviterName,
        role: data.role,
        status: data.status,
        createdAt: data.createdAt,
        expiresAt: data.expiresAt
      });
    }

    res.json({
      success: true,
      data: invitations
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error obteniendo invitaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo invitaciones',
      error: error.message
    });
  }
});

// Aceptar invitaci√≥n (desde el link)
app.post('/api/auth/children/invitations/:token/accept', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaci√≥n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'Invitaci√≥n no encontrada'
      });
    }

    const invitationDoc = invitationsSnapshot.docs[0];
    const invitationData = invitationDoc.data();

    // Validar que no est√© expirada
    if (invitationData.expiresAt.toDate() < new Date()) {
      return res.status(400).json({
        success: false,
        message: 'Esta invitaci√≥n ha expirado'
      });
    }

    // Validar que no est√© ya aceptada o rechazada
    if (invitationData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `Esta invitaci√≥n ya fue ${invitationData.status === 'accepted' ? 'aceptada' : 'rechazada'}`
      });
    }

    // Validar que no sea el mismo usuario que cre√≥ la invitaci√≥n
    if (invitationData.invitedBy === uid) {
      return res.status(400).json({
        success: false,
        message: 'No puedes aceptar tu propia invitaci√≥n'
      });
    }

    // Obtener el hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'El hijo ya no existe'
      });
    }

    const childData = childDoc.data();

    // Verificar que el usuario no tenga ya acceso
    if (childData.parentId === uid || childData.sharedWith?.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya tienes acceso a este hijo'
      });
    }

    // Agregar al usuario a la lista de compartidos
    await db.collection('children').doc(invitationData.childId).update({
      sharedWith: admin.firestore.FieldValue.arrayUnion(uid),
      updatedAt: new Date()
    });

    // Actualizar invitaci√≥n
    await invitationDoc.ref.update({
      status: 'accepted',
      acceptedBy: uid,
      acceptedAt: new Date()
    });

    // Obtener info del usuario para logging
    const userDoc = await db.collection('users').doc(uid).get();
    const userName = userDoc.exists ? (userDoc.data().displayName || userDoc.data().name || 'Usuario') : 'Usuario';

    console.log(`‚úÖ [SHARE] ${userName} (${uid}) acept√≥ invitaci√≥n para hijo ${invitationData.childId}`);

    res.json({
      success: true,
      message: 'Invitaci√≥n aceptada exitosamente',
      data: {
        childId: invitationData.childId,
        childName: invitationData.childName,
        role: invitationData.role
      }
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error aceptando invitaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error aceptando invitaci√≥n',
      error: error.message
    });
  }
});

// Rechazar invitaci√≥n
app.post('/api/auth/children/invitations/:token/reject', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaci√≥n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'Invitaci√≥n no encontrada'
      });
    }

    const invitationDoc = invitationsSnapshot.docs[0];
    const invitationData = invitationDoc.data();

    // Validar que est√© pendiente
    if (invitationData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: `Esta invitaci√≥n ya fue ${invitationData.status === 'accepted' ? 'aceptada' : 'rechazada'}`
      });
    }

    // Actualizar invitaci√≥n
    await invitationDoc.ref.update({
      status: 'rejected',
      rejectedBy: uid,
      rejectedAt: new Date()
    });

    console.log(`‚úÖ [SHARE] Usuario ${uid} rechaz√≥ invitaci√≥n para hijo ${invitationData.childId}`);

    res.json({
      success: true,
      message: 'Invitaci√≥n rechazada'
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error rechazando invitaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando invitaci√≥n',
      error: error.message
    });
  }
});

// Ver con qui√©n se comparte un hijo
app.get('/api/auth/children/:childId/shared-with', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe y el usuario tiene acceso
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();
    if (childData.parentId !== uid && !childData.sharedWith?.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver esta informaci√≥n'
      });
    }

    // Obtener lista de usuarios con quienes se comparte
    const sharedWithUsers = childData.sharedWith || [];
    const usersInfo = [];

    // Agregar el padre/madre principal
    try {
      const parentDoc = await db.collection('users').doc(childData.parentId).get();
      if (parentDoc.exists) {
        const parentData = parentDoc.data();
        usersInfo.push({
          userId: childData.parentId,
          name: parentData.displayName || parentData.name || 'Usuario',
          photoUrl: parentData.photoUrl || null,
          role: 'principal',
          isPrincipal: true
        });
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo info del padre:', error);
    }

    // Agregar los usuarios compartidos
    for (const userId of sharedWithUsers) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          
          // Buscar el rol en las invitaciones aceptadas
          let role = 'otro';
          const invitationSnapshot = await db.collection('childInvitations')
            .where('childId', '==', childId)
            .where('acceptedBy', '==', userId)
            .where('status', '==', 'accepted')
            .limit(1)
            .get();
          
          if (!invitationSnapshot.empty) {
            role = invitationSnapshot.docs[0].data().role;
          }

          usersInfo.push({
            userId,
            name: userData.displayName || userData.name || 'Usuario',
            photoUrl: userData.photoUrl || null,
            role,
            isPrincipal: false
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [SHARE] Error obteniendo info del usuario ${userId}:`, error);
      }
    }

    res.json({
      success: true,
      data: usersInfo
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error obteniendo usuarios compartidos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo usuarios compartidos',
      error: error.message
    });
  }
});

// Dejar de compartir con un usuario
app.delete('/api/auth/children/:childId/shared-with/:userId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, userId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo existe
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hijo no encontrado'
      });
    }

    const childData = childDoc.data();

    // Solo el padre principal puede dejar de compartir
    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el padre/madre principal puede dejar de compartir'
      });
    }

    // No puede eliminar al padre principal
    if (userId === childData.parentId) {
      return res.status(400).json({
        success: false,
        message: 'No puedes eliminar al padre/madre principal'
      });
    }

    // Remover usuario de la lista
    await db.collection('children').doc(childId).update({
      sharedWith: admin.firestore.FieldValue.arrayRemove(userId),
      updatedAt: new Date()
    });

    console.log(`‚úÖ [SHARE] Se dej√≥ de compartir hijo ${childId} con usuario ${userId}`);

    res.json({
      success: true,
      message: 'Se dej√≥ de compartir exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error dejando de compartir:', error);
    res.status(500).json({
      success: false,
      message: 'Error dejando de compartir',
      error: error.message
    });
  }
});

// Verificar invitaci√≥n por token (para mostrar info antes de aceptar/rechazar)
app.get('/api/auth/children/invitations/:token', authenticateToken, async (req, res) => {
  try {
    const { token } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar invitaci√≥n por token
    const invitationsSnapshot = await db.collection('childInvitations')
      .where('token', '==', token)
      .limit(1)
      .get();

    if (invitationsSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'Invitaci√≥n no encontrada'
      });
    }

    const invitationData = invitationsSnapshot.docs[0].data();

    // Obtener info del usuario que invit√≥
    let inviterName = 'Usuario';
    let inviterPhoto = null;
    try {
      const inviterDoc = await db.collection('users').doc(invitationData.invitedBy).get();
      if (inviterDoc.exists) {
        const inviterData = inviterDoc.data();
        inviterName = inviterData.displayName || inviterData.name || 'Usuario';
        inviterPhoto = inviterData.photoUrl || null;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SHARE] Error obteniendo info del invitador:', error);
    }

    // Obtener info del hijo
    const childDoc = await db.collection('children').doc(invitationData.childId).get();
    let childPhotoUrl = null;
    if (childDoc.exists) {
      childPhotoUrl = childDoc.data().photoUrl || null;
    }

    res.json({
      success: true,
      data: {
        token,
        childName: invitationData.childName,
        childPhotoUrl,
        inviterName,
        inviterPhoto,
        role: invitationData.role,
        status: invitationData.status,
        createdAt: invitationData.createdAt,
        expiresAt: invitationData.expiresAt,
        isExpired: invitationData.expiresAt.toDate() < new Date()
      }
    });

  } catch (error) {
    console.error('‚ùå [SHARE] Error obteniendo invitaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo invitaci√≥n',
      error: error.message
    });
  }
});

// Endpoint para verificar token
app.get('/api/auth/verify-token', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    // Obtener informaci√≥n del usuario
    const userRecord = await auth.getUser(uid);

    res.json({
      success: true,
      message: 'Token v√°lido',
      data: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        emailVerified: userRecord.emailVerified
      }
    });

  } catch (error) {
    console.error('Error al verificar token:', error);
    res.status(401).json({
      success: false,
      message: 'Token inv√°lido',
      error: error.message
    });
  }
});

// Endpoint para agregar conocimiento a la base de datos
app.post('/api/doula/knowledge', authenticateToken, async (req, res) => {
  try {
    const { text, metadata } = req.body;

    if (!text || text.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El texto es requerido'
      });
    }

    const success = await saveKnowledge(text, metadata);
    
    if (success) {
      res.json({
        success: true,
        message: 'Conocimiento agregado correctamente'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al agregar conocimiento'
      });
    }

  } catch (error) {
    console.error('‚ùå Error agregando conocimiento:', error);
    res.status(500).json({
      success: false,
      message: 'Error al agregar conocimiento',
      error: error.message
    });
  }
});

// Endpoint para aprendizaje validado (POST /learn)
app.post('/api/doula/learn', authenticateToken, async (req, res) => {
  try {
    const { 
      text, 
      metadata, 
      validation = {
        approved: false,
        approvedBy: null,
        approvedAt: null,
        checklist: {
          sourceVerified: false,
          medicalAccuracy: false,
          toneAppropriate: false,
          contentRelevant: false
        }
      }
    } = req.body;

    if (!text || text.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El texto es requerido'
      });
    }

    // Validar que el checklist est√© completo
    const checklist = validation.checklist;
    const isFullyValidated = Object.values(checklist).every(item => item === true);

    if (!isFullyValidated) {
      return res.status(400).json({
        success: false,
        message: 'El conocimiento debe pasar todas las validaciones del checklist',
        checklist: checklist
      });
    }

    // Agregar metadatos de validaci√≥n
    const validatedMetadata = {
      ...metadata,
      validation: {
        ...validation,
        approved: true,
        approvedAt: new Date(),
        approvedBy: req.user.uid
      },
      version: metadata.version || '1.0',
      createdAt: new Date(),
      isActive: true
    };

    const success = await saveKnowledge(text, validatedMetadata);
    
    if (success) {
      res.json({
        success: true,
        message: 'Conocimiento validado y agregado correctamente',
        data: {
          text: text.substring(0, 100) + '...',
          metadata: validatedMetadata
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al agregar conocimiento validado'
      });
    }

  } catch (error) {
    console.error('‚ùå Error en aprendizaje validado:', error);
    res.status(500).json({
      success: false,
      message: 'Error en aprendizaje validado',
      error: error.message
    });
  }
});

// Endpoint para guardar feedback del usuario
app.post('/api/doula/feedback', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { conversationId, feedback, details } = req.body;

    if (!feedback || !['positive', 'negative'].includes(feedback)) {
      return res.status(400).json({
        success: false,
        message: 'Feedback debe ser "positive" o "negative"'
      });
    }

    const feedbackData = {
      userId: uid,
      conversationId: conversationId,
      feedback: feedback,
      details: details || {},
      timestamp: new Date(),
      processed: false
    };

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('user_feedback').add(feedbackData);
    
    console.log('üíæ [FEEDBACK] Feedback guardado:', feedback);
    
    // Si es feedback positivo, considerar guardar como Q&A validado
    if (feedback === 'positive' && details && details.question && details.answer) {
      const qaData = {
        question: details.question,
        answer: details.answer,
        tags: details.tags || [],
        qualityScore: 0.9,
        createdAt: new Date(),
        isActive: true,
        usageCount: 0,
        source: 'user_feedback',
        validatedBy: uid
      };
      
      await db.collection('validated_qa').add(qaData);
      console.log('‚úÖ [QA] Q&A validado guardado desde feedback');
    }
    
    res.json({
      success: true,
      message: 'Feedback guardado correctamente'
    });

  } catch (error) {
    console.error('‚ùå Error guardando feedback:', error);
    res.status(500).json({
      success: false,
      message: 'Error al guardar feedback',
      error: error.message
    });
  }
});

// Endpoint para actualizar memoria del usuario
app.put('/api/doula/memory', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { notes, preferences } = req.body;

    const memoryData = {
      notes: notes || [],
      preferences: preferences || {}
    };

    const success = await saveUserMemory(uid, memoryData);
    
    if (success) {
      res.json({
        success: true,
        message: 'Memoria actualizada correctamente'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error al actualizar memoria'
      });
    }

  } catch (error) {
    console.error('‚ùå Error actualizando memoria:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar memoria',
      error: error.message
    });
  }
});

// Endpoint para borrar memoria del usuario
app.delete('/api/doula/memory', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('user_memory').doc(uid).delete();
    
    console.log('üóëÔ∏è [MEMORY] Memoria borrada para usuario:', uid);
    
    res.json({
      success: true,
      message: 'Memoria borrada correctamente'
    });

  } catch (error) {
    console.error('‚ùå Error borrando memoria:', error);
    res.status(500).json({
      success: false,
      message: 'Error al borrar memoria',
      error: error.message
    });
  }
});

// Endpoint para tests autom√°ticos de calidad
app.post('/api/doula/quality-test', authenticateToken, async (req, res) => {
  try {
    const testQuestions = [
      {
        question: "¬øQu√© ejercicios puedo hacer durante el embarazo?",
        expectedCategory: "embarazo",
        expectedKeywords: ["caminar", "yoga", "nataci√≥n", "seguro"]
      },
      {
        question: "¬øC√≥mo puedo prepararme para la lactancia?",
        expectedCategory: "lactancia",
        expectedKeywords: ["contacto", "agarre", "demanda", "beneficios"]
      },
      {
        question: "¬øCu√°les son los s√≠ntomas del primer trimestre?",
        expectedCategory: "embarazo",
        expectedKeywords: ["n√°useas", "fatiga", "senos", "hormonas"]
      },
      {
        question: "¬øPuedes ayudarme con programaci√≥n en JavaScript?",
        expectedCategory: "off_topic",
        expectedResponse: "especializada en acompa√±amiento durante el embarazo"
      }
    ];

    const results = [];
    let totalScore = 0;

    for (const test of testQuestions) {
      try {
        // Simular llamada al chat
        const response = await generateDoulaResponse(test.question, '', '', 'TestUser');
        
        let score = 0;
        let feedback = '';

        if (test.expectedCategory === 'off_topic') {
          // Verificar que redirija correctamente
          if (response.includes(test.expectedResponse)) {
            score = 1;
            feedback = '‚úÖ Redirecci√≥n correcta para tema fuera del √°mbito';
          } else {
            feedback = '‚ùå No redirigi√≥ correctamente tema fuera del √°mbito';
          }
        } else {
          // Verificar palabras clave esperadas
          const keywordMatches = test.expectedKeywords.filter(keyword => 
            response.toLowerCase().includes(keyword.toLowerCase())
          );
          
          score = keywordMatches.length / test.expectedKeywords.length;
          feedback = `‚úÖ Encontr√≥ ${keywordMatches.length}/${test.expectedKeywords.length} palabras clave`;
        }

        results.push({
          question: test.question,
          expectedCategory: test.expectedCategory,
          score: score,
          feedback: feedback,
          response: response.substring(0, 200) + '...'
        });

        totalScore += score;

      } catch (error) {
        results.push({
          question: test.question,
          expectedCategory: test.expectedCategory,
          score: 0,
          feedback: '‚ùå Error en test',
          error: error.message
        });
      }
    }

    const averageScore = totalScore / testQuestions.length;
    const qualityStatus = averageScore >= 0.8 ? 'EXCELENTE' : averageScore >= 0.6 ? 'BUENO' : 'NEEDS_IMPROVEMENT';

    res.json({
      success: true,
      data: {
        testDate: new Date(),
        totalTests: testQuestions.length,
        averageScore: averageScore,
        qualityStatus: qualityStatus,
        results: results
      }
    });

  } catch (error) {
    console.error('‚ùå Error en test de calidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error en test de calidad',
      error: error.message
    });
  }
});

// Endpoint para obtener informaci√≥n de desarrollo infantil por edad
app.post('/api/children/development-info', authenticateToken, async (req, res) => {
  try {
    const { childId, name } = req.body;
    const userId = req.user.uid;

    let child = null;
    let currentAgeInMonths = null;
    let currentGestationWeeks = null;
    let isUnborn = false;

    // Si se proporciona childId, buscar el hijo en la base de datos
    if (childId) {
      const childDoc = await db.collection('children').doc(childId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      
      child = childDoc.data();
      
      // Verificar que el hijo pertenece al usuario
      if (child.parentId !== userId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }

      // Calcular edad actual basada en fecha de registro
      const childInfo = getChildCurrentInfo(child);
      currentAgeInMonths = childInfo.currentAgeInMonths;
      currentGestationWeeks = childInfo.currentGestationWeeks;
      isUnborn = child.isUnborn;
      
      console.log(`üìä [DEVELOPMENT] ${child.name}: ${isUnborn ? currentGestationWeeks + ' semanas' : currentAgeInMonths + ' meses'} (calculado desde ${childInfo.registeredAgeInMonths || childInfo.registeredGestationWeeks})`);
    } else if (name) {
      // Modo de compatibilidad: usar nombre y par√°metros manuales
      const { ageInMonths, isUnborn: manualIsUnborn, gestationWeeks } = req.body;
      
      if (!name.trim()) {
        return res.status(400).json({
          success: false,
          message: 'El nombre del ni√±o es requerido'
        });
      }

      if (manualIsUnborn && !gestationWeeks) {
        return res.status(400).json({
          success: false,
          message: 'Para ni√±os por nacer, las semanas de gestaci√≥n son requeridas'
        });
      }

      if (!manualIsUnborn && !ageInMonths && ageInMonths !== 0) {
        return res.status(400).json({
          success: false,
          message: 'Para ni√±os nacidos, la edad en meses es requerida'
        });
      }

      currentAgeInMonths = manualIsUnborn ? null : ageInMonths;
      currentGestationWeeks = manualIsUnborn ? gestationWeeks : null;
      isUnborn = manualIsUnborn;
      
      console.log(`üìä [DEVELOPMENT] ${name}: ${isUnborn ? currentGestationWeeks + ' semanas' : currentAgeInMonths + ' meses'} (manual)`);
    } else {
      return res.status(400).json({
        success: false,
        message: 'Se requiere childId o nombre del ni√±o'
      });
    }

    // Crear clave √∫nica para el historial
    const childKey = child ? `${child.id}_${isUnborn ? 'unborn' : 'born'}` : `${name.trim()}_${isUnborn ? 'unborn' : 'born'}`;
    const previousResponses = await getPreviousDevelopmentResponses(userId, childKey);

    // Obtener informaci√≥n variada desde OpenAI
    let developmentInfo = [];
    if (isUnborn) {
      developmentInfo = await getUnbornDevelopmentInfoFromAI(currentGestationWeeks, previousResponses, child ? child.name : name.trim());
    } else {
      developmentInfo = await getChildDevelopmentInfoFromAI(currentAgeInMonths, previousResponses, child ? child.name : name.trim());
    }

    // Guardar esta respuesta para futuras consultas
    await saveDevelopmentResponse(userId, childKey, {
      childName: child ? child.name : name.trim(),
      childId: child ? child.id : null,
      ageInMonths: currentAgeInMonths,
      gestationWeeks: currentGestationWeeks,
      isUnborn: isUnborn,
      developmentInfo: developmentInfo,
      timestamp: new Date()
    });

    res.json({
      success: true,
      data: {
        childName: child ? child.name : name.trim(),
        childId: child ? child.id : null,
        ageInMonths: currentAgeInMonths,
        gestationWeeks: currentGestationWeeks,
        isUnborn: isUnborn,
        developmentInfo: developmentInfo,
        timestamp: new Date(),
        responseCount: previousResponses.length + 1,
        isNewInfo: previousResponses.length === 0,
        calculatedAge: true,
        // Informaci√≥n detallada de edades
        registeredAge: child ? (child.isUnborn ? childInfo.registeredGestationWeeks : childInfo.registeredAgeInMonths) : null,
        currentAge: child ? (child.isUnborn ? childInfo.currentGestationWeeks : childInfo.currentAgeInMonths) : null,
        daysSinceCreation: child ? childInfo.daysSinceCreation : null,
        // Informaci√≥n adicional para beb√©s por nacer
        isOverdue: child ? childInfo.isOverdue : false,
        // Informaci√≥n de c√°lculo
        calculationInfo: child ? {
          registeredWeeks: child.isUnborn ? childInfo.registeredGestationWeeks : null,
          registeredMonths: child.isUnborn ? null : childInfo.registeredAgeInMonths,
          currentWeeks: child.isUnborn ? childInfo.currentGestationWeeks : null,
          currentMonths: child.isUnborn ? null : childInfo.currentAgeInMonths,
          daysSinceCreation: childInfo.daysSinceCreation
        } : null
      }
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo informaci√≥n de desarrollo:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaci√≥n de desarrollo',
      error: error.message
    });
  }
});

// Gu√≠a diaria para beb√© o embarazo (con OpenAI)
app.post('/api/guide/today', authenticateToken, async (req, res) => {
  try {
    const { birthDate, gestationWeeks, ageWeeks, name, isPregnant = false, childId } = req.body;

    let weeks = null;
    let months = null;
    let ageBreakdown = null;
    let pregnant = Boolean(isPregnant);
    let resolvedChildId = childId || null;

    if (!resolvedChildId && name && db) {
      const trimmedName = String(name).trim();
      const ownSnapshot = await db.collection('children')
        .where('parentId', '==', req.user.uid)
        .where('name', '==', trimmedName)
        .limit(1)
        .get();
      if (!ownSnapshot.empty) {
        resolvedChildId = ownSnapshot.docs[0].id;
      } else {
        const sharedSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', req.user.uid)
          .where('name', '==', trimmedName)
          .limit(1)
          .get();
        if (!sharedSnapshot.empty) {
          resolvedChildId = sharedSnapshot.docs[0].id;
        }
      }
    }

    if (resolvedChildId) {
      const childDoc = await db.collection('children').doc(resolvedChildId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      const childData = childDoc.data();
      const isOwner = childData.parentId === req.user.uid;
      const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(req.user.uid);
      if (!isOwner && !isShared) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }
      pregnant = Boolean(childData.isUnborn);
      weeks = getWeeksFromChildData(childData);
      months = getMonthsFromChildData(childData);
      if (!pregnant && childData.birthDate) {
        ageBreakdown = calculateAgeBreakdownFromBirthDate(childData.birthDate);
      }
    } else if (gestationWeeks || isPregnant) {
      weeks = parseInt(gestationWeeks, 10);
      pregnant = true;
    } else if (ageWeeks || ageWeeks === 0) {
      weeks = parseInt(ageWeeks, 10);
    } else if (birthDate) {
      weeks = calculateWeeksFromBirthDate(birthDate);
      months = calculateMonthsFromBirthDate(birthDate);
      ageBreakdown = calculateAgeBreakdownFromBirthDate(birthDate);
    }

    if (pregnant) {
      if (!weeks || weeks < 1 || weeks > 45) {
        return res.status(400).json({
          success: false,
          message: 'Para embarazo debes enviar gestationWeeks (1-45) o childId'
        });
      }
    } else {
      if ((!weeks || weeks < 1 || weeks > 60) && (months === null || months < 0)) {
        return res.status(400).json({
          success: false,
          message: 'Debes enviar birthDate o ageWeeks (1-60) o childId'
        });
      }
    }

    let unit = 'week';
    let value = weeks;
    if (!pregnant) {
      const isUnderOneMonth = weeks !== null && weeks < 4;
      if (!isUnderOneMonth) {
        unit = 'month';
        if (months !== null) {
          value = Math.max(1, months);
        } else if (weeks !== null) {
          value = Math.max(1, Math.floor(weeks / 4.3));
        }
      }
    }

    const cacheKey = `/api/guide/today?childId=${resolvedChildId || 'none'}&unit=${unit}&value=${value}&pregnant=${Boolean(pregnant)}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const guide = await getDailyGuideFromAI({
      unit,
      value,
      name: name && String(name).trim() ? String(name).trim() : null,
      isPregnant: pregnant
    });

    let title = guide.title;
    let ageLabel = null;
    if (!pregnant && ageBreakdown && ageBreakdown.totalMonths >= 12) {
      const parts = [];
      if (ageBreakdown.years > 0) {
        parts.push(`${ageBreakdown.years} a√±o${ageBreakdown.years === 1 ? '' : 's'}`);
      }
      if (ageBreakdown.months > 0) {
        parts.push(`${ageBreakdown.months} mes${ageBreakdown.months === 1 ? '' : 'es'}`);
      }
      ageLabel = parts.length > 0 ? parts.join(' ') : `${ageBreakdown.totalMonths} meses`;
      const titleSuffix = title && String(title).includes(':')
        ? String(title).split(':').slice(1).join(':').trim()
        : String(title || '');
      title = `${ageLabel}: ${titleSuffix || 'El descubrimiento'}`;
    }

    const responsePayload = {
      success: true,
      data: {
        title,
        subtitle: guide.subtitle,
        description: guide.description,
        tip: guide.tip,
        unit,
        value,
        ageLabel,
        ageYears: ageBreakdown ? ageBreakdown.years : null,
        ageMonths: ageBreakdown ? ageBreakdown.months : null,
        ageTotalMonths: ageBreakdown ? ageBreakdown.totalMonths : null,
        isPregnant: pregnant,
        source: guide.source
      }
    };

    setCachedResponse(cacheKey, responsePayload, 2 * 60 * 60 * 1000);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå Error obteniendo gu√≠a diaria:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo gu√≠a diaria',
      error: error.message
    });
  }
});

// Preguntas frecuentes para mamas (FAQ) con cache 24h
app.post('/api/faq/moms', authenticateToken, async (req, res) => {
  try {
    const { childId, isPregnant = false } = req.body;
    const userId = req.user.uid;

    let childName = null;
    let pregnant = Boolean(isPregnant);
    let ageLabel = null;

    if (childId) {
      const childDoc = await db.collection('children').doc(childId).get();
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      const childData = childDoc.data();
      if (childData.parentId !== userId) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para acceder a este hijo'
        });
      }
      childName = childData.name || null;
      pregnant = Boolean(childData.isUnborn);
      if (!pregnant) {
        const weeks = getWeeksFromChildData(childData);
        const months = getMonthsFromChildData(childData);
        const isUnderOneMonth = weeks !== null && weeks < 4;
        if (isUnderOneMonth) {
          ageLabel = `Semana ${weeks}`;
        } else if (months !== null) {
          ageLabel = `Mes ${Math.max(1, months)}`;
        }
      } else {
        const weeks = getWeeksFromChildData(childData);
        if (weeks) ageLabel = `Semana ${weeks}`;
      }
    }

    const cacheKey = `/api/faq/moms?childId=${childId || 'none'}&pregnant=${pregnant}&age=${ageLabel || 'na'}&user=${userId}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const result = await getMomsFaqFromAI({ childName, isPregnant: pregnant, ageLabel });
    const responsePayload = {
      success: true,
      data: {
        questions: result.items,
        source: result.source
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå Error obteniendo FAQ mam√°s:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo FAQ',
      error: error.message
    });
  }
});

// Endpoint para obtener informaci√≥n del embarazo por semanas con imagen
app.post('/api/pregnancy/week-info', authenticateToken, async (req, res) => {
  try {
    const { gestationWeeks, name, includeImage = true } = req.body;

    const parsedWeeks = parseInt(gestationWeeks, 10);
    if (!parsedWeeks || parsedWeeks < 1 || parsedWeeks > 45) {
      return res.status(400).json({
        success: false,
        message: 'Las semanas de gestaci√≥n deben estar entre 1 y 45'
      });
    }

    const babyName = name && name.trim() ? name.trim() : 'tu beb√©';

    const infoResult = await getPregnancyWeekInfoFromAI(parsedWeeks, babyName);

    let imageUrl = null;
    let imageWarning = null;
    if (includeImage) {
      const imageResult = await generatePregnancyImageUrlFromAI(parsedWeeks);
      imageUrl = imageResult?.url || null;
      imageWarning = imageResult?.warning || null;
    }

    res.json({
      success: true,
      data: {
        gestationWeeks: parsedWeeks,
        babyName: babyName,
        importantInfo: infoResult.items,
        infoSource: infoResult.source,
        image: imageUrl ? {
          url: imageUrl
        } : null,
        imageSource: imageUrl ? 'openai' : 'none',
        imageWarning: imageWarning,
        timestamp: new Date()
      }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo info de embarazo por semana:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaci√≥n del embarazo',
      error: error.message
    });
  }
});

// Funci√≥n para calcular edad en meses desde fecha de nacimiento
const calculateAgeFromBirthDate = (birthDate) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let birth;
  if (birthDate && typeof birthDate === 'object' && birthDate._seconds) {
    birth = new Date(birthDate._seconds * 1000);
  } else {
    birth = new Date(birthDate);
  }
  
  // Calcular a√±os y meses
  let years = now.getFullYear() - birth.getFullYear();
  let months = now.getMonth() - birth.getMonth();
  
  // Ajustar si el d√≠a actual es menor que el d√≠a de nacimiento
  if (now.getDate() < birth.getDate()) {
    months--;
  }
  
  // Si los meses son negativos, ajustar a√±os y meses
  if (months < 0) {
    years--;
    months += 12;
  }
  
  const totalMonths = Math.max(0, years * 12 + months);
  
  console.log(`üìä [AGE CALCULATION] Nacimiento: ${birth.toLocaleDateString()} ‚Üí Edad actual: ${totalMonths} meses (${years} a√±os, ${months} meses)`);
  
  return totalMonths;
};

const calculateAgeBreakdownFromBirthDate = (birthDate) => {
  const now = new Date();
  let birth;
  if (birthDate && typeof birthDate === 'object' && birthDate._seconds) {
    birth = new Date(birthDate._seconds * 1000);
  } else {
    birth = new Date(birthDate);
  }
  let years = now.getFullYear() - birth.getFullYear();
  let months = now.getMonth() - birth.getMonth();
  if (now.getDate() < birth.getDate()) {
    months--;
  }
  if (months < 0) {
    years--;
    months += 12;
  }
  const totalMonths = Math.max(0, years * 12 + months);
  return { years: Math.max(0, years), months: Math.max(0, months), totalMonths };
};

// Funci√≥n para calcular edad actual basada en fecha de creaci√≥n (LEGACY - para compatibilidad con datos antiguos)
const calculateCurrentAge = (registeredAge, createdAt) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let createdDate;
  if (createdAt && typeof createdAt === 'object' && createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(createdAt);
  }
  
  const diffTime = now - createdDate;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  // Calcular meses completos transcurridos
  const diffMonths = Math.floor(diffDays / 30.44); // Promedio de d√≠as por mes
  
  // Calcular edad actual sumando los meses transcurridos
  const currentAge = Math.max(0, registeredAge + diffMonths);
  
  console.log(`üìä [AGE CALCULATION LEGACY] ${registeredAge} meses + ${diffMonths} meses = ${currentAge} meses (${diffDays} d√≠as desde creaci√≥n)`);
  
  return currentAge;
};

// Funci√≥n para calcular semanas de gestaci√≥n desde fecha esperada de parto
const calculateGestationFromDueDate = (dueDate) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let due;
  if (dueDate && typeof dueDate === 'object' && dueDate._seconds) {
    due = new Date(dueDate._seconds * 1000);
  } else {
    due = new Date(dueDate);
  }
  
  // Un embarazo completo son 40 semanas (280 d√≠as)
  // Calculamos cu√°ntos d√≠as faltan hasta la fecha de parto
  const diffTime = due - now;
  const daysUntilDue = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  // Calcular semanas de gestaci√≥n actual
  // Si faltan X d√≠as, la gestaci√≥n actual es (280 - X) / 7
  const currentWeeks = Math.floor((280 - daysUntilDue) / 7);
  
  // Limitar a un rango realista (4-45 semanas, permitiendo un poco de margen para partos tard√≠os)
  const finalWeeks = Math.max(4, Math.min(45, currentWeeks));
  
  console.log(`üìä [GESTATION CALCULATION] Fecha de parto: ${due.toLocaleDateString()} ‚Üí Semanas actuales: ${finalWeeks} (faltan ${daysUntilDue} d√≠as)`);
  
  return {
    weeks: finalWeeks,
    isOverdue: currentWeeks >= 40,
    daysUntilDue: daysUntilDue
  };
};

// Funci√≥n para calcular semanas de gestaci√≥n actual basada en fecha de creaci√≥n (LEGACY - para compatibilidad)
const calculateCurrentGestationWeeks = (registeredWeeks, createdAt) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore
  let createdDate;
  if (createdAt && typeof createdAt === 'object' && createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(createdAt);
  }
  
  const diffTime = now - createdDate;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const diffWeeks = Math.floor(diffDays / 7);
  
  // Calcular semanas actuales sumando las semanas transcurridas
  const currentWeeks = registeredWeeks + diffWeeks;
  
  // Limitar a un rango realista (4-42 semanas)
  const finalWeeks = Math.max(4, Math.min(42, currentWeeks));
  
  console.log(`üìä [GESTATION CALCULATION LEGACY] ${registeredWeeks} semanas + ${diffWeeks} semanas = ${finalWeeks} semanas (${diffDays} d√≠as desde creaci√≥n)`);
  
  return finalWeeks;
};

// Funci√≥n para obtener informaci√≥n actualizada de un hijo
const getChildCurrentInfo = (child) => {
  const now = new Date();
  
  // Manejar Timestamp de Firestore para daysSinceCreation
  let createdDate;
  if (child.createdAt && typeof child.createdAt === 'object' && child.createdAt._seconds) {
    // Es un Timestamp de Firestore
    createdDate = new Date(child.createdAt._seconds * 1000);
  } else {
    // Es una fecha normal
    createdDate = new Date(child.createdAt);
  }
  
  const daysSinceCreation = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));
  
  if (child.isUnborn) {
    // Si tiene dueDate (nuevo sistema), usar eso
    if (child.dueDate) {
      const gestationInfo = calculateGestationFromDueDate(child.dueDate);
      
      return {
        ...child,
        currentGestationWeeks: gestationInfo.weeks,
        currentAgeInMonths: null,
        registeredGestationWeeks: null, // Ya no aplica con el nuevo sistema
        daysSinceCreation: daysSinceCreation,
        isOverdue: gestationInfo.isOverdue,
        daysUntilDue: gestationInfo.daysUntilDue
      };
    } 
    // Fallback a sistema antiguo (legacy)
    else if (child.gestationWeeks) {
    const currentGestationWeeks = calculateCurrentGestationWeeks(child.gestationWeeks, child.createdAt);
    
    return {
      ...child,
      currentGestationWeeks: currentGestationWeeks,
      currentAgeInMonths: null,
      registeredGestationWeeks: child.gestationWeeks,
      daysSinceCreation: daysSinceCreation,
      isOverdue: currentGestationWeeks >= 40
    };
    }
  } else {
    // Si tiene birthDate (nuevo sistema), usar eso
    if (child.birthDate) {
      const currentAgeInMonths = calculateAgeFromBirthDate(child.birthDate);
      
      return {
        ...child,
        currentAgeInMonths: currentAgeInMonths,
        currentGestationWeeks: null,
        registeredAgeInMonths: null, // Ya no aplica con el nuevo sistema
        daysSinceCreation: daysSinceCreation
      };
    }
    // Fallback a sistema antiguo (legacy)
    else if (child.ageInMonths !== undefined && child.ageInMonths !== null) {
    const currentAgeInMonths = calculateCurrentAge(child.ageInMonths, child.createdAt);
    
    return {
      ...child,
      currentAgeInMonths: currentAgeInMonths,
      currentGestationWeeks: null,
      registeredAgeInMonths: child.ageInMonths,
      daysSinceCreation: daysSinceCreation
    };
  }
  }
  
  // Si no hay datos v√°lidos, retornar el child original con valores por defecto
  return {
    ...child,
    currentAgeInMonths: 0,
    currentGestationWeeks: null,
    daysSinceCreation: daysSinceCreation
  };
};

// Funci√≥n para obtener respuestas previas de desarrollo
const getPreviousDevelopmentResponses = async (userId, childKey) => {
  try {
    const response = await db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses')
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();

    return response.docs.map(doc => doc.data());
  } catch (error) {
    console.error('Error obteniendo respuestas previas:', error);
    return [];
  }
};

// Funci√≥n para guardar respuesta de desarrollo
const saveDevelopmentResponse = async (userId, childKey, responseData) => {
  try {
    await db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses')
      .add({
        ...responseData,
        savedAt: new Date()
      });
  } catch (error) {
    console.error('Error guardando respuesta:', error);
  }
};

// Funci√≥n para validar que las respuestas no se repitan
const validateResponseUniqueness = (newBullets, previousResponses, maxAttempts = 3) => {
  if (previousResponses.length === 0) {
    return { isValid: true, bullets: newBullets };
  }

  // Extraer todos los bullets previos
  const allPreviousBullets = previousResponses.flatMap(resp => resp.developmentInfo);
  
  // Funci√≥n para calcular similitud entre dos bullets
  const calculateSimilarity = (bullet1, bullet2) => {
    const words1 = bullet1.toLowerCase().split(/\s+/);
    const words2 = bullet2.toLowerCase().split(/\s+/);
    const commonWords = words1.filter(word => words2.includes(word));
    return commonWords.length / Math.max(words1.length, words2.length);
  };

  // Verificar si hay repeticiones significativas
  let hasRepetition = false;
  for (const newBullet of newBullets) {
    for (const prevBullet of allPreviousBullets) {
      const similarity = calculateSimilarity(newBullet, prevBullet);
      if (similarity > 0.6) { // Si m√°s del 60% de las palabras son iguales
        hasRepetition = true;
        console.log(`‚ö†Ô∏è Detected repetition: "${newBullet.substring(0, 50)}..." similar to "${prevBullet.substring(0, 50)}..." (${(similarity * 100).toFixed(1)}%)`);
        break;
      }
    }
    if (hasRepetition) break;
  }

  return { isValid: !hasRepetition, bullets: newBullets };
};

// Funci√≥n para obtener informaci√≥n del embarazo por semanas desde OpenAI
const getPregnancyWeekInfoFromAI = async (gestationWeeks, babyName) => {
  if (!openai) {
    return {
      items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
      source: 'fallback'
    };
  }

  try {
    const systemPrompt = `Eres una doula experta especializada en desarrollo fetal. Debes entregar informaci√≥n clara y √∫til para madres sobre el embarazo por semanas.

IMPORTANTE:
- Proporciona EXACTAMENTE 4 bullets
- Cada bullet debe ser concreto y pr√°ctico
- Usa emojis al inicio de cada bullet
- Mant√©n un tono c√°lido y profesional
- No incluyas diagn√≥stico ni consejo m√©dico personalizado

FORMATO REQUERIDO:
1. üë∂ **T√≠tulo**: Texto...
2. üß† **T√≠tulo**: Texto...
3. ü´∂ **T√≠tulo**: Texto...
4. ‚ö†Ô∏è **T√≠tulo**: Texto...`;

    const userPrompt = `Dame 4 bullets de informaci√≥n importante sobre el embarazo en la semana ${gestationWeeks} para ${babyName}.`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      max_tokens: 500,
      temperature: 0.7
    });

    const content = response.choices[0].message.content || '';
    const items = content
      .split('\n')
      .filter(line => line.trim().match(/^\d+\.\s*/))
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(Boolean)
      .slice(0, 4);

    if (items.length < 3) {
      return {
        items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
        source: 'fallback'
      };
    }

    return { items, source: 'openai' };
  } catch (error) {
    console.error('‚ùå Error OpenAI embarazo por semanas:', error.message);
    return {
      items: getPregnancyWeekInfoFallback(gestationWeeks, babyName),
      source: 'fallback'
    };
  }
};

const getDailyGuideFallback = ({ unit, value, name, isPregnant }) => {
  const safeName = name || (isPregnant ? 'tu beb√©' : 'tu beb√©');
  const label = unit === 'month' ? `Mes ${value}` : `Semana ${value}`;
  const title = `${label}: El descubrimiento`;
  const subtitle = isPregnant
    ? `En la ${label.toLowerCase()}, el desarrollo contin√∫a a buen ritmo.`
    : `En la ${label.toLowerCase()}, ${safeName} sigue descubriendo el mundo.`;
  const description = isPregnant
    ? `Tu cuerpo y tu beb√© atraviesan cambios importantes. Mant√©n una rutina suave y escucha tu energ√≠a.`
    : `Texturas, sonidos y movimientos nuevos estimulan el desarrollo. El juego guiado corto marca la diferencia.`;
  const tip = isPregnant
    ? 'Dedica unos minutos a descansar y respirar profundo.'
    : 'Crea un ambiente calmado antes de dormir y evita est√≠mulos fuertes.';
  return { title, subtitle, description, tip, source: 'fallback' };
};

const extractJsonFromText = (text) => {
  const match = text.match(/\{[\s\S]*\}/);
  if (!match) return null;
  try {
    return JSON.parse(match[0]);
  } catch (_) {
    return null;
  }
};

const getDailyGuideFromAI = async ({ unit, value, name, isPregnant }) => {
  if (!openai) {
    return getDailyGuideFallback({ unit, value, name, isPregnant });
  }

  try {
    const systemPrompt = `Eres una doula experta. Genera una gu√≠a breve y c√°lida en espa√±ol.
Responde SOLO con JSON v√°lido con estas claves: title, subtitle, description, tip.
Requisitos:
- title debe empezar con "Semana X:" o "Mes X:" seg√∫n corresponda
- subtitle: 1 oraci√≥n
- description: 1-2 oraciones
- tip: m√°ximo 20 palabras
- Sin emojis ni markdown`;

    const label = unit === 'month' ? `Mes ${value}` : `Semana ${value}`;
    const context = isPregnant
      ? `Embarazo en ${label.toLowerCase()}.`
      : `Beb√© nacido con ${label.toLowerCase()} de vida.`;
    const displayName = name ? `Nombre: ${name}.` : '';

    const userPrompt = `Crea la gu√≠a de hoy. ${context} ${displayName}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      max_tokens: 250,
      temperature: 0.7
    });

    const content = response.choices?.[0]?.message?.content || '';
    const parsed = extractJsonFromText(content);
    if (!parsed || !parsed.title || !parsed.subtitle || !parsed.description || !parsed.tip) {
      return getDailyGuideFallback({ unit, value, name, isPregnant });
    }
    const expectedPrefix = unit === 'month' ? `Mes ${value}:` : `Semana ${value}:`;
    if (!String(parsed.title || '').startsWith(expectedPrefix)) {
      return getDailyGuideFallback({ unit, value, name, isPregnant });
    }
    return { ...parsed, source: 'openai' };
  } catch (error) {
    console.error('‚ùå Error OpenAI gu√≠a diaria:', error.message);
    return getDailyGuideFallback({ unit, value, name, isPregnant });
  }
};

const getMomsFaqFallback = (childName) => {
  const name = childName || 'mi beb√©';
  return [
    `¬øEs normal que ${name} cambie sus horarios de sue√±o semana a semana?`,
    `¬øCu√°ntas siestas deber√≠a hacer ${name} seg√∫n su edad?`,
    `¬øQu√© se√±ales indican que ${name} ya tiene sue√±o?`,
    `¬øC√≥mo puedo crear una rutina tranquila antes de dormir?`
  ];
};

const getMomsFaqFromAI = async ({ childName, isPregnant, ageLabel }) => {
  if (!openai) {
    return { items: getMomsFaqFallback(childName), source: 'fallback' };
  }

  try {
    const systemPrompt = `Eres una doula experta. Genera EXACTAMENTE 4 preguntas frecuentes en espa√±ol para madres.
Requisitos:
- Deben ser preguntas cortas y claras
- Sin emojis ni markdown
- En una sola l√≠nea cada pregunta`;

    const context = isPregnant
      ? `Contexto: embarazo. ${ageLabel ? `Edad: ${ageLabel}.` : ''}`
      : `Contexto: beb√© nacido. Nombre: ${childName || 'mi beb√©'}. ${ageLabel ? `Edad: ${ageLabel}.` : ''}`;

    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Crea 4 preguntas frecuentes. ${context}` }
      ],
      max_tokens: 200,
      temperature: 0.7
    });

    const content = response.choices?.[0]?.message?.content || '';
    const items = content
      .split('\n')
      .map(line => line.replace(/^\d+\.\s*/, '').trim())
      .filter(Boolean)
      .slice(0, 4);

    if (items.length < 4) {
      return { items: getMomsFaqFallback(childName), source: 'fallback' };
    }

    return { items, source: 'openai' };
  } catch (error) {
    console.error('‚ùå Error OpenAI FAQ mam√°s:', error.message);
    return { items: getMomsFaqFallback(childName), source: 'fallback' };
  }
};

// Subir imagen base64 a Firebase Storage y devolver URL p√∫blica
const uploadPregnancyImageBase64 = async (base64Data, filePath) => {
  const bucket = admin.storage().bucket();
  const buffer = Buffer.from(base64Data, 'base64');
  const file = bucket.file(filePath);

  await file.save(buffer, {
    metadata: {
      contentType: 'image/png'
    }
  });
  await file.makePublic();

  return `https://storage.googleapis.com/${bucket.name}/${file.name}`;
};

// Funci√≥n para generar imagen del embarazo por semanas con OpenAI (URL p√∫blica)
const generatePregnancyImageUrlFromAI = async (gestationWeeks) => {
  if (!openai) {
    return { url: null, warning: 'openai_not_configured' };
  }

  try {
    const prompt = `Ilustraci√≥n m√©dica educativa, estilo suave y minimalista, de un feto en el √∫tero a las ${gestationWeeks} semanas de gestaci√≥n. 
No realista, sin sangre, sin desnudez expl√≠cita, fondo claro, colores suaves, enfoque en el desarrollo general.`;

    const response = await openai.images.generate({
      model: process.env.OPENAI_IMAGE_MODEL || 'gpt-image-1',
      prompt: prompt,
      size: '1024x1024'
    });

    const base64Image = response.data?.[0]?.b64_json || null;
    if (base64Image) {
      const filePath = `pregnancy/weeks/${gestationWeeks}/week-${gestationWeeks}-${Date.now()}.png`;
      const url = await uploadPregnancyImageBase64(base64Image, filePath);
      return { url, warning: null };
    }

    const imageUrl = response.data?.[0]?.url || null;
    return { url: imageUrl, warning: imageUrl ? null : 'openai_image_empty' };
  } catch (error) {
    const message = error?.message || '';
    if (message.includes('organization must be verified')) {
      console.warn('‚ö†Ô∏è OpenAI requiere verificaci√≥n de organizaci√≥n para im√°genes.');
      return { url: null, warning: 'openai_org_verification_required' };
    }
    if (message.includes('does not have access to model')) {
      console.warn('‚ö†Ô∏è OpenAI: el proyecto no tiene acceso al modelo de im√°genes.');
      return { url: null, warning: 'openai_model_not_allowed' };
    }
    console.error('‚ùå Error generando imagen de embarazo:', message);
    return { url: null, warning: 'openai_image_error' };
  }
};

// Fallback para informaci√≥n del embarazo por semanas
const getPregnancyWeekInfoFallback = (gestationWeeks, babyName) => {
  if (gestationWeeks <= 12) {
    return [
      `üë∂ **Formaci√≥n temprana**: ${babyName} est√° formando √≥rganos principales y estructuras b√°sicas.`,
      "üß¨ **Desarrollo clave**: Se fortalecen el cerebro y el sistema nervioso central.",
      "üçé **Nutrici√≥n**: Prioriza √°cido f√≥lico, hierro y una hidrataci√≥n constante.",
      "‚ö†Ô∏è **Cuidados**: Evita alcohol, tabaco y medicamentos sin indicaci√≥n m√©dica."
    ];
  }
  if (gestationWeeks <= 24) {
    return [
      `üë∂ **Movimientos**: ${babyName} ya realiza movimientos m√°s perceptibles.`,
      "üëÇ **Sentidos**: Responde a sonidos y a la voz de la madre.",
      "üìè **Crecimiento**: Aumenta peso y tama√±o r√°pidamente.",
      "ü´∂ **V√≠nculo**: Hablarle y tocar el abdomen ayuda a conectar."
    ];
  }
  if (gestationWeeks <= 36) {
    return [
      "ü´Å **Pulmones**: Se preparan para respirar fuera del √∫tero.",
      "üß† **Maduraci√≥n**: El cerebro contin√∫a desarroll√°ndose aceleradamente.",
      "üí§ **Sue√±o**: Presenta ciclos de sue√±o m√°s definidos.",
      "üè• **Preparaci√≥n**: Considera plan de parto y controles prenatales."
    ];
  }

  return [
    "üë∂ **Posici√≥n**: El beb√© suele colocarse cabeza abajo.",
    "üß† **√öltimos ajustes**: Maduraci√≥n final de √≥rganos y reflejos.",
    "üß≥ **Preparaci√≥n**: Ten lista tu bolsa para el parto.",
    "‚ö†Ô∏è **Se√±ales**: Consulta ante contracciones regulares o p√©rdida de l√≠quido."
  ];
};

// Funci√≥n para obtener informaci√≥n de desarrollo de beb√©s por nacer desde OpenAI
const getUnbornDevelopmentInfoFromAI = async (gestationWeeks, previousResponses, childName) => {
  try {
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      attempts++;
      console.log(`ü§ñ [OPENAI] Intento ${attempts}/${maxAttempts} para ${childName} (${gestationWeeks} semanas)`);

      // Crear contexto de respuestas previas
      const previousContext = previousResponses.length > 0 
        ? `\n\nInformaci√≥n ya proporcionada anteriormente:\n${previousResponses.slice(0, 3).map((resp, index) => 
            `${index + 1}. ${resp.developmentInfo.join('\n   ')}`
          ).join('\n')}`
        : '';

      const systemPrompt = `Eres una doula experta especializada en desarrollo fetal. Tu tarea es proporcionar informaci√≥n relevante y variada sobre el desarrollo del beb√© durante el embarazo.

IMPORTANTE:
- Proporciona EXACTAMENTE 3 bullets de informaci√≥n
- Cada bullet debe ser COMPLETAMENTE DIFERENTE a la informaci√≥n previa
- Evita repetir conceptos, temas o informaci√≥n ya proporcionada
- Usa emojis relevantes al inicio de cada bullet
- Mant√©n un tono c√°lido y profesional
- Incluye el nombre del beb√© cuando sea apropiado
- Si es la consulta #${previousResponses.length + 1}, enf√≥cate en aspectos NO mencionados anteriormente

FORMATO REQUERIDO:
1. ü´Ä **T√≠tulo del primer aspecto**: Descripci√≥n detallada...
2. üß¨ **T√≠tulo del segundo aspecto**: Descripci√≥n detallada...
3. ‚ö†Ô∏è **T√≠tulo del tercer aspecto**: Descripci√≥n detallada...

CONTEXTO ACTUAL:
- Beb√©: ${childName}
- Semanas de gestaci√≥n: ${gestationWeeks}
- Consulta #${previousResponses.length + 1}${previousContext}

${previousResponses.length > 0 ? 'IMPORTANTE: NO repitas ning√∫n concepto, tema o informaci√≥n de las consultas anteriores. Busca aspectos completamente nuevos.' : 'Si es la primera consulta, proporciona informaci√≥n fundamental.'}`;

      const userPrompt = `Proporciona 3 bullets de informaci√≥n √öNICA sobre el desarrollo fetal de ${childName} a las ${gestationWeeks} semanas de gestaci√≥n.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: 500,
        temperature: 0.8 + (attempts * 0.1), // Aumentar temperatura en cada intento
        presence_penalty: 0.8 + (attempts * 0.1), // Aumentar penalty en cada intento
        frequency_penalty: 0.9 + (attempts * 0.05)
      });

      const content = response.choices[0].message.content;
      
      // Extraer los 3 bullets del contenido
      const bullets = content.split('\n')
        .filter(line => line.trim().match(/^\d+\.\s*[ü´Äüß¨‚ö†Ô∏èüë∂üëÇüìèüéµü´ÅüëÅÔ∏èüí™üß†üí§üçéüéØüì¶‚è∞ü§±üè•üë∂]/))
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .slice(0, 3);

      // Si no se pudieron extraer bullets, usar fallback
      if (bullets.length < 3) {
        console.log('‚ö†Ô∏è No se pudieron extraer bullets de OpenAI, usando fallback');
        return getUnbornDevelopmentInfoFallback(gestationWeeks);
      }

      // Validar que no haya repeticiones
      const validation = validateResponseUniqueness(bullets, previousResponses);
      
      if (validation.isValid) {
        console.log(`‚úÖ [OPENAI] Respuesta v√°lida obtenida en intento ${attempts}`);
        return validation.bullets;
      } else {
        console.log(`‚ö†Ô∏è [OPENAI] Respuesta con repeticiones detectada, reintentando...`);
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar antes del siguiente intento
        }
      }
    }

    // Si se agotaron los intentos, usar fallback
    console.log(`‚ö†Ô∏è [OPENAI] Se agotaron los intentos, usando fallback`);
    return getUnbornDevelopmentInfoFallback(gestationWeeks);

  } catch (error) {
    console.error('‚ùå Error obteniendo informaci√≥n de OpenAI:', error);
    // Fallback a informaci√≥n predefinida
    return getUnbornDevelopmentInfoFallback(gestationWeeks);
  }
};

// Funci√≥n para obtener informaci√≥n de desarrollo de ni√±os nacidos desde OpenAI
const getChildDevelopmentInfoFromAI = async (ageInMonths, previousResponses, childName) => {
  try {
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      attempts++;
      console.log(`ü§ñ [OPENAI] Intento ${attempts}/${maxAttempts} para ${childName} (${ageInMonths} meses)`);

      // Crear contexto de respuestas previas
      const previousContext = previousResponses.length > 0 
        ? `\n\nInformaci√≥n ya proporcionada anteriormente:\n${previousResponses.slice(0, 3).map((resp, index) => 
            `${index + 1}. ${resp.developmentInfo.join('\n   ')}`
          ).join('\n')}`
        : '';

      const systemPrompt = `Eres una doula experta especializada en desarrollo infantil. Tu tarea es proporcionar informaci√≥n relevante y variada sobre el desarrollo del ni√±o.

IMPORTANTE:
- Proporciona EXACTAMENTE 3 bullets de informaci√≥n
- Cada bullet debe ser COMPLETAMENTE DIFERENTE a la informaci√≥n previa
- Evita repetir conceptos, temas o informaci√≥n ya proporcionada
- Usa emojis relevantes al inicio de cada bullet
- Mant√©n un tono c√°lido y profesional
- Incluye el nombre del ni√±o cuando sea apropiado
- Si es la consulta #${previousResponses.length + 1}, enf√≥cate en aspectos NO mencionados anteriormente

FORMATO REQUERIDO:
1. üëÄ **T√≠tulo del primer aspecto**: Descripci√≥n detallada...
2. üòä **T√≠tulo del segundo aspecto**: Descripci√≥n detallada...
3. üí™ **T√≠tulo del tercer aspecto**: Descripci√≥n detallada...

CONTEXTO ACTUAL:
- Ni√±o: ${childName}
- Edad: ${ageInMonths} meses
- Consulta #${previousResponses.length + 1}${previousContext}

${previousResponses.length > 0 ? 'IMPORTANTE: NO repitas ning√∫n concepto, tema o informaci√≥n de las consultas anteriores. Busca aspectos completamente nuevos.' : 'Si es la primera consulta, proporciona informaci√≥n fundamental.'}`;

      const userPrompt = `Proporciona 3 bullets de informaci√≥n √öNICA sobre el desarrollo de ${childName} a los ${ageInMonths} meses de edad.`;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: 500,
        temperature: 0.8 + (attempts * 0.1), // Aumentar temperatura en cada intento
        presence_penalty: 0.8 + (attempts * 0.1), // Aumentar penalty en cada intento
        frequency_penalty: 0.9 + (attempts * 0.05)
      });

      const content = response.choices[0].message.content;
      
      // Extraer los 3 bullets del contenido
      const bullets = content.split('\n')
        .filter(line => line.trim().match(/^\d+\.\s*[üëÄüòäüí™ü§±ü¶∑üîÑüé§üëêü™ëü§èüó£Ô∏èüö∂üëãüçΩÔ∏èüèÉüéØüéµüß©üé≠üìöüé®ü§ùüßÆüèÉ‚Äç‚ôÇÔ∏èüìñüî¢üéØüéìüèÉ‚Äç‚ôÇÔ∏èüß†üìöüé®üë•]/))
        .map(line => line.replace(/^\d+\.\s*/, '').trim())
        .slice(0, 3);

      // Si no se pudieron extraer bullets, usar fallback
      if (bullets.length < 3) {
        console.log('‚ö†Ô∏è No se pudieron extraer bullets de OpenAI, usando fallback');
        return getChildDevelopmentInfoFallback(ageInMonths);
      }

      // Validar que no haya repeticiones
      const validation = validateResponseUniqueness(bullets, previousResponses);
      
      if (validation.isValid) {
        console.log(`‚úÖ [OPENAI] Respuesta v√°lida obtenida en intento ${attempts}`);
        return validation.bullets;
      } else {
        console.log(`‚ö†Ô∏è [OPENAI] Respuesta con repeticiones detectada, reintentando...`);
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar antes del siguiente intento
        }
      }
    }

    // Si se agotaron los intentos, usar fallback
    console.log(`‚ö†Ô∏è [OPENAI] Se agotaron los intentos, usando fallback`);
    return getChildDevelopmentInfoFallback(ageInMonths);

  } catch (error) {
    console.error('‚ùå Error obteniendo informaci√≥n de OpenAI:', error);
    // Fallback a informaci√≥n predefinida
    return getChildDevelopmentInfoFallback(ageInMonths);
  }
};

// Funci√≥n de fallback para informaci√≥n de beb√©s por nacer
const getUnbornDevelopmentInfoFallback = (gestationWeeks) => {
  if (gestationWeeks <= 12) {
    return [
      "ü´Ä **Desarrollo del coraz√≥n**: El coraz√≥n de tu beb√© ya late y se est√°n formando los principales √≥rganos. Es un per√≠odo cr√≠tico de desarrollo.",
      "üß¨ **Formaci√≥n de √≥rganos**: Se est√°n desarrollando el cerebro, h√≠gado, ri√±ones y otros √≥rganos vitales. La nutrici√≥n materna es fundamental.",
      "‚ö†Ô∏è **Cuidados especiales**: Evita alcohol, tabaco y medicamentos sin prescripci√≥n m√©dica. Descansa lo suficiente y mant√©n una dieta equilibrada."
    ];
  } else if (gestationWeeks <= 24) {
    return [
      "üë∂ **Movimientos fetales**: Tu beb√© ya se mueve y puedes sentir sus pataditas. Los movimientos son una se√±al de bienestar.",
      "üëÇ **Desarrollo sensorial**: Ya puede o√≠r sonidos y responde a tu voz. Hablarle y cantarle fortalece el v√≠nculo.",
      "üìè **Crecimiento acelerado**: Tu beb√© crece r√°pidamente. Mant√©n una buena nutrici√≥n y control prenatal regular."
    ];
  } else if (gestationWeeks <= 36) {
    return [
      "ü´Å **Maduraci√≥n pulmonar**: Los pulmones se est√°n preparando para respirar. El beb√© practica movimientos respiratorios.",
      "üëÅÔ∏è **Desarrollo visual**: Los ojos se abren y puede distinguir entre luz y oscuridad. Responde a est√≠mulos luminosos.",
      "üí™ **Posici√≥n de parto**: El beb√© se est√° posicionando para el nacimiento. Los movimientos pueden ser m√°s limitados."
    ];
  } else {
    return [
      "üéØ **Listo para nacer**: Tu beb√© est√° completamente desarrollado y listo para el nacimiento en cualquier momento.",
      "üì¶ **Posici√≥n final**: Probablemente est√© en posici√≥n cef√°lica (cabeza abajo) prepar√°ndose para el parto.",
      "‚è∞ **Signos de parto**: Presta atenci√≥n a contracciones regulares, rotura de aguas o p√©rdida del tap√≥n mucoso."
    ];
  }
};

// Funci√≥n de fallback para informaci√≥n de ni√±os nacidos
const getChildDevelopmentInfoFallback = (ageInMonths) => {
  if (ageInMonths <= 3) {
    return [
      "üëÄ **Desarrollo visual**: Tu beb√© puede seguir objetos con la mirada y reconoce tu rostro. El contacto visual es fundamental.",
      "üòä **Primeras sonrisas**: Aparecen las sonrisas sociales y el beb√© responde a tu voz y caricias.",
      "üí™ **Control de cabeza**: Comienza a sostener la cabeza cuando est√° boca abajo. El tiempo boca abajo es importante."
    ];
  } else if (ageInMonths <= 6) {
    return [
      "ü§± **Alimentaci√≥n complementaria**: Est√° listo para comenzar con papillas. Introduce alimentos uno por uno.",
      "ü¶∑ **Primeros dientes**: Pueden aparecer los primeros dientes. Ofrece mordedores fr√≠os para aliviar las molestias.",
      "üîÑ **Volteo**: Aprende a darse la vuelta de boca arriba a boca abajo y viceversa. Supervisa siempre."
    ];
  } else if (ageInMonths <= 9) {
    return [
      "ü™ë **Sentarse solo**: Ya puede sentarse sin apoyo y mantenerse estable. El equilibrio mejora d√≠a a d√≠a.",
      "ü§è **Pinza fina**: Desarrolla la capacidad de agarrar objetos peque√±os entre el pulgar y el √≠ndice.",
      "üó£Ô∏è **Balbuceo**: Produce sonidos como 'mam√°', 'pap√°'. Responde a su nombre y entiende palabras simples."
    ];
  } else if (ageInMonths <= 12) {
    return [
      "üö∂ **Primeros pasos**: Puede dar sus primeros pasos sosteni√©ndose de muebles o de tu mano. Cada beb√© tiene su ritmo.",
      "üëã **Gestos comunicativos**: Hace gestos como saludar, se√±alar y aplaudir. La comunicaci√≥n no verbal se desarrolla.",
      "üçΩÔ∏è **Alimentaci√≥n independiente**: Quiere comer solo y explorar texturas. Ofrece alimentos seguros y variados."
    ];
  } else if (ageInMonths <= 18) {
    return [
      "üèÉ **Caminar estable**: Ya camina con seguridad y puede subir escaleras gateando. Supervisa en todo momento.",
      "üó£Ô∏è **Primeras palabras**: Dice entre 5-20 palabras y entiende muchas m√°s. Lee cuentos y habla constantemente.",
      "üéØ **Juego simb√≥lico**: Comienza a imitar acciones como hablar por tel√©fono o dar de comer a mu√±ecos."
    ];
  } else if (ageInMonths <= 24) {
    return [
      "üí¨ **Explosi√≥n del lenguaje**: Aprende nuevas palabras cada d√≠a y forma frases de 2-3 palabras.",
      "üé® **Creatividad**: Disfruta pintar, dibujar y crear. Ofrece materiales seguros para expresarse.",
      "üë• **Socializaci√≥n**: Muestra inter√©s por otros ni√±os aunque a√∫n juega en paralelo. Las citas de juego son beneficiosas."
    ];
  } else if (ageInMonths <= 36) {
    return [
      "üß© **Pensamiento l√≥gico**: Resuelve rompecabezas simples y entiende conceptos como grande/peque√±o, arriba/abajo.",
      "üé≠ **Juego de roles**: Imita roles como ser mam√°, pap√°, doctor. El juego imaginativo se desarrolla.",
      "üéµ **Habilidades musicales**: Disfruta cantar, bailar y hacer m√∫sica. La m√∫sica estimula el desarrollo cerebral."
    ];
  } else if (ageInMonths <= 48) {
    return [
      "üìö **Preparaci√≥n escolar**: Desarrolla habilidades pre-lectura como reconocer letras y contar.",
      "üé® **Expresi√≥n art√≠stica**: Crea dibujos m√°s detallados y puede representar personas y objetos.",
      "ü§ù **Cooperaci√≥n**: Aprende a compartir, esperar turnos y seguir reglas simples en grupo."
    ];
  } else if (ageInMonths <= 60) {
    return [
      "üìñ **Lectura emergente**: Reconoce algunas palabras escritas y puede 'leer' cuentos conocidos.",
      "üî¢ **Conceptos matem√°ticos**: Cuenta hasta 10, reconoce n√∫meros y entiende conceptos b√°sicos de cantidad.",
      "üéØ **Independencia**: Se viste solo, usa el ba√±o independientemente y ayuda en tareas simples."
    ];
  } else {
    return [
      "üéì **Desarrollo escolar**: Est√° listo para el aprendizaje formal. Las habilidades sociales y acad√©micas se desarrollan.",
      "üèÉ‚Äç‚ôÇÔ∏è **Actividad f√≠sica**: Disfruta deportes y actividades f√≠sicas. El ejercicio regular es importante.",
      "üß† **Pensamiento abstracto**: Comienza a entender conceptos m√°s complejos y puede resolver problemas simples."
    ];
  }
};

// Funci√≥n para obtener informaci√≥n de desarrollo de beb√©s por nacer
const getUnbornDevelopmentInfo = (gestationWeeks) => {
  if (gestationWeeks <= 12) {
    return [
      "ü´Ä **Desarrollo del coraz√≥n**: El coraz√≥n de tu beb√© ya late y se est√°n formando los principales √≥rganos. Es un per√≠odo cr√≠tico de desarrollo.",
      "üß¨ **Formaci√≥n de √≥rganos**: Se est√°n desarrollando el cerebro, h√≠gado, ri√±ones y otros √≥rganos vitales. La nutrici√≥n materna es fundamental.",
      "‚ö†Ô∏è **Cuidados especiales**: Evita alcohol, tabaco y medicamentos sin prescripci√≥n m√©dica. Descansa lo suficiente y mant√©n una dieta equilibrada."
    ];
  } else if (gestationWeeks <= 24) {
    return [
      "üë∂ **Movimientos fetales**: Tu beb√© ya se mueve y puedes sentir sus pataditas. Los movimientos son una se√±al de bienestar.",
      "üëÇ **Desarrollo sensorial**: Ya puede o√≠r sonidos y responde a tu voz. Hablarle y cantarle fortalece el v√≠nculo.",
      "üìè **Crecimiento acelerado**: Tu beb√© crece r√°pidamente. Mant√©n una buena nutrici√≥n y control prenatal regular."
    ];
  } else if (gestationWeeks <= 36) {
    return [
      "ü´Å **Maduraci√≥n pulmonar**: Los pulmones se est√°n preparando para respirar. El beb√© practica movimientos respiratorios.",
      "üëÅÔ∏è **Desarrollo visual**: Los ojos se abren y puede distinguir entre luz y oscuridad. Responde a est√≠mulos luminosos.",
      "üí™ **Posici√≥n de parto**: El beb√© se est√° posicionando para el nacimiento. Los movimientos pueden ser m√°s limitados."
    ];
  } else {
    return [
      "üéØ **Listo para nacer**: Tu beb√© est√° completamente desarrollado y listo para el nacimiento en cualquier momento.",
      "üì¶ **Posici√≥n final**: Probablemente est√© en posici√≥n cef√°lica (cabeza abajo) prepar√°ndose para el parto.",
      "‚è∞ **Signos de parto**: Presta atenci√≥n a contracciones regulares, rotura de aguas o p√©rdida del tap√≥n mucoso."
    ];
  }
};



// Funci√≥n para obtener informaci√≥n de desarrollo de ni√±os nacidos
const getChildDevelopmentInfo = (ageInMonths) => {
  if (ageInMonths <= 3) {
    return [
      "üëÄ **Desarrollo visual**: Tu beb√© puede seguir objetos con la mirada y reconoce tu rostro. El contacto visual es fundamental.",
      "üòä **Primeras sonrisas**: Aparecen las sonrisas sociales y el beb√© responde a tu voz y caricias.",
      "üí™ **Control de cabeza**: Comienza a sostener la cabeza cuando est√° boca abajo. El tiempo boca abajo es importante."
    ];
  } else if (ageInMonths <= 6) {
    return [
      "ü§± **Alimentaci√≥n complementaria**: Est√° listo para comenzar con papillas. Introduce alimentos uno por uno.",
      "ü¶∑ **Primeros dientes**: Pueden aparecer los primeros dientes. Ofrece mordedores fr√≠os para aliviar las molestias.",
      "üîÑ **Volteo**: Aprende a darse la vuelta de boca arriba a boca abajo y viceversa. Supervisa siempre."
    ];
  } else if (ageInMonths <= 9) {
    return [
      "ü™ë **Sentarse solo**: Ya puede sentarse sin apoyo y mantenerse estable. El equilibrio mejora d√≠a a d√≠a.",
      "ü§è **Pinza fina**: Desarrolla la capacidad de agarrar objetos peque√±os entre el pulgar y el √≠ndice.",
      "üó£Ô∏è **Balbuceo**: Produce sonidos como 'mam√°', 'pap√°'. Responde a su nombre y entiende palabras simples."
    ];
  } else if (ageInMonths <= 12) {
    return [
      "üö∂ **Primeros pasos**: Puede dar sus primeros pasos sosteni√©ndose de muebles o de tu mano. Cada beb√© tiene su ritmo.",
      "üëã **Gestos comunicativos**: Hace gestos como saludar, se√±alar y aplaudir. La comunicaci√≥n no verbal se desarrolla.",
      "üçΩÔ∏è **Alimentaci√≥n independiente**: Quiere comer solo y explorar texturas. Ofrece alimentos seguros y variados."
    ];
  } else if (ageInMonths <= 18) {
    return [
      "üèÉ **Caminar estable**: Ya camina con seguridad y puede subir escaleras gateando. Supervisa en todo momento.",
      "üó£Ô∏è **Primeras palabras**: Dice entre 5-20 palabras y entiende muchas m√°s. Lee cuentos y habla constantemente.",
      "üéØ **Juego simb√≥lico**: Comienza a imitar acciones como hablar por tel√©fono o dar de comer a mu√±ecos."
    ];
  } else if (ageInMonths <= 24) {
    return [
      "üí¨ **Explosi√≥n del lenguaje**: Aprende nuevas palabras cada d√≠a y forma frases de 2-3 palabras.",
      "üé® **Creatividad**: Disfruta pintar, dibujar y crear. Ofrece materiales seguros para expresarse.",
      "üë• **Socializaci√≥n**: Muestra inter√©s por otros ni√±os aunque a√∫n juega en paralelo. Las citas de juego son beneficiosas."
    ];
  } else if (ageInMonths <= 36) {
    return [
      "üß© **Pensamiento l√≥gico**: Resuelve rompecabezas simples y entiende conceptos como grande/peque√±o, arriba/abajo.",
      "üé≠ **Juego de roles**: Imita roles como ser mam√°, pap√°, doctor. El juego imaginativo se desarrolla.",
      "üéµ **Habilidades musicales**: Disfruta cantar, bailar y hacer m√∫sica. La m√∫sica estimula el desarrollo cerebral."
    ];
  } else if (ageInMonths <= 48) {
    return [
      "üìö **Preparaci√≥n escolar**: Desarrolla habilidades pre-lectura como reconocer letras y contar.",
      "üé® **Expresi√≥n art√≠stica**: Crea dibujos m√°s detallados y puede representar personas y objetos.",
      "ü§ù **Cooperaci√≥n**: Aprende a compartir, esperar turnos y seguir reglas simples en grupo."
    ];
  } else if (ageInMonths <= 60) {
    return [
      "üìñ **Lectura emergente**: Reconoce algunas palabras escritas y puede 'leer' cuentos conocidos.",
      "üî¢ **Conceptos matem√°ticos**: Cuenta hasta 10, reconoce n√∫meros y entiende conceptos b√°sicos de cantidad.",
      "üéØ **Independencia**: Se viste solo, usa el ba√±o independientemente y ayuda en tareas simples."
    ];
  } else {
    return [
      "üéì **Desarrollo escolar**: Est√° listo para el aprendizaje formal. Las habilidades sociales y acad√©micas se desarrollan.",
      "üèÉ‚Äç‚ôÇÔ∏è **Actividad f√≠sica**: Disfruta deportes y actividades f√≠sicas. El ejercicio regular es importante.",
      "üß† **Pensamiento abstracto**: Comienza a entender conceptos m√°s complejos y puede resolver problemas simples."
    ];
  }
};

// Endpoint para obtener informaci√≥n actualizada de hijos
app.get('/api/auth/children/current-info', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener hijos propios
    const ownChildrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    // Obtener hijos compartidos
    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const children = [];
    const childIds = new Set();

    // Procesar hijos propios
    ownChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...currentInfo,
          isShared: false,
          // Informaci√≥n adicional calculada
          createdDate: childData.createdAt,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    // Procesar hijos compartidos
    sharedChildrenSnapshot.forEach(doc => {
      if (!childIds.has(doc.id)) {
        childIds.add(doc.id);
        const childData = doc.data();
        const currentInfo = getChildCurrentInfo(childData);
        
        children.push({
          id: doc.id,
          ...currentInfo,
          isShared: true,
          // Informaci√≥n adicional calculada
          createdDate: childData.createdAt,
          daysSinceCreation: currentInfo.daysSinceCreation,
          isOverdue: currentInfo.isOverdue || false
        });
      }
    });

    res.json({
      success: true,
      data: {
        children: children,
        totalChildren: children.length,
        timestamp: new Date()
      }
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo informaci√≥n actualizada de hijos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo informaci√≥n de hijos',
      error: error.message
    });
  }
});

// Endpoint para limpiar historial de respuestas de desarrollo
app.delete('/api/children/development-history', authenticateToken, async (req, res) => {
  try {
    const { childName, ageInMonths, isUnborn = false } = req.body;
    const userId = req.user.uid;

    if (!childName || !childName.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre del ni√±o es requerido'
      });
    }

    const childKey = `${childName.trim()}_${isUnborn ? 'unborn' : ageInMonths}months`;

    // Obtener todas las respuestas para este ni√±o
    const responsesRef = db.collection('development_responses')
      .doc(userId)
      .collection('children')
      .doc(childKey)
      .collection('responses');

    const responses = await responsesRef.get();

    // Eliminar todas las respuestas
    const batch = db.batch();
    responses.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    res.json({
      success: true,
      message: 'Historial de respuestas eliminado',
      data: {
        childName: childName.trim(),
        deletedCount: responses.docs.length
      }
    });

  } catch (error) {
    console.error('‚ùå Error eliminando historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando historial',
      error: error.message
    });
  }
});
// Endpoint para obtener tips personalizados de los hijos
app.post('/api/children/tips', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { tipType = 'general', childId } = req.body; // general, alimentacion, desarrollo, salud, etc.
    
    console.log('üí° [TIPS] Solicitud de tip:', { tipType, childId, userId: uid });

    // Verificar si ya se dio un tip recientemente para evitar repetici√≥n
    let recentTips = [];
    let latestTipData = null;
    const forceRefresh = req.query?.force === 'true' || req.headers['x-force-refresh'] === 'true';
    const cacheTtlMinutes = 60;
    try {
      const recentTipsSnapshot = await db.collection('userTips')
        .where('userId', '==', uid)
        .where('tipType', '==', tipType)
        .orderBy('createdAt', 'desc')
        .limit(5)
        .get();
      
      recentTipsSnapshot.forEach(doc => {
        recentTips.push(doc.data().tip);
      });
      if (!recentTipsSnapshot.empty) {
        latestTipData = recentTipsSnapshot.docs[0].data();
      }
    } catch (indexError) {
      console.log('‚ö†Ô∏è √çndice no disponible a√∫n, continuando sin verificaci√≥n de duplicados:', indexError.message);
      // Continuar sin verificaci√≥n de duplicados hasta que se cree el √≠ndice
      recentTips = [];
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener informaci√≥n actualizada de los hijos
    let children = [];
    
    if (childId) {
      // Si se proporciona childId, solo obtener ese hijo espec√≠fico
      console.log('üîç [TIPS] Obteniendo informaci√≥n del hijo espec√≠fico:', childId);
      
      const childDoc = await db.collection('children').doc(childId).get();
      
      if (!childDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Hijo no encontrado'
        });
      }
      
      const childData = childDoc.data();
      
      // Verificar que el hijo pertenece al usuario
      if (childData.parentId !== uid) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permiso para acceder a este hijo'
        });
      }
      
      const currentInfo = getChildCurrentInfo(childData);
      children.push({
        id: childDoc.id,
        name: childData.name,
        ageInMonths: childData.ageInMonths,
        currentAgeInMonths: currentInfo.currentAgeInMonths,
        isUnborn: childData.isUnborn,
        gestationWeeks: childData.gestationWeeks,
        currentGestationWeeks: currentInfo.currentGestationWeeks,
        daysSinceCreation: currentInfo.daysSinceCreation
      });
      
      console.log('‚úÖ [TIPS] Hijo espec√≠fico obtenido:', children[0]);
    } else {
      // Si no se proporciona childId, obtener todos los hijos
      console.log('üîç [TIPS] Obteniendo todos los hijos del usuario');
      
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    if (childrenSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'No tienes hijos registrados'
      });
    }

    childrenSnapshot.forEach(doc => {
      const childData = doc.data();
      const currentInfo = getChildCurrentInfo(childData);
      children.push({
        id: doc.id,
        name: childData.name,
        ageInMonths: childData.ageInMonths,
        currentAgeInMonths: currentInfo.currentAgeInMonths,
        isUnborn: childData.isUnborn,
        gestationWeeks: childData.gestationWeeks,
        currentGestationWeeks: currentInfo.currentGestationWeeks,
        daysSinceCreation: currentInfo.daysSinceCreation
      });
    });
      
      console.log('‚úÖ [TIPS] Todos los hijos obtenidos:', children.length);
    }

    // Obtener perfil del usuario para verificar si est√° embarazada
    let isPregnant = false;
    let currentGestationWeeks = 0;
    
    try {
      const userProfileSnapshot = await db.collection('users').doc(uid).get();
      if (userProfileSnapshot.exists) {
        const userProfile = userProfileSnapshot.data();
        isPregnant = userProfile.isPregnant || false;
        currentGestationWeeks = userProfile.gestationWeeks || 0;
        console.log('üë§ [PROFILE] Perfil del usuario:', { isPregnant, currentGestationWeeks });
      }
    } catch (profileError) {
      console.log('‚ö†Ô∏è [PROFILE] Error obteniendo perfil del usuario:', profileError.message);
      // Continuar con valores por defecto
    }

    // ‚ö° Devolver tip cacheado si es reciente (evita OpenAI)
    if (!forceRefresh && latestTipData?.createdAt) {
      const createdAt = latestTipData.createdAt.toDate ? latestTipData.createdAt.toDate() : new Date(latestTipData.createdAt);
      const ageMinutes = Math.floor((Date.now() - createdAt.getTime()) / 60000);
      const childMatch = !childId || !latestTipData.childIds || latestTipData.childIds.includes(childId);
      if (ageMinutes <= cacheTtlMinutes && childMatch) {
        console.log(`‚ö° [TIPS] Usando cache (${ageMinutes} min)`);
        return res.json({
          success: true,
          data: {
            tips: [latestTipData.tip],
            children: children.map(child => ({
              id: child.id,
              name: child.name,
              currentAge: child.isUnborn ? `${child.currentGestationWeeks} semanas` : `${child.currentAgeInMonths} meses`,
              isUnborn: child.isUnborn
            })),
            tipType: tipType,
            timestamp: createdAt,
            cached: true
          }
        });
      }
    }

    // Crear contexto para OpenAI
    const childrenContext = children.map(child => {
      if (child.isUnborn) {
        return `${child.name}: Por nacer, ${child.currentGestationWeeks} semanas de gestaci√≥n`;
      } else {
        const years = Math.floor(child.currentAgeInMonths / 12);
        const months = child.currentAgeInMonths % 12;
        const ageText = years > 0 
          ? `${years} a√±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
          : `${months} mes${months > 1 ? 'es' : ''}`;
        return `${child.name}: ${ageText} de edad`;
      }
    }).join(', ');

    console.log('üë∂ [CHILDREN] Contexto de hijos:', childrenContext);
    console.log('ü§∞ [PREGNANCY] Estado de embarazo:', { isPregnant, currentGestationWeeks });

    // Generar tips usando OpenAI - UN TIP POR CADA HIJO
    let tips = [];
    if (openai) {
      try {
        // Si hay tips espec√≠ficos de hijos, generar uno por cada hijo
        const shouldGeneratePerChild = !['maternidad', 'crianza', 'embarazo'].includes(tipType);
        
        const prompt = shouldGeneratePerChild 
          ? `Eres una doula experta llamada "Douli". Necesito que generes tips personalizados para cada hijo.

INFORMACI√ìN DE LOS HIJOS:
${children.map((child, index) => {
  if (child.isUnborn) {
    return `${index + 1}. ${child.name}: Por nacer, ${child.currentGestationWeeks} semanas de gestaci√≥n`;
  } else {
    const years = Math.floor(child.currentAgeInMonths / 12);
    const months = child.currentAgeInMonths % 12;
    const ageText = years > 0 
      ? `${years} a√±o${years > 1 ? 's' : ''}${months > 0 ? ` y ${months} mes${months > 1 ? 'es' : ''}` : ''}`
      : `${months} mes${months > 1 ? 'es' : ''}`;
    return `${index + 1}. ${child.name}: ${ageText} de edad`;
  }
}).join('\n')}

TIPO DE TIP SOLICITADO: ${tipType}

TIPS RECIENTES (NO REPITAS ESTOS):
${recentTips.length > 0 ? recentTips.map(tip => `- ${tip}`).join('\n') : 'Ninguno'}

INSTRUCCIONES ESTRICTAS:
- Genera EXACTAMENTE ${children.length} tip${children.length > 1 ? 's' : ''} (uno para cada hijo listado arriba)
- USA EXACTAMENTE el nombre que aparece arriba (NO inventes nombres)
- DEBES mencionar el nombre EXACTO del hijo en cada tip
- Formato OBLIGATORIO: emoji + NOMBRE EXACTO DEL HIJO + consejo
- En espa√±ol
- Relacionado con el tipo "${tipType}"
- NO REPITAS ning√∫n tip de la lista de "TIPS RECIENTES"
- Cada tip en una l√≠nea separada

‚ö†Ô∏è MUY IMPORTANTE - USAR NOMBRES EXACTOS:
${children.map((child, index) => `- Hijo ${index + 1}: DEBES usar "${child.name}" (NO uses otro nombre)`).join('\n')}

CONTEXTO POR EDAD:
- Si el hijo es beb√© (0-12 meses), enf√≥cate en desarrollo temprano
- Si el hijo es ni√±o peque√±o (1-3 a√±os), enf√≥cate en autonom√≠a y lenguaje  
- Si el hijo es por nacer, enf√≥cate en preparaci√≥n

EJEMPLO CORRECTO de formato:
${children.length > 0 ? `üé® ${children[0].name}: [consejo personalizado para ${children[0].name}]` : ''}

Genera ${children.length} tip${children.length > 1 ? 's' : ''} ahora usando los NOMBRES EXACTOS listados arriba:`
          : `Eres una doula experta llamada "Douli". Necesito que generes SOLO 1 tip general de ${tipType}.

ESTADO DE EMBARAZO:
${isPregnant ? `Actualmente embarazada de ${currentGestationWeeks} semanas` : 'No est√° embarazada actualmente'}

TIPS RECIENTES (NO REPITAS ESTOS):
${recentTips.length > 0 ? recentTips.map(tip => `- ${tip}`).join('\n') : 'Ninguno'}

INSTRUCCIONES:
- Genera SOLO 1 tip general de ${tipType}
- Formato: emoji + texto corto
- En espa√±ol
- NO espec√≠fico de ning√∫n hijo en particular
- NO REPITAS ning√∫n tip de la lista de "TIPS RECIENTES"
${tipType === 'embarazo' && isPregnant ? `\n- Espec√≠fico para ${currentGestationWeeks} semanas de embarazo` : ''}

Genera el tip ahora:`;

        const completion = await openai.chat.completions.create({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: "Eres una doula experta y compasiva que da consejos pr√°cticos y √∫tiles para padres."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: shouldGeneratePerChild ? 150 * children.length : 300, // M√°s tokens si hay m√∫ltiples hijos
          temperature: 0.7
        });

        const response = completion.choices[0].message.content;
        tips = response.split('\n').filter(tip => tip.trim().length > 0);

      } catch (openaiError) {
        console.error('‚ùå Error con OpenAI:', openaiError.message);
        // Fallback con tips predefinidos
        tips = generateFallbackTips(children, tipType);
      }
    } else {
      // Fallback si OpenAI no est√° disponible
      tips = generateFallbackTips(children, tipType);
    }

    // Almacenar el tip generado para evitar repeticiones futuras
    if (tips.length > 0) {
      console.log('üîç [STORAGE] Intentando almacenar tip:', {
        userId: uid,
        tipType: tipType,
        tip: tips[0],
        childrenContext: childrenContext,
        isPregnant: isPregnant,
        currentGestationWeeks: currentGestationWeeks
      });
      
      try {
        const tipData = {
          userId: uid,
          tipType: tipType,
          tip: tips[0],
          childrenContext: childrenContext,
          childIds: children.map(child => child.id),
          isPregnant: isPregnant,
          currentGestationWeeks: currentGestationWeeks,
          createdAt: new Date(),
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // Expira en 30 d√≠as
        };
        
        console.log('üìù [STORAGE] Datos del tip a almacenar:', tipData);
        
        const docRef = await db.collection('userTips').add(tipData);
        console.log('‚úÖ [STORAGE] Tip almacenado exitosamente. Document ID:', docRef.id);
        console.log('‚úÖ [STORAGE] Tip almacenado para usuario:', uid, 'tipo:', tipType);
      } catch (storageError) {
        console.error('‚ùå [STORAGE] Error almacenando tip:', storageError);
        console.error('‚ùå [STORAGE] Error completo:', JSON.stringify(storageError, null, 2));
        // Continuar aunque falle el almacenamiento
      }
    } else {
      console.log('‚ö†Ô∏è [STORAGE] No hay tips para almacenar');
    }

    res.json({
      success: true,
      data: {
        tips: tips.slice(0, 1), // Solo 1 tip
        children: children.map(child => ({
          id: child.id,
          name: child.name,
          currentAge: child.isUnborn ? `${child.currentGestationWeeks} semanas` : `${child.currentAgeInMonths} meses`,
          isUnborn: child.isUnborn
        })),
        tipType: tipType,
        timestamp: new Date()
      }
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo tips:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo tips',
      error: error.message
    });
  }
});

// ===== SISTEMA DE COMUNIDADES =====

// Endpoint para subir foto de comunidad
app.post('/api/communities/upload-photo', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se ha subido ninguna imagen. Aseg√∫rate de usar el campo "image"'
      });
    }

    // Validar tipo de archivo
    const allowedTypes = [
      'image/jpeg',
      'image/jpg',
      'image/png',
      'image/gif',
      'image/webp',
      'image/heic',
      'image/heif'
    ];
    if (!allowedTypes.includes(req.file.mimetype)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de archivo no permitido. Solo se permiten: JPEG, JPG, PNG, GIF, WEBP, HEIC, HEIF'
      });
    }

    // Validar tama√±o (m√°ximo 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB en bytes
    if (req.file.size > maxSize) {
      return res.status(400).json({
        success: false,
        message: 'La imagen es demasiado grande. M√°ximo 5MB permitido'
      });
    }

    let imageUrl = null;
    
    try {
      const bucket = admin.storage().bucket();
      const fileName = `communities/photos/${Date.now()}-${req.file.originalname}`;
      const file = bucket.file(fileName);
      
      console.log('üì§ [UPLOAD] Subiendo imagen:', {
        originalName: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size,
        fileName: fileName
      });

      await file.save(req.file.buffer, {
        metadata: {
          contentType: req.file.mimetype
        }
      });

      // Hacer la imagen p√∫blica
      await file.makePublic();
      imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      
      console.log('‚úÖ [UPLOAD] Imagen subida exitosamente:', imageUrl);

      // Guardar registro de la imagen en Firestore (opcional, para tracking)
      await db.collection('communityPhotos').add({
        userId: uid,
        fileName: fileName,
        originalName: req.file.originalname,
        imageUrl: imageUrl,
        fileSize: req.file.size,
        mimetype: req.file.mimetype,
        uploadedAt: new Date()
      });

      res.json({
        success: true,
        message: 'Imagen subida exitosamente',
        data: {
          photoUrl: imageUrl,
          fileName: fileName,
          originalName: req.file.originalname,
          fileSize: req.file.size,
          mimetype: req.file.mimetype
        }
      });

    } catch (uploadError) {
      console.error('‚ùå [UPLOAD] Error subiendo imagen:', uploadError);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: uploadError.message
      });
    }

  } catch (error) {
    console.error('‚ùå [UPLOAD] Error general:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Endpoint para crear una comunidad
app.post('/api/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { name, keywords, description, imageUrl, isPublic = true } = req.body;

    console.log('üèóÔ∏è [COMMUNITIES] Datos recibidos:', {
      name, keywords, description, imageUrl, isPublic
    });

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar campos obligatorios
    if (!name || !keywords || !description) {
      return res.status(400).json({
        success: false,
        message: 'Nombre, palabras clave y descripci√≥n son obligatorios'
      });
    }

    // Verificar si ya existe una comunidad con ese nombre
    const existingCommunity = await db.collection('communities')
      .where('name', '==', name.trim())
      .get();

    if (!existingCommunity.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una comunidad con ese nombre'
      });
    }

    // Usar la URL de imagen recibida directamente
    console.log('üñºÔ∏è [COMMUNITIES] URL de imagen recibida:', imageUrl);

    // Crear la comunidad
    const communityData = {
      name: name.trim(),
      keywords: keywords.split(',').map(k => k.trim()).filter(k => k),
      description: description.trim(),
      imageUrl: imageUrl || null, // Asegurar que no sea undefined
      isPublic: isPublic === 'true' || isPublic === true,
      creatorId: uid,
      members: [uid], // El creador es el primer miembro
      memberCount: 1,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const communityRef = await db.collection('communities').add(communityData);
    
    console.log('‚úÖ [COMMUNITY] Comunidad creada exitosamente:', communityRef.id);

    res.json({
      success: true,
      message: 'Comunidad creada exitosamente',
      data: {
        id: communityRef.id,
        ...communityData
      }
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error creando comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comunidad',
      error: error.message
    });
  }
});

// Endpoint para buscar en todas las comunidades (p√∫blicas y privadas) incluyendo las del usuario
app.get('/api/communities/search', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { query, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El t√©rmino de b√∫squeda es obligatorio'
      });
    }

    const searchTerm = query.trim().toLowerCase();
    const searchLimit = Math.min(parseInt(limit), 50); // M√°ximo 50 resultados

    // Obtener TODAS las comunidades (incluyendo las del usuario)
    let communitiesSnapshot;
    try {
      // Intentar con ordenamiento - obtener TODAS las comunidades
      communitiesSnapshot = await db.collection('communities')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [COMMUNITIES SEARCH] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      communitiesSnapshot = await db.collection('communities').get();
    }

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Buscar en nombre, palabras clave y descripci√≥n
      const nameMatch = data.name.toLowerCase().includes(searchTerm);
      const keywordsMatch = data.keywords && data.keywords.some(keyword => 
        keyword.toLowerCase().includes(searchTerm)
      );
      const descriptionMatch = data.description.toLowerCase().includes(searchTerm);
      
      if (nameMatch || keywordsMatch || descriptionMatch) {
        const isCreator = data.creatorId === uid;
        const isMember = data.members && data.members.includes(uid);
        const isPublicResolved = data.isPublic !== undefined ? data.isPublic : (data.isPrivate ? false : true);
        const isPrivateResolved = data.isPrivate !== undefined ? data.isPrivate : !isPublicResolved;
        
        communities.push({
          id: doc.id,
          name: data.name,
          keywords: data.keywords,
          description: data.description,
          imageUrl: data.imageUrl,
          isPublic: isPublicResolved,
          isPrivate: isPrivateResolved,
          memberCount: data.memberCount || 0,
          isCreator: isCreator,
          isMember: isMember,
          canJoin: !isMember && isPublicResolved, // Solo si no es miembro y es p√∫blica
          joinType: !isMember ? (isPublicResolved ? 'direct' : 'request') : null, // Tipo de uni√≥n si no es miembro
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          // Campos de relevancia para el ranking
          relevanceScore: calculateRelevanceScore(data, searchTerm)
        });
      }
    });

    // Ordenar por relevancia (exacto > parcial > fecha)
    communities.sort((a, b) => {
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Si tienen la misma relevancia, ordenar por fecha de creaci√≥n
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Limitar resultados
    const limitedResults = communities.slice(0, searchLimit);

    res.json({
      success: true,
      message: 'B√∫squeda completada exitosamente',
      data: {
        results: limitedResults,
        totalFound: communities.length,
        searchTerm: searchTerm,
        limit: searchLimit
      }
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITIES] Error en b√∫squeda:', error);
    res.status(500).json({
      success: false,
      message: 'Error en la b√∫squeda',
      error: error.message
    });
  }
});

// Endpoint para obtener todas las comunidades (p√∫blicas y privadas)
app.get('/api/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let communitiesSnapshot;
    try {
      // Intentar con ordenamiento - obtener TODAS las comunidades excepto las del usuario
      communitiesSnapshot = await db.collection('communities')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [COMMUNITIES] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento y filtrar en memoria
      communitiesSnapshot = await db.collection('communities').get();
    }

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      const isPublicResolved = data.isPublic !== undefined ? data.isPublic : (data.isPrivate ? false : true);
      const isPrivateResolved = data.isPrivate !== undefined ? data.isPrivate : !isPublicResolved;
      
      const creatorId = data.creatorId || data.createdBy || null;
      const isMember = data.members && data.members.includes(uid);
      
      communities.push({
        id: doc.id,
        name: data.name,
        keywords: data.keywords,
        description: data.description,
        imageUrl: data.imageUrl,
        isPublic: isPublicResolved,
        isPrivate: isPrivateResolved,
        memberCount: data.memberCount || 0,
        isMember: isMember,
        isCreator: creatorId === uid,
        canJoin: isPublicResolved && !isMember, // Solo si no es miembro y es p√∫blica
        joinType: isPublicResolved ? 'direct' : 'request', // Tipo de uni√≥n permitida
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      data: communities
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error obteniendo comunidades:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades',
      error: error.message
    });
  }
});

// Endpoint para unirse a una comunidad
app.post('/api/communities/:communityId/join', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();

    // Verificar si ya es miembro
    if (communityData.members && communityData.members.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya eres miembro de esta comunidad'
      });
    }

    // Si es p√∫blica, unirse directamente
    if (communityData.isPublic) {
      await communityRef.update({
        members: admin.firestore.FieldValue.arrayUnion(uid),
        memberCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      console.log('‚úÖ [COMMUNITY] Usuario se uni√≥ directamente a comunidad p√∫blica:', uid, communityId);

      res.json({
        success: true,
        message: 'Te has unido a la comunidad exitosamente'
      });
    } else {
      // Si es privada, crear solicitud de uni√≥n
      // Verificar que no haya una solicitud pendiente
      let existingRequest;
      try {
        // Intentar con ordenamiento - requiere √≠ndice compuesto
        existingRequest = await db.collection('joinRequests')
          .where('communityId', '==', communityId)
          .where('userId', '==', uid)
          .where('status', '==', 'pending')
          .get();
      } catch (indexError) {
        console.log('‚ö†Ô∏è [JOIN CHECK] √çndice no disponible, verificando sin ordenamiento:', indexError.message);
        // Fallback: verificar sin ordenamiento
        existingRequest = await db.collection('joinRequests')
          .where('communityId', '==', communityId)
          .where('userId', '==', uid)
          .where('status', '==', 'pending')
          .get();
      }

      if (!existingRequest.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya tienes una solicitud pendiente para esta comunidad'
        });
      }

      const requestData = {
        userId: uid,
        communityId: communityId,
        userName: req.user.displayName || 'Usuario',
        status: 'pending', // pending, approved, rejected
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const joinRequestRef = await db.collection('joinRequests').add(requestData);
      
      console.log('‚úÖ [COMMUNITY] Solicitud de uni√≥n creada:', uid, communityId);

      res.json({
        success: true,
        message: 'Solicitud de uni√≥n enviada. Espera la aprobaci√≥n del administrador.',
        data: {
          communityId,
          requestId: joinRequestRef.id,
          status: 'pending'
        }
      });
    }

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error uni√©ndose a comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error uni√©ndose a comunidad',
      error: error.message
    });
  }
});

// Endpoint para salir de una comunidad
app.post('/api/communities/:communityId/leave', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    console.log('üö™ [COMMUNITY] Usuario intentando salir de comunidad:', uid, communityId);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();

    // Verificar si el usuario es el creador de la comunidad
    if (communityData.userId === uid) {
      return res.status(400).json({
        success: false,
        message: 'No puedes salir de una comunidad que creaste. Debes eliminarla o transferir la propiedad primero.'
      });
    }

    // Verificar si es miembro
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No eres miembro de esta comunidad'
      });
    }

    // Remover al usuario de la lista de miembros
    await communityRef.update({
      members: admin.firestore.FieldValue.arrayRemove(uid),
      memberCount: admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log('‚úÖ [COMMUNITY] Usuario sali√≥ de la comunidad:', uid, communityId);

    res.json({
      success: true,
      message: 'Has salido de la comunidad exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error saliendo de comunidad:', error);
    res.status(500).json({
      success: false,
      message: 'Error saliendo de comunidad',
      error: error.message
    });
  }
});

// Endpoint para obtener solicitudes pendientes de una comunidad (solo para el owner)
app.get('/api/communities/:communityId/join-requests', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la comunidad existe y el usuario es el owner
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (communityData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador de la comunidad puede ver las solicitudes'
      });
    }

    // Obtener solicitudes pendientes
    let requestsSnapshot;
    try {
      // Intentar con ordenamiento - requiere √≠ndice compuesto
      requestsSnapshot = await db.collection('joinRequests')
        .where('communityId', '==', communityId)
        .where('status', '==', 'pending')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [JOIN REQUESTS] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      requestsSnapshot = await db.collection('joinRequests')
        .where('communityId', '==', communityId)
        .where('status', '==', 'pending')
        .get();
    }

    const requests = [];
    for (const doc of requestsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaci√≥n completa del usuario
      let userProfile = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          userProfile = userDoc.data();
        }
      } catch (userError) {
        console.log('‚ö†Ô∏è [JOIN REQUESTS] Error obteniendo perfil de usuario:', data.userId, userError.message);
      }
      
      requests.push({
        id: doc.id,
        userId: data.userId,
        userName: userProfile?.displayName || data.userName || 'Usuario',
        userPhoto: userProfile?.photoURL || null,
        userEmail: userProfile?.email || null,
        communityId: data.communityId,
        status: data.status,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        requestDate: data.createdAt // Fecha de la solicitud
      });
    }

    res.json({
      success: true,
      message: 'Solicitudes obtenidas exitosamente',
      data: requests
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error obteniendo solicitudes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo solicitudes',
      error: error.message
    });
  }
});

// Endpoint para aprobar/rechazar solicitudes de uni√≥n (solo para el owner)
app.put('/api/communities/:communityId/join-requests/:requestId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId, requestId } = req.params;
    const { action } = req.body; // 'approve' o 'reject'

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!action || !['approve', 'reject'].includes(action)) {
      return res.status(400).json({
        success: false,
        message: 'Acci√≥n debe ser "approve" o "reject"'
      });
    }

    // Verificar que la comunidad existe y el usuario es el owner
    const communityDoc = await db.collection('communities').doc(communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (communityData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador de la comunidad puede aprobar/rechazar solicitudes'
      });
    }

    // Obtener la solicitud
    const requestDoc = await db.collection('joinRequests').doc(requestId).get();
    if (!requestDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Solicitud no encontrada'
      });
    }

    const requestData = requestDoc.data();
    if (requestData.communityId !== communityId) {
      return res.status(400).json({
        success: false,
        message: 'La solicitud no pertenece a esta comunidad'
      });
    }

    if (requestData.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'La solicitud ya no est√° pendiente'
      });
    }

    const batch = db.batch();

    if (action === 'approve') {
      // Aprobar solicitud: agregar usuario a la comunidad
      const communityRef = db.collection('communities').doc(communityId);
      batch.update(communityRef, {
        members: admin.firestore.FieldValue.arrayUnion(requestData.userId),
        memberCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      // Actualizar estado de la solicitud
      const requestRef = db.collection('joinRequests').doc(requestId);
      batch.update(requestRef, {
        status: 'approved',
        updatedAt: new Date()
      });

      await batch.commit();

      console.log('‚úÖ [COMMUNITY] Solicitud aprobada:', requestId, communityId);

      res.json({
        success: true,
        message: 'Solicitud aprobada. El usuario se ha unido a la comunidad.',
        data: {
          requestId,
          status: 'approved',
          userId: requestData.userId
        }
      });
    } else {
      // Rechazar solicitud
      const requestRef = db.collection('joinRequests').doc(requestId);
      batch.update(requestRef, {
        status: 'rejected',
        updatedAt: new Date()
      });

      await batch.commit();

      console.log('‚úÖ [COMMUNITY] Solicitud rechazada:', requestId, communityId);

      res.json({
        success: true,
        message: 'Solicitud rechazada',
        data: {
          requestId,
          status: 'rejected',
          userId: requestData.userId
        }
      });
    }

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error procesando solicitud:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando solicitud',
      error: error.message
    });
  }
});

// Endpoint para obtener solicitudes del usuario
app.get('/api/user/join-requests', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las solicitudes del usuario
    let requestsSnapshot;
    try {
      // Intentar con ordenamiento - requiere √≠ndice compuesto
      requestsSnapshot = await db.collection('joinRequests')
        .where('userId', '==', uid)
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [USER REQUESTS] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      requestsSnapshot = await db.collection('joinRequests')
        .where('userId', '==', uid)
        .get();
    }

    const requests = [];
    for (const doc of requestsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaci√≥n de la comunidad
      const communityDoc = await db.collection('communities').doc(data.communityId).get();
      if (communityDoc.exists) {
        const communityData = communityDoc.data();
        requests.push({
          id: doc.id,
          communityId: data.communityId,
          communityName: communityData.name,
          communityImage: communityData.imageUrl,
          status: data.status,
          createdAt: data.createdAt,
          updatedAt: data.updatedAt
        });
      }
    }

    res.json({
      success: true,
      message: 'Solicitudes obtenidas exitosamente',
      data: requests
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error obteniendo solicitudes del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo solicitudes',
      error: error.message
    });
  }
});

// Endpoint para buscar en las comunidades del usuario
app.get('/api/user/communities/search', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { query, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!query || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El t√©rmino de b√∫squeda es obligatorio'
      });
    }

    const searchTerm = query.trim().toLowerCase();
    const searchLimit = Math.min(parseInt(limit), 50); // M√°ximo 50 resultados

    // Obtener todas las comunidades del usuario
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', uid)
      .get();

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Buscar en nombre, palabras clave y descripci√≥n
      const nameMatch = data.name.toLowerCase().includes(searchTerm);
      const keywordsMatch = data.keywords && data.keywords.some(keyword => 
        keyword.toLowerCase().includes(searchTerm)
      );
      const descriptionMatch = data.description.toLowerCase().includes(searchTerm);
      
      if (nameMatch || keywordsMatch || descriptionMatch) {
        communities.push({
          id: doc.id,
          name: data.name,
          keywords: data.keywords,
          description: data.description,
          imageUrl: data.imageUrl,
          isPublic: data.isPublic,
          memberCount: data.memberCount || 0,
          isCreator: data.creatorId === uid,
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          // Campos de relevancia para el ranking
          relevanceScore: calculateRelevanceScore(data, searchTerm)
        });
      }
    });

    // Ordenar por relevancia (exacto > parcial > fecha)
    communities.sort((a, b) => {
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Si tienen la misma relevancia, ordenar por fecha de creaci√≥n
      return new Date(b.createdAt) - new Date(a.createdAt);
    });

    // Limitar resultados
    const limitedResults = communities.slice(0, searchLimit);

    res.json({
      success: true,
      message: 'B√∫squeda completada exitosamente',
      data: {
        results: limitedResults,
        totalFound: communities.length,
        searchTerm: searchTerm,
        limit: searchLimit
      }
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITIES] Error en b√∫squeda:', error);
    res.status(500).json({
      success: false,
      message: 'Error en la b√∫squeda',
      error: error.message
    });
  }
});

// Funci√≥n para calcular puntuaci√≥n de relevancia
function calculateRelevanceScore(community, searchTerm) {
  let score = 0;
  const term = searchTerm.toLowerCase();
  
  // B√∫squeda exacta en nombre (m√°xima puntuaci√≥n)
  if (community.name.toLowerCase() === term) {
    score += 100;
  }
  // B√∫squeda parcial en nombre
  else if (community.name.toLowerCase().includes(term)) {
    score += 50;
  }
  
  // B√∫squeda en palabras clave
  if (community.keywords) {
    community.keywords.forEach(keyword => {
      if (keyword.toLowerCase() === term) {
        score += 30;
      } else if (keyword.toLowerCase().includes(term)) {
        score += 15;
      }
    });
  }
  
  // B√∫squeda en descripci√≥n
  if (community.description.toLowerCase().includes(term)) {
    score += 10;
  }
  
  return score;
}

// Endpoint para obtener comunidades del usuario
app.get('/api/user/communities', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener comunidades donde el usuario es miembro
    const communitiesSnapshot = await db.collection('communities')
      .where('members', 'array-contains', uid)
      .get();

    const communities = [];
    communitiesSnapshot.forEach(doc => {
      const data = doc.data();
      communities.push({
        id: doc.id,
        name: data.name,
        keywords: data.keywords,
        description: data.description,
        imageUrl: data.imageUrl,
        isPublic: data.isPublic,
        memberCount: data.memberCount || 0,
        isCreator: data.creatorId === uid,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      data: communities
    });

  } catch (error) {
    console.error('‚ùå [COMMUNITY] Error obteniendo comunidades del usuario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comunidades del usuario',
      error: error.message
    });
  }
});

// ===== SISTEMA DE LISTAS =====

// Endpoint para crear una lista
app.post('/api/lists', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { title, description, isPublic = false, items = [] } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar campos obligatorios
    if (!title || title.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El t√≠tulo de la lista es obligatorio'
      });
    }

    // Crear la lista
    const listData = {
      title: title.trim(),
      description: description ? description.trim() : '',
      imageUrl: req.body.imageUrl || null, // URL de imagen de la lista
      isPublic: isPublic === 'true' || isPublic === true,
      creatorId: uid,
      items: items.map((item, index) => ({
        id: `item_${Date.now()}_${index}`,
        text: item.text ? item.text.trim() : '',
        imageUrl: item.imageUrl || null, // URL de imagen del item
        priority: item.priority || 'medium', // low, medium, high
        details: item.details || '', // Detalles adicionales
        brand: item.brand || '', // Marca
        store: item.store || '', // Tienda
        approximatePrice: item.approximatePrice || null, // Precio aproximado
        completed: false,
        createdAt: new Date()
      })),
      completedItems: 0,
      totalItems: items.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const listRef = await db.collection('lists').add(listData);
    
    console.log('‚úÖ [LISTS] Lista creada exitosamente:', listRef.id);

    res.json({
      success: true,
      message: 'Lista creada exitosamente',
      data: {
        id: listRef.id,
        ...listData
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error creando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando lista',
      error: error.message
    });
  }
});

// Endpoint para obtener las listas del usuario
app.get('/api/user/lists', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { type = 'all', includeItems = 'false' } = req.query; // 'all', 'public', 'private'

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('lists').where('creatorId', '==', uid);
    
    // Filtrar por tipo si se especifica
    if (type === 'public') {
      query = query.where('isPublic', '==', true);
    } else if (type === 'private') {
      query = query.where('isPublic', '==', false);
    }

    const listsSnapshot = await query.orderBy('updatedAt', 'desc').get();

    const shouldIncludeItems = includeItems === 'true';
    const lists = [];
    
    listsSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Por defecto, solo devolver primeros 5 items como preview
      let itemsPreview = [];
      if (shouldIncludeItems && data.items && data.items.length > 0) {
        itemsPreview = data.items.slice(0, 5);
      }
      
      lists.push({
        id: doc.id,
        title: data.title,
        description: data.description,
        imageUrl: data.imageUrl || null,
        isPublic: data.isPublic,
        isOwner: data.creatorId === uid,
        items: itemsPreview, // Solo preview de items
        hasMoreItems: data.items && data.items.length > 5,
        completedItems: data.completedItems || 0,
        totalItems: data.totalItems || 0,
        stars: data.stars || 0,
        comments: data.comments || 0,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      message: 'Listas obtenidas exitosamente',
      data: lists
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error obteniendo listas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas',
      error: error.message
    });
  }
});

// Endpoint para obtener listas p√∫blicas
app.get('/api/lists/public', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { limit = 20, offset = 0 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const listsSnapshot = await db.collection('lists')
      .where('isPublic', '==', true)
      .orderBy('stars', 'desc')
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit))
      .offset(parseInt(offset))
      .get();

    const lists = [];
    listsSnapshot.forEach(doc => {
      const data = doc.data();
      
      // Solo incluir preview de primeros 5 items
      const itemsPreview = data.items && data.items.length > 0 ? data.items.slice(0, 5) : [];
      
      lists.push({
        id: doc.id,
        title: data.title,
        description: data.description,
        imageUrl: data.imageUrl || null,
        creatorId: data.creatorId,
        isOwner: data.creatorId === uid,
        items: itemsPreview, // Solo preview
        hasMoreItems: data.items && data.items.length > 5,
        completedItems: data.completedItems || 0,
        totalItems: data.totalItems || 0,
        stars: data.stars || 0,
        comments: data.comments || 0,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      });
    });

    res.json({
      success: true,
      message: 'Listas p√∫blicas obtenidas exitosamente',
      data: lists
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error obteniendo listas p√∫blicas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo listas p√∫blicas',
      error: error.message
    });
  }
});

// Endpoint para actualizar una lista
app.put('/api/lists/:listId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { title, description, isPublic } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede editar la lista'
      });
    }

    // Actualizar la lista
    const updateData = {
      updatedAt: new Date()
    };

    if (title !== undefined) updateData.title = title.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (req.body.imageUrl !== undefined) updateData.imageUrl = req.body.imageUrl || null;
    if (isPublic !== undefined) updateData.isPublic = isPublic === 'true' || isPublic === true;

    await db.collection('lists').doc(listId).update(updateData);

    console.log('‚úÖ [LISTS] Lista actualizada exitosamente:', listId);

    res.json({
      success: true,
      message: 'Lista actualizada exitosamente',
      data: { listId, ...updateData }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error actualizando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando lista',
      error: error.message
    });
  }
});

// Endpoint para agregar un item a una lista
app.post('/api/lists/:listId/items', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { text } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!text || text.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El texto del item es obligatorio'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede agregar items a la lista'
      });
    }

    // Crear el nuevo item
    const newItem = {
      id: `item_${Date.now()}_${Math.random()}`,
      text: text.trim(),
      imageUrl: req.body.imageUrl || null,
      priority: req.body.priority || 'medium',
      details: req.body.details || '',
      brand: req.body.brand || '',
      store: req.body.store || '',
      approximatePrice: req.body.approximatePrice || null,
      completed: false,
      createdAt: new Date()
    };

    // Actualizar la lista
    const updatedItems = [...(listData.items || []), newItem];
    
    await db.collection('lists').doc(listId).update({
      items: updatedItems,
      totalItems: updatedItems.length,
      updatedAt: new Date()
    });

    console.log('‚úÖ [LISTS] Item agregado exitosamente:', newItem.id);

    res.json({
      success: true,
      message: 'Item agregado exitosamente',
      data: newItem
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error agregando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando item',
      error: error.message
    });
  }
});

// Endpoint para marcar/desmarcar un item como completado
app.put('/api/lists/:listId/items/:itemId/toggle', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede modificar items de la lista'
      });
    }

    // Encontrar y actualizar el item
    const items = listData.items || [];
    const itemIndex = items.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Toggle del estado completado
    items[itemIndex].completed = !items[itemIndex].completed;
    
    // Contar items completados
    const completedItems = items.filter(item => item.completed).length;

    // Actualizar la lista
    await db.collection('lists').doc(listId).update({
      items: items,
      completedItems: completedItems,
      updatedAt: new Date()
    });

    console.log('‚úÖ [LISTS] Item actualizado exitosamente:', itemId);

    res.json({
      success: true,
      message: 'Item actualizado exitosamente',
      data: {
        itemId: itemId,
        completed: items[itemIndex].completed,
        completedItems: completedItems
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error actualizando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando item',
      error: error.message
    });
  }
});

// Endpoint para eliminar un item de una lista
app.delete('/api/lists/:listId/items/:itemId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y el usuario es el creador
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el creador puede eliminar items de la lista'
      });
    }

    // Encontrar y eliminar el item
    const items = listData.items || [];
    const filteredItems = items.filter(item => item.id !== itemId);
    
    if (filteredItems.length === items.length) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Contar items completados
    const completedItems = filteredItems.filter(item => item.completed).length;

    // Actualizar la lista
    await db.collection('lists').doc(listId).update({
      items: filteredItems,
      totalItems: filteredItems.length,
      completedItems: completedItems,
      updatedAt: new Date()
    });

    console.log('‚úÖ [LISTS] Item eliminado exitosamente:', itemId);

    res.json({
      success: true,
      message: 'Item eliminado exitosamente',
      data: { itemId }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error eliminando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando item',
      error: error.message
    });
  }
});

// Endpoint para calificar un item de lista p√∫blica
app.post('/api/lists/:listId/items/:itemId/rate', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;
    const { rating } = req.body; // rating del 1 al 5

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar rating
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({
        success: false,
        message: 'El rating debe ser un n√∫mero del 1 al 5'
      });
    }

    // Verificar que la lista existe y es p√∫blica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden calificar items de listas p√∫blicas'
      });
    }

    // Verificar que el item existe
    const item = listData.items.find(item => item.id === itemId);
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Verificar si el usuario ya calific√≥ este item
    const existingRating = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .where('userId', '==', uid)
      .get();

    let ratingData;
    if (existingRating.empty) {
      // Crear nueva calificaci√≥n
      ratingData = {
        listId: listId,
        itemId: itemId,
        userId: uid,
        rating: parseInt(rating),
        createdAt: new Date(),
        updatedAt: new Date()
      };
      await db.collection('itemRatings').add(ratingData);
    } else {
      // Actualizar calificaci√≥n existente
      const ratingDoc = existingRating.docs[0];
      ratingData = {
        ...ratingDoc.data(),
        rating: parseInt(rating),
        updatedAt: new Date()
      };
      await db.collection('itemRatings').doc(ratingDoc.id).update({
        rating: parseInt(rating),
        updatedAt: new Date()
      });
    }

    // Calcular promedio de calificaciones para este item
    const allRatings = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    let totalRating = 0;
    let ratingCount = 0;
    allRatings.forEach(doc => {
      totalRating += doc.data().rating;
      ratingCount++;
    });

    const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

    console.log('‚úÖ [LISTS] Item calificado exitosamente:', itemId, 'Rating:', rating);

    res.json({
      success: true,
      message: 'Item calificado exitosamente',
      data: {
        listId: listId,
        itemId: itemId,
        rating: parseInt(rating),
        averageRating: parseFloat(averageRating),
        totalRatings: ratingCount,
        isNewRating: existingRating.empty
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error calificando item:', error);
    res.status(500).json({
      success: false,
      message: 'Error calificando item',
      error: error.message
    });
  }
});

// Endpoint para obtener calificaciones de un item
app.get('/api/lists/:listId/items/:itemId/ratings', async (req, res) => {
  try {
    const { listId, itemId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es p√∫blica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden ver calificaciones de items de listas p√∫blicas'
      });
    }

    // Obtener todas las calificaciones del item
    const ratingsSnapshot = await db.collection('itemRatings')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .get();

    let totalRating = 0;
    let ratingCount = 0;
    const ratings = [];

    ratingsSnapshot.forEach(doc => {
      const data = doc.data();
      totalRating += data.rating;
      ratingCount++;
      ratings.push({
        id: doc.id,
        userId: data.userId,
        rating: data.rating,
        createdAt: data.createdAt
      });
    });

    const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

    res.json({
      success: true,
      message: 'Calificaciones obtenidas exitosamente',
      data: {
        itemId: itemId,
        averageRating: parseFloat(averageRating),
        totalRatings: ratingCount,
        ratings: ratings
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error obteniendo calificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo calificaciones',
      error: error.message
    });
  }
});

// Endpoint para dar/quitar estrella a una lista p√∫blica
app.post('/api/lists/:listId/star', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es p√∫blica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden calificar listas p√∫blicas'
      });
    }

    // Verificar si el usuario ya dio estrella
    const existingStar = await db.collection('listStars')
      .where('listId', '==', listId)
      .where('userId', '==', uid)
      .get();

    let newStarsCount = listData.stars || 0;

    if (existingStar.empty) {
      // Agregar estrella
      await db.collection('listStars').add({
        listId: listId,
        userId: uid,
        createdAt: new Date()
      });
      newStarsCount += 1;
    } else {
      // Quitar estrella
      await db.collection('listStars').doc(existingStar.docs[0].id).delete();
      newStarsCount = Math.max(0, newStarsCount - 1);
    }

    // Actualizar contador de estrellas en la lista
    await db.collection('lists').doc(listId).update({
      stars: newStarsCount,
      updatedAt: new Date()
    });

    console.log('‚úÖ [LISTS] Estrella actualizada:', listId, newStarsCount);

    res.json({
      success: true,
      message: 'Estrella actualizada exitosamente',
      data: {
        listId: listId,
        stars: newStarsCount,
        hasStarred: existingStar.empty
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error actualizando estrella:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estrella',
      error: error.message
    });
  }
});

// Endpoint para comentar en un item de lista p√∫blica
app.post('/api/lists/:listId/items/:itemId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId, itemId } = req.params;
    const { content } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del comentario es obligatorio'
      });
    }

    // Verificar que la lista existe y es p√∫blica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden comentar listas p√∫blicas'
      });
    }

    // Verificar que el item existe
    const item = listData.items.find(item => item.id === itemId);
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item no encontrado'
      });
    }

    // Crear el comentario
    const commentData = {
      listId: listId,
      itemId: itemId,
      userId: uid,
      userName: req.user.displayName || 'Usuario',
      content: content.trim(),
      createdAt: new Date()
    };

    const commentRef = await db.collection('listComments').add(commentData);

    // Actualizar contador de comentarios en la lista
    const newCommentsCount = (listData.comments || 0) + 1;
    await db.collection('lists').doc(listId).update({
      comments: newCommentsCount,
      updatedAt: new Date()
    });

    console.log('‚úÖ [LISTS] Comentario agregado exitosamente:', commentRef.id);

    res.json({
      success: true,
      message: 'Comentario agregado exitosamente',
      data: {
        id: commentRef.id,
        ...commentData,
        commentsCount: newCommentsCount
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error agregando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando comentario',
      error: error.message
    });
  }
});

// Endpoint para obtener comentarios de un item de lista p√∫blica
app.get('/api/lists/:listId/items/:itemId/comments', async (req, res) => {
  try {
    const { listId, itemId } = req.params;
    const { limit = 20, offset = 0 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la lista existe y es p√∫blica
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();
    if (!listData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden ver comentarios de listas p√∫blicas'
      });
    }

    // Obtener comentarios del item
    const commentsSnapshot = await db.collection('listComments')
      .where('listId', '==', listId)
      .where('itemId', '==', itemId)
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit))
      .offset(parseInt(offset))
      .get();

    const comments = [];
    
    // Obtener informaci√≥n de perfil para cada comentario
    for (const doc of commentsSnapshot.docs) {
      const data = doc.data();
      
      // Obtener informaci√≥n del perfil del usuario
      let userProfile = null;
      try {
        const userDoc = await db.collection('users').doc(data.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userProfile = {
            displayName: userData.displayName || data.userName || 'Usuario',
            photoURL: userData.photoURL || null
          };
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [LISTS] Error obteniendo perfil del usuario:', data.userId, error.message);
        // Usar datos del comentario como fallback
        userProfile = {
          displayName: data.userName || 'Usuario',
          photoURL: null
        };
      }

      comments.push({
        id: doc.id,
        listId: data.listId,
        itemId: data.itemId,
        userId: data.userId,
        userName: userProfile.displayName,
        userPhoto: userProfile.photoURL,
        content: data.content,
        createdAt: data.createdAt
      });
    }

    res.json({
      success: true,
      message: 'Comentarios obtenidos exitosamente',
      data: comments
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Endpoint para obtener detalles de una lista p√∫blica con informaci√≥n de interacci√≥n del usuario
app.get('/api/lists/:listId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;
    const { page = 1, limit = 20, includeStats = 'true' } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la lista
    const listDoc = await db.collection('lists').doc(listId).get();
    if (!listDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const listData = listDoc.data();

    // Verificar si el usuario puede ver la lista
    if (!listData.isPublic && listData.creatorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver esta lista'
      });
    }

    // Obtener informaci√≥n de interacci√≥n del usuario (solo para listas p√∫blicas)
    let hasStarred = false;
    if (listData.isPublic) {
      const userStar = await db.collection('listStars')
        .where('listId', '==', listId)
        .where('userId', '==', uid)
        .get();
      hasStarred = !userStar.empty;
    }

    // Paginar items
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;

    const allItems = listData.items || [];
    const paginatedItems = allItems.slice(startIndex, endIndex);
    const shouldIncludeStats = includeStats === 'true';

    // Obtener calificaciones y comentarios para cada item (solo los paginados)
    let itemsWithStats = [];
    if (paginatedItems.length > 0 && shouldIncludeStats) {
      itemsWithStats = await Promise.all(
        paginatedItems.map(async (item) => {
          // Si el item no tiene ID, retornar sin stats
          if (!item.id) {
            console.warn('‚ö†Ô∏è [LISTS] Item sin ID encontrado:', item);
            return {
              ...item,
              averageRating: 0,
              totalRatings: 0,
              commentCount: 0
            };
          }

          // Obtener calificaciones del item
          const ratingsSnapshot = await db.collection('itemRatings')
            .where('listId', '==', listId)
            .where('itemId', '==', item.id)
            .get();

          let totalRating = 0;
          let ratingCount = 0;
          ratingsSnapshot.forEach(doc => {
            totalRating += doc.data().rating;
            ratingCount++;
          });
          const averageRating = ratingCount > 0 ? (totalRating / ratingCount).toFixed(1) : 0;

          // Obtener comentarios del item
          const commentsSnapshot = await db.collection('listComments')
            .where('listId', '==', listId)
            .where('itemId', '==', item.id)
            .get();

          const commentCount = commentsSnapshot.size;

          return {
            ...item,
            averageRating: parseFloat(averageRating),
            totalRatings: ratingCount,
            commentCount: commentCount
          };
        })
      );
    } else {
      itemsWithStats = paginatedItems;
    }

    const totalPages = Math.ceil(allItems.length / limitNum);
    const hasMore = pageNum < totalPages;

    console.log(`üìã [LISTS] Lista ${listId}: p√°gina ${pageNum} de ${totalPages} (${paginatedItems.length}/${allItems.length} items)`);

    res.json({
      success: true,
      message: 'Lista obtenida exitosamente',
      data: {
        id: listDoc.id,
        title: listData.title,
        description: listData.description,
        imageUrl: listData.imageUrl || null,
        isPublic: listData.isPublic,
        creatorId: listData.creatorId,
        isOwner: listData.creatorId === uid,
        items: itemsWithStats,
        completedItems: listData.completedItems || 0,
        totalItems: listData.totalItems || 0,
        stars: listData.stars || 0,
        comments: listData.comments || 0,
        hasStarred: hasStarred,
        isCreator: listData.creatorId === uid,
        createdAt: listData.createdAt,
        updatedAt: listData.updatedAt
      },
      pagination: {
        currentPage: pageNum,
        totalPages: totalPages,
        itemsPerPage: limitNum,
        totalItems: allItems.length,
        hasMore: hasMore
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error obteniendo lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo lista',
      error: error.message
    });
  }
});

// Endpoint para copiar una lista p√∫blica
app.post('/api/lists/:listId/copy', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { listId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener la lista original
    const originalListDoc = await db.collection('lists').doc(listId).get();
    if (!originalListDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Lista no encontrada'
      });
    }

    const originalData = originalListDoc.data();
    
    // Verificar que la lista sea p√∫blica
    if (!originalData.isPublic) {
      return res.status(403).json({
        success: false,
        message: 'Solo se pueden copiar listas p√∫blicas'
      });
    }

    // Crear la copia
    const copiedListData = {
      title: `${originalData.title} (Copia)`,
      description: originalData.description,
      imageUrl: originalData.imageUrl, // Copiar imagen de la lista original
      isPublic: false, // La copia es privada por defecto
      creatorId: uid,
      originalListId: listId, // Referencia a la lista original
      items: originalData.items.map(item => ({
        ...item,
        id: `item_${Date.now()}_${Math.random()}`,
        completed: false, // Resetear estado de completado
        createdAt: new Date()
      })),
      completedItems: 0,
      totalItems: originalData.items.length,
      stars: 0,
      comments: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const copiedListRef = await db.collection('lists').add(copiedListData);
    
    console.log('‚úÖ [LISTS] Lista copiada exitosamente:', copiedListRef.id);

    res.json({
      success: true,
      message: 'Lista copiada exitosamente',
      data: {
        id: copiedListRef.id,
        ...copiedListData
      }
    });

  } catch (error) {
    console.error('‚ùå [LISTS] Error copiando lista:', error);
    res.status(500).json({
      success: false,
      message: 'Error copiando lista',
      error: error.message
    });
  }
});

// ===== SISTEMA DE PUBLICACIONES EN COMUNIDADES =====

// Endpoint para crear una publicaci√≥n en una comunidad (recibe URL de imagen)
app.post('/api/communities/:communityId/posts', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;
    const { content, imageUrl, attachedLists = [], postType = 'normal', eventData } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para publicar'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido de la publicaci√≥n es obligatorio'
      });
    }

    // Validar que la URL de imagen sea v√°lida si se proporciona
    if (imageUrl && !imageUrl.startsWith('http')) {
      return res.status(400).json({
        success: false,
        message: 'La URL de la imagen debe ser v√°lida'
      });
    }

    // NUEVO: Validar datos de evento si postType es "event"
    let validatedEventData = null;
    if (postType === 'event') {
      if (!eventData) {
        return res.status(400).json({
          success: false,
          message: 'Los datos del evento son requeridos para posts tipo evento'
        });
      }

      // Validar campos requeridos del evento
      if (!eventData.title || eventData.title.trim().length === 0) {
        return res.status(400).json({
          success: false,
          message: 'El t√≠tulo del evento es obligatorio'
        });
      }

      if (!eventData.eventDate) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento es obligatoria'
        });
      }

      // Validar que la fecha del evento sea futura
      const eventDate = new Date(eventData.eventDate);
      if (isNaN(eventDate.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento no es v√°lida'
        });
      }

      if (eventDate < new Date()) {
        return res.status(400).json({
          success: false,
          message: 'La fecha del evento debe ser futura'
        });
      }

      // Validar eventEndDate si existe
      let eventEndDate = null;
      if (eventData.eventEndDate) {
        eventEndDate = new Date(eventData.eventEndDate);
        if (isNaN(eventEndDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de finalizaci√≥n del evento no es v√°lida'
          });
        }
        if (eventEndDate < eventDate) {
          return res.status(400).json({
            success: false,
            message: 'La fecha de finalizaci√≥n debe ser posterior a la fecha de inicio'
          });
        }
      }

      // Validar maxAttendees si existe
      if (eventData.maxAttendees !== undefined && eventData.maxAttendees !== null) {
        const maxAttendees = parseInt(eventData.maxAttendees);
        if (isNaN(maxAttendees) || maxAttendees < 1) {
          return res.status(400).json({
            success: false,
            message: 'El n√∫mero m√°ximo de asistentes debe ser mayor a 0'
          });
        }
      }

      // Construir objeto eventData validado
      validatedEventData = {
        title: eventData.title.trim(),
        description: eventData.description ? eventData.description.trim() : '',
        eventDate: admin.firestore.Timestamp.fromDate(eventDate),
        status: 'upcoming',
        attendees: [],
        attendeeCount: 0,
        waitlist: [],  // NUEVO: Lista de espera
        waitlistCount: 0,  // NUEVO: Contador de lista de espera
        checkedInAttendees: [],  // NUEVO: Asistentes que hicieron check-in
        checkedInCount: 0,  // NUEVO: Contador de check-ins
        requiresConfirmation: eventData.requiresConfirmation === true,
        reminderSent: false,
        reminderSentAt: null
      };

      // Agregar campos opcionales
      if (eventEndDate) {
        validatedEventData.eventEndDate = admin.firestore.Timestamp.fromDate(eventEndDate);
      }

      if (eventData.maxAttendees !== undefined && eventData.maxAttendees !== null) {
        validatedEventData.maxAttendees = parseInt(eventData.maxAttendees);
      }

      if (eventData.location) {
        validatedEventData.location = {
          name: eventData.location.name || '',
          address: eventData.location.address || '',
          latitude: eventData.location.latitude || null,
          longitude: eventData.location.longitude || null
        };
      }

      if (validatedEventData.requiresConfirmation) {
        validatedEventData.pendingAttendees = [];
      }

      console.log('‚úÖ [EVENT] Datos del evento validados:', validatedEventData.title);
    }

    // Validar y verificar que las listas existen y pertenecen al usuario o son p√∫blicas
    const validatedLists = [];
    if (attachedLists && Array.isArray(attachedLists) && attachedLists.length > 0) {
      console.log(`üìã [POST] Validando ${attachedLists.length} listas adjuntas`);
      
      for (const listId of attachedLists) {
        try {
          const listDoc = await db.collection('lists').doc(listId).get();
          
          if (!listDoc.exists) {
            console.warn(`‚ö†Ô∏è [POST] Lista no encontrada: ${listId}`);
            continue;
          }

          const listData = listDoc.data();
          
          // Verificar que la lista sea del usuario o sea p√∫blica
          if (listData.creatorId === uid || listData.isPublic) {
            validatedLists.push({
              id: listId,
              title: listData.title,
              description: listData.description || '',
              imageUrl: listData.imageUrl || null,
              isPublic: listData.isPublic,
              totalItems: listData.totalItems || 0,
              completedItems: listData.completedItems || 0
            });
            console.log(`‚úÖ [POST] Lista validada: ${listData.title}`);
          } else {
            console.warn(`‚ö†Ô∏è [POST] Lista ${listId} no es del usuario ni es p√∫blica`);
          }
        } catch (error) {
          console.error(`‚ùå [POST] Error validando lista ${listId}:`, error.message);
        }
      }
    }

    // Crear la publicaci√≥n
    const postData = {
      communityId: communityId,
      authorId: uid,
      content: content.trim(),
      postType: postType,  // "normal" o "event"
      isPinned: false,
      likes: [],
      likeCount: 0,
      commentCount: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Solo agregar imageUrl si existe y no es undefined
    if (imageUrl) {
      postData.imageUrl = imageUrl;
    }

    // Agregar datos del evento si es tipo "event"
    if (postType === 'event' && validatedEventData) {
      postData.eventData = validatedEventData;
      console.log(`üìÖ [EVENT] Creando evento: ${validatedEventData.title}`);
    }

    // Agregar listas adjuntas si hay
    if (validatedLists.length > 0) {
      postData.attachedLists = validatedLists;
      console.log(`üìã [POST] ${validatedLists.length} listas adjuntadas al post`);
    }

    const postRef = await db.collection('posts').add(postData);
    
    if (postType === 'event') {
      console.log('‚úÖ [EVENT] Evento creado exitosamente:', postRef.id);
    } else {
      console.log('‚úÖ [POST] Publicaci√≥n creada exitosamente:', postRef.id);
    }

    // Enviar notificaciones push a todos los miembros de la comunidad (excepto al autor)
    try {
      const authorDoc = await db.collection('users').doc(uid).get();
      const authorData = authorDoc.exists ? authorDoc.data() : {};
      const authorName = authorData.displayName || authorData.name || 'Un miembro';
      const communityName = communityData.name || 'la comunidad';

      // Obtener tokens de todos los miembros excepto el autor
      const membersToNotify = communityData.members.filter(memberId => memberId !== uid);
      
      if (membersToNotify.length > 0) {
        console.log(`üì§ [COMMUNITY] Enviando notificaci√≥n de nueva publicaci√≥n a ${membersToNotify.length} miembros`);
        
        const tokensPromises = membersToNotify.map(async (memberId) => {
          try {
            const memberDoc = await db.collection('users').doc(memberId).get();
            if (memberDoc.exists) {
              const memberData = memberDoc.data();
              return { userId: memberId, tokens: memberData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è [COMMUNITY] Error obteniendo tokens del miembro ${memberId}:`, error.message);
          }
          return { userId: memberId, tokens: [] };
        });
        
        const usersWithTokens = await Promise.all(tokensPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);
        
        if (allTokens.length > 0) {
          const isEvent = postType === 'event';
          const notification = {
            title: isEvent 
              ? `üìÖ ${authorName} cre√≥ un evento en ${communityName}`
              : `üì¢ ${authorName} public√≥ en ${communityName}`,
            body: isEvent && validatedEventData
              ? validatedEventData.title
              : (content.trim().length > 100 ? content.trim().substring(0, 100) + '...' : content.trim())
          };

          const notificationData = {
            type: isEvent ? 'community_event' : 'community_post',
            postId: postRef.id,
            communityId: communityId,
            communityName: communityName,
            authorId: uid,
            authorName: authorName,
            screen: 'CommunityPostScreen'
          };

          const pushResult = await sendPushNotification(allTokens, notification, notificationData);
          console.log(`‚úÖ [COMMUNITY] Notificaciones enviadas: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

          // Guardar notificaciones en Firestore para cada usuario
          const batch = db.batch();
          usersWithTokens.forEach(userWithTokens => {
            if (userWithTokens.tokens.length > 0) {
              const notifRef = db.collection('notifications').doc();
              batch.set(notifRef, {
                userId: userWithTokens.userId,
                type: isEvent ? 'community_event' : 'community_post',
                title: notification.title,
                body: notification.body,
                data: notificationData,
                read: false,
                createdAt: admin.firestore.Timestamp.fromDate(new Date())
              });
            }
          });
          await batch.commit();
          console.log(`‚úÖ [COMMUNITY] ${membersToNotify.length} notificaciones guardadas en Firestore`);
        } else {
          console.log('‚ö†Ô∏è [COMMUNITY] Ning√∫n miembro tiene tokens FCM registrados');
        }
      }
    } catch (notificationError) {
      console.error('‚ùå [COMMUNITY] Error enviando notificaciones de nueva publicaci√≥n:', notificationError);
      // No fallar la creaci√≥n de la publicaci√≥n si falla la notificaci√≥n
    }

    res.json({
      success: true,
      message: postType === 'event' ? 'Evento creado exitosamente' : 'Publicaci√≥n creada exitosamente',
      data: {
        id: postRef.id,
        ...postData
      }
    });

  } catch (error) {
    console.error('‚ùå [POST] Error creando publicaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando publicaci√≥n',
      error: error.message
    });
  }
});

// ===== ENDPOINTS PARA EVENTOS =====

// Confirmar asistencia a un evento
app.post('/api/posts/:postId/attend', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para asistir al evento'
      });
    }

    const eventData = postData.eventData;

    // Verificar que el evento no est√° cancelado
    if (eventData.status === 'cancelled') {
      return res.status(400).json({
        success: false,
        message: 'Este evento ha sido cancelado'
      });
    }

    // Verificar que el evento no ha pasado
    const eventDate = eventData.eventDate.toDate();
    if (eventDate < new Date()) {
      return res.status(400).json({
        success: false,
        message: 'Este evento ya pas√≥'
      });
    }

    // Verificar que el usuario no est√© ya en la lista
    const attendees = eventData.attendees || [];
    if (attendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya confirmaste tu asistencia a este evento'
      });
    }

    // Verificar si hay cupo disponible
    const isEventFull = eventData.maxAttendees && attendees.length >= eventData.maxAttendees;
    
    if (isEventFull) {
      // Si el evento est√° lleno, agregar a lista de espera
      const waitlist = eventData.waitlist || [];
      
      // Verificar que no est√© ya en la lista de espera
      if (waitlist.includes(uid)) {
        return res.status(400).json({
          success: false,
          message: 'Ya est√°s en la lista de espera para este evento'
        });
      }

      await db.collection('posts').doc(postId).update({
        'eventData.waitlist': admin.firestore.FieldValue.arrayUnion(uid),
        'eventData.waitlistCount': admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });

      console.log(`üìã [EVENT] Usuario ${uid} agregado a lista de espera del evento ${postId}`);

      // Notificar al usuario que fue agregado a lista de espera
      try {
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const userTokens = userData.fcmTokens || [];

          if (userTokens.length > 0) {
            const notification = {
              title: `üìã Agregado a lista de espera`,
              body: `Te agregamos a la lista de espera de "${eventData.title}". Te notificaremos si se libera un cupo.`
            };

            const notificationData = {
              type: 'event_waitlist_added',
              postId: postId,
              screen: 'CommunityPostScreen'
            };

            await sendPushNotification(userTokens, notification, notificationData);
          }
        }
      } catch (notificationError) {
        console.error('‚ùå [EVENT] Error enviando notificaci√≥n de lista de espera:', notificationError);
      }

      return res.json({
        success: true,
        message: 'Agregado a lista de espera. Te notificaremos si se libera un cupo.',
        data: {
          postId: postId,
          attendeeCount: attendees.length,
          waitlistCount: waitlist.length + 1,
          userInWaitlist: true,
          userAttending: false
        }
      });
    }

    // Agregar al usuario a la lista de asistentes
    await db.collection('posts').doc(postId).update({
      'eventData.attendees': admin.firestore.FieldValue.arrayUnion(uid),
      'eventData.attendeeCount': admin.firestore.FieldValue.increment(1),
      updatedAt: new Date()
    });

    console.log(`‚úÖ [EVENT] Usuario ${uid} confirm√≥ asistencia al evento ${postId}`);

    // Enviar notificaci√≥n al organizador
    try {
      const organizerDoc = await db.collection('users').doc(postData.authorId).get();
      if (organizerDoc.exists) {
        const organizerData = organizerDoc.data();
        const organizerTokens = organizerData.fcmTokens || [];

        if (organizerTokens.length > 0) {
          const attendeeDoc = await db.collection('users').doc(uid).get();
          const attendeeData = attendeeDoc.exists ? attendeeDoc.data() : {};
          const attendeeName = attendeeData.displayName || attendeeData.name || 'Un usuario';

          const notification = {
            title: `üìÖ Nueva confirmaci√≥n para tu evento`,
            body: `${attendeeName} confirm√≥ asistencia a "${eventData.title}"`
          };

          const notificationData = {
            type: 'event_attendance_confirmed',
            postId: postId,
            attendeeId: uid,
            screen: 'CommunityPostScreen'
          };

          await sendPushNotification(organizerTokens, notification, notificationData);
          console.log(`‚úÖ [EVENT] Notificaci√≥n enviada al organizador`);
        }
      }
    } catch (notificationError) {
      console.error('‚ùå [EVENT] Error enviando notificaci√≥n al organizador:', notificationError);
    }

    res.json({
      success: true,
      message: 'Asistencia confirmada exitosamente',
      data: {
        postId: postId,
        attendeeCount: attendees.length + 1,
        userAttending: true
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error confirmando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error confirmando asistencia',
      error: error.message
    });
  }
});

// Cancelar asistencia a un evento
app.delete('/api/posts/:postId/attend', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    const eventData = postData.eventData;
    const attendees = eventData.attendees || [];

    // Verificar que el usuario est√° en la lista
    if (!attendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No has confirmado asistencia a este evento'
      });
    }

    // Remover al usuario de la lista de asistentes
    await db.collection('posts').doc(postId).update({
      'eventData.attendees': admin.firestore.FieldValue.arrayRemove(uid),
      'eventData.attendeeCount': admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log(`‚úÖ [EVENT] Usuario ${uid} cancel√≥ asistencia al evento ${postId}`);

    // Promover al primero de la lista de espera si hay cupo y hay gente esperando
    try {
      const waitlist = eventData.waitlist || [];
      if (waitlist.length > 0) {
        const nextUserId = waitlist[0];
        
        // Obtener el documento actualizado
        const updatedPostDoc = await db.collection('posts').doc(postId).get();
        const updatedEventData = updatedPostDoc.data().eventData;
        const currentAttendees = updatedEventData.attendees || [];
        
        // Verificar que hay cupo disponible
        if (!updatedEventData.maxAttendees || currentAttendees.length < updatedEventData.maxAttendees) {
          // Mover de lista de espera a asistentes
          await db.collection('posts').doc(postId).update({
            'eventData.waitlist': admin.firestore.FieldValue.arrayRemove(nextUserId),
            'eventData.waitlistCount': admin.firestore.FieldValue.increment(-1),
            'eventData.attendees': admin.firestore.FieldValue.arrayUnion(nextUserId),
            'eventData.attendeeCount': admin.firestore.FieldValue.increment(1)
          });

          console.log(`‚úÖ [EVENT] Usuario ${nextUserId} promovido de lista de espera a asistente`);

          // Notificar al usuario promovido
          const nextUserDoc = await db.collection('users').doc(nextUserId).get();
          if (nextUserDoc.exists) {
            const nextUserData = nextUserDoc.data();
            const nextUserTokens = nextUserData.fcmTokens || [];

            if (nextUserTokens.length > 0) {
              const notification = {
                title: `üéâ ¬°Tienes un cupo disponible!`,
                body: `Se liber√≥ un cupo para "${eventData.title}". ¬°Ya est√°s confirmado!`
              };

              const notificationData = {
                type: 'event_waitlist_promoted',
                postId: postId,
                screen: 'CommunityPostScreen'
              };

              await sendPushNotification(nextUserTokens, notification, notificationData);
              console.log(`‚úÖ [EVENT] Notificaci√≥n de promoci√≥n enviada a ${nextUserId}`);
            }
          }
        }
      }
    } catch (waitlistError) {
      console.error('‚ùå [EVENT] Error procesando lista de espera:', waitlistError);
      // No fallar la cancelaci√≥n si falla la promoci√≥n de lista de espera
    }

    res.json({
      success: true,
      message: 'Asistencia cancelada exitosamente',
      data: {
        postId: postId,
        attendeeCount: attendees.length - 1,
        userAttending: false
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error cancelando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando asistencia',
      error: error.message
    });
  }
});

// Generar c√≥digo QR para check-in del evento (solo organizador)
app.get('/api/posts/:postId/qr-code', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Verificar que el usuario es el organizador
    if (postData.authorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el organizador puede generar el c√≥digo QR del evento'
      });
    }

    const eventData = postData.eventData;

    // Generar o recuperar el c√≥digo √∫nico del evento
    let checkInCode = eventData.checkInCode;
    if (!checkInCode) {
      // Generar un c√≥digo √∫nico de 8 caracteres
      checkInCode = Math.random().toString(36).substring(2, 10).toUpperCase();
      
      // Guardar el c√≥digo en el evento
      await db.collection('posts').doc(postId).update({
        'eventData.checkInCode': checkInCode,
        updatedAt: new Date()
      });

      console.log(`‚úÖ [EVENT] C√≥digo de check-in generado para evento ${postId}: ${checkInCode}`);
    }

    // Crear la URL de check-in
    const checkInUrl = `https://mumpa.app/event/${postId}/checkin?code=${checkInCode}`;

    res.json({
      success: true,
      data: {
        postId: postId,
        eventTitle: eventData.title,
        checkInCode: checkInCode,
        checkInUrl: checkInUrl,
        // El frontend puede usar esta URL para generar el QR
        qrData: checkInUrl
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error generando c√≥digo QR:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando c√≥digo QR',
      error: error.message
    });
  }
});

// Hacer check-in en el evento (escanear QR o ingresar c√≥digo)
app.post('/api/posts/:postId/checkin', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { code } = req.body;

    if (!code) {
      return res.status(400).json({
        success: false,
        message: 'El c√≥digo de check-in es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    const eventData = postData.eventData;

    // Verificar que el usuario est√° en la lista de asistentes
    const attendees = eventData.attendees || [];
    if (!attendees.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes confirmar tu asistencia antes de hacer check-in'
      });
    }

    // Verificar el c√≥digo
    if (eventData.checkInCode !== code.toUpperCase()) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo de check-in inv√°lido'
      });
    }

    // Verificar si ya hizo check-in
    const checkedInAttendees = eventData.checkedInAttendees || [];
    if (checkedInAttendees.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'Ya hiciste check-in en este evento'
      });
    }

    // Registrar check-in
    await db.collection('posts').doc(postId).update({
      'eventData.checkedInAttendees': admin.firestore.FieldValue.arrayUnion(uid),
      'eventData.checkedInCount': admin.firestore.FieldValue.increment(1),
      [`eventData.checkInTimes.${uid}`]: new Date(),
      updatedAt: new Date()
    });

    console.log(`‚úÖ [EVENT] Usuario ${uid} hizo check-in en evento ${postId}`);

    // Notificar al organizador
    try {
      if (postData.authorId !== uid) {
        const organizerDoc = await db.collection('users').doc(postData.authorId).get();
        if (organizerDoc.exists) {
          const organizerData = organizerDoc.data();
          const organizerTokens = organizerData.fcmTokens || [];

          if (organizerTokens.length > 0) {
            const userDoc = await db.collection('users').doc(uid).get();
            const userData = userDoc.exists ? userDoc.data() : {};
            const userName = userData.displayName || userData.name || 'Un usuario';

            const notification = {
              title: `‚úÖ Check-in registrado`,
              body: `${userName} hizo check-in en "${eventData.title}"`
            };

            const notificationData = {
              type: 'event_checkin',
              postId: postId,
              attendeeId: uid,
              screen: 'CommunityPostScreen'
            };

            await sendPushNotification(organizerTokens, notification, notificationData);
          }
        }
      }
    } catch (notificationError) {
      console.error('‚ùå [EVENT] Error enviando notificaci√≥n de check-in:', notificationError);
    }

    res.json({
      success: true,
      message: 'Check-in realizado exitosamente',
      data: {
        postId: postId,
        checkedInCount: checkedInAttendees.length + 1,
        userCheckedIn: true,
        checkInTime: new Date()
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error haciendo check-in:', error);
    res.status(500).json({
      success: false,
      message: 'Error haciendo check-in',
      error: error.message
    });
  }
});

// Exportar evento a Google Calendar (.ics)
app.get('/api/posts/:postId/calendar', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para exportar el evento'
      });
    }

    const eventData = postData.eventData;

    // Convertir fecha de Firestore a formato de fecha
    const eventDate = eventData.eventDate.toDate();
    const eventEndDate = eventData.eventEndDate 
      ? eventData.eventEndDate.toDate() 
      : new Date(eventDate.getTime() + 2 * 60 * 60 * 1000); // +2 horas por defecto

    // Funci√≥n auxiliar para formatear fecha en formato iCalendar
    const formatICalDate = (date) => {
      return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    };

    // Construir ubicaci√≥n
    let locationText = '';
    if (eventData.location) {
      const parts = [];
      if (eventData.location.name) parts.push(eventData.location.name);
      if (eventData.location.address) parts.push(eventData.location.address);
      locationText = parts.join(', ');
    }

    // Construir descripci√≥n
    let description = postData.content || '';
    if (eventData.description) {
      description += '\\n\\n' + eventData.description;
    }
    if (eventData.maxAttendees) {
      description += `\\n\\nCupo limitado: ${eventData.maxAttendees} personas`;
    }

    // Generar archivo .ics
    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Munpa//Event Calendar//ES
CALSCALE:GREGORIAN
METHOD:PUBLISH
BEGIN:VEVENT
UID:munpa-event-${postId}@munpa.app
DTSTAMP:${formatICalDate(new Date())}
DTSTART:${formatICalDate(eventDate)}
DTEND:${formatICalDate(eventEndDate)}
SUMMARY:${eventData.title}
DESCRIPTION:${description.replace(/\n/g, '\\n')}
LOCATION:${locationText}
STATUS:CONFIRMED
SEQUENCE:0
BEGIN:VALARM
TRIGGER:-PT24H
ACTION:DISPLAY
DESCRIPTION:Recordatorio: ${eventData.title} ma√±ana
END:VALARM
END:VEVENT
END:VCALENDAR`;

    // Enviar como archivo descargable
    res.setHeader('Content-Type', 'text/calendar; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="evento-${postId}.ics"`);
    res.send(icsContent);

    console.log(`‚úÖ [EVENT] Archivo .ics generado para evento ${postId}`);

  } catch (error) {
    console.error('‚ùå [EVENT] Error generando archivo de calendario:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando archivo de calendario',
      error: error.message
    });
  }
});

// Obtener enlace para agregar a Google Calendar
app.get('/api/posts/:postId/calendar/google', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    const eventData = postData.eventData;

    // Convertir fecha de Firestore a formato de fecha
    const eventDate = eventData.eventDate.toDate();
    const eventEndDate = eventData.eventEndDate 
      ? eventData.eventEndDate.toDate() 
      : new Date(eventDate.getTime() + 2 * 60 * 60 * 1000);

    // Formatear fechas para Google Calendar (YYYYMMDDTHHmmssZ)
    const formatGoogleDate = (date) => {
      return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    };

    // Construir ubicaci√≥n
    let location = '';
    if (eventData.location) {
      const parts = [];
      if (eventData.location.name) parts.push(eventData.location.name);
      if (eventData.location.address) parts.push(eventData.location.address);
      location = parts.join(', ');
    }

    // Construir descripci√≥n
    let details = postData.content || '';
    if (eventData.description) {
      details += '\n\n' + eventData.description;
    }

    // Crear URL de Google Calendar
    const googleCalendarUrl = new URL('https://calendar.google.com/calendar/render');
    googleCalendarUrl.searchParams.append('action', 'TEMPLATE');
    googleCalendarUrl.searchParams.append('text', eventData.title);
    googleCalendarUrl.searchParams.append('dates', `${formatGoogleDate(eventDate)}/${formatGoogleDate(eventEndDate)}`);
    googleCalendarUrl.searchParams.append('details', details);
    googleCalendarUrl.searchParams.append('location', location);
    googleCalendarUrl.searchParams.append('sf', 'true');
    googleCalendarUrl.searchParams.append('output', 'xml');

    res.json({
      success: true,
      data: {
        googleCalendarUrl: googleCalendarUrl.toString(),
        eventTitle: eventData.title,
        eventDate: eventDate,
        eventEndDate: eventEndDate
      }
    });

    console.log(`‚úÖ [EVENT] URL de Google Calendar generada para evento ${postId}`);

  } catch (error) {
    console.error('‚ùå [EVENT] Error generando URL de Google Calendar:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando URL de Google Calendar',
      error: error.message
    });
  }
});

// Obtener banners activos (banners normales + eventos marcados como banner)
app.get('/api/banners', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { section } = req.query; // 'home', 'communities', 'marketplace', etc.

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    let allBanners = [];

    // 1. OBTENER BANNERS NORMALES (de la colecci√≥n banners)
    try {
      let bannersQuery = db.collection('banners')
        .where('isActive', '==', true);
      
      // Filtrar por secci√≥n si se especifica
      if (section) {
        bannersQuery = bannersQuery.where('section', '==', section);
      }

      const bannersSnapshot = await bannersQuery.get();

      for (const doc of bannersSnapshot.docs) {
        const banner = doc.data();
        
        // Verificar fechas de programaci√≥n
        const startDate = banner.startDate ? banner.startDate.toDate() : null;
        const endDate = banner.endDate ? banner.endDate.toDate() : null;
        
        // Solo mostrar si est√° dentro del rango de fechas
        const isInDateRange = (!startDate || startDate <= now) && (!endDate || endDate >= now);
        
        if (isInDateRange) {
          allBanners.push({
            id: doc.id,
            type: 'banner', // ‚¨ÖÔ∏è NUEVO: tipo de banner
            isEvent: false, // ‚¨ÖÔ∏è NUEVO: indica que NO es un evento
            
            title: banner.title,
            description: banner.description || '',
            imageUrl: banner.imageUrl,
            link: banner.link || null,
            
            order: banner.order || 999,
            duration: banner.duration || 5,
            section: banner.section || 'home',
            
            startDate: banner.startDate || null,
            endDate: banner.endDate || null,
            
            views: banner.views || 0,
            clicks: banner.clicks || 0,
            
            createdAt: banner.createdAt
          });
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [BANNER] Error obteniendo banners normales:', error.message);
    }

    // 2. OBTENER EVENTOS MARCADOS COMO BANNER
    try {
      // Obtener comunidades del usuario
      const communitiesSnapshot = await db.collection('communities')
        .where('members', 'array-contains', uid)
        .get();

      const userCommunityIds = communitiesSnapshot.docs.map(doc => doc.id);

      if (userCommunityIds.length > 0) {
        // Firestore no permite "in" con m√°s de 10 elementos
        const chunkSize = 10;
        for (let i = 0; i < userCommunityIds.length; i += chunkSize) {
          const chunk = userCommunityIds.slice(i, i + chunkSize);
          
          const eventsSnapshot = await db.collection('posts')
            .where('postType', '==', 'event')
            .where('communityId', 'in', chunk)
            .where('eventData.isBanner', '==', true)
            .get();

          for (const doc of eventsSnapshot.docs) {
            const eventPost = doc.data();
            
            if (!eventPost.eventData) continue;
            
            const eventDate = eventPost.eventData.eventDate.toDate();
            const isCancelled = eventPost.eventData.status === 'cancelled';
            
            // Verificar visibilidad del evento
            const eventSection = eventPost.eventData.bannerSection || 'home';
            const publishedAt = eventPost.eventData.bannerPublishedAt 
              ? eventPost.eventData.bannerPublishedAt.toDate() 
              : eventPost.createdAt.toDate();
            
            // Filtrar por secci√≥n si se especifica
            if (section && eventSection !== section) continue;
            
            // Mostrar desde que se publica hasta la hora del evento
            const shouldShow = publishedAt <= now && eventDate >= now && !isCancelled;
            
            if (shouldShow) {
              // Obtener nombre de comunidad
              let communityName = 'Comunidad';
              try {
                const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
                if (communityDoc.exists) {
                  communityName = communityDoc.data().name || 'Comunidad';
                }
              } catch (error) {
                console.warn(`‚ö†Ô∏è [BANNER] Error obteniendo comunidad:`, error.message);
              }

              // Obtener nombre del autor
              let authorName = 'Usuario';
              try {
                const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
                if (authorDoc.exists) {
                  authorName = authorDoc.data().displayName || 'Usuario';
                }
              } catch (error) {
                console.warn(`‚ö†Ô∏è [BANNER] Error obteniendo autor:`, error.message);
              }

              allBanners.push({
                id: doc.id,
                type: 'event', // ‚¨ÖÔ∏è NUEVO: tipo de banner
                isEvent: true,  // ‚¨ÖÔ∏è NUEVO: indica que ES un evento
                
                title: eventPost.eventData.title,
                description: eventPost.eventData.description || '',
                imageUrl: eventPost.imageUrl || null,
                link: `/communities/${eventPost.communityId}/events/${doc.id}`, // Link al evento
                
                // Datos espec√≠ficos del evento
                eventDate: eventPost.eventData.eventDate,
                eventEndDate: eventPost.eventData.eventEndDate || null,
                location: eventPost.eventData.location || null,
                communityId: eventPost.communityId,
                communityName,
                authorId: eventPost.authorId,
                authorName,
                attendeeCount: eventPost.eventData.attendeeCount || 0,
                maxAttendees: eventPost.eventData.maxAttendees || null,
                isUserAttending: (eventPost.eventData.attendees || []).includes(uid),
                
                // Configuraci√≥n del banner
                order: eventPost.eventData.bannerOrder || 1,
                duration: eventPost.eventData.bannerDuration || 5,
                section: eventSection,
                
                startDate: eventPost.eventData.bannerPublishedAt || eventPost.createdAt,
                endDate: eventPost.eventData.eventDate, // El evento es el l√≠mite
                
                likeCount: eventPost.likeCount || 0,
                commentCount: eventPost.commentCount || 0,
                createdAt: eventPost.createdAt,
                bannerUpdatedAt: eventPost.eventData.bannerUpdatedAt || null
              });
            }
          }
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [BANNER] Error obteniendo eventos banner:', error.message);
    }

    // 3. ORDENAR TODOS LOS BANNERS
    allBanners.sort((a, b) => {
      // Primero por orden
      if (a.order !== b.order) {
        return a.order - b.order;
      }
      
      // Si tienen el mismo orden, eventos van antes (por fecha)
      if (a.isEvent && !b.isEvent) {
        return -1;
      }
      if (!a.isEvent && b.isEvent) {
        return 1;
      }
      
      // Si ambos son eventos, ordenar por fecha del evento (m√°s pr√≥ximo primero)
      if (a.isEvent && b.isEvent) {
        const dateA = a.eventDate.toDate();
        const dateB = b.eventDate.toDate();
        return dateA - dateB;
      }
      
      // Si ambos son banners normales, mantener orden actual
      return 0;
    });

    console.log(`‚úÖ [BANNER] ${allBanners.length} banners encontrados para usuario ${uid}${section ? ` (secci√≥n: ${section})` : ''}`);
    console.log(`   - Banners normales: ${allBanners.filter(b => !b.isEvent).length}`);
    console.log(`   - Eventos: ${allBanners.filter(b => b.isEvent).length}`);

    res.json({
      success: true,
      data: allBanners
    });

  } catch (error) {
    console.error('‚ùå [BANNER] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// Salir de la lista de espera
app.delete('/api/posts/:postId/waitlist', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    const eventData = postData.eventData;
    const waitlist = eventData.waitlist || [];

    // Verificar que el usuario est√° en la lista de espera
    if (!waitlist.includes(uid)) {
      return res.status(400).json({
        success: false,
        message: 'No est√°s en la lista de espera de este evento'
      });
    }

    // Remover de lista de espera
    await db.collection('posts').doc(postId).update({
      'eventData.waitlist': admin.firestore.FieldValue.arrayRemove(uid),
      'eventData.waitlistCount': admin.firestore.FieldValue.increment(-1),
      updatedAt: new Date()
    });

    console.log(`‚úÖ [EVENT] Usuario ${uid} sali√≥ de la lista de espera del evento ${postId}`);

    res.json({
      success: true,
      message: 'Saliste de la lista de espera exitosamente',
      data: {
        postId: postId,
        waitlistCount: waitlist.length - 1,
        userInWaitlist: false
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error saliendo de lista de espera:', error);
    res.status(500).json({
      success: false,
      message: 'Error saliendo de lista de espera',
      error: error.message
    });
  }
});

// Obtener lista de asistentes de un evento
app.get('/api/posts/:postId/attendees', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post/evento
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que es un evento
    if (postData.postType !== 'event' || !postData.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver los asistentes'
      });
    }

    const eventData = postData.eventData;
    const attendeeIds = eventData.attendees || [];

    // Obtener informaci√≥n de los asistentes
    const attendees = [];
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const attendeeData = attendeeDoc.data();
          attendees.push({
            userId: attendeeId,
            userName: attendeeData.displayName || attendeeData.name || 'Usuario',
            userPhoto: attendeeData.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [EVENT] Error obteniendo datos del asistente ${attendeeId}:`, error.message);
      }
    }

    // Calcular cupos disponibles
    const maxAttendees = eventData.maxAttendees || null;
    const spotsAvailable = maxAttendees ? Math.max(0, maxAttendees - attendees.length) : null;

    res.json({
      success: true,
      data: {
        attendees,
        attendeeCount: attendees.length,
        maxAttendees,
        spotsAvailable,
        eventTitle: eventData.title,
        eventDate: eventData.eventDate,
        eventStatus: eventData.status
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENT] Error obteniendo asistentes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo asistentes',
      error: error.message
    });
  }
});

// Obtener solo eventos de una comunidad
app.get('/api/communities/:communityId/events', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;
    const { filter = 'upcoming', page = 1, limit = 10 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(communityId).get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver los eventos'
      });
    }

    // Obtener eventos
    let postsSnapshot;
    try {
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .where('postType', '==', 'event')
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [EVENTS] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .where('postType', '==', 'event')
        .get();
    }

    let events = [];
    const now = new Date();

    for (const doc of postsSnapshot.docs) {
      const eventPost = doc.data();
      
      if (!eventPost.eventData) continue;

      const eventDate = eventPost.eventData.eventDate.toDate();
      
      // Filtrar seg√∫n el par√°metro filter
      if (filter === 'upcoming' && eventDate < now) continue;
      if (filter === 'past' && eventDate >= now) continue;
      if (eventPost.eventData.status === 'cancelled' && filter !== 'all') continue;

      // Obtener datos del autor
      let authorData = { displayName: 'Usuario Desconocido', photoUrl: null };
      try {
        const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
        if (authorDoc.exists) {
          const data = authorDoc.data();
          authorData = {
            displayName: data.displayName || data.name || 'Usuario',
            photoUrl: data.photoUrl || null
          };
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [EVENTS] Error obteniendo autor ${eventPost.authorId}:`, error.message);
      }

      // Verificar si el usuario est√° asistiendo
      const attendees = eventPost.eventData.attendees || [];
      const userAttending = attendees.includes(uid);

      events.push({
        id: doc.id,
        postType: eventPost.postType,
        content: eventPost.content,
        imageUrl: eventPost.imageUrl || null,
        eventData: {
          title: eventPost.eventData.title,
          description: eventPost.eventData.description || '',
          eventDate: eventPost.eventData.eventDate,
          eventEndDate: eventPost.eventData.eventEndDate || null,
          location: eventPost.eventData.location || null,
          attendeeCount: eventPost.eventData.attendeeCount || 0,
          maxAttendees: eventPost.eventData.maxAttendees || null,
          status: eventPost.eventData.status
        },
        author: {
          id: eventPost.authorId,
          name: authorData.displayName,
          photo: authorData.photoUrl
        },
        userAttending,
        likes: eventPost.likes || [],
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0,
        createdAt: eventPost.createdAt
      });
    }

    // Ordenar eventos por fecha del evento
    events.sort((a, b) => {
      const dateA = a.eventData.eventDate.toDate();
      const dateB = b.eventData.eventDate.toDate();
      return filter === 'past' ? dateB - dateA : dateA - dateB;
    });

    // Paginaci√≥n
    const total = events.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedEvents = events.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedEvents,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [EVENTS] Error obteniendo eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo eventos',
      error: error.message
    });
  }
});

// Editar post o evento (solo el autor)
app.put('/api/posts/:postId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { content, imageUrl, eventData } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que el usuario es el autor
    if (postData.authorId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'Solo el autor puede editar esta publicaci√≥n'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    // Actualizar contenido si se proporciona
    if (content !== undefined) {
      if (!content || content.trim().length === 0) {
        return res.status(400).json({
          success: false,
          message: 'El contenido no puede estar vac√≠o'
        });
      }
      updateData.content = content.trim();
    }

    // Actualizar imagen si se proporciona
    if (imageUrl !== undefined) {
      if (imageUrl && !imageUrl.startsWith('http')) {
        return res.status(400).json({
          success: false,
          message: 'La URL de la imagen debe ser v√°lida'
        });
      }
      updateData.imageUrl = imageUrl || null;
    }

    // Si es un evento, actualizar datos del evento
    if (postData.postType === 'event' && eventData) {
      const currentEventData = postData.eventData || {};

      // Actualizar t√≠tulo del evento
      if (eventData.title !== undefined) {
        if (!eventData.title || eventData.title.trim().length === 0) {
          return res.status(400).json({
            success: false,
            message: 'El t√≠tulo del evento es obligatorio'
          });
        }
        updateData['eventData.title'] = eventData.title.trim();
      }

      // Actualizar descripci√≥n
      if (eventData.description !== undefined) {
        updateData['eventData.description'] = eventData.description.trim();
      }

      // Actualizar fecha del evento
      if (eventData.eventDate !== undefined) {
        const newEventDate = new Date(eventData.eventDate);
        if (isNaN(newEventDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'La fecha del evento no es v√°lida'
          });
        }
        if (newEventDate < new Date()) {
          return res.status(400).json({
            success: false,
            message: 'La fecha del evento debe ser futura'
          });
        }
        updateData['eventData.eventDate'] = admin.firestore.Timestamp.fromDate(newEventDate);
        
        // Si se cambi√≥ la fecha, notificar a los asistentes
        const oldEventDate = currentEventData.eventDate?.toDate();
        if (oldEventDate && oldEventDate.getTime() !== newEventDate.getTime()) {
          updateData['eventData.dateChanged'] = true;
        }
      }

      // Actualizar fecha de finalizaci√≥n
      if (eventData.eventEndDate !== undefined) {
        if (eventData.eventEndDate) {
          const newEventEndDate = new Date(eventData.eventEndDate);
          if (isNaN(newEventEndDate.getTime())) {
            return res.status(400).json({
              success: false,
              message: 'La fecha de finalizaci√≥n no es v√°lida'
            });
          }
          updateData['eventData.eventEndDate'] = admin.firestore.Timestamp.fromDate(newEventEndDate);
        } else {
          updateData['eventData.eventEndDate'] = null;
        }
      }

      // Actualizar ubicaci√≥n
      if (eventData.location !== undefined) {
        updateData['eventData.location'] = {
          name: eventData.location.name || '',
          address: eventData.location.address || '',
          latitude: eventData.location.latitude || null,
          longitude: eventData.location.longitude || null
        };
      }

      // Actualizar m√°ximo de asistentes
      if (eventData.maxAttendees !== undefined) {
        const maxAttendees = eventData.maxAttendees ? parseInt(eventData.maxAttendees) : null;
        if (maxAttendees !== null && (isNaN(maxAttendees) || maxAttendees < 1)) {
          return res.status(400).json({
            success: false,
            message: 'El n√∫mero m√°ximo de asistentes debe ser mayor a 0'
          });
        }
        updateData['eventData.maxAttendees'] = maxAttendees;
      }

      // Actualizar estado del evento
      if (eventData.status !== undefined) {
        const validStatuses = ['upcoming', 'ongoing', 'completed', 'cancelled'];
        if (!validStatuses.includes(eventData.status)) {
          return res.status(400).json({
            success: false,
            message: 'Estado del evento inv√°lido'
          });
        }
        updateData['eventData.status'] = eventData.status;

        // Si se cancela, notificar a los asistentes
        if (eventData.status === 'cancelled' && currentEventData.status !== 'cancelled') {
          updateData['eventData.cancelledAt'] = new Date();
          
          // Notificar a los asistentes sobre la cancelaci√≥n
          try {
            const attendees = currentEventData.attendees || [];
            if (attendees.length > 0) {
              const attendeePromises = attendees.map(async (attendeeId) => {
                try {
                  const attendeeDoc = await db.collection('users').doc(attendeeId).get();
                  if (attendeeDoc.exists) {
                    const attendeeData = attendeeDoc.data();
                    return { userId: attendeeId, tokens: attendeeData.fcmTokens || [] };
                  }
                } catch (error) {
                  console.warn(`‚ö†Ô∏è [EVENT] Error obteniendo tokens del asistente ${attendeeId}:`, error.message);
                }
                return { userId: attendeeId, tokens: [] };
              });

              const usersWithTokens = await Promise.all(attendeePromises);
              const allTokens = usersWithTokens.flatMap(u => u.tokens);

              if (allTokens.length > 0) {
                const notification = {
                  title: '‚ùå Evento cancelado',
                  body: `El evento "${currentEventData.title}" ha sido cancelado`
                };

                const notificationData = {
                  type: 'event_cancelled',
                  postId: postId,
                  screen: 'CommunityPostScreen'
                };

                await sendPushNotification(allTokens, notification, notificationData);
                console.log(`‚úÖ [EVENT] Notificaciones de cancelaci√≥n enviadas a ${attendees.length} asistentes`);
              }
            }
          } catch (notificationError) {
            console.error('‚ùå [EVENT] Error enviando notificaciones de cancelaci√≥n:', notificationError);
          }
        }
      }

      console.log('‚úÖ [EVENT] Actualizando evento:', postId);
    }

    // Aplicar actualizaciones
    await db.collection('posts').doc(postId).update(updateData);

    console.log(`‚úÖ [POST] Post ${postId} actualizado exitosamente`);

    res.json({
      success: true,
      message: postData.postType === 'event' ? 'Evento actualizado exitosamente' : 'Publicaci√≥n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå [POST] Error actualizando publicaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando publicaci√≥n',
      error: error.message
    });
  }
});

// Endpoint para obtener publicaciones de una comunidad
app.get('/api/communities/:communityId/posts', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { communityId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el usuario es miembro de la comunidad
    const communityRef = db.collection('communities').doc(communityId);
    const communityDoc = await communityRef.get();

    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver las publicaciones'
      });
    }

    // Obtener publicaciones ordenadas por fecha
    let postsSnapshot;
    try {
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .orderBy('createdAt', 'desc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [POSTS] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      postsSnapshot = await db.collection('posts')
        .where('communityId', '==', communityId)
        .get();
    }

    const posts = [];
    for (const doc of postsSnapshot.docs) {
      const postData = doc.data();
      
      // Obtener informaci√≥n del autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(postData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [POST] Error obteniendo nombre del autor:', error.message);
      }

      posts.push({
        id: doc.id,
        content: postData.content,
        imageUrl: postData.imageUrl,
        authorId: postData.authorId,
        authorName: authorName,
        postType: postData.postType || 'normal',  // NUEVO: tipo de post
        eventData: postData.eventData || null,     // NUEVO: datos del evento si existe
        attachedLists: postData.attachedLists || [], // Listas adjuntas
        isPinned: postData.isPinned || false, // Post fijado
        likes: postData.likes || [],
        likeCount: postData.likeCount || 0,
        commentCount: postData.commentCount || 0,
        isLiked: postData.likes && postData.likes.includes(uid),
        createdAt: postData.createdAt,
        updatedAt: postData.updatedAt
      });
    }

    // Ordenar: posts fijados primero, luego por fecha
    posts.sort((a, b) => {
      // Si uno est√° pinneado y el otro no, el pinneado va primero
      if (a.isPinned && !b.isPinned) return -1;
      if (!a.isPinned && b.isPinned) return 1;
      
      // Si ambos tienen el mismo estado de pin, ordenar por fecha
      const dateA = a.createdAt?.toDate?.() || a.createdAt;
      const dateB = b.createdAt?.toDate?.() || b.createdAt;
      return dateB - dateA;
    });

    console.log(`üìå [POSTS] ${posts.filter(p => p.isPinned).length} posts fijados de ${posts.length} totales`);

    res.json({
      success: true,
      data: posts
    });

  } catch (error) {
    console.error('‚ùå [POST] Error obteniendo publicaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo publicaciones',
      error: error.message
    });
  }
});

// Obtener top 3 posts con m√°s likes (APP)
app.get('/api/communities/posts/top', authenticateToken, async (req, res) => {
  try {
    const cacheKey = buildCacheKey(req);
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const { limit = 3 } = req.query;
    const limitNumber = Math.min(parseInt(limit), 10);

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener posts recientes (para evitar escanear todo)
    const snapshot = await db.collection('posts')
      .orderBy('createdAt', 'desc')
      .limit(200)
      .get();

    const communityIds = new Set();
    const posts = [];
    for (const doc of snapshot.docs) {
      const postData = doc.data();
      if (postData.communityId) {
        communityIds.add(postData.communityId);
      }

      // Obtener nombre de autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(postData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (_) {}

      posts.push({
        id: doc.id,
        content: postData.content,
        imageUrl: postData.imageUrl,
        authorId: postData.authorId,
        authorName: authorName,
        communityId: postData.communityId,
        postType: postData.postType || 'normal',  // NUEVO: tipo de post
        eventData: postData.eventData || null,     // NUEVO: datos del evento si existe
        likeCount: postData.likeCount || 0,
        commentCount: postData.commentCount || 0,
        createdAt: postData.createdAt
      });
    }

    const communityMap = new Map();
    if (communityIds.size > 0) {
      const communitySnapshot = await db.collection('communities')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(communityIds).slice(0, 10))
        .get();
      communitySnapshot.forEach(doc => {
        const data = doc.data();
        communityMap.set(doc.id, {
          id: doc.id,
          name: data.name || null
        });
      });
    }

    const topPosts = posts
      .sort((a, b) => {
        if (b.likeCount !== a.likeCount) return b.likeCount - a.likeCount;
        const dateA = a.createdAt?.toDate?.() || a.createdAt;
        const dateB = b.createdAt?.toDate?.() || b.createdAt;
        return dateB - dateA;
      })
      .slice(0, limitNumber)
      .map(post => ({
        ...post,
        communityName: post.communityId ? communityMap.get(post.communityId)?.name || null : null
      }));

    const responsePayload = {
      success: true,
      data: topPosts
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå [POSTS] Error obteniendo top posts:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo top posts',
      error: error.message
    });
  }
});

// Obtener un post/evento espec√≠fico por ID
app.get('/api/posts/:postId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el post
    const postDoc = await db.collection('posts').doc(postId).get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();

    // Verificar que el usuario es miembro de la comunidad
    const communityDoc = await db.collection('communities').doc(postData.communityId).get();
    
    if (!communityDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comunidad no encontrada'
      });
    }

    const communityData = communityDoc.data();
    if (!communityData.members || !communityData.members.includes(uid)) {
      return res.status(403).json({
        success: false,
        message: 'Debes ser miembro de la comunidad para ver esta publicaci√≥n'
      });
    }

    // Obtener informaci√≥n del autor
    let authorName = 'Usuario';
    let authorPhotoUrl = null;
    try {
      const authorDoc = await db.collection('users').doc(postData.authorId).get();
      if (authorDoc.exists) {
        const authorData = authorDoc.data();
        authorName = authorData.displayName || authorData.name || 'Usuario';
        authorPhotoUrl = authorData.photoUrl || null;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [POST] Error obteniendo autor:', error.message);
    }

    // Construir respuesta base
    const response = {
      id: postId,
      content: postData.content,
      imageUrl: postData.imageUrl || null,
      authorId: postData.authorId,
      authorName: authorName,
      authorPhotoUrl: authorPhotoUrl,
      communityId: postData.communityId,
      communityName: communityData.name,
      postType: postData.postType || 'normal',
      attachedLists: postData.attachedLists || [],
      isPinned: postData.isPinned || false,
      likes: postData.likes || [],
      likeCount: postData.likeCount || 0,
      commentCount: postData.commentCount || 0,
      isLiked: postData.likes && postData.likes.includes(uid),
      createdAt: postData.createdAt,
      updatedAt: postData.updatedAt
    };

    // Si es un evento, agregar datos del evento
    if (postData.postType === 'event' && postData.eventData) {
      response.eventData = {
        title: postData.eventData.title,
        description: postData.eventData.description || '',
        eventDate: postData.eventData.eventDate,
        eventEndDate: postData.eventData.eventEndDate || null,
        location: postData.eventData.location || null,
        status: postData.eventData.status,
        maxAttendees: postData.eventData.maxAttendees || null,
        requiresConfirmation: postData.eventData.requiresConfirmation || false,
        
        // Informaci√≥n de asistencia
        attendees: postData.eventData.attendees || [],
        attendeeCount: postData.eventData.attendeeCount || 0,
        waitlist: postData.eventData.waitlist || [],
        waitlistCount: postData.eventData.waitlistCount || 0,
        
        // Check-in
        checkInCode: postData.eventData.checkInCode || null,
        checkedInAttendees: postData.eventData.checkedInAttendees || [],
        checkedInCount: postData.eventData.checkedInCount || 0,
        
        // Estado del usuario
        isUserAttending: (postData.eventData.attendees || []).includes(uid),
        isUserInWaitlist: (postData.eventData.waitlist || []).includes(uid),
        isUserCheckedIn: (postData.eventData.checkedInAttendees || []).includes(uid),
        isUserOrganizer: postData.authorId === uid,
        
        // Banner
        isBanner: postData.eventData.isBanner || false
      };
    }

    console.log(`‚úÖ [POST] Post ${postId} obtenido por usuario ${uid}`);

    res.json({
      success: true,
      data: response
    });

  } catch (error) {
    console.error('‚ùå [POST] Error obteniendo post:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo publicaci√≥n',
      error: error.message
    });
  }
});

// Endpoint para dar like a una publicaci√≥n
app.post('/api/posts/:postId/like', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    const postData = postDoc.data();
    const isLiked = postData.likes && postData.likes.includes(uid);

    if (isLiked) {
      // Quitar like
      await postRef.update({
        likes: admin.firestore.FieldValue.arrayRemove(uid),
        likeCount: admin.firestore.FieldValue.increment(-1),
        updatedAt: new Date()
      });
      
      console.log('‚úÖ [POST] Like removido:', uid, postId);
      
      res.json({
        success: true,
        message: 'Like removido',
        data: { liked: false }
      });
    } else {
      // Agregar like
      await postRef.update({
        likes: admin.firestore.FieldValue.arrayUnion(uid),
        likeCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });
      
      console.log('‚úÖ [POST] Like agregado:', uid, postId);
      
      res.json({
        success: true,
        message: 'Like agregado',
        data: { liked: true }
      });
    }

  } catch (error) {
    console.error('‚ùå [POST] Error manejando like:', error);
    res.status(500).json({
      success: false,
      message: 'Error manejando like',
      error: error.message
    });
  }
});

// Endpoint para comentar en una publicaci√≥n
app.post('/api/posts/:postId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;
    const { content } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!content || content.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El contenido del comentario es obligatorio'
      });
    }

    // Verificar que la publicaci√≥n existe
    const postRef = db.collection('posts').doc(postId);
    const postDoc = await postRef.get();

    if (!postDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Publicaci√≥n no encontrada'
      });
    }

    // Crear el comentario
    const commentData = {
      postId: postId,
      authorId: uid,
      content: content.trim(),
      likes: [],
      likeCount: 0,
      createdAt: new Date()
    };

    const commentRef = await db.collection('comments').add(commentData);

    // Incrementar contador de comentarios en la publicaci√≥n
    await postRef.update({
      commentCount: admin.firestore.FieldValue.increment(1),
      updatedAt: new Date()
    });

    console.log('‚úÖ [COMMENT] Comentario creado exitosamente:', commentRef.id);

    // Enviar notificaci√≥n push al autor de la publicaci√≥n (si no es √©l mismo)
    try {
      const postData = postDoc.data();
      const postAuthorId = postData.authorId;

      if (postAuthorId && postAuthorId !== uid) {
        console.log(`üì§ [COMMENT] Enviando notificaci√≥n al autor de la publicaci√≥n: ${postAuthorId}`);

        // Obtener informaci√≥n del comentarista
        const commenterDoc = await db.collection('users').doc(uid).get();
        const commenterData = commenterDoc.exists ? commenterDoc.data() : {};
        const commenterName = commenterData.displayName || commenterData.name || 'Alguien';

        // Obtener tokens del autor de la publicaci√≥n
        const postAuthorDoc = await db.collection('users').doc(postAuthorId).get();
        if (postAuthorDoc.exists) {
          const postAuthorData = postAuthorDoc.data();
          const authorTokens = postAuthorData.fcmTokens || [];

          if (authorTokens.length > 0) {
            const notification = {
              title: `üí¨ ${commenterName} coment√≥ tu publicaci√≥n`,
              body: content.trim().length > 100 ? content.trim().substring(0, 100) + '...' : content.trim()
            };

            const notificationData = {
              type: 'post_comment',
              postId: postId,
              commentId: commentRef.id,
              commenterId: uid,
              commenterName: commenterName,
              screen: 'PostDetailScreen'
            };

            const pushResult = await sendPushNotification(authorTokens, notification, notificationData);
            console.log(`‚úÖ [COMMENT] Notificaci√≥n enviada: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);

            // Guardar notificaci√≥n en Firestore
            await db.collection('notifications').add({
              userId: postAuthorId,
              type: 'post_comment',
              title: notification.title,
              body: notification.body,
              data: notificationData,
              read: false,
              createdAt: admin.firestore.Timestamp.fromDate(new Date())
            });

            console.log('‚úÖ [COMMENT] Notificaci√≥n guardada en Firestore');
          } else {
            console.log('‚ö†Ô∏è [COMMENT] El autor de la publicaci√≥n no tiene tokens FCM registrados');
          }
        } else {
          console.log(`‚ö†Ô∏è [COMMENT] Autor de la publicaci√≥n ${postAuthorId} no encontrado`);
        }
      } else {
        console.log('‚ÑπÔ∏è [COMMENT] No se env√≠a notificaci√≥n: el autor coment√≥ su propia publicaci√≥n');
      }
    } catch (notificationError) {
      console.error('‚ùå [COMMENT] Error enviando notificaci√≥n de comentario:', notificationError);
      // No fallar la creaci√≥n del comentario si falla la notificaci√≥n
    }

    res.json({
      success: true,
      message: 'Comentario creado exitosamente',
      data: {
        id: commentRef.id,
        ...commentData
      }
    });

  } catch (error) {
    console.error('‚ùå [COMMENT] Error creando comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando comentario',
      error: error.message
    });
  }
});

// Endpoint para obtener comentarios de una publicaci√≥n
app.get('/api/posts/:postId/comments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { postId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener comentarios ordenados por fecha
    let commentsSnapshot;
    try {
      commentsSnapshot = await db.collection('comments')
        .where('postId', '==', postId)
        .orderBy('createdAt', 'asc')
        .get();
    } catch (indexError) {
      console.log('‚ö†Ô∏è [COMMENTS] √çndice no disponible, obteniendo sin ordenamiento:', indexError.message);
      // Fallback: obtener sin ordenamiento
      commentsSnapshot = await db.collection('comments')
        .where('postId', '==', postId)
        .get();
    }

    const comments = [];
    for (const doc of commentsSnapshot.docs) {
      const commentData = doc.data();
      
      // Obtener nombre del autor
      let authorName = 'Usuario';
      try {
        const authorDoc = await db.collection('users').doc(commentData.authorId).get();
        if (authorDoc.exists) {
          authorName = authorDoc.data().displayName || 'Usuario';
        }
      } catch (error) {
        console.log('‚ö†Ô∏è [COMMENT] Error obteniendo nombre del autor:', error.message);
      }

      comments.push({
        id: doc.id,
        content: commentData.content,
        authorId: commentData.authorId,
        authorName: authorName,
        likes: commentData.likes || [],
        likeCount: commentData.likeCount || 0,
        isLiked: commentData.likes && commentData.likes.includes(uid),
        createdAt: commentData.createdAt
      });
    }

    res.json({
      success: true,
      data: comments
    });

  } catch (error) {
    console.error('‚ùå [COMMENT] Error obteniendo comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo comentarios',
      error: error.message
    });
  }
});

// Endpoint para dar like a un comentario
app.post('/api/comments/:commentId/like', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { commentId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const commentRef = db.collection('comments').doc(commentId);
    const commentDoc = await commentRef.get();

    if (!commentDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    const commentData = commentDoc.data();
    const isLiked = commentData.likes && commentData.likes.includes(uid);

    if (isLiked) {
      // Quitar like
      await commentRef.update({
        likes: admin.firestore.FieldValue.arrayRemove(uid),
        likeCount: admin.firestore.FieldValue.increment(-1),
        updatedAt: new Date()
      });
      
      console.log('‚úÖ [COMMENT] Like removido del comentario:', uid, commentId);
      
      res.json({
        success: true,
        message: 'Like removido del comentario',
        data: { liked: false }
      });
    } else {
      // Agregar like
      await commentRef.update({
        likes: admin.firestore.FieldValue.arrayUnion(uid),
        likeCount: admin.firestore.FieldValue.increment(1),
        updatedAt: new Date()
      });
      
      console.log('‚úÖ [COMMENT] Like agregado al comentario:', uid, commentId);
      
      res.json({
        success: true,
        message: 'Like agregado al comentario',
        data: { liked: true }
      });
    }

  } catch (error) {
    console.error('‚ùå [COMMENT] Error manejando like del comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error manejando like del comentario',
      error: error.message
    });
  }
});

// Endpoint de prueba para verificar almacenamiento de tips
app.post('/api/children/test-storage', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Intentar crear un documento de prueba
    const testData = {
      userId: uid,
      tipType: 'test',
      tip: 'Este es un tip de prueba para verificar el almacenamiento',
      childrenContext: 'Test context',
      isPregnant: false,
      currentGestationWeeks: 0,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    };

    console.log('üß™ [TEST] Intentando crear documento de prueba:', testData);

    const docRef = await db.collection('userTips').add(testData);
    
    console.log('‚úÖ [TEST] Documento de prueba creado exitosamente. ID:', docRef.id);

    // Verificar que se puede leer
    const readDoc = await db.collection('userTips').doc(docRef.id).get();
    
    if (readDoc.exists) {
      console.log('‚úÖ [TEST] Documento le√≠do exitosamente:', readDoc.data());
      
      // Limpiar el documento de prueba
      await db.collection('userTips').doc(docRef.id).delete();
      console.log('üßπ [TEST] Documento de prueba eliminado');
      
      res.json({
        success: true,
        message: 'Prueba de almacenamiento exitosa',
        data: {
          created: true,
          read: true,
          deleted: true,
          documentId: docRef.id
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Error: El documento no se puede leer despu√©s de crearlo'
      });
    }

  } catch (error) {
    console.error('‚ùå [TEST] Error en prueba de almacenamiento:', error);
    res.status(500).json({
      success: false,
      message: 'Error en prueba de almacenamiento',
      error: error.message
    });
  }
});

// Endpoint para limpiar tips antiguos (opcional, para mantenimiento)
app.post('/api/children/cleanup-tips', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Eliminar tips expirados (m√°s de 30 d√≠as)
    const expiredDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const expiredTipsSnapshot = await db.collection('userTips')
      .where('userId', '==', uid)
      .where('expiresAt', '<', expiredDate)
      .get();

    let deletedCount = 0;
    const batch = db.batch();
    
    expiredTipsSnapshot.forEach(doc => {
      batch.delete(doc.ref);
      deletedCount++;
    });

    if (deletedCount > 0) {
      await batch.commit();
      console.log(`üßπ Limpieza de tips: ${deletedCount} tips expirados eliminados para usuario ${uid}`);
    }

    res.json({
      success: true,
      message: `Limpieza completada. ${deletedCount} tips expirados eliminados.`
    });

  } catch (error) {
    console.error('‚ùå Error en limpieza de tips:', error);
    res.status(500).json({
      success: false,
      message: 'Error en limpieza de tips'
    });
  }
});

// Funci√≥n para generar tips de fallback (solo para hijos)
function generateFallbackTips(children, tipType) {
  // Rotar entre los hijos para dar variedad - usar timestamp + tipType para m√°s variedad
  const now = Date.now();
  const timeAndType = now + tipType.length + tipType.charCodeAt(0);
  
  const childIndex = Math.floor((timeAndType / 30000) % children.length); // Cambia cada 30 segundos + variaci√≥n por tipo
  const selectedChild = children[childIndex];
  let tip = '';
  
  if (tipType === 'general' || tipType === 'desarrollo') {
    if (selectedChild.isUnborn) {
      if (selectedChild.currentGestationWeeks >= 40) {
        tip = `ü§∞ ¬°${selectedChild.name} est√° listo para nacer! Mant√©n la calma y conf√≠a en tu cuerpo.`;
      } else if (selectedChild.currentGestationWeeks >= 37) {
        tip = `üë∂ ${selectedChild.name} ya no es prematuro desde las 37 semanas. ¬°Est√°s en la recta final!`;
      } else if (selectedChild.currentGestationWeeks >= 28) {
        tip = `üíï ${selectedChild.name} ya puede so√±ar y reconocer tu voz. Habla con √©l/ella todos los d√≠as.`;
      } else {
        tip = `üåü ${selectedChild.name} est√° creciendo bien en tu vientre. Mant√©n una alimentaci√≥n saludable.`;
      }
    } else {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `üçº La leche materna es el mejor alimento para ${selectedChild.name}. Amamanta a demanda.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ü•Ñ Introduce alimentos s√≥lidos gradualmente a ${selectedChild.name}. Un alimento nuevo cada 3-4 d√≠as.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `üö∂ ${selectedChild.name} est√° explorando el mundo. Mant√©n tu casa segura para ni√±os.`;
      } else if (selectedChild.currentAgeInMonths <= 36) {
        tip = `üé® Fomenta la creatividad de ${selectedChild.name} con dibujos, manualidades y juegos imaginativos.`;
      } else {
        tip = `üìö Lee cuentos con ${selectedChild.name}. Es una excelente manera de fortalecer el v√≠nculo.`;
      }
    }
  } else if (tipType === 'alimentacion') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `ü§± Amamanta exclusivamente a ${selectedChild.name} hasta los 6 meses. No necesita agua ni otros alimentos.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `ü•ë Introduce frutas y verduras de colores variados a ${selectedChild.name} para una nutrici√≥n completa.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ü•õ Ofrece a ${selectedChild.name} 3 comidas principales y 2-3 refrigerios saludables al d√≠a.`;
      } else {
        tip = `üçé Incluye en la dieta de ${selectedChild.name} prote√≠nas magras, granos enteros y muchas frutas y verduras.`;
      }
    } else {
      tip = `ü§∞ Para ${selectedChild.name}, mant√©n una alimentaci√≥n rica en √°cido f√≥lico, hierro y calcio durante el embarazo.`;
    }
  } else if (tipType === 'salud') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 12) {
        tip = `üíâ Mant√©n al d√≠a el calendario de vacunaci√≥n de ${selectedChild.name}. Es fundamental para su salud.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `ü¶∑ Cepilla los dientes de ${selectedChild.name} 2 veces al d√≠a con pasta dental con fl√∫or.`;
      } else {
        tip = `üèÉ Fomenta en ${selectedChild.name} al menos 1 hora de actividad f√≠sica diaria para un desarrollo saludable.`;
      }
    } else {
      tip = `üè• Asiste a todas las citas prenatales para monitorear el desarrollo saludable de ${selectedChild.name}.`;
    }
  } else if (tipType === 'sue√±o') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `üò¥ ${selectedChild.name} necesita 14-17 horas de sue√±o total al d√≠a. Respeta sus ritmos naturales.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `üåô Establece una rutina de sue√±o consistente para ${selectedChild.name}: ba√±o, cuento y cuna a la misma hora.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `üõèÔ∏è ${selectedChild.name} necesita 11-14 horas de sue√±o, incluyendo 1-2 siestas durante el d√≠a.`;
      } else {
        tip = `üí§ ${selectedChild.name} necesita 10-13 horas de sue√±o. Mant√©n horarios regulares para un descanso √≥ptimo.`;
      }
    } else {
      tip = `üò¥ Descansa bien durante el embarazo. Tu descanso tambi√©n beneficia el desarrollo de ${selectedChild.name}.`;
    }
  } else if (tipType === 'actividades') {
    if (!selectedChild.isUnborn) {
      if (selectedChild.currentAgeInMonths <= 6) {
        tip = `üéµ Canta canciones y haz movimientos r√≠tmicos con ${selectedChild.name}. Estimula su desarrollo auditivo y motor.`;
      } else if (selectedChild.currentAgeInMonths <= 12) {
        tip = `üß∏ Juega a esconder objetos con ${selectedChild.name}. Desarrolla su memoria y comprensi√≥n de permanencia.`;
      } else if (selectedChild.currentAgeInMonths <= 24) {
        tip = `üèóÔ∏è Construye torres con bloques junto a ${selectedChild.name}. Mejora su coordinaci√≥n y pensamiento espacial.`;
      } else {
        tip = `üé≠ Juega a disfrazarse con ${selectedChild.name}. Fomenta la imaginaci√≥n y la expresi√≥n creativa.`;
      }
    } else {
      tip = `üíï Habla, canta y acaricia tu vientre. ${selectedChild.name} puede sentir tu amor desde el √∫tero.`;
    }
  }

  // Si no hay tip espec√≠fico, generar uno general personalizado
  if (!tip) {
    tip = `üíï ${selectedChild.name} es √∫nico. Conf√≠a en tu instinto maternal/paternal para criarlo.`;
  }

  return [tip]; // Retornar solo 1 tip
}

// Endpoint para actualizar el nombre del usuario
app.put('/api/auth/update-name', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { displayName } = req.body;

    if (!displayName || displayName.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido'
      });
    }

    if (!auth || !db) {
      return res.status(500).json({
        success: false,
        message: 'Servicios no disponibles'
      });
    }

    console.log('üìù Actualizando nombre del usuario:', uid, 'Nuevo nombre:', displayName);

    // Actualizar en Firebase Auth
    await auth.updateUser(uid, {
      displayName: displayName.trim()
    });

    // Actualizar en Firestore
    await db.collection('users').doc(uid).update({
      displayName: displayName.trim(),
      updatedAt: new Date()
    });

    console.log('‚úÖ Nombre actualizado correctamente');

    res.json({
      success: true,
      message: 'Nombre actualizado correctamente',
      data: {
        displayName: displayName.trim()
      }
    });

  } catch (error) {
    console.error('‚ùå Error actualizando nombre:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar el nombre',
      error: error.message
    });
  }
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
  console.error('Error no manejado:', err);
  res.status(500).json({
    success: false,
    message: 'Error interno del servidor',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Algo sali√≥ mal'
  });
});

// ==========================================
// üìã ENDPOINTS DE PERFIL COMPLETO DE HIJOS
// ==========================================

// ==========================================
// 1. VACUNAS
// ==========================================

const buildVaccineSchedulePayload = ({ countryId, countryName, name, items, isActive = true }) => ({
  countryId,
  countryName,
  name,
  isActive,
  items: Array.isArray(items) ? items : [],
  updatedAt: new Date(),
  createdAt: new Date()
});

const mapScheduleItemToVaccine = (item, birthDate) => {
  const ageMonths = Number.isFinite(item.ageMonths) ? item.ageMonths : null;
  const ageWeeks = Number.isFinite(item.ageWeeks) ? item.ageWeeks : null;
  const scheduledDate = ageMonths !== null
    ? addMonthsToDate(birthDate, ageMonths)
    : addWeeksToDate(birthDate, ageWeeks);

  if (!scheduledDate) return null;

  return {
    name: item.name,
    scheduledDate,
    appliedDate: null,
    status: 'pending',
    location: '',
    batch: '',
    notes: item.notes || '',
    source: 'schedule',
    scheduleItemId: item.id || null,
    ageMonths,
    ageWeeks,
    createdAt: new Date(),
    updatedAt: new Date()
  };
};

// Listar calendarios de vacunas disponibles
app.get('/api/vaccines/schedules', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('vaccine_schedules')
      .where('isActive', '==', true)
      .orderBy('countryName', 'asc')
      .get();
    const schedules = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: schedules });
  } catch (error) {
    console.error('‚ùå Error listando calendarios de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error listando calendarios', error: error.message });
  }
});

// Obtener calendario por pa√≠s
app.get('/api/vaccines/schedules/country/:countryId', authenticateToken, async (req, res) => {
  try {
    const { countryId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('vaccine_schedules')
      .where('countryId', '==', countryId)
      .where('isActive', '==', true)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Calendario no encontrado' });
    }
    const doc = snapshot.docs[0];
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('‚ùå Error obteniendo calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo calendario', error: error.message });
  }
});

// Admin: crear calendario de vacunas
app.post('/api/admin/vaccines/schedules', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { countryId, name, items } = req.body || {};
    if (!countryId || !name) {
      return res.status(400).json({ success: false, message: 'countryId y name son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const countryDoc = await db.collection('countries').doc(countryId).get();
    if (!countryDoc.exists || countryDoc.data().isActive === false) {
      return res.status(400).json({ success: false, message: 'Pa√≠s no encontrado o inactivo' });
    }
    const payload = buildVaccineSchedulePayload({
      countryId,
      countryName: countryDoc.data().name,
      name,
      items,
      isActive: true
    });
    const ref = await db.collection('vaccine_schedules').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå Error creando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error creando calendario', error: error.message });
  }
});

// Admin: listar calendarios de vacunas
app.get('/api/admin/vaccines/schedules', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { isActive } = req.query || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('vaccine_schedules');
    if (isActive !== undefined) {
      query = query.where('isActive', '==', String(isActive) === 'true');
    }
    const snapshot = await query.orderBy('countryName', 'asc').get();
    const schedules = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
    res.json({ success: true, data: schedules });
  } catch (error) {
    console.error('‚ùå Error listando calendarios de vacunas (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando calendarios', error: error.message });
  }
});

// Admin: actualizar calendario de vacunas
app.put('/api/admin/vaccines/schedules/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, items, isActive } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = {
      updatedAt: new Date()
    };
    if (name !== undefined) updateData.name = name;
    if (items !== undefined) updateData.items = Array.isArray(items) ? items : [];
    if (isActive !== undefined) updateData.isActive = Boolean(isActive);
    await db.collection('vaccine_schedules').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå Error actualizando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error actualizando calendario', error: error.message });
  }
});

// Admin: eliminar calendario de vacunas
app.delete('/api/admin/vaccines/schedules/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('vaccine_schedules').doc(id).delete();
    res.json({ success: true, message: 'Calendario eliminado' });
  } catch (error) {
    console.error('‚ùå Error eliminando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error eliminando calendario', error: error.message });
  }
});

// Asignar calendario de vacunas a un hijo
app.post('/api/children/:childId/vaccines/assign-schedule', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { countryId } = req.body || {};

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    if (!countryId) {
      return res.status(400).json({ success: false, message: 'countryId es requerido' });
    }

    const childRef = db.collection('children').doc(childId);
    const childDoc = await childRef.get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({ success: false, message: 'No tienes permiso para acceder a este hijo' });
    }

    const childData = childDoc.data();
    const birthDate = parseDateSafe(childData.birthDate);
    if (!birthDate) {
      return res.status(400).json({ success: false, message: 'El hijo no tiene birthDate v√°lida' });
    }

    const existingVaccines = await childRef.collection('vaccines').limit(1).get();
    if (!existingVaccines.empty) {
      return res.status(400).json({ success: false, message: 'El hijo ya tiene vacunas registradas' });
    }

    const scheduleSnapshot = await db.collection('vaccine_schedules')
      .where('countryId', '==', countryId)
      .where('isActive', '==', true)
      .limit(1)
      .get();
    if (scheduleSnapshot.empty) {
      return res.status(404).json({ success: false, message: 'Calendario de vacunas no encontrado' });
    }

    const scheduleDoc = scheduleSnapshot.docs[0];
    const scheduleData = scheduleDoc.data();
    const items = Array.isArray(scheduleData.items) ? scheduleData.items : [];
    if (items.length === 0) {
      return res.status(400).json({ success: false, message: 'El calendario no tiene vacunas' });
    }

    const batch = db.batch();
    const vaccinesToCreate = [];
    items.forEach(item => {
      if (!item || !item.name) return;
      const vaccinePayload = mapScheduleItemToVaccine(item, birthDate);
      if (!vaccinePayload) return;
      const docRef = childRef.collection('vaccines').doc();
      batch.set(docRef, {
        ...vaccinePayload,
        scheduleId: scheduleDoc.id,
        scheduleName: scheduleData.name || '',
        countryId: scheduleData.countryId,
        countryName: scheduleData.countryName || ''
      });
      vaccinesToCreate.push({ id: docRef.id, ...vaccinePayload });
    });

    const countryDoc = await db.collection('countries').doc(countryId).get();
    const countryName = countryDoc.exists ? countryDoc.data().name : scheduleData.countryName || '';

    batch.update(childRef, stripUndefined({
      vaccinationCountryId: countryId,
      vaccinationCountryName: countryName || '',
      vaccinationScheduleId: scheduleDoc.id,
      vaccinationScheduleName: scheduleData.name || '',
      vaccinationAssignedAt: new Date(),
      updatedAt: new Date()
    }));

    await batch.commit();

    res.json({
      success: true,
      message: 'Calendario asignado correctamente',
      data: vaccinesToCreate
    });
  } catch (error) {
    console.error('‚ùå Error asignando calendario de vacunas:', error);
    res.status(500).json({ success: false, message: 'Error asignando calendario', error: error.message });
  }
});

// Obtener vacunas de un hijo
app.get('/api/children/:childId/vaccines', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const vaccinesSnapshot = await db.collection('children').doc(childId)
      .collection('vaccines')
      .orderBy('scheduledDate', 'asc')
      .get();

    const vaccines = [];
    vaccinesSnapshot.forEach(doc => {
      vaccines.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: vaccines,
      needsVaccinationCountry: vaccines.length === 0 && !childDoc.data().vaccinationCountryId
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo vacunas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo vacunas',
      error: error.message
    });
  }
});

// Agregar/actualizar vacuna
app.post('/api/children/:childId/vaccines', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name, 
      scheduledDate, 
      appliedDate, 
      status, // 'pending', 'applied', 'skipped'
      location,
      batch,
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el hijo pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const vaccineData = {
      name,
      scheduledDate: new Date(scheduledDate),
      appliedDate: appliedDate ? new Date(appliedDate) : null,
      status: status || 'pending',
      location: location || '',
      batch: batch || '',
      notes: notes || '',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const vaccineRef = await db.collection('children').doc(childId)
      .collection('vaccines')
      .add(vaccineData);

    res.json({
      success: true,
      message: 'Vacuna registrada exitosamente',
      data: {
        id: vaccineRef.id,
        ...vaccineData
      }
    });

  } catch (error) {
    console.error('‚ùå Error registrando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando vacuna',
      error: error.message
    });
  }
});

// ==========================================
// 2. CITAS M√âDICAS
// ==========================================

// Obtener citas m√©dicas
app.get('/api/children/:childId/appointments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const appointmentsSnapshot = await db.collection('children').doc(childId)
      .collection('appointments')
      .orderBy('date', 'desc')
      .get();

    const appointments = [];
    appointmentsSnapshot.forEach(doc => {
      appointments.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: appointments
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo citas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo citas',
      error: error.message
    });
  }
});

// Agregar cita m√©dica
app.post('/api/children/:childId/appointments', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'checkup', 'specialist', 'emergency', 'vaccine'
      date,
      doctor,
      location,
      reason,
      notes,
      status // 'scheduled', 'completed', 'cancelled'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este hijo'
      });
    }

    const appointmentData = {
      type: type || 'checkup',
      date: new Date(date),
      doctor: doctor || '',
      location: location || '',
      reason: reason || '',
      notes: notes || '',
      status: status || 'scheduled',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const appointmentRef = await db.collection('children').doc(childId)
      .collection('appointments')
      .add(appointmentData);

    res.json({
      success: true,
      message: 'Cita registrada exitosamente',
      data: {
        id: appointmentRef.id,
        ...appointmentData
      }
    });

  } catch (error) {
    console.error('‚ùå Error registrando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando cita',
      error: error.message
    });
  }
});

// ==========================================
// 3. MEDICAMENTOS
// ==========================================

// Obtener medicamentos
app.get('/api/children/:childId/medications', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const medicationsSnapshot = await db.collection('children').doc(childId)
      .collection('medications')
      .orderBy('startDate', 'desc')
      .get();

    const medications = [];
    medicationsSnapshot.forEach(doc => {
      medications.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: medications
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo medicamentos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo medicamentos',
      error: error.message
    });
  }
});

// Agregar medicamento
app.post('/api/children/:childId/medications', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name,
      dosage,
      frequency,
      startDate,
      endDate,
      reason,
      prescribedBy,
      notes,
      status // 'active', 'completed', 'discontinued'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const medicationData = {
      name,
      dosage,
      frequency,
      startDate: new Date(startDate),
      endDate: endDate ? new Date(endDate) : null,
      reason: reason || '',
      prescribedBy: prescribedBy || '',
      notes: notes || '',
      status: status || 'active',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const medicationRef = await db.collection('children').doc(childId)
      .collection('medications')
      .add(medicationData);

    res.json({
      success: true,
      message: 'Medicamento registrado exitosamente',
      data: {
        id: medicationRef.id,
        ...medicationData
      }
    });

  } catch (error) {
    console.error('‚ùå Error registrando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando medicamento',
      error: error.message
    });
  }
});

// ==========================================
// 4. ALERGIAS (actualizar hijo con campo allergies)
// ==========================================

// Actualizar alergias del hijo
app.put('/api/children/:childId/allergies', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { allergies } = req.body; // array de strings

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId).update({
      allergies: allergies || [],
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Alergias actualizadas exitosamente',
      data: {
        allergies
      }
    });

  } catch (error) {
    console.error('‚ùå Error actualizando alergias:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando alergias',
      error: error.message
    });
  }
});

// ==========================================
// 5. HISTORIAL M√âDICO
// ==========================================

// Obtener historial m√©dico
app.get('/api/children/:childId/medical-history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const historySnapshot = await db.collection('children').doc(childId)
      .collection('medical_history')
      .orderBy('date', 'desc')
      .get();

    const history = [];
    historySnapshot.forEach(doc => {
      history.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: history
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo historial m√©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial m√©dico',
      error: error.message
    });
  }
});

// Agregar entrada al historial m√©dico
app.post('/api/children/:childId/medical-history', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'diagnosis', 'treatment', 'surgery', 'hospitalization', 'other'
      date,
      title,
      description,
      doctor,
      location,
      attachments // URLs de documentos/im√°genes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const historyData = {
      type: type || 'other',
      date: new Date(date),
      title,
      description: description || '',
      doctor: doctor || '',
      location: location || '',
      attachments: attachments || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const historyRef = await db.collection('children').doc(childId)
      .collection('medical_history')
      .add(historyData);

    res.json({
      success: true,
      message: 'Historial m√©dico actualizado exitosamente',
      data: {
        id: historyRef.id,
        ...historyData
      }
    });

  } catch (error) {
    console.error('‚ùå Error actualizando historial m√©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando historial m√©dico',
      error: error.message
    });
  }
});

// ==========================================
// 6. MEDICIONES (Peso, Altura, Per√≠metro Cef√°lico)
// ==========================================

// Obtener mediciones
app.get('/api/children/:childId/measurements', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const measurementsSnapshot = await db.collection('children').doc(childId)
      .collection('measurements')
      .orderBy('date', 'desc')
      .get();

    const measurements = [];
    measurementsSnapshot.forEach(doc => {
      measurements.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: measurements
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo mediciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mediciones',
      error: error.message
    });
  }
});

// Agregar medici√≥n
app.post('/api/children/:childId/measurements', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      weight, // en kg
      height, // en cm
      headCircumference, // en cm
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const measurementData = {
      date: new Date(date),
      weight: weight || null,
      height: height || null,
      headCircumference: headCircumference || null,
      notes: notes || '',
      createdAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Medici√≥n registrada exitosamente',
      data: {
        id: measurementRef.id,
        ...measurementData
      }
    });

  } catch (error) {
    console.error('‚ùå Error registrando medici√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando medici√≥n',
      error: error.message
    });
  }
});

// ==========================================
// 7. SEGUIMIENTO DE SUE√ëO
// ==========================================

// Obtener registros de sue√±o
app.get('/api/children/:childId/sleep-tracking', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { startDate, endDate } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    let query = db.collection('children').doc(childId).collection('sleep_tracking');
    
    if (startDate) {
      query = query.where('date', '>=', new Date(startDate));
    }
    if (endDate) {
      query = query.where('date', '<=', new Date(endDate));
    }

    const sleepSnapshot = await query.orderBy('date', 'desc').get();

    const sleepRecords = [];
    sleepSnapshot.forEach(doc => {
      sleepRecords.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: sleepRecords
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo registros de sue√±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo registros de sue√±o',
      error: error.message
    });
  }
});

// Agregar registro de sue√±o
app.post('/api/children/:childId/sleep-tracking', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      sleepTime, // hora de dormir
      wakeTime, // hora de despertar
      duration, // duraci√≥n en minutos
      quality, // 'good', 'fair', 'poor'
      naps, // array de siestas [{time, duration}]
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const sleepData = {
      date: new Date(date),
      sleepTime: sleepTime ? new Date(sleepTime) : null,
      wakeTime: wakeTime ? new Date(wakeTime) : null,
      duration: duration || 0,
      quality: quality || 'fair',
      naps: naps || [],
      notes: notes || '',
      createdAt: new Date()
    };

    const sleepRef = await db.collection('children').doc(childId)
      .collection('sleep_tracking')
      .add(sleepData);

    res.json({
      success: true,
      message: 'Registro de sue√±o guardado exitosamente',
      data: {
        id: sleepRef.id,
        ...sleepData
      }
    });

  } catch (error) {
    console.error('‚ùå Error guardando registro de sue√±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando registro de sue√±o',
      error: error.message
    });
  }
});

// ==========================================
// 8. REGISTRO DE ALIMENTACI√ìN
// ==========================================

// Obtener registros de alimentaci√≥n
app.get('/api/children/:childId/feeding-log', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { startDate, endDate } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    let query = db.collection('children').doc(childId).collection('feeding_log');
    
    if (startDate) {
      query = query.where('date', '>=', new Date(startDate));
    }
    if (endDate) {
      query = query.where('date', '<=', new Date(endDate));
    }

    const feedingSnapshot = await query.orderBy('date', 'desc').get();

    const feedingRecords = [];
    feedingSnapshot.forEach(doc => {
      feedingRecords.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: feedingRecords
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo registros de alimentaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo registros de alimentaci√≥n',
      error: error.message
    });
  }
});

// Agregar registro de alimentaci√≥n
app.post('/api/children/:childId/feeding-log', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      type, // 'breastfeeding', 'bottle', 'solid', 'water'
      amount, // ml o gramos
      duration, // minutos (para lactancia)
      food, // descripci√≥n del alimento
      breast, // 'left', 'right', 'both' (para lactancia)
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const feedingData = {
      date: new Date(date),
      type,
      amount: amount || null,
      duration: duration || null,
      food: food || '',
      breast: breast || null,
      notes: notes || '',
      createdAt: new Date()
    };

    const feedingRef = await db.collection('children').doc(childId)
      .collection('feeding_log')
      .add(feedingData);

    res.json({
      success: true,
      message: 'Registro de alimentaci√≥n guardado exitosamente',
      data: {
        id: feedingRef.id,
        ...feedingData
      }
    });

  } catch (error) {
    console.error('‚ùå Error guardando registro de alimentaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando registro de alimentaci√≥n',
      error: error.message
    });
  }
});

// ==========================================
// 9. HITOS DEL DESARROLLO
// ==========================================

// Obtener hitos
app.get('/api/children/:childId/milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const milestonesSnapshot = await db.collection('children').doc(childId)
      .collection('milestones')
      .orderBy('date', 'desc')
      .get();

    const milestones = [];
    milestonesSnapshot.forEach(doc => {
      milestones.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: milestones
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo hitos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Agregar hito
app.post('/api/children/:childId/milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      type, // 'first_smile', 'first_word', 'first_step', 'first_tooth', 'custom'
      title,
      date,
      description,
      photos, // array de URLs
      celebrationEmoji
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const milestoneData = {
      type,
      title,
      date: new Date(date),
      description: description || '',
      photos: photos || [],
      celebrationEmoji: celebrationEmoji || 'üéâ',
      createdAt: new Date()
    };

    const milestoneRef = await db.collection('children').doc(childId)
      .collection('milestones')
      .add(milestoneData);

    res.json({
      success: true,
      message: 'Hito registrado exitosamente',
      data: {
        id: milestoneRef.id,
        ...milestoneData
      }
    });

  } catch (error) {
    console.error('‚ùå Error registrando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando hito',
      error: error.message
    });
  }
});

// ==========================================
// 10. DIARIO DEL BEB√â
// ==========================================

// Obtener entradas del diario
app.get('/api/children/:childId/diary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const diarySnapshot = await db.collection('children').doc(childId)
      .collection('diary')
      .orderBy('date', 'desc')
      .limit(50)
      .get();

    const diaryEntries = [];
    diarySnapshot.forEach(doc => {
      diaryEntries.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: diaryEntries
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo diario',
      error: error.message
    });
  }
});

// Agregar entrada al diario
app.post('/api/children/:childId/diary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      date,
      title,
      content,
      mood, // 'happy', 'sad', 'neutral', 'excited'
      photos,
      tags
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const diaryData = {
      date: new Date(date),
      title: title || '',
      content,
      mood: mood || 'neutral',
      photos: photos || [],
      tags: tags || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const diaryRef = await db.collection('children').doc(childId)
      .collection('diary')
      .add(diaryData);

    res.json({
      success: true,
      message: 'Entrada del diario guardada exitosamente',
      data: {
        id: diaryRef.id,
        ...diaryData
      }
    });

  } catch (error) {
    console.error('‚ùå Error guardando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando entrada del diario',
      error: error.message
    });
  }
});

// ==========================================
// 11. √ÅLBUMES DE FOTOS
// ==========================================

// Obtener √°lbumes
app.get('/api/children/:childId/albums', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumsSnapshot = await db.collection('children').doc(childId)
      .collection('albums')
      .orderBy('createdAt', 'desc')
      .get();

    const albums = [];
    albumsSnapshot.forEach(doc => {
      albums.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: albums
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo √°lbumes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo √°lbumes',
      error: error.message
    });
  }
});

// Crear √°lbum
app.post('/api/children/:childId/albums', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      name,
      description,
      coverPhoto,
      photos, // array de {url, caption, date}
      theme // 'birthday', 'first_year', 'vacation', 'custom'
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumData = {
      name,
      description: description || '',
      coverPhoto: coverPhoto || '',
      photos: photos || [],
      theme: theme || 'custom',
      photoCount: (photos || []).length,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const albumRef = await db.collection('children').doc(childId)
      .collection('albums')
      .add(albumData);

    res.json({
      success: true,
      message: '√Ålbum creado exitosamente',
      data: {
        id: albumRef.id,
        ...albumData
      }
    });

  } catch (error) {
    console.error('‚ùå Error creando √°lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando √°lbum',
      error: error.message
    });
  }
});

// Agregar fotos a un √°lbum
app.post('/api/children/:childId/albums/:albumId/photos', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;
    const { photos } = req.body; // array de {url, caption, date}

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const albumRef = db.collection('children').doc(childId).collection('albums').doc(albumId);
    const albumDoc = await albumRef.get();

    if (!albumDoc.exists) {
      return res.status(404).json({
        success: false,
        message: '√Ålbum no encontrado'
      });
    }

    const currentPhotos = albumDoc.data().photos || [];
    const updatedPhotos = [...currentPhotos, ...photos];

    await albumRef.update({
      photos: updatedPhotos,
      photoCount: updatedPhotos.length,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      message: 'Fotos agregadas al √°lbum exitosamente',
      data: {
        photoCount: updatedPhotos.length
      }
    });

  } catch (error) {
    console.error('‚ùå Error agregando fotos al √°lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando fotos al √°lbum',
      error: error.message
    });
  }
});

// ==========================================
// 12. CUIDADORES (Compartir acceso)
// ==========================================

// Obtener cuidadores
app.get('/api/children/:childId/caregivers', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const caregiversSnapshot = await db.collection('children').doc(childId)
      .collection('caregivers')
      .get();

    const caregivers = [];
    caregiversSnapshot.forEach(doc => {
      caregivers.push({
        id: doc.id,
        ...doc.data()
      });
    });

    res.json({
      success: true,
      data: caregivers
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo cuidadores:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo cuidadores',
      error: error.message
    });
  }
});

// Agregar cuidador
app.post('/api/children/:childId/caregivers', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { 
      email,
      name,
      relationship, // 'father', 'mother', 'grandparent', 'other'
      permissions // {canEdit: bool, canViewMedical: bool, canViewPhotos: bool}
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Verificar si el email ya existe como cuidador
    const existingCaregiver = await db.collection('children').doc(childId)
      .collection('caregivers')
      .where('email', '==', email)
      .get();

    if (!existingCaregiver.empty) {
      return res.status(400).json({
        success: false,
        message: 'Este email ya est√° registrado como cuidador'
      });
    }

    const caregiverData = {
      email,
      name: name || '',
      relationship: relationship || 'other',
      permissions: permissions || {
        canEdit: false,
        canViewMedical: true,
        canViewPhotos: true
      },
      status: 'pending', // 'pending', 'active', 'declined'
      invitedAt: new Date(),
      invitedBy: uid
    };

    const caregiverRef = await db.collection('children').doc(childId)
      .collection('caregivers')
      .add(caregiverData);

    res.json({
      success: true,
      message: 'Cuidador invitado exitosamente',
      data: {
        id: caregiverRef.id,
        ...caregiverData
      }
    });

  } catch (error) {
    console.error('‚ùå Error agregando cuidador:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando cuidador',
      error: error.message
    });
  }
});

// ==========================================
// 13. EXPORTAR A PDF
// ==========================================

// Exportar informaci√≥n completa del hijo a PDF
app.get('/api/children/:childId/export-pdf', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();

    // Recopilar toda la informaci√≥n
    const vaccinesSnapshot = await db.collection('children').doc(childId).collection('vaccines').get();
    const appointmentsSnapshot = await db.collection('children').doc(childId).collection('appointments').get();
    const milestonesSnapshot = await db.collection('children').doc(childId).collection('milestones').get();
    const measurementsSnapshot = await db.collection('children').doc(childId).collection('measurements').get();

    const exportData = {
      child: {
        name: childData.name,
        birthDate: childData.birthDate,
        ageInMonths: childData.currentAgeInMonths,
        allergies: childData.allergies || []
      },
      vaccines: [],
      appointments: [],
      milestones: [],
      measurements: []
    };

    vaccinesSnapshot.forEach(doc => exportData.vaccines.push(doc.data()));
    appointmentsSnapshot.forEach(doc => exportData.appointments.push(doc.data()));
    milestonesSnapshot.forEach(doc => exportData.milestones.push(doc.data()));
    measurementsSnapshot.forEach(doc => exportData.measurements.push(doc.data()));

    // Por ahora devolver JSON (puedes integrar una librer√≠a de PDF como PDFKit o Puppeteer)
    res.json({
      success: true,
      message: 'Datos recopilados para exportar',
      data: exportData,
      note: 'Integrar librer√≠a de PDF para generar documento descargable'
    });

  } catch (error) {
    console.error('‚ùå Error exportando datos:', error);
    res.status(500).json({
      success: false,
      message: 'Error exportando datos',
      error: error.message
    });
  }
});

// ==========================================
// FIN DE ENDPOINTS DE PERFIL DE HIJOS


// ==========================================
// üìù ENDPOINTS CRUD - UPDATE & DELETE
// ==========================================

// PUT (actualizar) y DELETE (eliminar) para todos los recursos

// ==========================================
// 1. VACUNAS - UPDATE & DELETE
// ==========================================

// Actualizar vacuna
app.put('/api/children/:childId/vaccines/:vaccineId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, vaccineId } = req.params;
    const { 
      name, 
      scheduledDate, 
      appliedDate, 
      status,
      location,
      batch,
      notes
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name !== undefined) updateData.name = name;
    if (scheduledDate !== undefined) updateData.scheduledDate = new Date(scheduledDate);
    if (appliedDate !== undefined) updateData.appliedDate = appliedDate ? new Date(appliedDate) : null;
    if (status !== undefined) updateData.status = status;
    if (location !== undefined) updateData.location = location;
    if (batch !== undefined) updateData.batch = batch;
    if (notes !== undefined) updateData.notes = notes;

    await db.collection('children').doc(childId)
      .collection('vaccines').doc(vaccineId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Vacuna actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando vacuna',
      error: error.message
    });
  }
});

// Eliminar vacuna
app.delete('/api/children/:childId/vaccines/:vaccineId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, vaccineId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('vaccines').doc(vaccineId)
      .delete();

    res.json({
      success: true,
      message: 'Vacuna eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando vacuna:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando vacuna',
      error: error.message
    });
  }
});

// ==========================================
// 2. CITAS M√âDICAS - UPDATE & DELETE
// ==========================================

// Actualizar cita m√©dica
app.put('/api/children/:childId/appointments/:appointmentId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, appointmentId } = req.params;
    const { type, date, doctor, location, reason, notes, status } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (type !== undefined) updateData.type = type;
    if (date !== undefined) updateData.date = new Date(date);
    if (doctor !== undefined) updateData.doctor = doctor;
    if (location !== undefined) updateData.location = location;
    if (reason !== undefined) updateData.reason = reason;
    if (notes !== undefined) updateData.notes = notes;
    if (status !== undefined) updateData.status = status;

    await db.collection('children').doc(childId)
      .collection('appointments').doc(appointmentId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Cita actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando cita',
      error: error.message
    });
  }
});

// Eliminar cita m√©dica
app.delete('/api/children/:childId/appointments/:appointmentId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, appointmentId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('appointments').doc(appointmentId)
      .delete();

    res.json({
      success: true,
      message: 'Cita eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando cita:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando cita',
      error: error.message
    });
  }
});

// ==========================================
// 3. MEDICAMENTOS - UPDATE & DELETE
// ==========================================

// Actualizar medicamento
app.put('/api/children/:childId/medications/:medicationId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, medicationId } = req.params;
    const { name, dosage, frequency, startDate, endDate, reason, prescribedBy, notes, status } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (name !== undefined) updateData.name = name;
    if (dosage !== undefined) updateData.dosage = dosage;
    if (frequency !== undefined) updateData.frequency = frequency;
    if (startDate !== undefined) updateData.startDate = new Date(startDate);
    if (endDate !== undefined) updateData.endDate = endDate ? new Date(endDate) : null;
    if (reason !== undefined) updateData.reason = reason;
    if (prescribedBy !== undefined) updateData.prescribedBy = prescribedBy;
    if (notes !== undefined) updateData.notes = notes;
    if (status !== undefined) updateData.status = status;

    await db.collection('children').doc(childId)
      .collection('medications').doc(medicationId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Medicamento actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando medicamento',
      error: error.message
    });
  }
});

// Eliminar medicamento
app.delete('/api/children/:childId/medications/:medicationId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, medicationId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('medications').doc(medicationId)
      .delete();

    res.json({
      success: true,
      message: 'Medicamento eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando medicamento:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando medicamento',
      error: error.message
    });
  }
});

// ==========================================
// 4. HISTORIAL M√âDICO - UPDATE & DELETE
// ==========================================

// Actualizar historial m√©dico
app.put('/api/children/:childId/medical-history/:historyId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, historyId } = req.params;
    const { type, date, title, description, doctor, location, attachments } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (type !== undefined) updateData.type = type;
    if (date !== undefined) updateData.date = new Date(date);
    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (doctor !== undefined) updateData.doctor = doctor;
    if (location !== undefined) updateData.location = location;
    if (attachments !== undefined) updateData.attachments = attachments;

    await db.collection('children').doc(childId)
      .collection('medical_history').doc(historyId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Historial m√©dico actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando historial m√©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando historial m√©dico',
      error: error.message
    });
  }
});

// Eliminar historial m√©dico
app.delete('/api/children/:childId/medical-history/:historyId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, historyId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('medical_history').doc(historyId)
      .delete();

    res.json({
      success: true,
      message: 'Historial m√©dico eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando historial m√©dico:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando historial m√©dico',
      error: error.message
    });
  }
});

// ==========================================
// 5. MEDICIONES - UPDATE & DELETE
// ==========================================

// Actualizar medici√≥n
app.put('/api/children/:childId/measurements/:measurementId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, measurementId } = req.params;
    const { date, weight, height, headCircumference, notes } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {};
    if (date !== undefined) updateData.date = new Date(date);
    if (weight !== undefined) updateData.weight = weight;
    if (height !== undefined) updateData.height = height;
    if (headCircumference !== undefined) updateData.headCircumference = headCircumference;
    if (notes !== undefined) updateData.notes = notes;

    await db.collection('children').doc(childId)
      .collection('measurements').doc(measurementId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Medici√≥n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando medici√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando medici√≥n',
      error: error.message
    });
  }
});

// Eliminar medici√≥n
app.delete('/api/children/:childId/measurements/:measurementId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, measurementId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements').doc(measurementId)
      .delete();

    res.json({
      success: true,
      message: 'Medici√≥n eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando medici√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando medici√≥n',
      error: error.message
    });
  }
});

// ==========================================
// 6.1 MEDICIONES - PESO (ENDPOINTS DEDICADOS)
// ==========================================

const mapWeightMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueKg: data.valueKg ?? data.weight ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

const mapHeightMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueCm: data.valueCm ?? data.height ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

const mapHeadMeasurement = (doc) => {
  const data = doc.data();
  const measuredAt = parseDateSafe(data.measuredAt || data.date);
  return {
    id: doc.id,
    valueCm: data.valueCm ?? data.headCircumference ?? null,
    measuredAt: measuredAt ? measuredAt.toISOString() : null,
    source: data.source || null,
    notes: data.notes || null,
    createdBy: data.createdBy || null
  };
};

// Obtener historial de peso
app.get('/api/children/:childId/measurements/weight', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'weight') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_weight')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapWeightMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueKg !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueKg, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().weight !== undefined && doc.data().weight !== null)
        .map((doc) => {
          const mapped = mapWeightMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueKg !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueKg, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo peso',
      error: error.message
    });
  }
});

// Crear registro de peso
app.post('/api/children/:childId/measurements/weight', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueKg, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueKg === undefined || valueKg === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueKg y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueKg: Number(valueKg),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_weight')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Peso registrado exitosamente',
      data: {
        id: measurementRef.id,
        ...mapWeightMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('‚ùå Error registrando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando peso',
      error: error.message
    });
  }
});

// Actualizar registro de peso
app.put('/api/children/:childId/measurements/weight/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueKg, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueKg !== undefined) updateData.valueKg = Number(valueKg);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_weight').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Peso actualizado exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('‚ùå Error actualizando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando peso',
      error: error.message
    });
  }
});

// Eliminar registro de peso
app.delete('/api/children/:childId/measurements/weight/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_weight').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Peso eliminado exitosamente'
    });
  } catch (error) {
    console.error('‚ùå Error eliminando peso:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando peso',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.1 MEDICIONES - ALTURA (ENDPOINTS DEDICADOS)
// ==========================================

// Obtener historial de altura
app.get('/api/children/:childId/measurements/height', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'height') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_height')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapHeightMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().height !== undefined && doc.data().height !== null)
        .map((doc) => {
          const mapped = mapHeightMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo altura',
      error: error.message
    });
  }
});

// Crear registro de altura
app.post('/api/children/:childId/measurements/height', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueCm === undefined || valueCm === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueCm y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueCm: Number(valueCm),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_height')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Altura registrada exitosamente',
      data: {
        id: measurementRef.id,
        ...mapHeightMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('‚ùå Error registrando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando altura',
      error: error.message
    });
  }
});

// Actualizar registro de altura
app.put('/api/children/:childId/measurements/height/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueCm !== undefined) updateData.valueCm = Number(valueCm);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_height').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Altura actualizada exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('‚ùå Error actualizando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando altura',
      error: error.message
    });
  }
});

// Eliminar registro de altura
app.delete('/api/children/:childId/measurements/height/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_height').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Altura eliminada exitosamente'
    });
  } catch (error) {
    console.error('‚ùå Error eliminando altura:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando altura',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.2 MEDICIONES - PERIMETRO CEFALICO (ENDPOINTS DEDICADOS)
// ==========================================

// Obtener historial de perimetro cefalico
app.get('/api/children/:childId/measurements/head', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const percentilePoints = childSex ? await getGrowthPercentilePoints(childSex, 'head') : [];

    let snapshot = await db.collection('children').doc(childId)
      .collection('measurements_head')
      .orderBy('measuredAt', 'desc')
      .get();

    let measurements = snapshot.docs.map((doc) => {
      const mapped = mapHeadMeasurement(doc);
      if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
        const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
        mapped.ageWeeks = ageWeeks;
        mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
      }
      return mapped;
    });

    if (measurements.length === 0) {
      const fallbackSnapshot = await db.collection('children').doc(childId)
        .collection('measurements')
        .orderBy('date', 'desc')
        .get();
      measurements = fallbackSnapshot.docs
        .filter(doc => doc.data().headCircumference !== undefined && doc.data().headCircumference !== null)
        .map((doc) => {
          const mapped = mapHeadMeasurement(doc);
          if (birthDate && mapped.measuredAt && mapped.valueCm !== null && percentilePoints.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            const curvePoint = interpolatePercentile(percentilePoints, ageWeeks);
            mapped.ageWeeks = ageWeeks;
            mapped.percentile = estimatePercentileFromPoint(mapped.valueCm, curvePoint);
          }
          return mapped;
        });
    }

    res.json({
      success: true,
      data: measurements
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo perimetro cefalico',
      error: error.message
    });
  }
});

// Crear registro de perimetro cefalico
app.post('/api/children/:childId/measurements/head', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (valueCm === undefined || valueCm === null || measuredAt === undefined || measuredAt === null) {
      return res.status(400).json({
        success: false,
        message: 'valueCm y measuredAt son requeridos'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.exists ? userDoc.data() : {};
    const createdBy = {
      uid,
      name: userData.displayName || userData.name || userData.email || 'Usuario'
    };

    const measurementData = {
      valueCm: Number(valueCm),
      measuredAt: new Date(measuredAt),
      notes: notes || '',
      source: source || null,
      createdBy,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const measurementRef = await db.collection('children').doc(childId)
      .collection('measurements_head')
      .add(measurementData);

    res.json({
      success: true,
      message: 'Perimetro cefalico registrado exitosamente',
      data: {
        id: measurementRef.id,
        ...mapHeadMeasurement({ id: measurementRef.id, data: () => measurementData })
      }
    });
  } catch (error) {
    console.error('‚ùå Error registrando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando perimetro cefalico',
      error: error.message
    });
  }
});

// Actualizar registro de perimetro cefalico
app.put('/api/children/:childId/measurements/head/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;
    const { valueCm, measuredAt, notes, source } = req.body || {};

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (valueCm !== undefined) updateData.valueCm = Number(valueCm);
    if (measuredAt !== undefined) updateData.measuredAt = new Date(measuredAt);
    if (notes !== undefined) updateData.notes = notes;
    if (source !== undefined) updateData.source = source;

    await db.collection('children').doc(childId)
      .collection('measurements_head').doc(id)
      .update(updateData);

    res.json({
      success: true,
      message: 'Perimetro cefalico actualizado exitosamente',
      data: { id, ...updateData }
    });
  } catch (error) {
    console.error('‚ùå Error actualizando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando perimetro cefalico',
      error: error.message
    });
  }
});

// Eliminar registro de perimetro cefalico
app.delete('/api/children/:childId/measurements/head/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('measurements_head').doc(id)
      .delete();

    res.json({
      success: true,
      message: 'Perimetro cefalico eliminado exitosamente'
    });
  } catch (error) {
    console.error('‚ùå Error eliminando perimetro cefalico:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando perimetro cefalico',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.3 MEDICIONES - RESUMEN (PANTALLA SUMMARY)
// ==========================================

app.get('/api/children/:childId/measurements/summary', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();
    const childSex = normalizeChildSex(childData);
    const birthDate = childData?.birthDate || null;
    const [weightPoints, heightPoints, headPoints] = childSex
      ? await Promise.all([
          getGrowthPercentilePoints(childSex, 'weight'),
          getGrowthPercentilePoints(childSex, 'height'),
          getGrowthPercentilePoints(childSex, 'head')
        ])
      : [[], [], []];

    const snapshot = await db.collection('children').doc(childId)
      .collection('measurements')
      .orderBy('date', 'desc')
      .get();

    const normalizeMeasuredAt = (value) => {
      const measuredAt = parseDateSafe(value);
      return measuredAt ? measuredAt.toISOString() : null;
    };

    const historyMap = new Map();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      const measuredAt = normalizeMeasuredAt(data.date);
      if (!measuredAt) return;
      const entry = {
        id: doc.id,
        measuredAt,
        weightKg: data.weight ?? null,
        heightCm: data.height ?? null,
        headCm: data.headCircumference ?? null,
        notes: data.notes || null,
        createdBy: data.createdBy || null
      };

      if (birthDate && measuredAt) {
        const ageWeeks = calculateWeeksBetweenDates(birthDate, measuredAt);
        if (entry.weightKg !== null && weightPoints.length > 0) {
          entry.weightPercentile = estimatePercentileFromPoint(entry.weightKg, interpolatePercentile(weightPoints, ageWeeks));
        }
        if (entry.heightCm !== null && heightPoints.length > 0) {
          entry.heightPercentile = estimatePercentileFromPoint(entry.heightCm, interpolatePercentile(heightPoints, ageWeeks));
        }
        if (entry.headCm !== null && headPoints.length > 0) {
          entry.headPercentile = estimatePercentileFromPoint(entry.headCm, interpolatePercentile(headPoints, ageWeeks));
        }
        entry.ageWeeks = ageWeeks;
      }

      historyMap.set(measuredAt, entry);
    });

    const mergeDedicated = (docs, field, mapFn, points) => {
      docs.forEach(doc => {
        const mapped = mapFn(doc);
        if (!mapped.measuredAt) return;
        const existing = historyMap.get(mapped.measuredAt);
        if (existing) {
          existing[field] = mapped.valueCm ?? mapped.valueKg ?? existing[field];
          if (!existing.createdBy && mapped.createdBy) existing.createdBy = mapped.createdBy;
          if (!existing.notes && mapped.notes) existing.notes = mapped.notes;
          if (birthDate && existing[field] !== null && points.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            existing.ageWeeks = existing.ageWeeks ?? ageWeeks;
            const percentile = estimatePercentileFromPoint(existing[field], interpolatePercentile(points, ageWeeks));
            if (field === 'weightKg') existing.weightPercentile = percentile;
            if (field === 'heightCm') existing.heightPercentile = percentile;
            if (field === 'headCm') existing.headPercentile = percentile;
          }
        } else {
          const entry = {
            id: mapped.id,
            measuredAt: mapped.measuredAt,
            weightKg: null,
            heightCm: null,
            headCm: null,
            notes: mapped.notes || null,
            createdBy: mapped.createdBy || null,
            [field]: mapped.valueCm ?? mapped.valueKg ?? null
          };
          if (birthDate && entry[field] !== null && points.length > 0) {
            const ageWeeks = calculateWeeksBetweenDates(birthDate, mapped.measuredAt);
            entry.ageWeeks = ageWeeks;
            const percentile = estimatePercentileFromPoint(entry[field], interpolatePercentile(points, ageWeeks));
            if (field === 'weightKg') entry.weightPercentile = percentile;
            if (field === 'heightCm') entry.heightPercentile = percentile;
            if (field === 'headCm') entry.headPercentile = percentile;
          }
          historyMap.set(mapped.measuredAt, entry);
        }
      });
    };

    const [weightSnapshot, heightSnapshot, headSnapshot] = await Promise.all([
      db.collection('children').doc(childId).collection('measurements_weight').orderBy('measuredAt', 'desc').get(),
      db.collection('children').doc(childId).collection('measurements_height').orderBy('measuredAt', 'desc').get(),
      db.collection('children').doc(childId).collection('measurements_head').orderBy('measuredAt', 'desc').get()
    ]);

    mergeDedicated(weightSnapshot.docs, 'weightKg', mapWeightMeasurement, weightPoints);
    mergeDedicated(heightSnapshot.docs, 'heightCm', mapHeightMeasurement, heightPoints);
    mergeDedicated(headSnapshot.docs, 'headCm', mapHeadMeasurement, headPoints);

    const history = Array.from(historyMap.values()).sort((a, b) => {
      const dateA = parseDateSafe(a.measuredAt) || new Date(0);
      const dateB = parseDateSafe(b.measuredAt) || new Date(0);
      return dateB - dateA;
    });

    const latest = history[0] || null;

    res.json({
      success: true,
      data: {
        latest,
        history
      }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo resumen de mediciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo resumen de mediciones',
      error: error.message
    });
  }
});

// ==========================================
// 6.1.4 DENTICION (ERUPCION Y CAIDA DE DIENTES)
// ==========================================

const handleTeethingSummary = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }

    const birthDate = childData.birthDate || null;
    const currentAgeMonths = birthDate ? calculateAgeFromBirthDate(birthDate) : null;
    const snapshot = await db.collection('children').doc(childId)
      .collection('teething_events')
      .orderBy('occurredAt', 'desc')
      .get();

    const latestByTooth = new Map();
    const timeline = snapshot.docs.map(doc => {
      const data = doc.data();
      const occurredAt = parseDateSafe(data.occurredAt);
      const ageMonthsAtEvent = birthDate && occurredAt ? calculateAgeInMonthsAtDate(birthDate, occurredAt) : null;
      const entry = {
        id: doc.id,
        toothId: data.toothId,
        toothName: data.toothName || null,
        type: data.type,
        occurredAt: occurredAt ? occurredAt.toISOString() : null,
        symptoms: Array.isArray(data.symptoms) ? data.symptoms : [],
        notes: data.notes || null,
        createdBy: data.createdBy || null,
        ageMonths: ageMonthsAtEvent,
        notifyToothFairy: Boolean(data.notifyToothFairy)
      };
      if (!latestByTooth.has(entry.toothId)) {
        latestByTooth.set(entry.toothId, entry);
      }
      return entry;
    });

    const teeth = TEETH_DEFINITIONS.map(def => {
      const latest = latestByTooth.get(def.id) || null;
      return {
        ...def,
        status: latest ? latest.type : 'none',
        lastEvent: latest
      };
    });

    res.json({
      success: true,
      data: {
        childId,
        ageMonths: currentAgeMonths,
        teeth,
        timeline
      }
    });
  } catch (error) {
    console.error('‚ùå [TEETH] Error obteniendo resumen:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo resumen', error: error.message });
  }
};

const handleTeethingEventsList = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { month } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const birthDate = childData.birthDate || null;
    const snapshot = await db.collection('children').doc(childId)
      .collection('teething_events')
      .orderBy('occurredAt', 'desc')
      .get();
    let events = snapshot.docs.map(doc => {
      const data = doc.data();
      const occurredAt = parseDateSafe(data.occurredAt);
      const ageMonthsAtEvent = birthDate && occurredAt ? calculateAgeInMonthsAtDate(birthDate, occurredAt) : null;
      return {
        id: doc.id,
        toothId: data.toothId,
        toothName: data.toothName || null,
        type: data.type,
        occurredAt: occurredAt ? occurredAt.toISOString() : null,
        symptoms: Array.isArray(data.symptoms) ? data.symptoms : [],
        notes: data.notes || null,
        createdBy: data.createdBy || null,
        ageMonths: ageMonthsAtEvent,
        notifyToothFairy: Boolean(data.notifyToothFairy)
      };
    });

    if (month !== undefined) {
      const target = parseInt(month, 10);
      if (!Number.isNaN(target)) {
        events = events.filter(event => event.ageMonths === target);
      }
    }

    res.json({ success: true, data: events });
  } catch (error) {
    console.error('‚ùå [TEETH] Error listando eventos:', error);
    res.status(500).json({ success: false, message: 'Error listando eventos', error: error.message });
  }
};

const handleTeethingEventCreate = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const rawBody = req.body || {};
    const resolvedToothId = rawBody.toothId || rawBody.tooth || rawBody.toothKey || rawBody.id;
    const resolvedType = normalizeTeethingType(rawBody.type || rawBody.eventType || rawBody.status);
    const { occurredAt, symptoms, notes } = rawBody;
    if (!resolvedToothId || !resolvedType) {
      return res.status(400).json({ success: false, message: 'toothId y type son requeridos', details: { toothId: resolvedToothId || null, type: resolvedType || null } });
    }
    const toothDef = getToothDefinition(resolvedToothId);
    if (!toothDef) {
      return res.status(400).json({ success: false, message: 'toothId inv√°lido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const eventDate = parseDateSafe(occurredAt) || new Date();
    const ageMonthsAtEvent = childData.birthDate ? calculateAgeInMonthsAtDate(childData.birthDate, eventDate) : null;
    const notifyToothFairy = resolvedType === 'shed' && typeof ageMonthsAtEvent === 'number' && ageMonthsAtEvent >= 48;
    const payload = {
      toothId: resolvedToothId,
      toothName: toothDef.name,
      type: resolvedType,
      occurredAt: eventDate,
      symptoms: Array.isArray(symptoms) ? symptoms : [],
      notes: notes || null,
      notifyToothFairy,
      createdBy: { uid, name: req.user.name || req.user.email || 'Usuario' },
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('children').doc(childId)
      .collection('teething_events')
      .add(payload);

    if (notifyToothFairy && childData.parentId) {
      await db.collection('notifications').add({
        userId: childData.parentId,
        type: 'tooth_fairy',
        title: 'Raton Perez',
        body: `${childData.name || 'Tu hijo'} se le cayo un diente`,
        data: {
          childId,
          toothId,
          eventId: ref.id
        },
        read: false,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    }

    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [TEETH] Error creando evento:', error);
    res.status(500).json({ success: false, message: 'Error creando evento', error: error.message });
  }
};

const handleTeethingEventUpdate = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, eventId } = req.params;
    const rawBody = req.body || {};
    const { occurredAt, symptoms, notes } = rawBody;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    const eventRef = db.collection('children').doc(childId)
      .collection('teething_events').doc(eventId);
    const eventDoc = await eventRef.get();
    if (!eventDoc.exists) {
      return res.status(404).json({ success: false, message: 'Evento no encontrado' });
    }

    const updateData = { updatedAt: new Date() };
    if (rawBody.toothId !== undefined || rawBody.tooth !== undefined || rawBody.toothKey !== undefined || rawBody.id !== undefined) {
      const incomingToothId = rawBody.toothId || rawBody.tooth || rawBody.toothKey || rawBody.id;
      const toothDef = getToothDefinition(incomingToothId);
      if (!toothDef) {
        return res.status(400).json({ success: false, message: 'toothId inv√°lido' });
      }
      updateData.toothId = incomingToothId;
      updateData.toothName = toothDef.name;
    }
    if (rawBody.type !== undefined || rawBody.eventType !== undefined || rawBody.status !== undefined) {
      const normalizedType = normalizeTeethingType(rawBody.type || rawBody.eventType || rawBody.status);
      if (!normalizedType) {
        return res.status(400).json({ success: false, message: 'type inv√°lido' });
      }
      updateData.type = normalizedType;
    }
    if (occurredAt !== undefined) {
      const parsed = parseDateSafe(occurredAt);
      if (!parsed) {
        return res.status(400).json({ success: false, message: 'occurredAt inv√°lido' });
      }
      updateData.occurredAt = parsed;
    }
    if (symptoms !== undefined) {
      updateData.symptoms = Array.isArray(symptoms) ? symptoms : [];
    }
    if (notes !== undefined) updateData.notes = notes || null;

    const nextType = updateData.type || eventDoc.data().type;
    const nextOccurredAt = updateData.occurredAt || eventDoc.data().occurredAt;
    const ageMonthsAtEvent = childData.birthDate && nextOccurredAt
      ? calculateAgeInMonthsAtDate(childData.birthDate, nextOccurredAt)
      : null;
    const notifyToothFairy = nextType === 'shed' && typeof ageMonthsAtEvent === 'number' && ageMonthsAtEvent >= 48;
    updateData.notifyToothFairy = notifyToothFairy;

    await eventRef.update(stripUndefined(updateData));

    if (notifyToothFairy && childData.parentId && !eventDoc.data().notifyToothFairy) {
      await db.collection('notifications').add({
        userId: childData.parentId,
        type: 'tooth_fairy',
        title: 'Raton Perez',
        body: `${childData.name || 'Tu hijo'} se le cayo un diente`,
        data: {
          childId,
          toothId: updateData.toothId || eventDoc.data().toothId,
          eventId
        },
        read: false,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    }

    res.json({ success: true, data: { id: eventId, ...updateData } });
  } catch (error) {
    console.error('‚ùå [TEETH] Error actualizando evento:', error);
    res.status(500).json({ success: false, message: 'Error actualizando evento', error: error.message });
  }
};

const handleTeethingEventDelete = async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, eventId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists) {
      return res.status(404).json({ success: false, message: 'Hijo no encontrado' });
    }
    const childData = childDoc.data();
    const isOwner = childData.parentId === uid;
    const isShared = Array.isArray(childData.sharedWith) && childData.sharedWith.includes(uid);
    if (!isOwner && !isShared) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para acceder a este hijo' });
    }
    await db.collection('children').doc(childId)
      .collection('teething_events').doc(eventId).delete();
    res.json({ success: true, message: 'Evento eliminado' });
  } catch (error) {
    console.error('‚ùå [TEETH] Error eliminando evento:', error);
    res.status(500).json({ success: false, message: 'Error eliminando evento', error: error.message });
  }
};

app.get('/api/children/:childId/teething/summary', authenticateToken, handleTeethingSummary);
app.get('/children/:childId/teething/summary', authenticateToken, handleTeethingSummary);

app.get('/api/children/:childId/teething/events', authenticateToken, handleTeethingEventsList);
app.get('/children/:childId/teething/events', authenticateToken, handleTeethingEventsList);

app.post('/api/children/:childId/teething/events', authenticateToken, handleTeethingEventCreate);
app.post('/children/:childId/teething/events', authenticateToken, handleTeethingEventCreate);

app.put('/api/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventUpdate);
app.put('/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventUpdate);

app.delete('/api/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventDelete);
app.delete('/children/:childId/teething/events/:eventId', authenticateToken, handleTeethingEventDelete);

// ==========================================
// 6.2 CURVAS DE CRECIMIENTO (PERCENTILES)
// ==========================================

const interpolatePercentile = (points, ageWeeks) => {
  if (!points || points.length === 0) return null;
  const sorted = [...points].sort((a, b) => a.ageWeeks - b.ageWeeks);
  const exact = sorted.find(point => point.ageWeeks === ageWeeks);
  if (exact) return exact;
  let lower = null;
  let upper = null;
  for (const point of sorted) {
    if (point.ageWeeks < ageWeeks) lower = point;
    if (point.ageWeeks > ageWeeks) {
      upper = point;
      break;
    }
  }
  if (!lower) return sorted[0];
  if (!upper) return sorted[sorted.length - 1];
  const range = upper.ageWeeks - lower.ageWeeks;
  const ratio = range === 0 ? 0 : (ageWeeks - lower.ageWeeks) / range;
  const lerp = (a, b) => a + (b - a) * ratio;
  return {
    ageWeeks,
    p3: lerp(lower.p3, upper.p3),
    p10: lower.p10 !== undefined && upper.p10 !== undefined ? lerp(lower.p10, upper.p10) : undefined,
    p25: lower.p25 !== undefined && upper.p25 !== undefined ? lerp(lower.p25, upper.p25) : undefined,
    p50: lerp(lower.p50, upper.p50),
    p75: lower.p75 !== undefined && upper.p75 !== undefined ? lerp(lower.p75, upper.p75) : undefined,
    p90: lower.p90 !== undefined && upper.p90 !== undefined ? lerp(lower.p90, upper.p90) : undefined,
    p97: lerp(lower.p97, upper.p97)
  };
};

const buildDefaultPercentiles = (sex, type) => {
  const presets = {
    weight: {
      F: { start: { p3: 2.4, p50: 3.2, p97: 4.0 }, end: { p3: 5.8, p50: 7.2, p97: 8.6 } },
      M: { start: { p3: 2.5, p50: 3.3, p97: 4.1 }, end: { p3: 6.0, p50: 7.5, p97: 9.0 } }
    },
    height: {
      F: { start: { p3: 46.5, p50: 49.1, p97: 52.0 }, end: { p3: 60.5, p50: 65.0, p97: 69.5 } },
      M: { start: { p3: 47.0, p50: 49.9, p97: 53.0 }, end: { p3: 61.5, p50: 66.5, p97: 71.0 } }
    },
    head: {
      F: { start: { p3: 32.0, p50: 34.0, p97: 36.0 }, end: { p3: 40.0, p50: 42.0, p97: 44.0 } },
      M: { start: { p3: 32.5, p50: 34.5, p97: 36.5 }, end: { p3: 40.5, p50: 42.5, p97: 44.5 } }
    }
  };

  const preset = presets[type]?.[sex];
  if (!preset) return [];

  const points = [];
  const totalWeeks = 26;
  for (let week = 0; week <= totalWeeks; week += 1) {
    const ratio = totalWeeks === 0 ? 0 : week / totalWeeks;
    const lerp = (a, b) => a + (b - a) * ratio;
    points.push({
      ageWeeks: week,
      p3: lerp(preset.start.p3, preset.end.p3),
      p50: lerp(preset.start.p50, preset.end.p50),
      p97: lerp(preset.start.p97, preset.end.p97)
    });
  }
  return points;
};

const normalizeChildSex = (childData) => {
  if (!childData) return null;
  const raw = String(childData.sex || childData.gender || '').toLowerCase().trim();
  if (!raw) return null;
  if (['m', 'male', 'masculino', 'ni√±o', 'nino', 'boy'].includes(raw)) return 'M';
  if (['f', 'female', 'femenino', 'ni√±a', 'nina', 'girl'].includes(raw)) return 'F';
  return null;
};

const calculateWeeksBetweenDates = (startDate, endDate) => {
  const start = parseDateSafe(startDate);
  const end = parseDateSafe(endDate);
  if (!start || !end) return null;
  const diffMs = end.getTime() - start.getTime();
  if (diffMs < 0) return null;
  const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
  return Math.max(0, Math.floor(diffDays / 7));
};

const estimatePercentileFromPoint = (value, curvePoint) => {
  if (value === null || value === undefined || !curvePoint) return null;
  const pairs = [
    { percentile: 3, value: curvePoint.p3 },
    { percentile: 10, value: curvePoint.p10 },
    { percentile: 25, value: curvePoint.p25 },
    { percentile: 50, value: curvePoint.p50 },
    { percentile: 75, value: curvePoint.p75 },
    { percentile: 90, value: curvePoint.p90 },
    { percentile: 97, value: curvePoint.p97 }
  ].filter(entry => entry.value !== undefined && entry.value !== null)
    .sort((a, b) => a.value - b.value);

  if (pairs.length === 0) return null;
  if (value <= pairs[0].value) return pairs[0].percentile;
  if (value >= pairs[pairs.length - 1].value) return pairs[pairs.length - 1].percentile;

  for (let i = 0; i < pairs.length - 1; i += 1) {
    const lower = pairs[i];
    const upper = pairs[i + 1];
    if (value >= lower.value && value <= upper.value) {
      const range = upper.value - lower.value;
      const ratio = range === 0 ? 0 : (value - lower.value) / range;
      const percentile = lower.percentile + (upper.percentile - lower.percentile) * ratio;
      return Math.round(percentile * 10) / 10;
    }
  }
  return null;
};

const getGrowthPercentilePoints = async (sex, type) => {
  if (!db) return buildDefaultPercentiles(sex, type);
  const snapshot = await db.collection('growth_percentiles')
    .where('type', '==', type)
    .where('sex', '==', sex)
    .limit(1)
    .get();
  if (snapshot.empty) return buildDefaultPercentiles(sex, type);
  const data = snapshot.docs[0].data();
  return Array.isArray(data.points) ? data.points : [];
};

// Obtener curvas de percentiles por sexo y edad
app.get('/api/growth/percentiles', authenticateToken, async (req, res) => {
  try {
    const { sex, ageWeeks, type } = req.query;
    const sexValue = String(sex || '').toUpperCase();
    const typeValue = String(type || 'weight').toLowerCase();
    if (!sexValue || !['M', 'F'].includes(sexValue)) {
      return res.status(400).json({
        success: false,
        message: 'sex es requerido (M o F)'
      });
    }
    if (!['weight', 'height', 'head'].includes(typeValue)) {
      return res.status(400).json({
        success: false,
        message: 'type debe ser weight, height o head'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('growth_percentiles')
      .where('type', '==', typeValue)
      .where('sex', '==', sexValue)
      .limit(1)
      .get();

    if (snapshot.empty) {
      const fallbackPoints = buildDefaultPercentiles(sexValue, typeValue);
      return res.json({
        success: true,
        data: fallbackPoints,
        meta: { sex: sexValue, type: typeValue, empty: true, synthetic: true },
        message: 'Curvas de percentiles no configuradas'
      });
    }

    const curve = snapshot.docs[0].data();
    const points = Array.isArray(curve.points) ? curve.points : [];

    if (ageWeeks !== undefined) {
      const ageNumber = parseFloat(ageWeeks);
      if (Number.isNaN(ageNumber)) {
        return res.status(400).json({
          success: false,
          message: 'ageWeeks debe ser num√©rico'
        });
      }
      const interpolated = interpolatePercentile(points, ageNumber);
      return res.json({
        success: true,
        data: interpolated,
        meta: { sex: sexValue, type: typeValue }
      });
    }

    res.json({
      success: true,
      data: points,
      meta: { sex: sexValue, type: typeValue }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo percentiles:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo percentiles',
      error: error.message
    });
  }
});

// ==========================================
// 6. HITOS - UPDATE & DELETE
// ==========================================

// Actualizar hito
app.put('/api/children/:childId/milestones/:milestoneId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;
    const { type, title, date, description, photos, celebrationEmoji } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = {};
    if (type !== undefined) updateData.type = type;
    if (title !== undefined) updateData.title = title;
    if (date !== undefined) updateData.date = new Date(date);
    if (description !== undefined) updateData.description = description;
    if (photos !== undefined) updateData.photos = photos;
    if (celebrationEmoji !== undefined) updateData.celebrationEmoji = celebrationEmoji;

    await db.collection('children').doc(childId)
      .collection('milestones').doc(milestoneId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Hito actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando hito',
      error: error.message
    });
  }
});

// Eliminar hito
app.delete('/api/children/:childId/milestones/:milestoneId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('milestones').doc(milestoneId)
      .delete();

    res.json({
      success: true,
      message: 'Hito eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hito',
      error: error.message
    });
  }
});

// ==========================================
// 7. DIARIO - UPDATE & DELETE
// ==========================================

// Actualizar entrada del diario
app.put('/api/children/:childId/diary/:diaryId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, diaryId } = req.params;
    const { date, title, content, mood, photos, tags } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (date !== undefined) updateData.date = new Date(date);
    if (title !== undefined) updateData.title = title;
    if (content !== undefined) updateData.content = content;
    if (mood !== undefined) updateData.mood = mood;
    if (photos !== undefined) updateData.photos = photos;
    if (tags !== undefined) updateData.tags = tags;

    await db.collection('children').doc(childId)
      .collection('diary').doc(diaryId)
      .update(updateData);

    res.json({
      success: true,
      message: 'Entrada del diario actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando entrada del diario',
      error: error.message
    });
  }
});

// Eliminar entrada del diario
app.delete('/api/children/:childId/diary/:diaryId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, diaryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('diary').doc(diaryId)
      .delete();

    res.json({
      success: true,
      message: 'Entrada del diario eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando entrada del diario:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando entrada del diario',
      error: error.message
    });
  }
});

// ==========================================
// 8. √ÅLBUMES - UPDATE & DELETE
// ==========================================

// Actualizar √°lbum
app.put('/api/children/:childId/albums/:albumId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;
    const { name, description, coverPhoto, theme } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const updateData = { updatedAt: new Date() };
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (coverPhoto !== undefined) updateData.coverPhoto = coverPhoto;
    if (theme !== undefined) updateData.theme = theme;

    await db.collection('children').doc(childId)
      .collection('albums').doc(albumId)
      .update(updateData);

    res.json({
      success: true,
      message: '√Ålbum actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå Error actualizando √°lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando √°lbum',
      error: error.message
    });
  }
});

// Eliminar √°lbum
app.delete('/api/children/:childId/albums/:albumId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, albumId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const childDoc = await db.collection('children').doc(childId).get();
    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    await db.collection('children').doc(childId)
      .collection('albums').doc(albumId)
      .delete();

    res.json({
      success: true,
      message: '√Ålbum eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå Error eliminando √°lbum:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando √°lbum',
      error: error.message
    });
  }
});

// ==========================================
// FIN DE ENDPOINTS CRUD ADICIONALES
// ==========================================




// Iniciar servidor
app.listen(PORT, () => {
  console.log(`üöÄ Servidor corriendo en puerto ${PORT}`);
  console.log(`üì± Ambiente: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üîó URL: http://localhost:${PORT}`);
  console.log(`üî• Firebase: ${firebaseStatus}`);
});

// Manejo de se√±ales para cierre graceful
process.on('SIGTERM', () => {
  console.log('SIGTERM recibido, cerrando servidor...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT recibido, cerrando servidor...');
  process.exit(0);
});

module.exports = app;

// ===== SISTEMA DE APRENDIZAJE CONTINUO (RAG) =====

// Funci√≥n para guardar conocimiento en el vector store (simulado en Firestore)
const saveKnowledge = async (text, metadata = {}) => {
  try {
    if (!db) return false;
    
    const knowledgeDoc = {
      text: text,
      metadata: {
        source: metadata.source || 'manual',
        topic: metadata.topic || 'general',
        stage: metadata.stage || 'general', // embarazo|posparto|lactancia|general
        version: metadata.version || '1.0',
        language: metadata.language || 'es',
        createdBy: metadata.createdBy || 'system',
        createdAt: new Date(),
        qualityScore: metadata.qualityScore || 1.0
      },
      // Simulaci√≥n de embedding (en producci√≥n usar√≠as un servicio real)
      embedding: [0.1, 0.2, 0.3], // Placeholder
      isActive: true
    };
    
    await db.collection('knowledge_base').add(knowledgeDoc);
    console.log('üíæ [RAG] Conocimiento guardado:', metadata.topic);
    return true;
  } catch (error) {
    console.error('‚ùå [RAG] Error guardando conocimiento:', error);
    return false;
  }
};

// Funci√≥n para recuperar conocimiento relevante
const retrieveKnowledge = async (query, filters = {}) => {
  try {
    if (!db) return [];
    
    let queryRef = db.collection('knowledge_base').where('isActive', '==', true);
    
    // Aplicar filtros
    if (filters.stage) {
      queryRef = queryRef.where('metadata.stage', '==', filters.stage);
    }
    if (filters.topic) {
      queryRef = queryRef.where('metadata.topic', '==', filters.topic);
    }
    if (filters.language) {
      queryRef = queryRef.where('metadata.language', '==', filters.language);
    }
    
    const snapshot = await queryRef.orderBy('metadata.qualityScore', 'desc').limit(5).get();
    
    const knowledge = [];
    snapshot.forEach(doc => {
      knowledge.push({
        id: doc.id,
        ...doc.data()
      });
    });
    
    console.log('üîç [RAG] Conocimiento recuperado:', knowledge.length, 'fragmentos');
    return knowledge;
  } catch (error) {
    console.error('‚ùå [RAG] Error recuperando conocimiento:', error);
    return [];
  }
};

// Funci√≥n para guardar memoria del usuario
const saveUserMemory = async (userId, memoryData) => {
  try {
    if (!db) return false;
    
    const memoryDoc = {
      userId: userId,
      profile: memoryData.profile || {},
      notes: memoryData.notes || [],
      preferences: memoryData.preferences || {},
      lastUpdated: new Date()
    };
    
    await db.collection('user_memory').doc(userId).set(memoryDoc, { merge: true });
    console.log('üíæ [MEMORY] Memoria guardada para usuario:', userId);
    return true;
  } catch (error) {
    console.error('‚ùå [MEMORY] Error guardando memoria:', error);
    return false;
  }
};

// Funci√≥n para obtener memoria del usuario
const getUserMemory = async (userId) => {
  try {
    if (!db) return null;
    
    const memoryDoc = await db.collection('user_memory').doc(userId).get();
    
    if (memoryDoc.exists) {
      console.log('üîç [MEMORY] Memoria recuperada para usuario:', userId);
      return memoryDoc.data();
    }
    
    return null;
  } catch (error) {
    console.error('‚ùå [MEMORY] Error obteniendo memoria:', error);
    return null;
  }
};

// Funci√≥n para guardar Q&A validado
const saveValidatedQA = async (question, answer, tags = [], qualityScore = 1.0) => {
  try {
    if (!db) return false;
    
    const qaDoc = {
      question: question,
      answer: answer,
      tags: tags,
      qualityScore: qualityScore,
      createdAt: new Date(),
      isActive: true,
      usageCount: 0
    };
    
    await db.collection('validated_qa').add(qaDoc);
    console.log('üíæ [QA] Q&A validado guardado');
    return true;
  } catch (error) {
    console.error('‚ùå [QA] Error guardando Q&A:', error);
    return false;
  }
};

// Funci√≥n para guardar feedback del usuario
const saveFeedback = async (userId, conversationId, feedback) => {
  try {
    if (!db) return false;
    
    const feedbackDoc = {
      userId: userId,
      conversationId: conversationId,
      feedback: feedback, // 'positive' | 'negative'
      timestamp: new Date(),
      processed: false
    };
    
    await db.collection('user_feedback').add(feedbackDoc);
    console.log('üíæ [FEEDBACK] Feedback guardado:', feedback);
    return true;
  } catch (error) {
    console.error('‚ùå [FEEDBACK] Error guardando feedback:', error);
    return false;
  }
};

// ============================================================================
// üõçÔ∏è MARKETPLACE - SISTEMA DE COMPRA/VENTA/DONACI√ìN/TRUEQUE
// ============================================================================

// Categor√≠as permitidas para productos
const MARKETPLACE_CATEGORIES = [
  'transporte',     // Carriolas, sillas de auto
  'ropa',          // Ropa de beb√©, mam√°
  'juguetes',      // Juguetes educativos
  'alimentacion',  // Biberones, extractores
  'muebles',       // Cunas, cambiadores
  'higiene',       // Ba√±eras, pa√±aleras
  'libros',        // Libros infantiles
  'maternidad',    // Ropa de embarazo
  'electronica',   // Monitores, calentadores
  'otros'          // Otros art√≠culos
];

// Condiciones del producto
const PRODUCT_CONDITIONS = [
  'nuevo',
  'como_nuevo',
  'buen_estado',
  'usado'
];

// Tipos de transacci√≥n
const TRANSACTION_TYPES = [
  'venta',
  'donacion',
  'trueque'
];

// Estados del producto
const PRODUCT_STATUS = [
  'disponible',
  'reservado',
  'vendido',
  'donado',
  'intercambiado',
  'eliminado'
];

// ============================================================================
// üì± ENDPOINTS PARA USUARIOS - MARKETPLACE
// ============================================================================

// üîç ENDPOINT DE DEBUGGING - Mostrar TODOS los productos sin filtros
app.get('/api/marketplace/products/debug', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener TODOS los productos sin ning√∫n filtro
    const snapshot = await db.collection('marketplace_products')
      .orderBy('createdAt', 'desc')
      .limit(50)
      .get();

    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      // Convertir timestamps a formato legible
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt,
      updatedAt: doc.data().updatedAt?.toDate?.() || doc.data().updatedAt,
    }));

    console.log('üîç [DEBUG] Total de productos en Firebase:', products.length);
    
    res.json({
      success: true,
      message: 'Endpoint de debugging - TODOS los productos sin filtros',
      total: products.length,
      data: products
    });

  } catch (error) {
    console.error('‚ùå [DEBUG] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Obtener lista de productos con filtros
app.get('/api/marketplace/products', authenticateToken, async (req, res) => {
  try {
    const { 
      type,           // venta, donacion, trueque
      category,       // transporte, ropa, etc.
      status,         // disponible, vendido, etc.
      minPrice,
      maxPrice,
      search,         // b√∫squeda en t√≠tulo/descripci√≥n
      orderBy,        // reciente, precio_asc, precio_desc
      page = 1,
      limit = 20,
      userId,         // Filtrar por usuario espec√≠fico
      latitude,
      longitude
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);

    let query = db.collection('marketplace_products');
    if (userLocation.countryId) {
      query = query.where('countryId', '==', userLocation.countryId);
    }

    // Aplicar filtros
    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    // Filtrar por categor√≠a (ahora din√°mica desde Firestore)
    // Soporta tanto slug como ID de categor√≠a
    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      
      // Si no parece ser un ID de Firestore (muy corto o tiene guiones), buscar por slug
      if (category.length < 15 || category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category.toLowerCase())
            .limit(1)
            .get();
          
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error buscando categor√≠a por slug:', error);
        }
      }
      
      // Solo aplicar filtro si encontramos una categor√≠a v√°lida
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    console.log('üîç [MARKETPLACE] Filtros recibidos:', { status, userId, category, type, minPrice, maxPrice, search, orderBy });
    
    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
      console.log('‚úÖ [MARKETPLACE] Filtrando por status:', status);
    } else {
      // Por defecto, solo mostrar productos disponibles
      query = query.where('status', '==', 'disponible');
      console.log('‚úÖ [MARKETPLACE] Filtrando por status por defecto: disponible');
    }

    if (userId) {
      query = query.where('userId', '==', userId);
      console.log('‚úÖ [MARKETPLACE] Filtrando por userId:', userId);
    }

    // Filtro de aprobaci√≥n (deshabilitado temporalmente para compatibilidad)
    // Los productos antiguos sin isApproved se mostrar√°n
    // TODO: En producci√≥n, habilitar: query = query.where('isApproved', '==', true);

    // Ordenamiento
    switch (orderBy) {
      case 'precio_asc':
        query = query.orderBy('price', 'asc');
        break;
      case 'precio_desc':
        query = query.orderBy('price', 'desc');
        break;
      case 'reciente':
      default:
        query = query.orderBy('createdAt', 'desc');
        break;
    }

    // Ejecutar query
    const snapshot = await query.get();
    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const hasUserLocation = !isNaN(userLat) && !isNaN(userLng);

    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    // Filtro de precio (Firestore no permite where con != null)
    if (minPrice !== undefined) {
      const min = parseFloat(minPrice);
      products = products.filter(p => p.price >= min);
    }

    if (maxPrice !== undefined) {
      const max = parseFloat(maxPrice);
      products = products.filter(p => p.price <= max);
    }

    // B√∫squeda en texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p => 
        p.title.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Ordenar por distancia si hay ubicaci√≥n del usuario
    if (hasUserLocation && (!orderBy || orderBy === 'distancia')) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => ({
          ...p,
          distance: calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          )
        }))
        .sort((a, b) => a.distance - b.distance);
    }

    // Logging de productos encontrados
    console.log(`üìä [MARKETPLACE] Productos encontrados: ${products.length}`);
    if (products.length > 0) {
      const statusCounts = products.reduce((acc, p) => {
        acc[p.status] = (acc[p.status] || 0) + 1;
        return acc;
      }, {});
      console.log('üìä [MARKETPLACE] Distribuci√≥n por status:', statusCounts);
    }
    
    // Paginaci√≥n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    console.log(`üìÑ [MARKETPLACE] Devolviendo p√°gina ${page}: ${paginatedProducts.length} productos (de ${total} totales)`);

    res.json({
      success: true,
      data: paginatedProducts,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});
// Buscar productos cercanos (por proximidad geogr√°fica)
app.get('/api/marketplace/products/nearby', authenticateToken, async (req, res) => {
  try {
    const cacheKey = `${buildCacheKey(req)}&uid=${req.user.uid}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const {
      latitude,
      longitude,
      radius = 50,    // Radio en kil√≥metros (por defecto 50 km)
      type,
      category,
      status,
      minPrice,
      maxPrice,
      search,
      orderBy,
      page = 1,
      limit = 20
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);
    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const searchRadius = parseFloat(radius);
    const hasUserLocation = !isNaN(userLat) && !isNaN(userLng);

    if ((latitude || longitude) && !hasUserLocation) {
      return res.status(400).json({
        success: false,
        message: 'Latitude y longitude deben ser n√∫meros v√°lidos'
      });
    }
    // Funci√≥n para calcular distancia entre dos puntos (f√≥rmula de Haversine)
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371; // Radio de la Tierra en km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // Distancia en km
    };

    let query = db.collection('marketplace_products');

    // Aplicar filtros b√°sicos
    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    // Filtrar por categor√≠a (ahora din√°mica desde Firestore)
    // Soporta tanto slug como ID de categor√≠a
    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      
      // Si no parece ser un ID de Firestore (muy corto o tiene guiones), buscar por slug
      if (category.length < 15 || category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category.toLowerCase())
            .limit(1)
            .get();
          
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error buscando categor√≠a por slug:', error);
        }
      }
      
      // Solo aplicar filtro si encontramos una categor√≠a v√°lida
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    } else {
      query = query.where('status', '==', 'disponible');
    }

    // Filtro de aprobaci√≥n (deshabilitado temporalmente para compatibilidad)
    // Los productos antiguos sin isApproved se mostrar√°n
    // TODO: En producci√≥n, habilitar: query = query.where('isApproved', '==', true);

    // Obtener todos los productos
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    if (hasUserLocation && (!orderBy || orderBy === 'distancia')) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => ({
          ...p,
          distance: calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          )
        }))
        .filter(p => p.distance <= parseFloat(radius));
    }

    // Filtrar por distancia y calcular distancia para cada producto
    products = products
      .filter(p => p.location && p.location.latitude && p.location.longitude)
      .map(p => {
        const distance = calculateDistance(
          userLat, 
          userLng, 
          p.location.latitude, 
          p.location.longitude
        );
        return { ...p, distance };
      })
      .filter(p => p.distance <= searchRadius);

    // Filtro de precio
    if (minPrice !== undefined) {
      const min = parseFloat(minPrice);
      products = products.filter(p => p.price >= min);
    }

    if (maxPrice !== undefined) {
      const max = parseFloat(maxPrice);
      products = products.filter(p => p.price <= max);
    }

    // B√∫squeda en texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p => 
        p.title.toLowerCase().includes(searchLower) ||
        p.description.toLowerCase().includes(searchLower)
      );
    }

    // Ordenamiento
    const orderByNormalized = orderBy || 'distancia';
    switch (orderByNormalized) {
      case 'distancia':
        products.sort((a, b) => a.distance - b.distance);
        break;
      case 'precio_asc':
        products.sort((a, b) => (a.price || 0) - (b.price || 0));
        break;
      case 'precio_desc':
        products.sort((a, b) => (b.price || 0) - (a.price || 0));
        break;
      case 'reciente':
      default:
        products.sort((a, b) => b.createdAt.seconds - a.createdAt.seconds);
        break;
    }

    // Paginaci√≥n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    const responsePayload = {
      success: true,
      data: paginatedProducts,
      searchParams: {
        latitude: userLat,
        longitude: userLng,
        radius: searchRadius
      },
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error buscando productos cercanos:', error);
    res.status(500).json({
      success: false,
      message: 'Error buscando productos cercanos',
      error: error.message
    });
  }
});

// Top productos cercanos por vistas (APP)
app.get('/api/marketplace/products/nearby/top', authenticateToken, async (req, res) => {
  try {
    const cacheKey = `${buildCacheKey(req)}&uid=${req.user.uid}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      return res.json(cached);
    }

    const {
      latitude,
      longitude,
      radius = 50,
      type,
      category,
      status,
      limit = 3
    } = req.query;

    const userLat = latitude ? parseFloat(latitude) : null;
    const userLng = longitude ? parseFloat(longitude) : null;
    const searchRadius = parseFloat(radius);
    const limitNumber = Math.min(parseInt(limit), 10);

    if ((latitude || longitude) && (isNaN(userLat) || userLat < -90 || userLat > 90)) {
      return res.status(400).json({
        success: false,
        message: 'Latitud inv√°lida'
      });
    }

    if ((latitude || longitude) && (isNaN(userLng) || userLng < -180 || userLng > 180)) {
      return res.status(400).json({
        success: false,
        message: 'Longitud inv√°lida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    };

    let query = db.collection('marketplace_products');

    if (type && TRANSACTION_TYPES.includes(type)) {
      query = query.where('type', '==', type);
    }

    let categoryIdToFilter = null;
    if (category) {
      categoryIdToFilter = category;
      if (typeof category === 'string' && category.includes('-')) {
        try {
          const categoryQuery = await db.collection('marketplace_categories')
            .where('slug', '==', category)
            .limit(1)
            .get();
          if (!categoryQuery.empty) {
            categoryIdToFilter = categoryQuery.docs[0].id;
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error buscando categor√≠a por slug:', error);
        }
      }
      if (categoryIdToFilter) {
        query = query.where('category', '==', categoryIdToFilter);
      }
    }

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    } else {
      query = query.where('status', '==', 'disponible');
    }

    const userLocation = await getUserCountryForMarketplace(req.user.uid);
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => {
      const data = doc.data();
      const location = normalizeMarketplaceLocation(data);
      return {
        id: doc.id,
        ...data,
        location
      };
    });

    products = products.filter(p => p.countryId && p.countryId === userLocation.countryId);

    if (!isNaN(userLat) && !isNaN(userLng)) {
      products = products
        .filter(p => p.location && p.location.latitude && p.location.longitude)
        .map(p => {
          const distance = calculateDistance(
            userLat,
            userLng,
            p.location.latitude,
            p.location.longitude
          );
          return { ...p, distance };
        })
        .filter(p => p.distance <= searchRadius);
    }

    products.sort((a, b) => {
      const aViews = a.views || 0;
      const bViews = b.views || 0;
      if (bViews !== aViews) return bViews - aViews;
      if (a.distance !== b.distance) return a.distance - b.distance;
      return (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0);
    });

    const topProducts = products.slice(0, limitNumber);

    const responsePayload = {
      success: true,
      data: topProducts,
      meta: {
        latitude: !isNaN(userLat) ? userLat : null,
        longitude: !isNaN(userLng) ? userLng : null,
        radius: searchRadius,
        limit: limitNumber
      }
    };

    setCachedResponse(cacheKey, responsePayload);
    res.json(responsePayload);
  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo top productos cercanos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo top productos cercanos',
      error: error.message
    });
  }
});

// Obtener detalle de un producto espec√≠fico
app.get('/api/marketplace/products/:id', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    
    // Enriquecer con informaci√≥n actualizada del vendedor
    const sellerDoc = await db.collection('users').doc(productData.userId).get();
    let enrichedProduct = {
      id: productDoc.id,
      ...productData,
      location: normalizeMarketplaceLocation(productData)
    };
    
    if (sellerDoc.exists) {
      const sellerData = sellerDoc.data();
      enrichedProduct.userName = sellerData.displayName || sellerData.name || productData.userName || 'Usuario';
      enrichedProduct.userPhoto = sellerData.photoUrl || productData.userPhoto || null;
      console.log(`‚úÖ [MARKETPLACE] Producto ${id} enriquecido con info del vendedor: ${enrichedProduct.userName}`);
    } else {
      console.log(`‚ö†Ô∏è [MARKETPLACE] Vendedor ${productData.userId} no encontrado para producto ${id}`);
    }

    // Incrementar contador de vistas
    await db.collection('marketplace_products').doc(id).update({
      views: admin.firestore.FieldValue.increment(1)
    });

    res.json({
      success: true,
      data: enrichedProduct
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo producto',
      error: error.message
    });
  }
});

// Crear nuevo producto
app.post('/api/marketplace/products', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const {
      title,
      description,
      category,
      condition,
      photos,
      type,
      price,
      tradeFor,
      location,
      cityId,
      countryId
    } = req.body;

    // Validaciones
    if (!title || title.trim().length < 10 || title.trim().length > 100) {
      return res.status(400).json({
        success: false,
        message: 'El t√≠tulo debe tener entre 10 y 100 caracteres'
      });
    }

    if (!description || description.trim().length < 20 || description.trim().length > 1000) {
      return res.status(400).json({
        success: false,
        message: 'La descripci√≥n debe tener entre 20 y 1000 caracteres'
      });
    }

    // Validar categor√≠a din√°mica desde Firestore
    if (!category) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la categor√≠a existe y est√° activa (buscar por slug o por ID)
    let categoryDoc;
    let categoryId;
    
    // Primero intentar buscar por ID
    categoryDoc = await db.collection('marketplace_categories').doc(category).get();
    
    if (categoryDoc.exists) {
      categoryId = categoryDoc.id;
    } else {
      // Si no existe por ID, buscar por slug
      const categoryQuery = await db.collection('marketplace_categories')
        .where('slug', '==', category.toLowerCase())
        .limit(1)
        .get();
      
      if (categoryQuery.empty) {
        return res.status(400).json({
          success: false,
          message: 'Categor√≠a inv√°lida o no existe'
        });
      }
      
      categoryDoc = categoryQuery.docs[0];
      categoryId = categoryDoc.id;
    }

    const categoryData = categoryDoc.data();
    if (!categoryData.isActive) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a no est√° disponible'
      });
    }

    if (!condition || !PRODUCT_CONDITIONS.includes(condition)) {
      return res.status(400).json({
        success: false,
        message: 'Condici√≥n del producto inv√°lida'
      });
    }

    if (!photos || !Array.isArray(photos) || photos.length === 0 || photos.length > 5) {
      return res.status(400).json({
        success: false,
        message: 'Debes subir entre 1 y 5 fotos'
      });
    }

    if (!type || !TRANSACTION_TYPES.includes(type)) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de transacci√≥n inv√°lido'
      });
    }

    if (type === 'venta') {
      if (!price || price <= 0) {
        return res.status(400).json({
          success: false,
          message: 'El precio es requerido para ventas y debe ser mayor a 0'
        });
      }
    }

    if (type === 'trueque') {
      if (!tradeFor || tradeFor.trim().length < 5) {
        return res.status(400).json({
          success: false,
          message: 'Debes especificar qu√© buscas a cambio'
        });
      }
    }

    let locationData = { countryId: null, countryName: null, cityId: null, cityName: null };
    if (!cityId && !countryId) {
      locationData = await getDefaultUserLocation();
    } else {
      try {
        locationData = await resolveCountryCity(countryId, cityId);
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    let normalizedLocation = {
      city: locationData.cityName || '',
      state: '',
      country: locationData.countryName || null
    };
    if (location && typeof location === 'object') {
      const hasLat = location.latitude !== undefined && location.latitude !== null;
      const hasLng = location.longitude !== undefined && location.longitude !== null;
      normalizedLocation.city = location.city || locationData.cityName || '';
      normalizedLocation.state = location.state || '';
      normalizedLocation.country = location.country || locationData.countryName || null;
      if (hasLat || hasLng) {
        const lat = parseFloat(location.latitude);
        const lng = parseFloat(location.longitude);
        if (!isNaN(lat) && !isNaN(lng)) {
          normalizedLocation.latitude = lat;
          normalizedLocation.longitude = lng;
        }
      }
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener informaci√≥n del usuario
    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();

    // Crear producto
    const now = new Date();
    const productData = {
      userId: uid,
      userName: userData?.displayName || userData?.name || 'Usuario',
      userPhoto: userData?.photoUrl || null,
      
      title: title.trim(),
      description: description.trim(),
      category: categoryId,  // Guardar el ID real de la categor√≠a
      categoryName: categoryData.name,  // Guardar el nombre para facilitar consultas
      categorySlug: categoryData.slug,  // Guardar el slug para referencia
      condition,
      photos,
      
      type,
      price: type === 'venta' ? parseFloat(price) : null,
      tradeFor: type === 'trueque' ? tradeFor.trim() : null,
      
      location: normalizedLocation,
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      
      status: 'disponible',
      
      views: 0,
      favorites: 0,
      messages: 0,
      
      createdAt: now,
      updatedAt: now,
      publishedAt: now,
      soldAt: null,
      
      isApproved: true,  // Auto-aprobar por ahora
      isReported: false,
      reportCount: 0
    };

    const productRef = await db.collection('marketplace_products').add(productData);

    console.log('‚úÖ [MARKETPLACE] Producto creado:', productRef.id);

    res.json({
      success: true,
      message: 'Producto publicado exitosamente',
      data: {
        id: productRef.id,
        ...productData
      }
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error creando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando producto',
      error: error.message
    });
  }
});

// Actualizar producto propio
app.put('/api/marketplace/products/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;
    const {
      title,
      description,
      category,
      condition,
      photos,
      price,
      tradeFor,
      location,
      cityId,
      countryId
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el producto existe y pertenece al usuario
    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para editar este producto'
      });
    }

    // Preparar datos de actualizaci√≥n
    const updateData = {
      updatedAt: new Date()
    };

    if (title) {
      if (title.trim().length < 10 || title.trim().length > 100) {
        return res.status(400).json({
          success: false,
          message: 'El t√≠tulo debe tener entre 10 y 100 caracteres'
        });
      }
      updateData.title = title.trim();
    }

    if (description) {
      if (description.trim().length < 20 || description.trim().length > 1000) {
        return res.status(400).json({
          success: false,
          message: 'La descripci√≥n debe tener entre 20 y 1000 caracteres'
        });
      }
      updateData.description = description.trim();
    }

    if (category) {
      // Verificar que la categor√≠a existe y est√° activa (buscar por slug o por ID)
      let categoryDoc;
      let categoryId;
      
      // Primero intentar buscar por ID
      categoryDoc = await db.collection('marketplace_categories').doc(category).get();
      
      if (categoryDoc.exists) {
        categoryId = categoryDoc.id;
      } else {
        // Si no existe por ID, buscar por slug
        const categoryQuery = await db.collection('marketplace_categories')
          .where('slug', '==', category.toLowerCase())
          .limit(1)
          .get();
        
        if (categoryQuery.empty) {
          return res.status(400).json({
            success: false,
            message: 'Categor√≠a inv√°lida o no existe'
          });
        }
        
        categoryDoc = categoryQuery.docs[0];
        categoryId = categoryDoc.id;
      }

      const categoryData = categoryDoc.data();
      if (!categoryData.isActive) {
        return res.status(400).json({
          success: false,
          message: 'La categor√≠a no est√° disponible'
        });
      }

      updateData.category = categoryId;
      updateData.categoryName = categoryData.name;
      updateData.categorySlug = categoryData.slug;
    }

    if (condition) {
      if (!PRODUCT_CONDITIONS.includes(condition)) {
        return res.status(400).json({
          success: false,
          message: 'Condici√≥n del producto inv√°lida'
        });
      }
      updateData.condition = condition;
    }

    if (photos) {
      if (!Array.isArray(photos) || photos.length === 0 || photos.length > 5) {
        return res.status(400).json({
          success: false,
          message: 'Debes tener entre 1 y 5 fotos'
        });
      }
      updateData.photos = photos;
    }

    if (price !== undefined) {
      if (productDoc.data().type === 'venta' && price <= 0) {
        return res.status(400).json({
          success: false,
          message: 'El precio debe ser mayor a 0'
        });
      }
      updateData.price = parseFloat(price);
    }

    if (tradeFor) {
      updateData.tradeFor = tradeFor.trim();
    }

    const hasLocationUpdate = Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId');
    if (hasLocationUpdate) {
      try {
        const locationData = await resolveCountryCity(countryId, cityId);
        updateData.countryId = locationData.countryId;
        updateData.countryName = locationData.countryName;
        updateData.cityId = locationData.cityId;
        updateData.cityName = locationData.cityName;
      } catch (err) {
        return res.status(400).json({
          success: false,
          message: err.message
        });
      }
    }

    if (location) {
      // Validar coordenadas si se proporciona ubicaci√≥n
      if (location.latitude && location.longitude) {
        const lat = parseFloat(location.latitude);
        const lng = parseFloat(location.longitude);
        
        if (isNaN(lat) || lat < -90 || lat > 90) {
          return res.status(400).json({
            success: false,
            message: 'Latitud inv√°lida (debe estar entre -90 y 90)'
          });
        }

        if (isNaN(lng) || lng < -180 || lng > 180) {
          return res.status(400).json({
            success: false,
            message: 'Longitud inv√°lida (debe estar entre -180 y 180)'
          });
        }

        updateData.location = {
          latitude: lat,
          longitude: lng,
          city: location.city || '',
          state: location.state || '',
          country: location.country || updateData.countryName || 'M√©xico'
        };
      } else {
        return res.status(400).json({
          success: false,
          message: 'Las coordenadas (latitude, longitude) son requeridas'
        });
      }
    }

    await db.collection('marketplace_products').doc(id).update(updateData);

    console.log('‚úÖ [MARKETPLACE] Producto actualizado:', id);

    res.json({
      success: true,
      message: 'Producto actualizado exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error actualizando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando producto',
      error: error.message
    });
  }
});

// Eliminar producto propio (soft delete)
app.delete('/api/marketplace/products/:id', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el producto existe y pertenece al usuario
    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar este producto'
      });
    }

    // Soft delete
    await db.collection('marketplace_products').doc(id).update({
      status: 'eliminado',
      updatedAt: new Date()
    });

    console.log('‚úÖ [MARKETPLACE] Producto eliminado:', id);

    res.json({
      success: true,
      message: 'Producto eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Cambiar estado del producto
app.patch('/api/marketplace/products/:id/status', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;
    const { status, buyerId, buyerName } = req.body;

    if (!status || !PRODUCT_STATUS.includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Estado inv√°lido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    if (productDoc.data().userId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para cambiar el estado de este producto'
      });
    }

    const now = new Date();
    const updateData = {
      status,
      updatedAt: now
    };

    // Si se marca como vendido/donado/intercambiado, guardar fecha y crear transacci√≥n
    if (['vendido', 'donado', 'intercambiado'].includes(status)) {
      updateData.soldAt = now;

      // Crear transacci√≥n
      const productData = productDoc.data();
      const transactionData = {
        productId: id,
        productTitle: productData.title,
        sellerId: uid,
        sellerName: productData.userName,
        buyerId: buyerId || null,
        buyerName: buyerName || 'No especificado',
        type: productData.type,
        amount: productData.price || 0,
        tradeDetails: productData.tradeFor || null,
        status: 'completada',
        createdAt: now,
        completedAt: now
      };

      await db.collection('marketplace_transactions').add(transactionData);
      console.log('‚úÖ [MARKETPLACE] Transacci√≥n creada para producto:', id);

      // Notificar a todos los usuarios que chatearon sobre este producto
      try {
        const productData = productDoc.data();
        console.log('üì¢ [MARKETPLACE] Buscando usuarios que chatearon sobre el producto:', id);
        
        // Obtener todos los mensajes relacionados con este producto
        const messagesSnapshot = await db.collection('marketplace_messages')
          .where('productId', '==', id)
          .get();

        // Recopilar IDs √∫nicos de usuarios (excluyendo al vendedor)
        const interestedUserIds = new Set();
        messagesSnapshot.docs.forEach(doc => {
          const msgData = doc.data();
          if (msgData.senderId !== uid) {
            interestedUserIds.add(msgData.senderId);
          }
          if (msgData.receiverId !== uid) {
            interestedUserIds.add(msgData.receiverId);
          }
        });

        console.log(`üì¢ [MARKETPLACE] ${interestedUserIds.size} usuarios interesados encontrados`);

        // Enviar notificaci√≥n a cada usuario interesado
        for (const userId of interestedUserIds) {
          try {
            // Obtener tokens FCM del usuario
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists || !userDoc.data().fcmTokens || userDoc.data().fcmTokens.length === 0) {
              console.log(`‚ö†Ô∏è [MARKETPLACE] Usuario ${userId} sin tokens FCM`);
              continue;
            }

            const tokens = userDoc.data().fcmTokens;
            const statusText = status === 'vendido' ? 'vendi√≥' : status === 'donado' ? 'don√≥' : 'intercambi√≥';

            // Enviar push notification
            await sendPushNotification(
              tokens,
              {
                title: 'üõçÔ∏è Art√≠culo vendido',
                body: `${productData.title} ya se ${statusText}. ¬°Gracias por tu inter√©s!`
              },
              {
                type: 'compra',
                productId: id,
                productTitle: productData.title,
                status: status,
                sellerId: uid
              }
            );

            // Guardar notificaci√≥n en Firestore para historial
            await db.collection('notifications').add({
              userId: userId,
              type: 'compra',
              title: 'üõçÔ∏è Art√≠culo vendido',
              message: `${productData.title} ya se ${statusText}. ¬°Gracias por tu inter√©s!`,
              data: {
                productId: id,
                productTitle: productData.title,
                status: status,
                sellerId: uid
              },
              read: false,
              createdAt: now
            });

            console.log(`‚úÖ [MARKETPLACE] Notificaci√≥n enviada a usuario ${userId}`);

          } catch (userError) {
            console.error(`‚ùå [MARKETPLACE] Error notificando a usuario ${userId}:`, userError.message);
          }
        }

      } catch (notifyError) {
        console.error('‚ùå [MARKETPLACE] Error enviando notificaciones:', notifyError.message);
        // No fallar el endpoint si las notificaciones fallan
      }
    }

    await db.collection('marketplace_products').doc(id).update(updateData);

    console.log('‚úÖ [MARKETPLACE] Estado actualizado:', id, '->', status);
    console.log('üìù [MARKETPLACE] Datos actualizados:', JSON.stringify(updateData, null, 2));
    
    // Verificar que se guard√≥ correctamente
    const updatedDoc = await db.collection('marketplace_products').doc(id).get();
    const updatedData = updatedDoc.data();
    console.log('üîç [MARKETPLACE] Verificaci√≥n - Status en BD:', updatedData.status);

    res.json({
      success: true,
      message: 'Estado actualizado exitosamente',
      data: {
        ...updateData,
        currentStatus: updatedData.status // Incluir el status actual de la BD
      }
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error actualizando estado:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estado',
      error: error.message
    });
  }
});

// Obtener productos propios
app.get('/api/marketplace/my-products', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { status } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_products')
      .where('userId', '==', uid);

    if (status && PRODUCT_STATUS.includes(status)) {
      query = query.where('status', '==', status);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo productos propios:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// ============================================================================
// ‚≠ê FAVORITOS
// ============================================================================

// Obtener favoritos del usuario
app.get('/api/marketplace/favorites', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const favoritesSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const productIds = favoritesSnapshot.docs.map(doc => doc.data().productId);

    if (productIds.length === 0) {
      return res.json({
        success: true,
        data: []
      });
    }

    // Obtener productos favoritos
    const productsSnapshot = await db.collection('marketplace_products')
      .where(admin.firestore.FieldPath.documentId(), 'in', productIds.slice(0, 10))
      .get();

    const products = productsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo favoritos',
      error: error.message
    });
  }
});

// Agregar producto a favoritos
app.post('/api/marketplace/favorites/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar si ya est√° en favoritos
    const existingFavorite = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .where('productId', '==', productId)
      .get();

    if (!existingFavorite.empty) {
      return res.status(400).json({
        success: false,
        message: 'El producto ya est√° en favoritos'
      });
    }

    // Agregar a favoritos
    await db.collection('marketplace_favorites').add({
      userId: uid,
      productId,
      createdAt: new Date()
    });

    // Incrementar contador en el producto
    await db.collection('marketplace_products').doc(productId).update({
      favorites: admin.firestore.FieldValue.increment(1)
    });

    console.log('‚úÖ [MARKETPLACE] Producto agregado a favoritos:', productId);

    res.json({
      success: true,
      message: 'Producto agregado a favoritos'
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error agregando a favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error agregando a favoritos',
      error: error.message
    });
  }
});

// Quitar producto de favoritos
app.delete('/api/marketplace/favorites/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Buscar y eliminar favorito
    const favoriteSnapshot = await db.collection('marketplace_favorites')
      .where('userId', '==', uid)
      .where('productId', '==', productId)
      .get();

    if (favoriteSnapshot.empty) {
      return res.status(404).json({
        success: false,
        message: 'El producto no est√° en favoritos'
      });
    }

    // Eliminar todos los documentos encontrados
    const batch = db.batch();
    favoriteSnapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();

    // Decrementar contador en el producto
    await db.collection('marketplace_products').doc(productId).update({
      favorites: admin.firestore.FieldValue.increment(-1)
    });

    console.log('‚úÖ [MARKETPLACE] Producto quitado de favoritos:', productId);

    res.json({
      success: true,
      message: 'Producto quitado de favoritos'
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error quitando de favoritos:', error);
    res.status(500).json({
      success: false,
      message: 'Error quitando de favoritos',
      error: error.message
    });
  }
});

// ============================================================================
// üí¨ MENSAJES
// ============================================================================

// Obtener conversaciones del usuario
app.get('/api/marketplace/messages', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener mensajes donde el usuario es sender o receiver
    const sentMessages = await db.collection('marketplace_messages')
      .where('senderId', '==', uid)
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();

    const receivedMessages = await db.collection('marketplace_messages')
      .where('receiverId', '==', uid)
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();

    const allMessages = [
      ...sentMessages.docs.map(doc => ({ id: doc.id, ...doc.data() })),
      ...receivedMessages.docs.map(doc => ({ id: doc.id, ...doc.data() }))
    ];

    // Agrupar por producto
    const conversationsByProduct = {};
    allMessages.forEach(msg => {
      if (!conversationsByProduct[msg.productId]) {
        conversationsByProduct[msg.productId] = [];
      }
      conversationsByProduct[msg.productId].push(msg);
    });

    res.json({
      success: true,
      data: conversationsByProduct
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo mensajes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// Obtener mensajes de un producto espec√≠fico
app.get('/api/marketplace/messages/:productId', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const messagesSnapshot = await db.collection('marketplace_messages')
      .where('productId', '==', productId)
      .orderBy('createdAt', 'asc')
      .get();

    let messages = messagesSnapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() }))
      .filter(msg => msg.senderId === uid || msg.receiverId === uid);

    // Enriquecer mensajes con informaci√≥n actual de usuarios
    const usersCache = {};
    const userIds = new Set();
    
    // Recolectar todos los IDs de usuarios √∫nicos
    messages.forEach(msg => {
      if (msg.senderId) userIds.add(msg.senderId);
      if (msg.receiverId) userIds.add(msg.receiverId);
    });

    console.log(`üîç [MARKETPLACE] Enriqueciendo ${messages.length} mensajes con info de ${userIds.size} usuarios`);

    // Obtener informaci√≥n de todos los usuarios de una vez
    for (const userId of userIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          usersCache[userId] = userDoc.data();
          const userName = usersCache[userId].displayName || usersCache[userId].name || 'Usuario';
          console.log(`‚úÖ [MARKETPLACE] Usuario ${userId}: ${userName}, foto: ${usersCache[userId].photoUrl ? 'S√≠' : 'No'}`);
        } else {
          console.log(`‚ö†Ô∏è [MARKETPLACE] Usuario ${userId} no encontrado en Firestore`);
        }
      } catch (error) {
        console.error(`‚ùå [MARKETPLACE] Error obteniendo usuario ${userId}:`, error);
      }
    }

    // Enriquecer cada mensaje con la informaci√≥n actualizada
    messages = messages.map(msg => {
      const enrichedMsg = { ...msg };

      // Enriquecer informaci√≥n del sender - usar displayName o name (consistente con el resto del c√≥digo)
      if (msg.senderId && usersCache[msg.senderId]) {
        enrichedMsg.senderName = usersCache[msg.senderId].displayName || usersCache[msg.senderId].name || 'Usuario';
        enrichedMsg.senderPhoto = usersCache[msg.senderId].photoUrl || null;
      } else if (msg.senderId) {
        console.log(`‚ö†Ô∏è [MARKETPLACE] No se encontr√≥ info para sender: ${msg.senderId}`);
        enrichedMsg.senderName = enrichedMsg.senderName || 'Usuario';
        enrichedMsg.senderPhoto = null;
      }

      // Enriquecer informaci√≥n del receiver - usar displayName o name (consistente con el resto del c√≥digo)
      if (msg.receiverId && usersCache[msg.receiverId]) {
        enrichedMsg.receiverName = usersCache[msg.receiverId].displayName || usersCache[msg.receiverId].name || 'Usuario';
        enrichedMsg.receiverPhoto = usersCache[msg.receiverId].photoUrl || null;
      } else if (msg.receiverId) {
        console.log(`‚ö†Ô∏è [MARKETPLACE] No se encontr√≥ info para receiver: ${msg.receiverId}`);
        enrichedMsg.receiverName = enrichedMsg.receiverName || 'Usuario';
        enrichedMsg.receiverPhoto = null;
      }

      return enrichedMsg;
    });

    console.log(`‚úÖ [MARKETPLACE] ${messages.length} mensajes enriquecidos para producto ${productId}`);

    res.json({
      success: true,
      data: messages
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo mensajes del producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// Enviar mensaje
app.post('/api/marketplace/messages', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId, message } = req.body;

    if (!productId || !message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Producto y mensaje son requeridos'
      });
    }

    if (message.trim().length > 500) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje no puede exceder 500 caracteres'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener info del producto y del sender
    const productDoc = await db.collection('marketplace_products').doc(productId).get();
    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const productData = productDoc.data();
    const userDoc = await db.collection('users').doc(uid).get();
    
    if (!userDoc.exists) {
      console.log(`‚ö†Ô∏è [MARKETPLACE] Usuario ${uid} no encontrado en Firestore`);
    }
    
    const userData = userDoc.exists ? userDoc.data() : {};
    
    console.log(`üîç [MARKETPLACE] Datos del sender (${uid}):`);
    console.log(`   - Existe en Firestore: ${userDoc.exists}`);
    console.log(`   - displayName: ${userData.displayName || 'NO TIENE'}`);
    console.log(`   - name: ${userData.name || 'NO TIENE'}`);
    console.log(`   - Foto: ${userData.photoUrl || 'NO TIENE'}`);
    console.log(`   - Es due√±o del producto: ${uid === productData.userId}`);

    // Determinar qui√©n es el receptor del mensaje
    let receiverId;
    
    // Si el que env√≠a es el due√±o del producto, buscar al otro usuario en los mensajes previos
    if (uid === productData.userId) {
      console.log(`üì® [MARKETPLACE] El sender es el due√±o del producto, buscando al otro usuario...`);
      
      // Buscar mensajes previos de este producto donde el sender NO sea el due√±o
      const previousMessagesSnapshot = await db.collection('marketplace_messages')
        .where('productId', '==', productId)
        .where('senderId', '!=', uid)
        .orderBy('senderId')
        .orderBy('createdAt', 'desc')
        .limit(1)
        .get();
      
      if (!previousMessagesSnapshot.empty) {
        receiverId = previousMessagesSnapshot.docs[0].data().senderId;
        console.log(`‚úÖ [MARKETPLACE] Receiver encontrado: ${receiverId}`);
      } else {
        // Si no hay mensajes previos, puede ser que el due√±o est√© iniciando la conversaci√≥n
        // (caso raro, pero posible). En este caso, no hay a qui√©n enviar notificaci√≥n.
        console.log(`‚ö†Ô∏è [MARKETPLACE] El due√±o est√° enviando el primer mensaje, no hay receptor conocido`);
        return res.status(400).json({
          success: false,
          message: 'No se puede iniciar una conversaci√≥n como due√±o del producto'
        });
      }
    } else {
      // Si el que env√≠a NO es el due√±o, el receptor es el due√±o del producto
      receiverId = productData.userId;
      console.log(`‚úÖ [MARKETPLACE] El receiver es el due√±o del producto: ${receiverId}`);
    }

    // Obtener informaci√≥n del receiver
    const receiverDoc = await db.collection('users').doc(receiverId).get();
    const receiverData = receiverDoc.exists ? receiverDoc.data() : {};
    
    console.log(`üîç [MARKETPLACE] Datos del receiver (${receiverId}):`);
    console.log(`   - Existe en Firestore: ${receiverDoc.exists}`);
    console.log(`   - displayName: ${receiverData.displayName || 'NO TIENE'}`);
    console.log(`   - name: ${receiverData.name || 'NO TIENE'}`);
    console.log(`   - Foto: ${receiverData.photoUrl || 'NO TIENE'}`);

    // Crear mensaje - usar displayName o name (consistente con el resto del c√≥digo)
    const messageData = {
      productId,
      senderId: uid,
      senderName: userData?.displayName || userData?.name || 'Usuario',
      senderPhoto: userData?.photoUrl || null,
      receiverId: receiverId,
      receiverName: receiverData?.displayName || receiverData?.name || productData.userName || 'Usuario',
      receiverPhoto: receiverData?.photoUrl || null,
      message: message.trim(),
      isRead: false,
      createdAt: new Date()
    };
    
    console.log(`üìù [MARKETPLACE] Mensaje a guardar:`, {
      senderName: messageData.senderName,
      senderPhoto: messageData.senderPhoto ? 'S√≠' : 'No',
      receiverName: messageData.receiverName,
      receiverPhoto: messageData.receiverPhoto ? 'S√≠' : 'No'
    });

    const messageRef = await db.collection('marketplace_messages').add(messageData);

    // Incrementar contador de mensajes en el producto
    await db.collection('marketplace_products').doc(productId).update({
      messages: admin.firestore.FieldValue.increment(1)
    });

    console.log('‚úÖ [MARKETPLACE] Mensaje enviado:', messageRef.id);

    // Enviar notificaci√≥n push al destinatario
    try {
      // Verificar que el receiver no sea el mismo que el sender
      if (uid === receiverId) {
        console.log(`‚ö†Ô∏è [MARKETPLACE] No se env√≠a notificaci√≥n: sender y receiver son el mismo usuario (${uid})`);
      } else {
        const receiverTokens = receiverData?.fcmTokens || [];
        
        if (receiverTokens.length > 0) {
          console.log(`üì§ [MARKETPLACE] Enviando notificaci√≥n push a ${receiverId}`);
        
        const senderFullName = userData?.displayName || userData?.name || 'Usuario';
        
        const notification = {
          title: `üí¨ Nuevo mensaje de ${senderFullName}`,
          body: message.trim().length > 100 ? message.trim().substring(0, 100) + '...' : message.trim()
        };

        const notificationData = {
          type: 'new_message',
          senderId: uid,
          senderName: senderFullName,
          senderPhoto: userData?.photoUrl || null,
          productId: productId,
          productTitle: productData.title || 'Producto',
          screen: 'ChatScreen',
          chatId: `${productId}_${uid}_${receiverId}`
        };

        const pushResult = await sendPushNotification(receiverTokens, notification, notificationData);
        
        if (pushResult.success) {
          console.log(`‚úÖ [MARKETPLACE] Notificaci√≥n enviada: ${pushResult.successCount} exitosas, ${pushResult.failureCount} fallidas`);
        } else {
          console.log(`‚ö†Ô∏è [MARKETPLACE] No se pudo enviar notificaci√≥n: ${pushResult.error || pushResult.message}`);
        }

        // Guardar notificaci√≥n en Firestore
        await db.collection('notifications').add({
          userId: receiverId,
          type: 'new_message',
          title: notification.title,
          body: notification.body,
          data: notificationData,
          read: false,
          createdAt: admin.firestore.Timestamp.fromDate(new Date())
        });
        
        console.log('‚úÖ [MARKETPLACE] Notificaci√≥n guardada en Firestore');
        } else {
          console.log('‚ö†Ô∏è [MARKETPLACE] El destinatario no tiene tokens FCM registrados');
        }
      }
    } catch (notificationError) {
      console.error('‚ùå [MARKETPLACE] Error enviando notificaci√≥n push:', notificationError);
      // No fallar el env√≠o del mensaje si falla la notificaci√≥n
    }

    res.json({
      success: true,
      message: 'Mensaje enviado exitosamente',
      data: {
        id: messageRef.id,
        ...messageData
      }
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error enviando mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando mensaje',
      error: error.message
    });
  }
});

// Marcar mensaje como le√≠do
app.patch('/api/marketplace/messages/:id/read', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const messageDoc = await db.collection('marketplace_messages').doc(id).get();

    if (!messageDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Mensaje no encontrado'
      });
    }

    // Solo el receptor puede marcar como le√≠do
    if (messageDoc.data().receiverId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para marcar este mensaje'
      });
    }

    await db.collection('marketplace_messages').doc(id).update({
      isRead: true
    });

    res.json({
      success: true,
      message: 'Mensaje marcado como le√≠do'
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error marcando mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando mensaje',
      error: error.message
    });
  }
});

// ============================================================================
// üìä TRANSACCIONES
// ============================================================================

// Obtener transacciones del usuario
app.get('/api/marketplace/transactions', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener transacciones donde el usuario es vendedor o comprador
    const asSellerSnapshot = await db.collection('marketplace_transactions')
      .where('sellerId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const asBuyerSnapshot = await db.collection('marketplace_transactions')
      .where('buyerId', '==', uid)
      .orderBy('createdAt', 'desc')
      .get();

    const transactions = [
      ...asSellerSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        role: 'vendedor'
      })),
      ...asBuyerSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        role: 'comprador'
      }))
    ].sort((a, b) => b.createdAt - a.createdAt);

    res.json({
      success: true,
      data: transactions
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error obteniendo transacciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo transacciones',
      error: error.message
    });
  }
});

// ============================================================================
// üö® REPORTES
// ============================================================================

// Reportar un producto
app.post('/api/marketplace/reports', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { productId, reason, description } = req.body;

    const validReasons = [
      'spam',
      'fraude',
      'contenido_inapropiado',
      'precio_incorrecto',
      'informacion_falsa',
      'otro'
    ];

    if (!productId || !reason || !validReasons.includes(reason)) {
      return res.status(400).json({
        success: false,
        message: 'Producto y raz√≥n v√°lida son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    const userData = userDoc.data();

    const reportData = {
      productId,
      reportedBy: uid,
      reporterName: userData?.name || 'Usuario',
      reason,
      description: description || '',
      status: 'pendiente',
      reviewedBy: null,
      reviewedAt: null,
      actionTaken: null,
      createdAt: new Date()
    };

    const reportRef = await db.collection('marketplace_reports').add(reportData);

    // Incrementar contador de reportes en el producto
    await db.collection('marketplace_products').doc(productId).update({
      reportCount: admin.firestore.FieldValue.increment(1),
      isReported: true
    });

    console.log('‚úÖ [MARKETPLACE] Reporte creado:', reportRef.id);

    res.json({
      success: true,
      message: 'Reporte enviado exitosamente. Lo revisaremos pronto.',
      data: {
        id: reportRef.id,
        ...reportData
      }
    });

  } catch (error) {
    console.error('‚ùå [MARKETPLACE] Error creando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando reporte',
      error: error.message
    });
  }
});

// ============================================================================
// üõ†Ô∏è ENDPOINTS PARA ADMINISTRADOR - MARKETPLACE
// ============================================================================

// Ver todos los productos (incluye eliminados y pendientes)
app.get('/api/admin/marketplace/products', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status, isReported } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_products');

    if (status) {
      query = query.where('status', '==', status);
    }

    if (isReported === 'true') {
      query = query.where('isReported', '==', true);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: products
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Aprobar un producto
app.patch('/api/admin/marketplace/products/:id/approve', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved: true,
      updatedAt: new Date()
    });

    console.log('‚úÖ [ADMIN] Producto aprobado:', id);

    res.json({
      success: true,
      message: 'Producto aprobado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error aprobando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error aprobando producto',
      error: error.message
    });
  }
});

// Rechazar un producto
app.patch('/api/admin/marketplace/products/:id/reject', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved: false,
      status: 'eliminado',
      updatedAt: new Date()
    });

    console.log('‚úÖ [ADMIN] Producto rechazado:', id);

    res.json({
      success: true,
      message: 'Producto rechazado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error rechazando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error rechazando producto',
      error: error.message
    });
  }
});

// Eliminar permanentemente un producto
app.delete('/api/admin/marketplace/products/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_products').doc(id).delete();

    console.log('‚úÖ [ADMIN] Producto eliminado permanentemente:', id);

    res.json({
      success: true,
      message: 'Producto eliminado permanentemente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Ver todos los reportes
app.get('/api/admin/marketplace/reports', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_reports');

    if (status) {
      query = query.where('status', '==', status);
    }

    query = query.orderBy('createdAt', 'desc');

    const snapshot = await query.get();
    const reports = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: reports
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo reportes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo reportes',
      error: error.message
    });
  }
});

// Revisar y tomar acci√≥n sobre un reporte
app.patch('/api/admin/marketplace/reports/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { actionTaken } = req.body;

    if (!actionTaken) {
      return res.status(400).json({
        success: false,
        message: 'Acci√≥n tomada es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('marketplace_reports').doc(id).update({
      status: 'revisado',
      reviewedBy: req.user.uid,
      reviewedAt: new Date(),
      actionTaken
    });

    console.log('‚úÖ [ADMIN] Reporte revisado:', id);

    res.json({
      success: true,
      message: 'Reporte procesado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error procesando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando reporte',
      error: error.message
    });
  }
});

// Obtener estad√≠sticas del marketplace
app.get('/api/admin/marketplace/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todos los productos
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    // Obtener todas las transacciones
    const transactionsSnapshot = await db.collection('marketplace_transactions').get();
    const transactions = transactionsSnapshot.docs.map(doc => doc.data());

    // Calcular estad√≠sticas
    const stats = {
      totalProducts: products.length,
      productsByType: {
        venta: products.filter(p => p.type === 'venta').length,
        donacion: products.filter(p => p.type === 'donacion').length,
        trueque: products.filter(p => p.type === 'trueque').length
      },
      productsByStatus: {
        disponible: products.filter(p => p.status === 'disponible').length,
        vendido: products.filter(p => p.status === 'vendido').length,
        donado: products.filter(p => p.status === 'donado').length,
        intercambiado: products.filter(p => p.status === 'intercambiado').length,
        eliminado: products.filter(p => p.status === 'eliminado').length
      },
      productsByCategory: MARKETPLACE_CATEGORIES.reduce((acc, cat) => {
        acc[cat] = products.filter(p => p.category === cat).length;
        return acc;
      }, {}),
      totalTransactions: transactions.length,
      totalRevenue: transactions
        .filter(t => t.type === 'venta')
        .reduce((sum, t) => sum + (t.amount || 0), 0),
      reportedProducts: products.filter(p => p.isReported).length,
      averageViews: products.length > 0 
        ? Math.round(products.reduce((sum, p) => sum + (p.views || 0), 0) / products.length)
        : 0
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// Ver todas las transacciones
app.get('/api/admin/marketplace/transactions', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('marketplace_transactions')
      .orderBy('createdAt', 'desc')
      .get();

    const transactions = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: transactions
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo transacciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo transacciones',
      error: error.message
    });
  }
});

// ============================================================================
// üìÖ ENDPOINTS ADMIN - GESTI√ìN DE EVENTOS
// ============================================================================

// Obtener todos los eventos (admin dashboard)
app.get('/api/admin/events', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { 
      status, 
      communityId, 
      page = 1, 
      limit = 20,
      sortBy = 'date',  // date, created, attendees, checkins
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Query base
    let query = db.collection('posts').where('postType', '==', 'event');

    // Aplicar filtros
    if (communityId) {
      query = query.where('communityId', '==', communityId);
    }

    // Obtener todos los eventos
    const snapshot = await query.get();

    let events = [];
    const now = new Date();

    for (const doc of snapshot.docs) {
      const eventPost = doc.data();
      
      if (!eventPost.eventData) continue;

      const eventDate = eventPost.eventData.eventDate.toDate();
      
      // Filtrar por status si se especifica
      if (status) {
        if (status === 'upcoming' && eventDate < now) continue;
        if (status === 'past' && eventDate >= now) continue;
        if (status === 'cancelled' && eventPost.eventData.status !== 'cancelled') continue;
      }

      // Obtener datos del autor y comunidad
      let authorData = { displayName: 'Usuario Desconocido' };
      let communityName = 'Comunidad';

      try {
        const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
        if (authorDoc.exists) {
          const data = authorDoc.data();
          authorData = {
            id: eventPost.authorId,
            displayName: data.displayName || data.name || 'Usuario',
            email: data.email || null,
            photoUrl: data.photoUrl || null
          };
        }

        const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
        if (communityDoc.exists) {
          communityName = communityDoc.data().name || 'Comunidad';
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo datos adicionales:`, error.message);
      }

      // Calcular m√©tricas
      const attendeeCount = eventPost.eventData.attendeeCount || 0;
      const checkedInCount = eventPost.eventData.checkedInCount || 0;
      const waitlistCount = eventPost.eventData.waitlistCount || 0;
      const attendanceRate = attendeeCount > 0 ? (checkedInCount / attendeeCount) * 100 : 0;

      events.push({
        id: doc.id,
        title: eventPost.eventData.title,
        description: eventPost.eventData.description || '',
        eventDate: eventPost.eventData.eventDate,
        eventEndDate: eventPost.eventData.eventEndDate || null,
        location: eventPost.eventData.location || null,
        status: eventPost.eventData.status,
        isBanner: eventPost.eventData.isBanner || false,  // NUEVO: estado de banner
        
        // M√©tricas
        attendeeCount,
        checkedInCount,
        waitlistCount,
        maxAttendees: eventPost.eventData.maxAttendees || null,
        attendanceRate: Math.round(attendanceRate),
        
        // Info adicional
        author: authorData,
        communityId: eventPost.communityId,
        communityName,
        imageUrl: eventPost.imageUrl || null,
        
        // Interacciones
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0,
        
        // Fechas
        createdAt: eventPost.createdAt,
        updatedAt: eventPost.updatedAt
      });
    }

    // Ordenar
    events.sort((a, b) => {
      switch (sortBy) {
        case 'date':
          const dateA = a.eventDate.toDate();
          const dateB = b.eventDate.toDate();
          return order === 'desc' ? dateB - dateA : dateA - dateB;
        
        case 'created':
          const createdA = a.createdAt.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
          const createdB = b.createdAt.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
          return order === 'desc' ? createdB - createdA : createdA - createdB;
        
        case 'attendees':
          return order === 'desc' 
            ? b.attendeeCount - a.attendeeCount 
            : a.attendeeCount - b.attendeeCount;
        
        case 'checkins':
          return order === 'desc' 
            ? b.checkedInCount - a.checkedInCount 
            : a.checkedInCount - b.checkedInCount;
        
        default:
          return 0;
      }
    });

    // Paginaci√≥n
    const total = events.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedEvents = events.slice(startIndex, endIndex);

    // Calcular estad√≠sticas generales
    const stats = {
      total: total,
      upcoming: events.filter(e => e.eventDate.toDate() >= now && e.status !== 'cancelled').length,
      past: events.filter(e => e.eventDate.toDate() < now).length,
      cancelled: events.filter(e => e.status === 'cancelled').length,
      totalAttendees: events.reduce((sum, e) => sum + e.attendeeCount, 0),
      totalCheckins: events.reduce((sum, e) => sum + e.checkedInCount, 0),
      totalWaitlist: events.reduce((sum, e) => sum + e.waitlistCount, 0),
      averageAttendanceRate: events.length > 0 
        ? Math.round(events.reduce((sum, e) => sum + e.attendanceRate, 0) / events.length)
        : 0
    };

    res.json({
      success: true,
      data: paginatedEvents,
      stats,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo eventos',
      error: error.message
    });
  }
});

// Obtener detalle completo de un evento (admin)
app.get('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener el evento
    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event' || !eventPost.eventData) {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Obtener datos del autor
    let authorData = { displayName: 'Usuario Desconocido' };
    try {
      const authorDoc = await db.collection('users').doc(eventPost.authorId).get();
      if (authorDoc.exists) {
        const data = authorDoc.data();
        authorData = {
          id: eventPost.authorId,
          displayName: data.displayName || data.name || 'Usuario',
          email: data.email || null,
          photoUrl: data.photoUrl || null
        };
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo autor:`, error.message);
    }

    // Obtener datos de la comunidad
    let communityData = { name: 'Comunidad' };
    try {
      const communityDoc = await db.collection('communities').doc(eventPost.communityId).get();
      if (communityDoc.exists) {
        const data = communityDoc.data();
        communityData = {
          id: eventPost.communityId,
          name: data.name || 'Comunidad',
          imageUrl: data.imageUrl || null,
          memberCount: data.members?.length || 0
        };
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo comunidad:`, error.message);
    }

    // Obtener lista detallada de asistentes
    const attendeeIds = eventPost.eventData.attendees || [];
    const attendeesList = [];
    
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const data = attendeeDoc.data();
          const checkedIn = (eventPost.eventData.checkedInAttendees || []).includes(attendeeId);
          const checkInTime = eventPost.eventData.checkInTimes?.[attendeeId] || null;
          
          attendeesList.push({
            userId: attendeeId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null,
            checkedIn,
            checkInTime
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo asistente ${attendeeId}:`, error.message);
      }
    }

    // Obtener lista de espera
    const waitlistIds = eventPost.eventData.waitlist || [];
    const waitlistList = [];
    
    for (const userId of waitlistIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const data = userDoc.data();
          waitlistList.push({
            userId: userId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo usuario en espera ${userId}:`, error.message);
      }
    }

    // Construir respuesta completa
    const response = {
      id: eventId,
      postType: eventPost.postType,
      content: eventPost.content,
      imageUrl: eventPost.imageUrl || null,
      
      eventData: {
        title: eventPost.eventData.title,
        description: eventPost.eventData.description || '',
        eventDate: eventPost.eventData.eventDate,
        eventEndDate: eventPost.eventData.eventEndDate || null,
        location: eventPost.eventData.location || null,
        status: eventPost.eventData.status,
        isBanner: eventPost.eventData.isBanner || false,  // NUEVO: estado de banner
        bannerUpdatedAt: eventPost.eventData.bannerUpdatedAt || null,  // NUEVO: cu√°ndo se marc√≥ como banner
        maxAttendees: eventPost.eventData.maxAttendees || null,
        checkInCode: eventPost.eventData.checkInCode || null,
        requiresConfirmation: eventPost.eventData.requiresConfirmation || false
      },
      
      author: authorData,
      community: communityData,
      
      attendees: attendeesList,
      waitlist: waitlistList,
      
      metrics: {
        attendeeCount: attendeesList.length,
        checkedInCount: attendeesList.filter(a => a.checkedIn).length,
        waitlistCount: waitlistList.length,
        attendanceRate: attendeesList.length > 0 
          ? Math.round((attendeesList.filter(a => a.checkedIn).length / attendeesList.length) * 100)
          : 0,
        likeCount: eventPost.likeCount || 0,
        commentCount: eventPost.commentCount || 0
      },
      
      dates: {
        createdAt: eventPost.createdAt,
        updatedAt: eventPost.updatedAt,
        publishedAt: eventPost.publishedAt || eventPost.createdAt
      }
    };

    res.json({
      success: true,
      data: response
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalle de evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle de evento',
      error: error.message
    });
  }
});

// Cancelar evento (admin)
app.patch('/api/admin/events/:eventId/cancel', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { reason } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Actualizar estado
    await db.collection('posts').doc(eventId).update({
      'eventData.status': 'cancelled',
      'eventData.cancelledAt': new Date(),
      'eventData.cancelReason': reason || 'Cancelado por administrador',
      updatedAt: new Date()
    });

    // Notificar a todos los asistentes y lista de espera
    try {
      const attendees = eventPost.eventData.attendees || [];
      const waitlist = eventPost.eventData.waitlist || [];
      const allUsers = [...attendees, ...waitlist];

      if (allUsers.length > 0) {
        const usersPromises = allUsers.map(async (userId) => {
          try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists) {
              const userData = userDoc.data();
              return { userId, tokens: userData.fcmTokens || [] };
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo tokens del usuario ${userId}:`, error.message);
          }
          return { userId, tokens: [] };
        });

        const usersWithTokens = await Promise.all(usersPromises);
        const allTokens = usersWithTokens.flatMap(u => u.tokens);

        if (allTokens.length > 0) {
          const notification = {
            title: '‚ùå Evento cancelado',
            body: `El evento "${eventPost.eventData.title}" ha sido cancelado por el administrador${reason ? ': ' + reason : ''}`
          };

          const notificationData = {
            type: 'event_cancelled_admin',
            postId: eventId,
            screen: 'CommunityPostScreen'
          };

          await sendPushNotification(allTokens, notification, notificationData);
          console.log(`‚úÖ [ADMIN] Notificaciones de cancelaci√≥n enviadas a ${allUsers.length} usuarios`);
        }
      }
    } catch (notificationError) {
      console.error('‚ùå [ADMIN] Error enviando notificaciones:', notificationError);
    }

    console.log(`‚úÖ [ADMIN] Evento ${eventId} cancelado por admin`);

    res.json({
      success: true,
      message: 'Evento cancelado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error cancelando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando evento',
      error: error.message
    });
  }
});

// Editar evento (admin)
app.put('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { 
      title, 
      description, 
      content,              // NUEVO: contenido del post
      imageUrl,             // NUEVO: imagen del post
      eventDate, 
      eventEndDate, 
      location,
      maxAttendees,
      requiresConfirmation,
      status
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Preparar datos de actualizaci√≥n
    const updateData = {
      updatedAt: new Date()
    };

    // Actualizar campos del post (nivel superior)
    if (content !== undefined) {
      updateData['content'] = content.trim();
    }

    if (imageUrl !== undefined) {
      updateData['imageUrl'] = imageUrl || null;
    }

    // Actualizar solo los campos de eventData que se proporcionan
    if (title !== undefined) {
      if (!title || title.trim().length < 3) {
        return res.status(400).json({
          success: false,
          message: 'El t√≠tulo debe tener al menos 3 caracteres'
        });
      }
      updateData['eventData.title'] = title.trim();
    }

    if (description !== undefined) {
      updateData['eventData.description'] = description.trim();
    }

    if (eventDate !== undefined) {
      try {
        const parsedDate = new Date(eventDate);
        if (isNaN(parsedDate.getTime())) {
          return res.status(400).json({
            success: false,
            message: 'Fecha del evento inv√°lida'
          });
        }
        updateData['eventData.eventDate'] = parsedDate;
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: 'Formato de fecha inv√°lido'
        });
      }
    }

    if (eventEndDate !== undefined) {
      if (eventEndDate) {
        try {
          const parsedEndDate = new Date(eventEndDate);
          if (isNaN(parsedEndDate.getTime())) {
            return res.status(400).json({
              success: false,
              message: 'Fecha de fin del evento inv√°lida'
            });
          }
          updateData['eventData.eventEndDate'] = parsedEndDate;
        } catch (error) {
          return res.status(400).json({
            success: false,
            message: 'Formato de fecha de fin inv√°lido'
          });
        }
      } else {
        updateData['eventData.eventEndDate'] = null;
      }
    }

    if (location !== undefined) {
      updateData['eventData.location'] = location;
    }

    if (maxAttendees !== undefined) {
      if (maxAttendees !== null) {
        const maxAttendeesNum = parseInt(maxAttendees);
        if (isNaN(maxAttendeesNum) || maxAttendeesNum < 1) {
          return res.status(400).json({
            success: false,
            message: 'El m√°ximo de asistentes debe ser un n√∫mero positivo'
          });
        }
        
        // Verificar que el nuevo m√°ximo no sea menor que los asistentes actuales
        const currentAttendees = eventPost.eventData?.attendeeCount || 0;
        if (maxAttendeesNum < currentAttendees) {
          return res.status(400).json({
            success: false,
            message: `No puedes reducir el l√≠mite a ${maxAttendeesNum} porque ya hay ${currentAttendees} asistentes confirmados`
          });
        }
        
        updateData['eventData.maxAttendees'] = maxAttendeesNum;
      } else {
        updateData['eventData.maxAttendees'] = null;
      }
    }

    if (requiresConfirmation !== undefined) {
      updateData['eventData.requiresConfirmation'] = Boolean(requiresConfirmation);
    }

    if (status !== undefined) {
      const validStatuses = ['active', 'cancelled', 'completed'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          success: false,
          message: `Estado inv√°lido. Debe ser: ${validStatuses.join(', ')}`
        });
      }
      updateData['eventData.status'] = status;
    }

    // Actualizar el evento
    await db.collection('posts').doc(eventId).update(updateData);

    console.log(`‚úÖ [ADMIN] Evento ${eventId} actualizado por admin ${req.user.uid}`);

    // Obtener el evento actualizado completo (como el GET /api/admin/events/:eventId)
    const updatedEventDoc = await db.collection('posts').doc(eventId).get();
    const updatedEventPost = updatedEventDoc.data();

    // Obtener datos del autor
    let authorData = { displayName: 'Usuario Desconocido' };
    try {
      const authorDoc = await db.collection('users').doc(updatedEventPost.authorId).get();
      if (authorDoc.exists) {
        const data = authorDoc.data();
        authorData = {
          id: updatedEventPost.authorId,
          displayName: data.displayName || data.name || 'Usuario',
          email: data.email || null,
          photoUrl: data.photoUrl || null
        };
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo autor:`, error.message);
    }

    // Obtener datos de la comunidad
    let communityData = { name: 'Comunidad' };
    try {
      const communityDoc = await db.collection('communities').doc(updatedEventPost.communityId).get();
      if (communityDoc.exists) {
        const data = communityDoc.data();
        communityData = {
          id: updatedEventPost.communityId,
          name: data.name || 'Comunidad',
          imageUrl: data.imageUrl || null,
          memberCount: data.members?.length || 0
        };
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo comunidad:`, error.message);
    }

    // Obtener lista detallada de asistentes
    const attendeeIds = updatedEventPost.eventData.attendees || [];
    const attendeesList = [];
    
    for (const attendeeId of attendeeIds) {
      try {
        const attendeeDoc = await db.collection('users').doc(attendeeId).get();
        if (attendeeDoc.exists) {
          const data = attendeeDoc.data();
          const checkedIn = (updatedEventPost.eventData.checkedInAttendees || []).includes(attendeeId);
          const checkInTime = updatedEventPost.eventData.checkInTimes?.[attendeeId] || null;
          
          attendeesList.push({
            userId: attendeeId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null,
            checkedIn,
            checkInTime
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo asistente ${attendeeId}:`, error.message);
      }
    }

    // Obtener lista de espera
    const waitlistIds = updatedEventPost.eventData.waitlist || [];
    const waitlistList = [];
    
    for (const userId of waitlistIds) {
      try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const data = userDoc.data();
          waitlistList.push({
            userId: userId,
            userName: data.displayName || data.name || 'Usuario',
            userEmail: data.email || null,
            userPhoto: data.photoUrl || null
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [ADMIN] Error obteniendo usuario en espera ${userId}:`, error.message);
      }
    }

    // Construir respuesta completa (igual que GET /api/admin/events/:eventId)
    const response = {
      id: eventId,
      postType: updatedEventPost.postType,
      content: updatedEventPost.content,
      imageUrl: updatedEventPost.imageUrl || null,
      
      eventData: {
        title: updatedEventPost.eventData.title,
        description: updatedEventPost.eventData.description || '',
        eventDate: updatedEventPost.eventData.eventDate,
        eventEndDate: updatedEventPost.eventData.eventEndDate || null,
        location: updatedEventPost.eventData.location || null,
        status: updatedEventPost.eventData.status,
        isBanner: updatedEventPost.eventData.isBanner || false,
        bannerUpdatedAt: updatedEventPost.eventData.bannerUpdatedAt || null,
        maxAttendees: updatedEventPost.eventData.maxAttendees || null,
        checkInCode: updatedEventPost.eventData.checkInCode || null,
        requiresConfirmation: updatedEventPost.eventData.requiresConfirmation || false
      },
      
      author: authorData,
      community: communityData,
      
      attendees: attendeesList,
      waitlist: waitlistList,
      
      metrics: {
        attendeeCount: attendeesList.length,
        checkedInCount: attendeesList.filter(a => a.checkedIn).length,
        waitlistCount: waitlistList.length,
        attendanceRate: attendeesList.length > 0 
          ? Math.round((attendeesList.filter(a => a.checkedIn).length / attendeesList.length) * 100)
          : 0,
        likeCount: updatedEventPost.likeCount || 0,
        commentCount: updatedEventPost.commentCount || 0
      },
      
      dates: {
        createdAt: updatedEventPost.createdAt,
        updatedAt: updatedEventPost.updatedAt,
        publishedAt: updatedEventPost.publishedAt || updatedEventPost.createdAt
      }
    };

    res.json({
      success: true,
      message: 'Evento actualizado exitosamente',
      data: response
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando evento',
      error: error.message
    });
  }
});

// Eliminar evento (admin)
app.delete('/api/admin/events/:eventId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    // Eliminar el documento
    await db.collection('posts').doc(eventId).delete();

    console.log(`‚úÖ [ADMIN] Evento ${eventId} eliminado permanentemente`);

    res.json({
      success: true,
      message: 'Evento eliminado permanentemente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando evento',
      error: error.message
    });
  }
});

// Marcar/desmarcar evento como banner (admin)
app.patch('/api/admin/events/:eventId/banner', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { 
      isBanner, 
      section = 'home',        // 'home', 'communities', 'marketplace', etc.
      order = 1,               // Orden de aparici√≥n
      duration = 5,            // Duraci√≥n en carrusel (segundos)
      publishNow = true        // Si se publica inmediatamente o no
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (typeof isBanner !== 'boolean') {
      return res.status(400).json({
        success: false,
        message: 'El campo isBanner debe ser un booleano'
      });
    }

    const eventDoc = await db.collection('posts').doc(eventId).get();

    if (!eventDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    const eventPost = eventDoc.data();

    if (eventPost.postType !== 'event') {
      return res.status(400).json({
        success: false,
        message: 'Esta publicaci√≥n no es un evento'
      });
    }

    // Si se est√° marcando como banner, verificar que el evento no est√© cancelado
    if (isBanner && eventPost.eventData?.status === 'cancelled') {
      return res.status(400).json({
        success: false,
        message: 'No se puede marcar como banner un evento cancelado'
      });
    }

    // Preparar datos de actualizaci√≥n
    const updateData = {
      'eventData.isBanner': isBanner,
      'eventData.bannerUpdatedAt': new Date(),
      'eventData.bannerUpdatedBy': req.user.uid,
      updatedAt: new Date()
    };

    // Si se est√° marcando como banner, agregar configuraci√≥n
    if (isBanner) {
      updateData['eventData.bannerSection'] = section;
      updateData['eventData.bannerOrder'] = parseInt(order);
      updateData['eventData.bannerDuration'] = parseInt(duration);
      
      // Si publishNow es true, se publica inmediatamente
      // Si es false, se puede configurar una fecha espec√≠fica de publicaci√≥n
      if (publishNow) {
        updateData['eventData.bannerPublishedAt'] = new Date();
      }
    }

    // Actualizar estado de banner
    await db.collection('posts').doc(eventId).update(updateData);

    console.log(`‚úÖ [ADMIN] Evento ${eventId} ${isBanner ? 'marcado' : 'desmarcado'} como banner`);
    if (isBanner) {
      console.log(`   - Secci√≥n: ${section}, Orden: ${order}, Duraci√≥n: ${duration}s`);
    }

    res.json({
      success: true,
      message: isBanner ? 'Evento marcado como banner' : 'Banner removido del evento',
      data: {
        eventId,
        isBanner,
        ...(isBanner && {
          section,
          order,
          duration,
          publishedAt: publishNow ? new Date() : null
        })
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando estado de banner',
      error: error.message
    });
  }
});

// Estad√≠sticas de eventos (admin dashboard)
app.get('/api/admin/events/stats/summary', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const eventsSnapshot = await db.collection('posts')
      .where('postType', '==', 'event')
      .get();

    const events = eventsSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    const now = new Date();

    // Estad√≠sticas generales
    const stats = {
      totalEvents: events.length,
      upcomingEvents: events.filter(e => {
        const eventDate = e.eventData?.eventDate?.toDate();
        return eventDate && eventDate >= now && e.eventData.status !== 'cancelled';
      }).length,
      pastEvents: events.filter(e => {
        const eventDate = e.eventData?.eventDate?.toDate();
        return eventDate && eventDate < now;
      }).length,
      cancelledEvents: events.filter(e => e.eventData?.status === 'cancelled').length,
      
      totalAttendees: events.reduce((sum, e) => sum + (e.eventData?.attendeeCount || 0), 0),
      totalCheckins: events.reduce((sum, e) => sum + (e.eventData?.checkedInCount || 0), 0),
      totalWaitlist: events.reduce((sum, e) => sum + (e.eventData?.waitlistCount || 0), 0),
      
      averageAttendeesPerEvent: events.length > 0
        ? Math.round(events.reduce((sum, e) => sum + (e.eventData?.attendeeCount || 0), 0) / events.length)
        : 0,
      
      averageAttendanceRate: events.length > 0
        ? Math.round(events.reduce((sum, e) => {
            const attendees = e.eventData?.attendeeCount || 0;
            const checkins = e.eventData?.checkedInCount || 0;
            return sum + (attendees > 0 ? (checkins / attendees) * 100 : 0);
          }, 0) / events.length)
        : 0,
      
      eventsWithWaitlist: events.filter(e => (e.eventData?.waitlistCount || 0) > 0).length,
      eventsWithCheckIn: events.filter(e => (e.eventData?.checkedInCount || 0) > 0).length,
      
      // Top comunidades con m√°s eventos
      topCommunities: Object.entries(
        events.reduce((acc, e) => {
          acc[e.communityId] = (acc[e.communityId] || 0) + 1;
          return acc;
        }, {})
      )
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([communityId, count]) => ({ communityId, eventCount: count })),
      
      // Eventos por mes (√∫ltimos 6 meses)
      eventsByMonth: {},
      
      // Engagement
      totalLikes: events.reduce((sum, e) => sum + (e.likeCount || 0), 0),
      totalComments: events.reduce((sum, e) => sum + (e.commentCount || 0), 0)
    };

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas de eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// ============================================================================
// üè∑Ô∏è CATEGOR√çAS DIN√ÅMICAS PARA MARKETPLACE
// ============================================================================

// Obtener todas las categor√≠as (p√∫blico)
app.get('/api/marketplace/categories', async (req, res) => {
  try {
    const { includeInactive } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_categories');

    // Si no es admin o no se especifica, solo mostrar activas
    if (!includeInactive || includeInactive !== 'true') {
      query = query.where('isActive', '==', true);
    }

    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();
    const categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: categories
    });

  } catch (error) {
    console.error('‚ùå [CATEGORIES] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Obtener detalle de una categor√≠a
app.get('/api/marketplace/categories/:id', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    res.json({
      success: true,
      data: {
        id: categoryDoc.id,
        ...categoryDoc.data()
      }
    });

  } catch (error) {
    console.error('‚ùå [CATEGORIES] Error obteniendo categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠a',
      error: error.message
    });
  }
});

// ============================================================================
// üõ†Ô∏è ADMIN - GESTI√ìN DE PRODUCTOS
// ============================================================================

// Listar todos los productos (Admin) - con filtros y paginaci√≥n
app.get('/api/admin/marketplace/items', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 100,
      search = '',
      status = '',
      type = '',
      category = '',
      userId = '',
      orderBy = 'createdAt',
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Construir query base
    let query = db.collection('marketplace_products');

    // Aplicar filtros
    if (status) {
      query = query.where('status', '==', status);
    }

    if (type) {
      query = query.where('type', '==', type);
    }

    if (userId) {
      query = query.where('userId', '==', userId);
    }

    // Ordenar
    const orderDirection = order === 'asc' ? 'asc' : 'desc';
    query = query.orderBy(orderBy, orderDirection);

    // Obtener todos los productos
    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtro por categor√≠a (puede ser slug o ID)
    if (category) {
      products = products.filter(p => 
        p.category === category || 
        p.categorySlug === category
      );
    }

    // B√∫squeda por texto
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p =>
        p.title?.toLowerCase().includes(searchLower) ||
        p.description?.toLowerCase().includes(searchLower) ||
        p.userName?.toLowerCase().includes(searchLower) ||
        p.categoryName?.toLowerCase().includes(searchLower)
      );
    }

    // Paginaci√≥n
    const total = products.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedProducts = products.slice(startIndex, endIndex);

    console.log('‚úÖ [ADMIN] Productos del marketplace obtenidos:', paginatedProducts.length);

    res.json({
      success: true,
      data: paginatedProducts,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo productos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos del marketplace',
      error: error.message
    });
  }
});

// Ver detalles completos de un producto (Admin)
app.get('/api/admin/marketplace/items/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    const product = {
      id: productDoc.id,
      ...productDoc.data()
    };

    // Obtener informaci√≥n del usuario vendedor
    let userInfo = null;
    if (product.userId) {
      const userDoc = await db.collection('users').doc(product.userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        userInfo = {
          id: product.userId,
          name: userData.name,
          email: userData.email,
          phone: userData.phone,
          photoUrl: userData.photoUrl,
          createdAt: userData.createdAt
        };
      }
    }

    console.log('‚úÖ [ADMIN] Detalles del producto obtenidos:', id);

    res.json({
      success: true,
      data: {
        product,
        user: userInfo
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalles del producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalles del producto',
      error: error.message
    });
  }
});

// Aprobar/Rechazar producto (Admin)
app.patch('/api/admin/marketplace/items/:id/approve', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { isApproved, reason = '' } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    await db.collection('marketplace_products').doc(id).update({
      isApproved,
      moderationReason: reason,
      moderatedAt: admin.firestore.Timestamp.fromDate(new Date()),
      moderatedBy: req.user.uid,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`‚úÖ [ADMIN] Producto ${isApproved ? 'aprobado' : 'rechazado'}:`, id);

    res.json({
      success: true,
      message: `Producto ${isApproved ? 'aprobado' : 'rechazado'} exitosamente`
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error moderando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error moderando producto',
      error: error.message
    });
  }
});

// Eliminar producto (Admin)
app.delete('/api/admin/marketplace/items/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const productDoc = await db.collection('marketplace_products').doc(id).get();

    if (!productDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Producto no encontrado'
      });
    }

    // Marcar como eliminado en lugar de borrar
    await db.collection('marketplace_products').doc(id).update({
      status: 'eliminado',
      deletedAt: admin.firestore.Timestamp.fromDate(new Date()),
      deletedBy: req.user.uid,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log('‚úÖ [ADMIN] Producto eliminado:', id);

    res.json({
      success: true,
      message: 'Producto eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando producto:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando producto',
      error: error.message
    });
  }
});

// Listar mensajes/chats del marketplace (Admin)
app.get('/api/admin/marketplace/messages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      productId = '',
      userId = '',
      orderBy = 'createdAt',
      order = 'desc'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('marketplace_messages');

    if (productId) {
      query = query.where('productId', '==', productId);
    }

    if (userId) {
      query = query.where('participants', 'array-contains', userId);
    }

    const orderDirection = order === 'asc' ? 'asc' : 'desc';
    query = query.orderBy(orderBy, orderDirection);

    const snapshot = await query.get();
    let messages = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Paginaci√≥n
    const total = messages.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedMessages = messages.slice(startIndex, endIndex);

    console.log('‚úÖ [ADMIN] Mensajes obtenidos:', paginatedMessages.length);

    res.json({
      success: true,
      data: paginatedMessages,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo mensajes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes',
      error: error.message
    });
  }
});

// Estad√≠sticas del marketplace (Admin)
app.get('/api/admin/marketplace/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Estad√≠sticas de productos
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    const productStats = {
      total: products.length,
      disponible: products.filter(p => p.status === 'disponible').length,
      vendido: products.filter(p => p.status === 'vendido').length,
      reservado: products.filter(p => p.status === 'reservado').length,
      eliminado: products.filter(p => p.status === 'eliminado').length,
      venta: products.filter(p => p.type === 'venta').length,
      donacion: products.filter(p => p.type === 'donacion').length,
      trueque: products.filter(p => p.type === 'trueque').length,
      pendientesAprobacion: products.filter(p => !p.isApproved).length,
      reportados: products.filter(p => p.isReported).length
    };

    // Top vendedores
    const sellerCounts = {};
    products.forEach(p => {
      if (p.userId) {
        sellerCounts[p.userId] = (sellerCounts[p.userId] || 0) + 1;
      }
    });

    const topSellersIds = Object.entries(sellerCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([userId]) => userId);

    const topSellers = [];
    for (const userId of topSellersIds) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        topSellers.push({
          userId,
          name: userData.name,
          email: userData.email,
          photoUrl: userData.photoUrl,
          productsCount: sellerCounts[userId]
        });
      }
    }

    // Categor√≠as m√°s populares
    const categoryCounts = {};
    products.forEach(p => {
      const catName = p.categoryName || 'Sin categor√≠a';
      categoryCounts[catName] = (categoryCounts[catName] || 0) + 1;
    });

    const topCategories = Object.entries(categoryCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([category, count]) => ({ category, count }));

    console.log('‚úÖ [ADMIN] Estad√≠sticas del marketplace obtenidas');

    res.json({
      success: true,
      data: {
        productStats,
        topSellers,
        topCategories
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// Listar usuarios vendedores (Admin)
app.get('/api/admin/marketplace/sellers', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search = ''
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener productos para contar por usuario
    const productsSnapshot = await db.collection('marketplace_products').get();
    const products = productsSnapshot.docs.map(doc => doc.data());

    // Contar productos por usuario
    const userProductCounts = {};
    products.forEach(p => {
      if (p.userId) {
        if (!userProductCounts[p.userId]) {
          userProductCounts[p.userId] = {
            total: 0,
            disponible: 0,
            vendido: 0
          };
        }
        userProductCounts[p.userId].total++;
        if (p.status === 'disponible') userProductCounts[p.userId].disponible++;
        if (p.status === 'vendido') userProductCounts[p.userId].vendido++;
      }
    });

    // Obtener informaci√≥n de usuarios
    const sellers = [];
    for (const [userId, stats] of Object.entries(userProductCounts)) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        sellers.push({
          id: userId,
          name: userData.name,
          email: userData.email,
          phone: userData.phone,
          photoUrl: userData.photoUrl,
          createdAt: userData.createdAt,
          stats
        });
      }
    }

    // B√∫squeda
    let filteredSellers = sellers;
    if (search) {
      const searchLower = search.toLowerCase();
      filteredSellers = sellers.filter(s =>
        s.name?.toLowerCase().includes(searchLower) ||
        s.email?.toLowerCase().includes(searchLower)
      );
    }

    // Ordenar por n√∫mero de productos
    filteredSellers.sort((a, b) => b.stats.total - a.stats.total);

    // Paginaci√≥n
    const total = filteredSellers.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedSellers = filteredSellers.slice(startIndex, endIndex);

    console.log('‚úÖ [ADMIN] Vendedores obtenidos:', paginatedSellers.length);

    res.json({
      success: true,
      data: paginatedSellers,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo vendedores:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo vendedores',
      error: error.message
    });
  }
});

// ============================================================================
// üõ†Ô∏è ADMIN - GESTI√ìN DE CATEGOR√çAS
// ============================================================================

// Listar todas las categor√≠as (Admin) - con filtros y paginaci√≥n
app.get('/api/admin/marketplace/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 20, 
      search = '', 
      includeInactive = 'true',
      orderBy = 'order'
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las categor√≠as
    let query = db.collection('marketplace_categories');

    // El admin puede ver todas, incluidas las inactivas
    // (No aplicar filtro de isActive)

    // Ordenamiento
    const validOrderBy = ['order', 'name', 'createdAt', 'productCount'];
    const orderField = validOrderBy.includes(orderBy) ? orderBy : 'order';
    query = query.orderBy(orderField, 'asc');

    const snapshot = await query.get();
    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por includeInactive
    if (includeInactive === 'false') {
      categories = categories.filter(cat => cat.isActive);
    }

    // B√∫squeda por nombre o slug
    if (search && search.trim().length > 0) {
      const searchLower = search.toLowerCase().trim();
      categories = categories.filter(cat => 
        cat.name.toLowerCase().includes(searchLower) ||
        cat.slug.toLowerCase().includes(searchLower) ||
        (cat.description && cat.description.toLowerCase().includes(searchLower))
      );
    }

    // Paginaci√≥n
    const total = categories.length;
    const startIndex = (parseInt(page) - 1) * parseInt(limit);
    const endIndex = startIndex + parseInt(limit);
    const paginatedCategories = categories.slice(startIndex, endIndex);

    console.log(`‚úÖ [ADMIN] Categor√≠as listadas: ${paginatedCategories.length} de ${total}`);

    res.json({
      success: true,
      data: paginatedCategories,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / parseInt(limit))
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Crear nueva categor√≠a (Admin)
app.post('/api/admin/marketplace/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      name,
      slug,
      description,
      icon,
      imageUrl,
      imageStoragePath,
      order,
      isActive
    } = req.body;

    // Validaciones
    if (!name || name.trim().length < 2) {
      return res.status(400).json({
        success: false,
        message: 'El nombre es requerido (m√≠nimo 2 caracteres)'
      });
    }

    if (!slug || slug.trim().length < 2) {
      return res.status(400).json({
        success: false,
        message: 'El slug es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el slug sea √∫nico
    const existingSlug = await db.collection('marketplace_categories')
      .where('slug', '==', slug.trim().toLowerCase())
      .get();

    if (!existingSlug.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una categor√≠a con ese slug'
      });
    }

    const now = new Date();
    const categoryData = {
      name: name.trim(),
      slug: slug.trim().toLowerCase(),
      description: description?.trim() || '',
      icon: icon || 'üì¶',
      imageUrl: imageUrl || null,
      imageStoragePath: imageStoragePath || null,
      order: order || 999,
      isActive: isActive !== undefined ? isActive : true,
      productCount: 0,
      createdAt: now,
      updatedAt: now,
      createdBy: req.user.uid
    };

    const categoryRef = await db.collection('marketplace_categories').add(categoryData);

    console.log('‚úÖ [ADMIN] Categor√≠a creada:', categoryRef.id);

    res.json({
      success: true,
      message: 'Categor√≠a creada exitosamente',
      data: {
        id: categoryRef.id,
        ...categoryData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categor√≠a',
      error: error.message
    });
  }
});

// Actualizar categor√≠a (Admin)
app.put('/api/admin/marketplace/categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      slug,
      description,
      icon,
      imageUrl,
      imageStoragePath,
      order,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const updateData = {
      updatedAt: new Date()
    };

    if (name) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (icon) updateData.icon = icon;
    if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
    if (imageStoragePath !== undefined) updateData.imageStoragePath = imageStoragePath;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive;

    // Si se cambia el slug, verificar que sea √∫nico
    if (slug && slug !== categoryDoc.data().slug) {
      const existingSlug = await db.collection('marketplace_categories')
        .where('slug', '==', slug.trim().toLowerCase())
        .get();

      if (!existingSlug.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una categor√≠a con ese slug'
        });
      }

      updateData.slug = slug.trim().toLowerCase();
    }

    await db.collection('marketplace_categories').doc(id).update(updateData);

    console.log('‚úÖ [ADMIN] Categor√≠a actualizada:', id);

    res.json({
      success: true,
      message: 'Categor√≠a actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categor√≠a',
      error: error.message
    });
  }
});

// Eliminar categor√≠a (Admin)
app.delete('/api/admin/marketplace/categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    // Verificar que no tenga productos
    const categoryData = categoryDoc.data();
    if (categoryData.productCount > 0) {
      return res.status(400).json({
        success: false,
        message: `No se puede eliminar. La categor√≠a tiene ${categoryData.productCount} productos asociados. Primero elimina o reasigna los productos.`
      });
    }

    // Eliminar imagen de Storage si existe
    if (categoryData.imageStoragePath) {
      try {
        const bucket = admin.storage().bucket();
        const file = bucket.file(categoryData.imageStoragePath);
        await file.delete();
        console.log('üóëÔ∏è [ADMIN] Imagen de categor√≠a eliminada:', categoryData.imageStoragePath);
      } catch (error) {
        console.warn('‚ö†Ô∏è [ADMIN] No se pudo eliminar la imagen:', error.message);
      }
    }

    await db.collection('marketplace_categories').doc(id).delete();

    console.log('‚úÖ [ADMIN] Categor√≠a eliminada:', id);

    res.json({
      success: true,
      message: 'Categor√≠a eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categor√≠a',
      error: error.message
    });
  }
});

// Toggle activo/inactivo (Admin)
app.patch('/api/admin/marketplace/categories/:id/toggle', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const categoryDoc = await db.collection('marketplace_categories').doc(id).get();

    if (!categoryDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const currentStatus = categoryDoc.data().isActive;
    const newStatus = !currentStatus;

    await db.collection('marketplace_categories').doc(id).update({
      isActive: newStatus,
      updatedAt: new Date()
    });

    console.log('‚úÖ [ADMIN] Categor√≠a toggle:', id, '->', newStatus);

    res.json({
      success: true,
      message: `Categor√≠a ${newStatus ? 'activada' : 'desactivada'} exitosamente`,
      data: {
        isActive: newStatus
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en toggle de categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categor√≠a',
      error: error.message
    });
  }
});

// Subir imagen de categor√≠a (Admin)
app.post('/api/admin/marketplace/categories/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    const { categoryId } = req.body;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    // Validar tipo de archivo
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
    if (!allowedTypes.includes(req.file.mimetype)) {
      return res.status(400).json({
        success: false,
        message: 'Formato de imagen no v√°lido. Solo JPG, PNG o WEBP'
      });
    }

    // Validar tama√±o (m√°ximo 2MB)
    if (req.file.size > 2 * 1024 * 1024) {
      return res.status(400).json({
        success: false,
        message: 'La imagen no debe superar 2MB'
      });
    }

    // Obtener bucket de Firebase Storage
    const bucket = admin.storage().bucket();
    
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Firebase Storage no disponible'
      });
    }

    const timestamp = Date.now();
    const fileName = `${categoryId || timestamp}_${req.file.originalname}`;
    const filePath = `marketplace/categories/${fileName}`;
    const file = bucket.file(filePath);

    const stream = file.createWriteStream({
      metadata: {
        contentType: req.file.mimetype,
      },
    });

    stream.on('error', (error) => {
      console.error('‚ùå [ADMIN] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      await file.makePublic();
      const publicUrl = `https://storage.googleapis.com/${bucket.name}/${filePath}`;

      console.log('‚úÖ [ADMIN] Imagen de categor√≠a subida:', filePath);

      res.json({
        success: true,
        message: 'Imagen subida exitosamente',
        data: {
          imageUrl: publicUrl,
          imageStoragePath: filePath
        }
      });
    });

    stream.end(req.file.buffer);

  } catch (error) {
    console.error('‚ùå [ADMIN] Error en upload de imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Inicializar categor√≠as por defecto (Admin)
app.post('/api/admin/marketplace/categories/init-defaults', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar si ya existen categor√≠as
    const existingCategories = await db.collection('marketplace_categories').get();
    if (!existingCategories.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existen categor√≠as en el sistema'
      });
    }

    const defaultCategories = [
      {
        name: 'Transporte',
        slug: 'transporte',
        description: 'Carriolas, sillas de auto, portabeb√©s',
        icon: 'üöó',
        order: 1
      },
      {
        name: 'Ropa',
        slug: 'ropa',
        description: 'Ropa de beb√©, mam√° y embarazo',
        icon: 'üëï',
        order: 2
      },
      {
        name: 'Juguetes',
        slug: 'juguetes',
        description: 'Juguetes educativos y de entretenimiento',
        icon: 'üß∏',
        order: 3
      },
      {
        name: 'Alimentaci√≥n',
        slug: 'alimentacion',
        description: 'Biberones, extractores, esterilizadores',
        icon: 'üçº',
        order: 4
      },
      {
        name: 'Muebles',
        slug: 'muebles',
        description: 'Cunas, cambiadores, mecedoras',
        icon: 'üõèÔ∏è',
        order: 5
      },
      {
        name: 'Higiene',
        slug: 'higiene',
        description: 'Ba√±eras, pa√±aleras, cambiadores',
        icon: 'üßº',
        order: 6
      },
      {
        name: 'Libros',
        slug: 'libros',
        description: 'Libros infantiles y de crianza',
        icon: 'üìö',
        order: 7
      },
      {
        name: 'Maternidad',
        slug: 'maternidad',
        description: 'Ropa de embarazo, almohadas, fajas',
        icon: 'ü§∞',
        order: 8
      },
      {
        name: 'Electr√≥nica',
        slug: 'electronica',
        description: 'Monitores, calentadores, luces',
        icon: 'üì±',
        order: 9
      },
      {
        name: 'Otros',
        slug: 'otros',
        description: 'Otros art√≠culos para beb√©',
        icon: 'üì¶',
        order: 10
      }
    ];

    const now = new Date();
    const batch = db.batch();

    defaultCategories.forEach(category => {
      const categoryRef = db.collection('marketplace_categories').doc();
      batch.set(categoryRef, {
        ...category,
        imageUrl: null,
        imageStoragePath: null,
        isActive: true,
        productCount: 0,
        createdAt: now,
        updatedAt: now,
        createdBy: req.user.uid
      });
    });

    await batch.commit();

    console.log('‚úÖ [ADMIN] Categor√≠as por defecto inicializadas');

    res.json({
      success: true,
      message: `${defaultCategories.length} categor√≠as creadas exitosamente`,
      data: {
        count: defaultCategories.length
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error inicializando categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error inicializando categor√≠as',
      error: error.message
    });
  }
});

// ============================================================================
// üé® BANNERS - Sistema de Banners Rotativos
// ============================================================================

// Obtener banners activos (p√∫blico)
app.get('/api/banners', async (req, res) => {
  try {
    const { section } = req.query; // Filtrar por secci√≥n: home, marketplace, products, etc.

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();

    // Obtener banners activos
    let query = db.collection('banners')
      .where('isActive', '==', true);

    // Filtrar por secci√≥n si se proporciona
    if (section) {
      query = query.where('section', '==', section);
    }

    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();

    let banners = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por fechas de visibilidad
    banners = banners.filter(banner => {
      const startDate = banner.startDate?.toDate?.() || new Date(0);
      const endDate = banner.endDate?.toDate?.() || new Date('2099-12-31');
      return now >= startDate && now <= endDate;
    });

    console.log(`üì∞ [BANNERS] Banners activos${section ? ` para secci√≥n "${section}"` : ''}: ${banners.length}`);

    res.json({
      success: true,
      data: banners
    });

  } catch (error) {
    console.error('‚ùå [BANNERS] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// ============================================================================
// üé® ADMIN - Gesti√≥n de Banners
// ============================================================================

// Listar productos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/products-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 50 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener productos disponibles
    let query = db.collection('marketplace_products')
      .where('status', '==', 'disponible')
      .orderBy('createdAt', 'desc')
      .limit(parseInt(limit));

    const snapshot = await query.get();
    let products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // B√∫squeda por texto si se proporciona
    if (search) {
      const searchLower = search.toLowerCase();
      products = products.filter(p =>
        p.title?.toLowerCase().includes(searchLower) ||
        p.categoryName?.toLowerCase().includes(searchLower)
      );
    }

    // Formatear para el selector
    const productOptions = products.map(p => ({
      id: p.id,
      title: p.title,
      category: p.categoryName || 'Sin categor√≠a',
      imageUrl: p.photos?.[0] || null,
      link: `/marketplace/item/${p.id}`,
      label: `üõçÔ∏è ${p.title} (${p.categoryName || 'Sin categor√≠a'})`
    }));

    console.log('‚úÖ [ADMIN] Productos para selector:', productOptions.length);

    res.json({
      success: true,
      data: productOptions
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo productos para selector:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo productos',
      error: error.message
    });
  }
});

// Listar art√≠culos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/articles-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 50 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('articles')
      .where('status', '==', 'published')
      .orderBy('publishedAt', 'desc')
      .limit(parseInt(limit));

    const snapshot = await query.get();
    let articles = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      articles = articles.filter(a =>
        a.title?.toLowerCase().includes(searchLower) ||
        a.summary?.toLowerCase().includes(searchLower)
      );
    }

    const articleOptions = articles.map(a => ({
      id: a.id,
      title: a.title,
      publishedAt: a.publishedAt || null,
      coverImageUrl: a.coverImageUrl || null,
      linkType: 'article',
      label: `üì∞ ${a.title}`
    }));

    res.json({
      success: true,
      data: articleOptions
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo art√≠culos para selector:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo art√≠culos',
      error: error.message
    });
  }
});

// Listar categor√≠as de art√≠culos para selector de enlaces en banners (admin)
app.get('/api/admin/banners/article-categories-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 100 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('article_categories')
      .orderBy('name', 'asc')
      .limit(parseInt(limit))
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(c =>
        c.name?.toLowerCase().includes(searchLower)
      );
    }

    const categoryOptions = categories.map(c => ({
      id: c.id,
      name: c.name,
      linkType: 'article-category',
      label: `üìÇ ${c.name}`
    }));

    res.json({
      success: true,
      data: categoryOptions
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo categor√≠as de art√≠culos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Listar categor√≠as de recomendaciones para selector de enlaces en banners (admin)
app.get('/api/admin/banners/recommendation-categories-selector', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { search = '', limit = 100 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('categories')
      .orderBy('name', 'asc')
      .limit(parseInt(limit))
      .get();

    let categories = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    if (search) {
      const searchLower = search.toLowerCase();
      categories = categories.filter(c =>
        c.name?.toLowerCase().includes(searchLower)
      );
    }

    const categoryOptions = categories.map(c => ({
      id: c.id,
      name: c.name,
      linkType: 'recommendation-category',
      label: `‚≠ê ${c.name}`
    }));

    res.json({
      success: true,
      data: categoryOptions
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo categor√≠as de recomendaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as de recomendaciones',
      error: error.message
    });
  }
});

// Listar todos los banners (admin)
app.get('/api/admin/banners', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search = '',
      includeInactive = 'true',
      section
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('banners');

    // Filtrar por estado activo
    if (includeInactive === 'false') {
      query = query.where('isActive', '==', true);
    }

    // Filtrar por secci√≥n si se proporciona
    if (section) {
      query = query.where('section', '==', section);
    }

    // Ordenar
    query = query.orderBy('order', 'asc');

    const snapshot = await query.get();
    let banners = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // B√∫squeda por texto
    if (search) {
      const searchLower = search.toLowerCase();
      banners = banners.filter(banner =>
        banner.title?.toLowerCase().includes(searchLower) ||
        banner.description?.toLowerCase().includes(searchLower)
      );
    }

    // Paginaci√≥n
    const total = banners.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedBanners = banners.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedBanners,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo banners:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banners',
      error: error.message
    });
  }
});

// Obtener banner espec√≠fico (admin)
app.get('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const banner = {
      id: bannerDoc.id,
      ...bannerDoc.data()
    };

    console.log('‚úÖ [ADMIN] Banner obtenido:', id);

    res.json({
      success: true,
      data: banner
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo banner',
      error: error.message
    });
  }
});

// Crear banner (admin)
app.post('/api/admin/banners', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      title,
      description,
      imageUrl,
      imageStoragePath,
      link,
      linkType,
      articleId,
      articleCategoryId,
      recommendationCategoryId,
      order,
      duration,
      startDate,
      endDate,
      isActive,
      section
    } = req.body;

    // Validaciones
    if (!title || title.trim().length < 3) {
      return res.status(400).json({
        success: false,
        message: 'El t√≠tulo es requerido (m√≠nimo 3 caracteres)'
      });
    }

    if (!imageUrl) {
      return res.status(400).json({
        success: false,
        message: 'La imagen es requerida'
      });
    }

    // Validar secci√≥n
    const validSections = [
      'home',
      'home1',
      'home2',
      'home3',
      'marketplace',
      'products',
      'comunidades',
      'recomendaciones',
      'medicina',
      'crecimiento',
      'vacunas',
      'denticion',
      'hitos',
      'menu-lateral'
    ];
    if (section && !validSections.includes(section)) {
      return res.status(400).json({
        success: false,
        message: `Secci√≥n inv√°lida. Debe ser: ${validSections.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const validLinkTypes = [
      'url',
      'article',
      'article-category',
      'recommendation-category',
      'denticion',
      'crecimiento',
      'hitos',
      'medicacion',
      'vacunas',
      'solicitud-servicio',
      'none'
    ];
    let resolvedLinkType = linkType;
    if (!resolvedLinkType) {
      if (articleId) {
        resolvedLinkType = 'article';
      } else if (link) {
        resolvedLinkType = 'url';
      } else {
        resolvedLinkType = 'none';
      }
    }
    if (!validLinkTypes.includes(resolvedLinkType)) {
      return res.status(400).json({
        success: false,
        message: `Tipo de navegaci√≥n inv√°lido. Debe ser: ${validLinkTypes.join(', ')}`
      });
    }
    if (resolvedLinkType === 'article' && !articleId) {
      return res.status(400).json({
        success: false,
        message: 'articleId es requerido cuando linkType es article'
      });
    }
    if (resolvedLinkType === 'article-category' && !articleCategoryId) {
      return res.status(400).json({
        success: false,
        message: 'articleCategoryId es requerido cuando linkType es article-category'
      });
    }
    if (resolvedLinkType === 'recommendation-category' && !recommendationCategoryId) {
      return res.status(400).json({
        success: false,
        message: 'recommendationCategoryId es requerido cuando linkType es recommendation-category'
      });
    }

    let resolvedArticleId = articleId || null;
    if (resolvedLinkType === 'article') {
      const articleDoc = await db.collection('articles').doc(resolvedArticleId).get();
      if (!articleDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleId inv√°lido'
        });
      }
    }
    let resolvedArticleCategoryId = articleCategoryId || null;
    if (resolvedLinkType === 'article-category') {
      const categoryDoc = await db.collection('article_categories').doc(resolvedArticleCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId inv√°lido'
        });
      }
    }
    let resolvedRecommendationCategoryId = recommendationCategoryId || null;
    if (resolvedLinkType === 'recommendation-category') {
      const categoryDoc = await db.collection('categories').doc(resolvedRecommendationCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId inv√°lido'
        });
      }
    }

    const now = new Date();
    
    // Convertir fechas a Timestamp de Firestore
    let processedStartDate;
    if (startDate) {
      if (typeof startDate === 'object' && startDate._seconds) {
        processedStartDate = admin.firestore.Timestamp.fromMillis(startDate._seconds * 1000);
      } else {
        processedStartDate = admin.firestore.Timestamp.fromDate(new Date(startDate));
      }
    } else {
      processedStartDate = admin.firestore.Timestamp.fromDate(now);
    }
    
    let processedEndDate = null;
    if (endDate) {
      if (typeof endDate === 'object' && endDate._seconds) {
        processedEndDate = admin.firestore.Timestamp.fromMillis(endDate._seconds * 1000);
      } else {
        processedEndDate = admin.firestore.Timestamp.fromDate(new Date(endDate));
      }
    }
    
    const bannerData = {
      title: title.trim(),
      description: description?.trim() || '',
      imageUrl,
      imageStoragePath: imageStoragePath || null,
      link: resolvedLinkType === 'url' ? (link?.trim() || null) : null,
      linkType: resolvedLinkType,
      articleId: resolvedLinkType === 'article' ? resolvedArticleId : null,
      articleCategoryId: resolvedLinkType === 'article-category' ? resolvedArticleCategoryId : null,
      recommendationCategoryId: resolvedLinkType === 'recommendation-category' ? resolvedRecommendationCategoryId : null,
      section: section || 'home', // Por defecto: home
      order: order || 999,
      duration: duration || 5, // Duraci√≥n en segundos (por defecto 5s)
      startDate: processedStartDate,
      endDate: processedEndDate,
      isActive: isActive !== undefined ? isActive : true,
      views: 0,
      clicks: 0,
      createdAt: admin.firestore.Timestamp.fromDate(now),
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      createdBy: req.user.uid
    };

    const bannerRef = await db.collection('banners').add(bannerData);

    console.log('‚úÖ [ADMIN] Banner creado:', bannerRef.id);

    res.json({
      success: true,
      message: 'Banner creado exitosamente',
      data: {
        id: bannerRef.id,
        ...bannerData
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error creando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando banner',
      error: error.message
    });
  }
});

// Actualizar banner (admin)
app.put('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      title,
      description,
      imageUrl,
      imageStoragePath,
      link,
      linkType,
      articleId,
      articleCategoryId,
      recommendationCategoryId,
      section,
      order,
      duration,
      startDate,
      endDate,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const updateData = {
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    };

    if (title) {
      if (title.trim().length < 3) {
        return res.status(400).json({
          success: false,
          message: 'El t√≠tulo debe tener al menos 3 caracteres'
        });
      }
      updateData.title = title.trim();
    }

    if (description !== undefined) {
      updateData.description = description.trim();
    }

    if (imageUrl) {
      updateData.imageUrl = imageUrl;
    }

    if (imageStoragePath !== undefined) {
      updateData.imageStoragePath = imageStoragePath;
    }

    if (link !== undefined) {
      updateData.link = link?.trim() || null;
    }

    const validLinkTypes = [
      'url',
      'article',
      'article-category',
      'recommendation-category',
      'denticion',
      'crecimiento',
      'hitos',
      'medicacion',
      'vacunas',
      'solicitud-servicio',
      'none'
    ];
    if (linkType !== undefined) {
      if (!validLinkTypes.includes(linkType)) {
        return res.status(400).json({
          success: false,
          message: `Tipo de navegaci√≥n inv√°lido. Debe ser: ${validLinkTypes.join(', ')}`
        });
      }
      updateData.linkType = linkType;
    }

    if (articleId !== undefined) {
      updateData.articleId = articleId || null;
    }

    if (articleCategoryId !== undefined) {
      updateData.articleCategoryId = articleCategoryId || null;
    }
    if (recommendationCategoryId !== undefined) {
      updateData.recommendationCategoryId = recommendationCategoryId || null;
    }

    if (updateData.linkType === 'article' || (linkType === undefined && updateData.articleId)) {
      const resolvedArticleId = updateData.articleId || bannerDoc.data().articleId;
      if (!resolvedArticleId) {
        return res.status(400).json({
          success: false,
          message: 'articleId es requerido cuando linkType es article'
        });
      }
      const articleDoc = await db.collection('articles').doc(resolvedArticleId).get();
      if (!articleDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleId inv√°lido'
        });
      }
      updateData.link = null;
      updateData.articleId = resolvedArticleId;
      updateData.articleCategoryId = null;
    } else if (updateData.linkType === 'article-category' || (linkType === undefined && updateData.articleCategoryId)) {
      const resolvedCategoryId = updateData.articleCategoryId || bannerDoc.data().articleCategoryId;
      if (!resolvedCategoryId) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId es requerido cuando linkType es article-category'
        });
      }
      const categoryDoc = await db.collection('article_categories').doc(resolvedCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'articleCategoryId inv√°lido'
        });
      }
      updateData.link = null;
      updateData.articleCategoryId = resolvedCategoryId;
      updateData.articleId = null;
      updateData.recommendationCategoryId = null;
    } else if (updateData.linkType === 'recommendation-category' || (linkType === undefined && updateData.recommendationCategoryId)) {
      const resolvedCategoryId = updateData.recommendationCategoryId || bannerDoc.data().recommendationCategoryId;
      if (!resolvedCategoryId) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId es requerido cuando linkType es recommendation-category'
        });
      }
      const categoryDoc = await db.collection('categories').doc(resolvedCategoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({
          success: false,
          message: 'recommendationCategoryId inv√°lido'
        });
      }
      updateData.link = null;
      updateData.recommendationCategoryId = resolvedCategoryId;
      updateData.articleId = null;
      updateData.articleCategoryId = null;
    } else if (updateData.linkType === 'url') {
      updateData.articleId = null;
      updateData.articleCategoryId = null;
      updateData.recommendationCategoryId = null;
    } else if (updateData.linkType === 'none') {
      updateData.articleId = null;
      updateData.articleCategoryId = null;
      updateData.recommendationCategoryId = null;
      updateData.link = null;
    }

    if (section !== undefined) {
      const validSections = [
        'home',
        'home1',
        'home2',
        'home3',
        'marketplace',
        'products',
        'comunidades',
        'recomendaciones',
        'medicina',
        'crecimiento',
        'vacunas',
        'denticion',
        'hitos'
      ];
      if (section && !validSections.includes(section)) {
        return res.status(400).json({
          success: false,
          message: `Secci√≥n inv√°lida. Debe ser: ${validSections.join(', ')}`
        });
      }
      updateData.section = section || 'home';
    }

    if (order !== undefined) {
      updateData.order = parseInt(order);
    }

    if (duration !== undefined) {
      updateData.duration = parseInt(duration);
    }

    if (startDate !== undefined) {
      if (startDate === null || startDate === '') {
        updateData.startDate = null;
      } else if (typeof startDate === 'object' && startDate._seconds) {
        // Es un Timestamp de Firestore serializado
        updateData.startDate = admin.firestore.Timestamp.fromMillis(startDate._seconds * 1000);
      } else if (typeof startDate === 'string' || typeof startDate === 'number') {
        // Es un string ISO o timestamp en milisegundos
        updateData.startDate = admin.firestore.Timestamp.fromDate(new Date(startDate));
      }
    }

    if (endDate !== undefined) {
      if (endDate === null || endDate === '') {
        updateData.endDate = null;
      } else if (typeof endDate === 'object' && endDate._seconds) {
        // Es un Timestamp de Firestore serializado
        updateData.endDate = admin.firestore.Timestamp.fromMillis(endDate._seconds * 1000);
      } else if (typeof endDate === 'string' || typeof endDate === 'number') {
        // Es un string ISO o timestamp en milisegundos
        updateData.endDate = admin.firestore.Timestamp.fromDate(new Date(endDate));
      }
    }

    if (isActive !== undefined) {
      updateData.isActive = isActive;
    }

    await db.collection('banners').doc(id).update(updateData);

    console.log('‚úÖ [ADMIN] Banner actualizado:', id);

    res.json({
      success: true,
      message: 'Banner actualizado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando banner',
      error: error.message
    });
  }
});

// Eliminar banner (admin)
app.delete('/api/admin/banners/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const bannerData = bannerDoc.data();

    // Eliminar imagen de Storage si existe
    if (bannerData.imageStoragePath) {
      try {
        const bucket = admin.storage().bucket();
        const file = bucket.file(bannerData.imageStoragePath);
        await file.delete();
        console.log('üóëÔ∏è [ADMIN] Imagen de banner eliminada:', bannerData.imageStoragePath);
      } catch (error) {
        console.warn('‚ö†Ô∏è [ADMIN] No se pudo eliminar la imagen:', error.message);
      }
    }

    await db.collection('banners').doc(id).delete();

    console.log('‚úÖ [ADMIN] Banner eliminado:', id);

    res.json({
      success: true,
      message: 'Banner eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error eliminando banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando banner',
      error: error.message
    });
  }
});

// Activar/Desactivar banner (admin)
app.patch('/api/admin/banners/:id/toggle', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const bannerDoc = await db.collection('banners').doc(id).get();

    if (!bannerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Banner no encontrado'
      });
    }

    const currentStatus = bannerDoc.data().isActive;
    const newStatus = !currentStatus;

    await db.collection('banners').doc(id).update({
      isActive: newStatus,
      updatedAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log('‚úÖ [ADMIN] Banner toggle:', id, newStatus ? 'ACTIVADO' : 'DESACTIVADO');

    res.json({
      success: true,
      message: `Banner ${newStatus ? 'activado' : 'desactivado'} exitosamente`,
      isActive: newStatus
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error toggle banner:', error);
    res.status(500).json({
      success: false,
      message: 'Error cambiando estado del banner',
      error: error.message
    });
  }
});

// Subir imagen de banner (admin)
app.post('/api/admin/banners/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    const bucket = admin.storage().bucket();
    
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Firebase Storage no disponible'
      });
    }

    const timestamp = Date.now();
    const fileName = `banners/${timestamp}_${req.file.originalname}`;
    const file = bucket.file(fileName);

    await file.save(req.file.buffer, {
      metadata: {
        contentType: req.file.mimetype,
      },
      public: true,
    });

    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;

    console.log('‚úÖ [ADMIN] Imagen de banner subida:', fileName);

    res.json({
      success: true,
      message: 'Imagen subida exitosamente',
      data: {
        imageUrl: publicUrl,
        imageStoragePath: fileName
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error subiendo imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Incrementar vistas de banner (p√∫blico)
app.post('/api/banners/:id/view', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('banners').doc(id).update({
      views: admin.firestore.FieldValue.increment(1)
    });

    res.json({
      success: true,
      message: 'Vista registrada'
    });

  } catch (error) {
    console.error('‚ùå [BANNERS] Error registrando vista:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando vista',
      error: error.message
    });
  }
});

// Incrementar clicks de banner (p√∫blico)
app.post('/api/banners/:id/click', async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('banners').doc(id).update({
      clicks: admin.firestore.FieldValue.increment(1)
    });

    res.json({
      success: true,
      message: 'Click registrado'
    });

  } catch (error) {
    console.error('‚ùå [BANNERS] Error registrando click:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando click',
      error: error.message
    });
  }
});

// ============================================================================
// üìä ANALYTICS - Sistema de Analytics para Recomendaciones
// ============================================================================

// Tipos de eventos v√°lidos
const ANALYTICS_EVENT_TYPES = [
  'view',      // Vista de recomendaci√≥n
  'call',      // Llamada telef√≥nica
  'whatsapp',  // Contacto por WhatsApp
  'email',     // Click en email
  'website',   // Click en website
  'map',       // Click en mapa
  'share',     // Compartir recomendaci√≥n
  'favorite',  // Agregar a favoritos
  'wishlist'   // Agregar a wishlist
];

// Registrar evento de analytics (p√∫blico)
app.post('/api/recommendations/:recommendationId/analytics/events', async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      eventType,
      metadata = {},
      userId = null,
      source = 'app',
      utmParams = {}
    } = req.body;

    // Validaciones
    if (!eventType || !ANALYTICS_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `Tipo de evento inv√°lido. Debe ser uno de: ${ANALYTICS_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la recomendaci√≥n existe
    const recommendationRef = db.collection('recommendations').doc(recommendationId);
    const recommendationDoc = await recommendationRef.get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendaci√≥n no encontrada'
      });
    }

    const now = new Date();

    // Crear evento de analytics
    const analyticsEvent = {
      recommendationId,
      eventType,
      userId,
      source,
      metadata,
      utmParams: {
        utm_source: utmParams.utm_source || null,
        utm_medium: utmParams.utm_medium || null,
        utm_campaign: utmParams.utm_campaign || null,
        utm_content: utmParams.utm_content || null,
        utm_term: utmParams.utm_term || null
      },
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    // Guardar evento
    const eventRef = await db.collection('recommendation_analytics').add(analyticsEvent);

    // Actualizar contadores en la recomendaci√≥n
    const updateData = {
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    // Incrementar contador espec√≠fico seg√∫n el tipo de evento
    switch (eventType) {
      case 'view':
        updateData['analytics.views'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'call':
        updateData['analytics.calls'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'whatsapp':
        updateData['analytics.whatsappClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'email':
        updateData['analytics.emailClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'website':
        updateData['analytics.websiteClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'map':
        updateData['analytics.mapClicks'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'share':
        updateData['analytics.shares'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'favorite':
        updateData['analytics.favorites'] = admin.firestore.FieldValue.increment(1);
        break;
      case 'wishlist':
        updateData['analytics.wishlists'] = admin.firestore.FieldValue.increment(1);
        break;
    }

    // Total de interacciones (excluye views)
    if (eventType !== 'view') {
      updateData['analytics.totalInteractions'] = admin.firestore.FieldValue.increment(1);
    }

    await recommendationRef.update(updateData);

    console.log(`üìä [ANALYTICS] Evento registrado: ${eventType} - Recomendaci√≥n: ${recommendationId}`);

    res.json({
      success: true,
      message: 'Evento registrado exitosamente',
      data: {
        eventId: eventRef.id,
        eventType,
        timestamp: now
      }
    });

  } catch (error) {
    console.error('‚ùå [ANALYTICS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento',
      error: error.message
    });
  }
});

// Obtener estad√≠sticas de una recomendaci√≥n (p√∫blico)
app.get('/api/recommendations/:recommendationId/analytics', async (req, res) => {
  try {
    const { recommendationId } = req.params;
    const {
      startDate,
      endDate,
      eventType,
      groupBy = 'day' // day, week, month
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que la recomendaci√≥n existe
    const recommendationDoc = await db.collection('recommendations').doc(recommendationId).get();

    if (!recommendationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recomendaci√≥n no encontrada'
      });
    }

    const recommendationData = recommendationDoc.data();

    // Obtener eventos de analytics
    let query = db.collection('recommendation_analytics')
      .where('recommendationId', '==', recommendationId);

    // Filtros opcionales
    if (startDate) {
      query = query.where('timestamp', '>=', admin.firestore.Timestamp.fromDate(new Date(startDate)));
    }

    if (endDate) {
      query = query.where('timestamp', '<=', admin.firestore.Timestamp.fromDate(new Date(endDate)));
    }

    if (eventType && ANALYTICS_EVENT_TYPES.includes(eventType)) {
      query = query.where('eventType', '==', eventType);
    }

    query = query.orderBy('timestamp', 'desc');

    const snapshot = await query.get();
    const events = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Agregar estad√≠sticas por tipo de evento
    const eventStats = {};
    ANALYTICS_EVENT_TYPES.forEach(type => {
      eventStats[type] = events.filter(e => e.eventType === type).length;
    });

    // Estad√≠sticas agregadas de la recomendaci√≥n
    const aggregatedStats = recommendationData.analytics || {
      views: 0,
      calls: 0,
      whatsappClicks: 0,
      emailClicks: 0,
      websiteClicks: 0,
      mapClicks: 0,
      shares: 0,
      favorites: 0,
      wishlists: 0,
      totalInteractions: 0
    };

    // Calcular tasa de conversi√≥n (interacciones / vistas)
    const conversionRate = aggregatedStats.views > 0
      ? (aggregatedStats.totalInteractions / aggregatedStats.views) * 100
      : 0;

    // Fuentes de tr√°fico (utm_source)
    const trafficSources = {};
    events.forEach(event => {
      const source = event.utmParams?.utm_source || 'direct';
      trafficSources[source] = (trafficSources[source] || 0) + 1;
    });

    // Eventos recientes (√∫ltimos 10)
    const recentEvents = events.slice(0, 10);

    console.log(`üìä [ANALYTICS] Estad√≠sticas obtenidas - Recomendaci√≥n: ${recommendationId}`);

    res.json({
      success: true,
      data: {
        recommendationId,
        aggregatedStats,
        eventStats,
        conversionRate: Math.round(conversionRate * 100) / 100,
        trafficSources,
        recentEvents,
        totalEvents: events.length,
        dateRange: {
          start: startDate || null,
          end: endDate || null
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [ANALYTICS] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// Obtener estad√≠sticas globales (admin)
app.get('/api/admin/analytics/recommendations', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      startDate,
      endDate,
      limit = 20
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las recomendaciones con analytics
    const recommendationsSnapshot = await db.collection('recommendations')
      .orderBy('analytics.views', 'desc')
      .limit(parseInt(limit))
      .get();

    const recommendations = recommendationsSnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title || 'Sin t√≠tulo',
        description: data.description || '',
        category: data.category || 'general',
        categoryName: data.categoryName || data.category || 'General',
        imageUrl: data.imageUrl || data.images?.[0] || null,
        location: data.location || {},
        phone: data.phone || null,
        website: data.website || null,
        email: data.email || null,
        whatsapp: data.whatsapp || data.phone || null,
        createdBy: data.createdBy || null,
        createdByName: data.createdByName || 'Usuario',
        analytics: data.analytics || {
          views: 0,
          calls: 0,
          whatsappClicks: 0,
          emailClicks: 0,
          websiteClicks: 0,
          mapClicks: 0,
          shares: 0,
          favorites: 0,
          wishlists: 0,
          totalInteractions: 0
        },
        createdAt: data.createdAt,
        updatedAt: data.updatedAt
      };
    });

    // Estad√≠sticas totales
    let totalStats = {
      views: 0,
      calls: 0,
      whatsappClicks: 0,
      emailClicks: 0,
      websiteClicks: 0,
      mapClicks: 0,
      shares: 0,
      favorites: 0,
      wishlists: 0,
      totalInteractions: 0
    };

    recommendations.forEach(rec => {
      const analytics = rec.analytics || {};
      Object.keys(totalStats).forEach(key => {
        totalStats[key] += (analytics[key] || 0);
      });
    });

    // Recomendaciones m√°s populares (por vistas)
    const topByViews = [...recommendations]
      .sort((a, b) => (b.analytics.views || 0) - (a.analytics.views || 0))
      .slice(0, 10);

    // Recomendaciones con m√°s interacciones
    const topByInteractions = [...recommendations]
      .sort((a, b) => (b.analytics.totalInteractions || 0) - (a.analytics.totalInteractions || 0))
      .slice(0, 10);

    // Recomendaciones con mejor conversi√≥n
    const topByConversion = [...recommendations]
      .map(rec => ({
        ...rec,
        conversionRate: rec.analytics.views > 0
          ? (rec.analytics.totalInteractions / rec.analytics.views) * 100
          : 0
      }))
      .filter(rec => rec.analytics.views >= 3) // M√≠nimo 3 vistas para conversi√≥n confiable
      .sort((a, b) => b.conversionRate - a.conversionRate)
      .slice(0, 10);

    console.log('üìä [ADMIN] Estad√≠sticas globales obtenidas');

    res.json({
      success: true,
      data: {
        totalStats,
        totalRecommendations: recommendations.length,
        topByViews,
        topByInteractions,
        topByConversion
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas globales:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas globales',
      error: error.message
    });
  }
});

// ============================================================================
// üîî SISTEMA DE NOTIFICACIONES PUSH - FIREBASE CLOUD MESSAGING (FCM)
// ============================================================================

// Funci√≥n helper para enviar notificaciones push
async function sendPushNotification(tokens, notification, data = {}) {
  try {
    if (!tokens || tokens.length === 0) {
      console.log('‚ö†Ô∏è [PUSH] No hay tokens para enviar notificaci√≥n');
      return { success: false, message: 'No tokens provided' };
    }

    // Asegurar que tokens sea un array
    const tokenArray = Array.isArray(tokens) ? tokens : [tokens];
    
    // Filtrar tokens v√°lidos
    const validTokens = tokenArray.filter(token => token && typeof token === 'string' && token.length > 0);
    
    if (validTokens.length === 0) {
      console.log('‚ö†Ô∏è [PUSH] No hay tokens v√°lidos');
      return { success: false, message: 'No valid tokens' };
    }

    // Separar tokens de Expo de tokens de FCM
    const expoTokens = validTokens.filter(token => token.startsWith('ExponentPushToken['));
    const fcmTokens = validTokens.filter(token => !token.startsWith('ExponentPushToken['));

    console.log(`üìä [PUSH] Tokens Expo: ${expoTokens.length}, Tokens FCM: ${fcmTokens.length}`);

    let totalSuccess = 0;
    let totalFailure = 0;
    const failedTokens = [];

    // Enviar a tokens de Expo
    if (expoTokens.length > 0) {
      const expoResult = await sendExpoNotifications(expoTokens, notification, data);
      totalSuccess += expoResult.successCount;
      totalFailure += expoResult.failureCount;
      if (expoResult.failedTokens) {
        failedTokens.push(...expoResult.failedTokens);
      }
    }

    // Enviar a tokens de FCM
    if (fcmTokens.length > 0) {
      const fcmResult = await sendFCMNotifications(fcmTokens, notification, data);
      totalSuccess += fcmResult.successCount;
      totalFailure += fcmResult.failureCount;
      if (fcmResult.failedTokens) {
        failedTokens.push(...fcmResult.failedTokens);
      }
    }

    console.log(`‚úÖ [PUSH] Total notificaciones enviadas: ${totalSuccess}/${validTokens.length}`);

    // Limpiar tokens inv√°lidos
    if (failedTokens.length > 0) {
      await cleanInvalidTokens(failedTokens);
    }

    return {
      success: true,
      successCount: totalSuccess,
      failureCount: totalFailure
    };

  } catch (error) {
    console.error('‚ùå [PUSH] Error enviando notificaci√≥n:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// üìä ANALYTICS - UI (Pantallas y Botones)
// ============================================================================
const UI_ANALYTICS_EVENT_TYPES = ['view', 'click'];
const DEEPLINK_EVENT_TYPES = ['click', 'open', 'view'];

const buildDeeplinkUrl = (path, params = {}) => {
  const cleanPath = String(path || '').trim().replace(/^\/+/, '');
  if (!cleanPath) return null;
  const entries = Object.entries(params || {}).filter(
    ([key, value]) => key && value !== undefined && value !== null && value !== ''
  );
  let url = `munpa://${cleanPath}`;
  if (entries.length > 0) {
    const query = entries
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
      .join('&');
    url += `?${query}`;
  }
  return url;
};

const generateShortCode = (length = 7) => {
  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < length; i += 1) {
    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
  }
  return result;
};

// Registrar evento de UI (requiere auth)
app.post('/api/analytics/ui/events', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { page, button = null, eventType, metadata = {} } = req.body;

    if (!page || !eventType || !UI_ANALYTICS_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `page y eventType son requeridos. eventType debe ser: ${UI_ANALYTICS_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const cleanPage = String(page).trim();
    const cleanButton = button ? String(button).trim() : null;

    const eventData = {
      page: cleanPage,
      button: cleanButton,
      eventType,
      userId,
      metadata,
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('ui_analytics_events').add(eventData);

    const aggregateId = `${cleanPage}::${cleanButton || 'page'}`;
    const aggregateRef = db.collection('ui_analytics').doc(aggregateId);
    const updateData = {
      page: cleanPage,
      button: cleanButton,
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    if (eventType === 'view') {
      updateData.views = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'click') {
      updateData.clicks = admin.firestore.FieldValue.increment(1);
    }

    await aggregateRef.set(updateData, { merge: true });

    res.json({
      success: true,
      message: 'Evento registrado',
      data: {
        page: cleanPage,
        button: cleanButton,
        eventType,
        timestamp: now
      }
    });
  } catch (error) {
    console.error('‚ùå [UI ANALYTICS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento',
      error: error.message
    });
  }
});

// Consultar estad√≠sticas UI (admin)
app.get('/api/admin/analytics/ui', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page, button } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('ui_analytics');
    if (page) query = query.where('page', '==', String(page));
    if (button) query = query.where('button', '==', String(button));

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const results = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('‚ùå [UI ANALYTICS] Error consultando stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando estad√≠sticas',
      error: error.message
    });
  }
});

// ============================================================================
// üîó DEEPLINKS - Admin + Analytics
// ============================================================================

// Crear o actualizar deeplink (admin)
app.post('/api/admin/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { key, name, path, params = {}, category = null, description = null, enabled = true } = req.body;

    if (!key || !name || !path) {
      return res.status(400).json({
        success: false,
        message: 'key, name y path son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const cleanKey = String(key).trim();
    const cleanName = String(name).trim();
    const cleanPath = String(path).trim().replace(/^\/+/, '');
    const deeplinkUrl = buildDeeplinkUrl(cleanPath, params);

    if (!deeplinkUrl) {
      return res.status(400).json({
        success: false,
        message: 'path invalido'
      });
    }

    const now = new Date();
    const deeplinkRef = db.collection('deeplinks').doc(cleanKey);
    const existing = await deeplinkRef.get();

    const payload = {
      key: cleanKey,
      name: cleanName,
      path: cleanPath,
      params,
      category,
      description,
      enabled: Boolean(enabled),
      deeplinkUrl,
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      updatedBy: req.user.uid
    };

    if (!existing.exists) {
      payload.createdAt = admin.firestore.Timestamp.fromDate(now);
      payload.createdBy = req.user.uid;
    }

    await deeplinkRef.set(payload, { merge: true });

    res.json({
      success: true,
      message: 'Deeplink guardado',
      data: payload
    });
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error guardando deeplink:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando deeplink',
      error: error.message
    });
  }
});

const createDeeplinkShort = async (req, res) => {
  try {
    const { path, params = {}, key = null, webFallback = 'https://munpa.online', enabled = true } = req.body;

    if (!path) {
      return res.status(400).json({
        success: false,
        message: 'path es requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const cleanPath = String(path).trim().replace(/^\/+/, '');
    const deeplinkUrl = buildDeeplinkUrl(cleanPath, params);
    if (!deeplinkUrl) {
      return res.status(400).json({
        success: false,
        message: 'path invalido'
      });
    }

    let code = null;
    let attempts = 0;
    while (!code && attempts < 5) {
      const candidate = generateShortCode(7);
      const existing = await db.collection('deeplink_short_urls').doc(candidate).get();
      if (!existing.exists) code = candidate;
      attempts += 1;
    }

    if (!code) {
      return res.status(500).json({
        success: false,
        message: 'No se pudo generar short link'
      });
    }

    const now = new Date();
    const payload = {
      code,
      key: key ? String(key).trim() : null,
      path: cleanPath,
      params,
      deeplinkUrl,
      webFallback: String(webFallback || 'https://munpa.online'),
      enabled: Boolean(enabled),
      createdAt: admin.firestore.Timestamp.fromDate(now),
      createdBy: req.user?.uid || null,
      updatedAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('deeplink_short_urls').doc(code).set(payload);

    res.json({
      success: true,
      data: {
        ...payload,
        shortUrl: `https://api.munpa.online/dl/${code}`
      }
    });
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error creando short link:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando short link',
      error: error.message
    });
  }
};

// Crear short link para deeplink (admin)
app.post('/api/admin/deeplinks/short', authenticateToken, isAdmin, createDeeplinkShort);

// Crear short link publico (sin token)
app.post('/api/deeplinks/short', createDeeplinkShort);

// Resolver short link a deeplink
app.get('/dl/:code', async (req, res) => {
  try {
    const { code } = req.params;

    if (!db) {
      return res.status(500).send('DB no disponible');
    }

    const doc = await db.collection('deeplink_short_urls').doc(code).get();
    if (!doc.exists) {
      return res.status(404).send('Link no encontrado');
    }

    const data = doc.data();
    if (data.enabled === false) {
      return res.status(404).send('Link deshabilitado');
    }

    const deeplinkUrl = data.deeplinkUrl;
    const webFallback = data.webFallback || 'https://munpa.online';
    const analyticsKey = data.key || `short:${code}`;
    const now = admin.firestore.Timestamp.fromDate(new Date());

    await db.collection('deeplink_analytics').doc(analyticsKey).set({
      key: analyticsKey,
      path: data.path || null,
      updatedAt: now,
      lastEventAt: now,
      lastEventType: 'click',
      totalEvents: admin.firestore.FieldValue.increment(1),
      totalClicks: admin.firestore.FieldValue.increment(1)
    }, { merge: true });

    const html = `
      <html>
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>Munpa</title>
        </head>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 32px;">
          <h2>Abriendo Munpa...</h2>
          <p>Si no se abre autom√°ticamente, toca el bot√≥n.</p>
          <a href="${deeplinkUrl}" style="display:inline-block;padding:12px 20px;background:#2C7EF7;color:#fff;text-decoration:none;border-radius:6px;">Abrir app</a>
          <script>
            window.location.href = "${deeplinkUrl}";
            setTimeout(function() {
              window.location.href = "${webFallback}";
            }, 1600);
          </script>
        </body>
      </html>
    `;

    res.setHeader('Content-Type', 'text/html');
    return res.send(html);
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error resolviendo short link:', error);
    res.status(500).send('Error');
  }
});

// Listar deeplinks con stats (admin)
app.get('/api/admin/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { category, enabled } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('deeplinks');
    if (category) query = query.where('category', '==', String(category));
    if (enabled !== undefined) query = query.where('enabled', '==', String(enabled) === 'true');

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const deeplinks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    const analyticsRefs = deeplinks.map(item => db.collection('deeplink_analytics').doc(item.key));
    const analyticsSnaps = analyticsRefs.length ? await db.getAll(...analyticsRefs) : [];
    const analyticsMap = new Map(
      analyticsSnaps.map(doc => [doc.id, doc.exists ? doc.data() : null])
    );

    const results = deeplinks.map(item => ({
      ...item,
      analytics: analyticsMap.get(item.key) || {
        totalClicks: 0,
        totalOpens: 0,
        totalViews: 0,
        totalEvents: 0,
        lastEventAt: null
      }
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error consultando deeplinks:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando deeplinks',
      error: error.message
    });
  }
});

// Registrar evento de deeplink (requiere auth)
app.post('/api/analytics/deeplinks/events', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { key, eventType = 'click', path = null, params = {}, source = null, metadata = {} } = req.body;

    if (!key || !DEEPLINK_EVENT_TYPES.includes(eventType)) {
      return res.status(400).json({
        success: false,
        message: `key y eventType son requeridos. eventType debe ser: ${DEEPLINK_EVENT_TYPES.join(', ')}`
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const now = new Date();
    const cleanKey = String(key).trim();
    const cleanPath = path ? String(path).trim().replace(/^\/+/, '') : null;

    const eventData = {
      key: cleanKey,
      path: cleanPath,
      params,
      eventType,
      source,
      userId,
      metadata,
      timestamp: admin.firestore.Timestamp.fromDate(now),
      createdAt: admin.firestore.Timestamp.fromDate(now)
    };

    await db.collection('deeplink_events').add(eventData);

    const aggregateRef = db.collection('deeplink_analytics').doc(cleanKey);
    const updateData = {
      key: cleanKey,
      path: cleanPath,
      updatedAt: admin.firestore.Timestamp.fromDate(now),
      lastEventAt: admin.firestore.Timestamp.fromDate(now),
      lastEventType: eventType,
      lastUserId: userId,
      totalEvents: admin.firestore.FieldValue.increment(1)
    };

    if (eventType === 'click') {
      updateData.totalClicks = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'open') {
      updateData.totalOpens = admin.firestore.FieldValue.increment(1);
    } else if (eventType === 'view') {
      updateData.totalViews = admin.firestore.FieldValue.increment(1);
    }

    await aggregateRef.set(updateData, { merge: true });

    res.json({
      success: true,
      message: 'Evento deeplink registrado',
      data: {
        key: cleanKey,
        eventType,
        timestamp: now
      }
    });
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error registrando evento:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando evento deeplink',
      error: error.message
    });
  }
});

// Consultar stats de deeplinks (admin)
app.get('/api/admin/analytics/deeplinks', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { key } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('deeplink_analytics');
    if (key) query = query.where('key', '==', String(key));

    const snapshot = await query.orderBy('updatedAt', 'desc').limit(200).get();
    const results = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('‚ùå [DEEPLINKS] Error consultando stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error consultando stats deeplinks',
      error: error.message
    });
  }
});

// Enviar notificaciones a trav√©s de Expo Push Notification Service
async function sendExpoNotifications(tokens, notification, data) {
  try {
    const messages = tokens.map(token => ({
      to: token,
      sound: 'default',
      title: notification.title || 'Munpa',
      body: notification.body || '',
      data: {
        ...data,
        timestamp: new Date().toISOString()
      },
      badge: 1,
      priority: 'high',
    }));

    console.log('üì§ [EXPO] Enviando notificaci√≥n a Expo Push Service:');
    console.log('   T√≠tulo:', notification.title);
    console.log('   Cuerpo:', notification.body);
    console.log('   Total tokens:', tokens.length);
    console.log('   Primer mensaje:', JSON.stringify(messages[0], null, 2));

    const chunks = [];
    for (let i = 0; i < messages.length; i += 100) {
      chunks.push(messages.slice(i, i + 100));
    }

    let successCount = 0;
    let failureCount = 0;
    const failedTokens = [];

    for (const chunk of chunks) {
      const response = await fetch('https://exp.host/--/api/v2/push/send', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(chunk),
      });

      const result = await response.json();
      
      console.log('üîç [EXPO] Respuesta completa de Expo:', JSON.stringify(result, null, 2));
      
      if (result.data) {
        result.data.forEach((item, index) => {
          if (item.status === 'ok') {
            successCount++;
            console.log(`‚úÖ [EXPO] Notificaci√≥n enviada exitosamente a: ${chunk[index].to.substring(0, 30)}...`);
          } else {
            failureCount++;
            failedTokens.push(chunk[index].to);
            console.log(`‚ùå [EXPO] Error enviando notificaci√≥n:`);
            console.log(`   Token: ${chunk[index].to.substring(0, 30)}...`);
            console.log(`   Status: ${item.status}`);
            console.log(`   Message: ${item.message}`);
            console.log(`   Details: ${JSON.stringify(item.details || {})}`);
          }
        });
      } else {
        console.log('‚ùå [EXPO] Respuesta sin data:', JSON.stringify(result));
      }
    }

    console.log(`‚úÖ [EXPO] Notificaciones Expo enviadas: ${successCount}/${tokens.length}`);

    return { successCount, failureCount, failedTokens };

  } catch (error) {
    console.error('‚ùå [EXPO] Error enviando notificaciones Expo:', error);
    return { successCount: 0, failureCount: tokens.length, failedTokens: tokens };
  }
}

// Enviar notificaciones a trav√©s de Firebase Cloud Messaging
async function sendFCMNotifications(tokens, notification, data) {
  try {
    const message = {
      notification: {
        title: notification.title || 'Munpa',
        body: notification.body || '',
        ...(notification.imageUrl && isValidUrl(notification.imageUrl) ? { imageUrl: notification.imageUrl } : {})
      },
      data: {
        ...data,
        click_action: data.click_action || 'FLUTTER_NOTIFICATION_CLICK',
        timestamp: new Date().toISOString()
      },
      tokens: tokens,
      android: {
        priority: 'high',
        notification: {
          sound: 'default',
          channelId: 'munpa_notifications'
        }
      },
      apns: {
        payload: {
          aps: {
            sound: 'default',
            badge: 1
          }
        }
      }
    };

    const response = await admin.messaging().sendEachForMulticast(message);
    
    console.log(`‚úÖ [FCM] Notificaciones FCM enviadas: ${response.successCount}/${tokens.length}`);
    
    const failedTokens = [];
    const invalidTokenCodes = new Set([
      'messaging/registration-token-not-registered',
      'messaging/invalid-registration-token'
    ]);
    if (response.failureCount > 0) {
      response.responses.forEach((resp, idx) => {
        if (!resp.success) {
          const errorCode = resp.error?.code;
          if (invalidTokenCodes.has(errorCode)) {
            failedTokens.push(tokens[idx]);
            console.log(`‚ùå [FCM] Token inv√°lido: ${errorCode}`);
          } else {
            console.log(`‚ö†Ô∏è [FCM] Error enviando token (${errorCode || 'unknown'})`);
          }
        }
      });
    }

    return {
      successCount: response.successCount,
      failureCount: response.failureCount,
      failedTokens
    };

  } catch (error) {
    console.error('‚ùå [FCM] Error enviando notificaciones FCM:', error);
    return { successCount: 0, failureCount: tokens.length, failedTokens: [] };
  }
}

// Limpiar tokens inv√°lidos
async function cleanInvalidTokens(invalidTokens) {
  try {
    const usersRef = db.collection('users');
    const snapshot = await usersRef.where('fcmTokens', 'array-contains-any', invalidTokens.slice(0, 10)).get();
    
    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      const userData = doc.data();
      const validTokens = userData.fcmTokens?.filter(token => !invalidTokens.includes(token)) || [];
      batch.update(doc.ref, { fcmTokens: validTokens });
    });
    
    await batch.commit();
    console.log(`üßπ [PUSH] Tokens inv√°lidos limpiados: ${invalidTokens.length}`);
  } catch (error) {
    console.error('‚ùå [PUSH] Error limpiando tokens:', error);
  }
}

// Registrar/actualizar token FCM del dispositivo
app.post('/api/notifications/register-token', authenticateToken, async (req, res) => {
  try {
    const { token, platform } = req.body;
    const userId = req.user.uid;

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token FCM requerido'
      });
    }

    // Evitar guardar tokens APNS (64 hex) en lugar de FCM
    const looksLikeApnsToken = /^[a-f0-9]{64}$/i.test(token);
    if (looksLikeApnsToken) {
      return res.status(400).json({
        success: false,
        message: 'Token inv√°lido. Se requiere token FCM, no APNS.'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();

    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();
    const currentTokens = userData.fcmTokens || [];

    // Agregar token si no existe
    if (!currentTokens.includes(token)) {
      await userRef.update({
        fcmTokens: admin.firestore.FieldValue.arrayUnion(token),
        lastTokenUpdate: admin.firestore.Timestamp.fromDate(new Date()),
        platform: platform || 'unknown'
      });
      console.log('‚úÖ [PUSH] Token registrado para:', userId);
    } else {
      console.log('‚ÑπÔ∏è [PUSH] Token ya existe para:', userId);
    }

    res.json({
      success: true,
      message: 'Token registrado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [PUSH] Error registrando token:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando token',
      error: error.message
    });
  }
});

// Verificar tokens FCM registrados (debug)
app.get('/api/notifications/check-tokens', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(userId).get();

    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();
    const tokens = userData.fcmTokens || [];

    console.log(`üîç [DEBUG] Tokens FCM para ${userId}:`, tokens.length);

    res.json({
      success: true,
      data: {
        userId,
        tokensCount: tokens.length,
        tokens: tokens,
        hasTokens: tokens.length > 0,
        lastTokenUpdate: userData.lastTokenUpdate,
        platform: userData.platform
      }
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error verificando tokens:', error);
    res.status(500).json({
      success: false,
      message: 'Error verificando tokens',
      error: error.message
    });
  }
});

const removeNotificationToken = async (req, res) => {
  try {
    const token = req.body?.token || req.query?.token;
    const userId = req.user.uid;

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token FCM requerido'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('users').doc(userId).update({
      fcmTokens: admin.firestore.FieldValue.arrayRemove(token)
    });

    console.log('‚úÖ [PUSH] Token eliminado para:', userId);

    res.json({
      success: true,
      message: 'Token eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [PUSH] Error eliminando token:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando token',
      error: error.message
    });
  }
};

// Eliminar token FCM (logout o desinstalaci√≥n)
app.post('/api/notifications/remove-token', authenticateToken, removeNotificationToken);
app.delete('/api/notifications/remove-token', authenticateToken, removeNotificationToken);

// Obtener notificaciones del usuario
app.get('/api/notifications', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { page = 1, limit = 50, unreadOnly = false } = req.query;
    const cacheKey = `${req.path}?uid=${userId}&page=${page}&limit=${limit}&unreadOnly=${unreadOnly}`;
    const cached = getCachedResponse(cacheKey);
    if (cached) {
      res.set('Cache-Control', 'private, max-age=10');
      return res.json(cached);
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones del usuario
    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .get();

    // Si est√° vac√≠o, devolver array vac√≠o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0,
          unreadCount: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar solo no le√≠das si se especifica
    if (unreadOnly === 'true') {
      notifications = notifications.filter(n => !n.read);
    }

    // Ordenar por fecha de creaci√≥n (m√°s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.createdAt instanceof Date ? a.createdAt : new Date(a.createdAt || 0);
      const dateB = b.createdAt instanceof Date ? b.createdAt : new Date(b.createdAt || 0);
      return dateB - dateA;
    });

    // Calcular contador de no le√≠das antes de paginar
    const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;

    // Paginaci√≥n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`‚úÖ [NOTIFICATIONS] Notificaciones obtenidas para ${userId}: ${paginatedNotifications.length}`);

    const responsePayload = {
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
        unreadCount
      }
    };

    setCachedResponse(cacheKey, responsePayload, 10 * 1000);
    res.set('Cache-Control', 'private, max-age=10');
    res.json(responsePayload);

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error obteniendo notificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo notificaciones',
      error: error.message
    });
  }
});

// Marcar notificaci√≥n como le√≠da
app.patch('/api/notifications/:id/read', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationRef = db.collection('notifications').doc(id);
    const notificationDoc = await notificationRef.get();

    if (!notificationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Notificaci√≥n no encontrada'
      });
    }

    const notificationData = notificationDoc.data();

    // Verificar que la notificaci√≥n pertenece al usuario
    if (notificationData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para modificar esta notificaci√≥n'
      });
    }

    await notificationRef.update({
      read: true,
      readAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`‚úÖ [NOTIFICATIONS] Notificaci√≥n marcada como le√≠da: ${id}`);

    res.json({
      success: true,
      message: 'Notificaci√≥n marcada como le√≠da'
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error marcando notificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando notificaci√≥n',
      error: error.message
    });
  }
});

// Marcar todas las notificaciones como le√≠das (con alias para compatibilidad)
const markAllNotificationsAsReadHandler = async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', false)
      .get();

    if (snapshot.empty) {
      return res.json({
        success: true,
        message: 'No hay notificaciones sin leer'
      });
    }

    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      batch.update(doc.ref, {
        read: true,
        readAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    });

    await batch.commit();

    console.log(`‚úÖ [NOTIFICATIONS] ${snapshot.size} notificaciones marcadas como le√≠das para: ${userId}`);

    res.json({
      success: true,
      message: `${snapshot.size} notificaciones marcadas como le√≠das`
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error marcando todas como le√≠das:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando notificaciones',
      error: error.message
    });
  }
};

// Registrar ambas rutas para compatibilidad
app.patch('/api/notifications/read-all', authenticateToken, markAllNotificationsAsReadHandler);
app.patch('/api/notifications/mark-all-read', authenticateToken, markAllNotificationsAsReadHandler);

// Eliminar notificaci√≥n
app.delete('/api/notifications/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationRef = db.collection('notifications').doc(id);
    const notificationDoc = await notificationRef.get();

    if (!notificationDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Notificaci√≥n no encontrada'
      });
    }

    const notificationData = notificationDoc.data();

    // Verificar que la notificaci√≥n pertenece al usuario
    if (notificationData.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar esta notificaci√≥n'
      });
    }

    await notificationRef.delete();

    console.log(`‚úÖ [NOTIFICATIONS] Notificaci√≥n eliminada: ${id}`);

    res.json({
      success: true,
      message: 'Notificaci√≥n eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error eliminando notificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando notificaci√≥n',
      error: error.message
    });
  }
});

// Eliminar todas las notificaciones le√≠das
app.delete('/api/notifications/read-all', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', true)
      .get();

    if (snapshot.empty) {
      return res.json({
        success: true,
        message: 'No hay notificaciones le√≠das para eliminar'
      });
    }

    const batch = db.batch();
    snapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    console.log(`‚úÖ [NOTIFICATIONS] ${snapshot.size} notificaciones eliminadas para: ${userId}`);

    res.json({
      success: true,
      message: `${snapshot.size} notificaciones eliminadas exitosamente`
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error eliminando notificaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando notificaciones',
      error: error.message
    });
  }
});

// Obtener contador de notificaciones sin leer
app.get('/api/notifications/unread-count', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('notifications')
      .where('userId', '==', userId)
      .where('read', '==', false)
      .get();

    const count = snapshot.size;

    res.json({
      success: true,
      data: {
        unreadCount: count
      }
    });

  } catch (error) {
    console.error('‚ùå [NOTIFICATIONS] Error obteniendo contador:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo contador',
      error: error.message
    });
  }
});

// Enviar notificaci√≥n cuando hay un nuevo mensaje
app.post('/api/notifications/new-message', authenticateToken, async (req, res) => {
  try {
    const { receiverId, senderName, message, productId, productTitle } = req.body;

    if (!receiverId || !message) {
      return res.status(400).json({
        success: false,
        message: 'receiverId y message son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens del receptor
    const receiverDoc = await db.collection('users').doc(receiverId).get();
    if (!receiverDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario receptor no encontrado'
      });
    }

    const receiverData = receiverDoc.data();
    const tokens = receiverData.fcmTokens || [];

    if (tokens.length === 0) {
      return res.json({
        success: true,
        message: 'Usuario no tiene tokens registrados'
      });
    }

    // Enviar notificaci√≥n
    const notification = {
      title: `üí¨ Nuevo mensaje de ${senderName}`,
      body: message.length > 100 ? message.substring(0, 100) + '...' : message,
      imageUrl: null
    };

    const data = {
      type: 'new_message',
      senderId: req.user.uid,
      senderName: senderName || 'Usuario',
      productId: productId || '',
      productTitle: productTitle || '',
      screen: 'ChatScreen',
      chatId: `${req.user.uid}_${receiverId}_${productId}`
    };

    const result = await sendPushNotification(tokens, notification, data);

    // Guardar notificaci√≥n en Firestore
    await db.collection('notifications').add({
      userId: receiverId,
      type: 'new_message',
      title: notification.title,
      body: notification.body,
      data: data,
      read: false,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    res.json({
      success: true,
      message: 'Notificaci√≥n enviada',
      result
    });

  } catch (error) {
    console.error('‚ùå [PUSH] Error enviando notificaci√≥n de mensaje:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaci√≥n',
      error: error.message
    });
  }
});

// Enviar notificaci√≥n de compra/venta
app.post('/api/notifications/transaction', authenticateToken, async (req, res) => {
  try {
    const { sellerId, buyerName, productTitle, transactionType } = req.body;

    if (!sellerId || !productTitle) {
      return res.status(400).json({
        success: false,
        message: 'sellerId y productTitle son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens del vendedor
    const sellerDoc = await db.collection('users').doc(sellerId).get();
    if (!sellerDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario vendedor no encontrado'
      });
    }

    const sellerData = sellerDoc.data();
    const tokens = sellerData.fcmTokens || [];

    if (tokens.length === 0) {
      return res.json({
        success: true,
        message: 'Vendedor no tiene tokens registrados'
      });
    }

    // Preparar notificaci√≥n seg√∫n el tipo
    let notification;
    let data;

    switch (transactionType) {
      case 'purchase':
        notification = {
          title: 'üéâ ¬°Venta realizada!',
          body: `${buyerName} compr√≥ tu producto: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'purchase',
          buyerId: req.user.uid,
          buyerName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      case 'reservation':
        notification = {
          title: 'üìå Producto reservado',
          body: `${buyerName} reserv√≥ tu producto: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'reservation',
          buyerId: req.user.uid,
          buyerName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      case 'interest':
        notification = {
          title: 'üëÄ Alguien est√° interesado',
          body: `${buyerName} mostr√≥ inter√©s en: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'interest',
          userId: req.user.uid,
          userName: buyerName || 'Usuario',
          productTitle,
          screen: 'MyProductsScreen'
        };
        break;

      default:
        notification = {
          title: 'üì¶ Actualizaci√≥n de producto',
          body: `Hay una actualizaci√≥n sobre: ${productTitle}`,
          imageUrl: null
        };
        data = {
          type: 'transaction',
          productTitle,
          screen: 'MyProductsScreen'
        };
    }

    const result = await sendPushNotification(tokens, notification, data);

    // Guardar notificaci√≥n en Firestore
    await db.collection('notifications').add({
      userId: sellerId,
      type: transactionType || 'transaction',
      title: notification.title,
      body: notification.body,
      data: data,
      read: false,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    res.json({
      success: true,
      message: 'Notificaci√≥n enviada',
      result
    });

  } catch (error) {
    console.error('‚ùå [PUSH] Error enviando notificaci√≥n de transacci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaci√≥n',
      error: error.message
    });
  }
});

// ============================================================================
// üõ†Ô∏è ADMIN - ENVIAR NOTIFICACIONES DESDE EL DASHBOARD
// ============================================================================

// Enviar notificaci√≥n a usuarios espec√≠ficos
app.post('/api/admin/notifications/send', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { userIds, title, body, imageUrl, data, screen } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'T√≠tulo y mensaje son requeridos'
      });
    }

    if (!userIds || userIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Debe especificar al menos un usuario'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener tokens de los usuarios
    let allTokens = [];
    for (const userId of userIds) {
      const userDoc = await db.collection('users').doc(userId).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        if (userData.fcmTokens && userData.fcmTokens.length > 0) {
          allTokens = allTokens.concat(userData.fcmTokens);
        }
      }
    }

    if (allTokens.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Ning√∫n usuario tiene tokens registrados'
      });
    }

    const notification = {
      title,
      body,
      imageUrl: imageUrl || null
    };

    const notificationData = {
      type: 'admin_notification',
      screen: screen || 'HomeScreen',
      ...(data || {})
    };

    const result = await sendPushNotification(allTokens, notification, notificationData);

    // Guardar notificaci√≥n para cada usuario
    const batch = db.batch();
    userIds.forEach(userId => {
      const notifRef = db.collection('notifications').doc();
      batch.set(notifRef, {
        userId,
        type: 'admin_notification',
        title,
        body,
        imageUrl: imageUrl || null,
        data: notificationData,
        read: false,
        sentBy: req.user.uid,
        createdAt: admin.firestore.Timestamp.fromDate(new Date())
      });
    });
    await batch.commit();

    console.log(`‚úÖ [ADMIN] Notificaci√≥n enviada a ${userIds.length} usuarios`);

    res.json({
      success: true,
      message: `Notificaci√≥n enviada a ${userIds.length} usuarios`,
      result
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error enviando notificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando notificaci√≥n',
      error: error.message
    });
  }
});

// Enviar notificaci√≥n a todos los usuarios (broadcast)
app.post('/api/admin/notifications/broadcast', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, body, imageUrl, data, screen, segment } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'T√≠tulo y mensaje son requeridos'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Construir query seg√∫n segmento
    let query = db.collection('users');

    // Aplicar filtros de segmentaci√≥n
    if (segment) {
      if (segment.hasChildren !== undefined) {
        query = query.where('hasChildren', '==', segment.hasChildren);
      }
      if (segment.city) {
        query = query.where('city', '==', segment.city);
      }
      if (segment.state) {
        query = query.where('state', '==', segment.state);
      }
    }

    const snapshot = await query.get();
    
    if (snapshot.empty) {
      return res.status(400).json({
        success: false,
        message: 'No se encontraron usuarios con los filtros especificados'
      });
    }

    // Recolectar todos los tokens
    let allTokens = [];
    const userIds = [];
    let usersWithTokens = 0;
    let usersWithoutTokens = 0;

    snapshot.docs.forEach(doc => {
      const userData = doc.data();
      if (userData.fcmTokens && userData.fcmTokens.length > 0) {
        allTokens = allTokens.concat(userData.fcmTokens);
        userIds.push(doc.id);
        usersWithTokens++;
      } else {
        usersWithoutTokens++;
      }
    });

    console.log(`üìä [BROADCAST] Total usuarios: ${snapshot.size}, Con tokens: ${usersWithTokens}, Sin tokens: ${usersWithoutTokens}`);
    console.log(`üì± [BROADCAST] Total tokens FCM recolectados: ${allTokens.length}`);

    if (allTokens.length === 0) {
      return res.status(400).json({
        success: false,
        message: `Ning√∫n usuario tiene tokens registrados. ${snapshot.size} usuarios encontrados pero ninguno tiene la app instalada o FCM configurado.`,
        stats: {
          totalUsers: snapshot.size,
          usersWithTokens: 0,
          usersWithoutTokens: snapshot.size
        }
      });
    }

    const notification = {
      title,
      body,
      imageUrl: imageUrl || null
    };

    const notificationData = {
      type: 'broadcast',
      screen: screen || 'HomeScreen',
      ...(data || {})
    };

    // Enviar en lotes de 500 (l√≠mite de FCM)
    const batchSize = 500;
    let totalSuccess = 0;
    let totalFailure = 0;

    for (let i = 0; i < allTokens.length; i += batchSize) {
      const tokenBatch = allTokens.slice(i, i + batchSize);
      const result = await sendPushNotification(tokenBatch, notification, notificationData);
      totalSuccess += result.successCount || 0;
      totalFailure += result.failureCount || 0;
    }

    // Guardar notificaci√≥n para cada usuario (en lotes)
    const batchPromises = [];
    for (let i = 0; i < userIds.length; i += 500) {
      const userBatch = userIds.slice(i, i + 500);
      const batch = db.batch();
      
      userBatch.forEach(userId => {
        const notifRef = db.collection('notifications').doc();
        batch.set(notifRef, {
          userId,
          type: 'broadcast',
          title,
          body,
          imageUrl: imageUrl || null,
          data: notificationData,
          read: false,
          sentBy: req.user.uid,
          segment: segment || null,
          createdAt: admin.firestore.Timestamp.fromDate(new Date())
        });
      });
      
      batchPromises.push(batch.commit());
    }

    await Promise.all(batchPromises);

    console.log(`‚úÖ [ADMIN] Broadcast enviado a ${userIds.length} usuarios`);
    console.log(`üì§ [PUSH] Notificaciones enviadas: ${totalSuccess}/${allTokens.length} exitosas, ${totalFailure} fallidas`);

    res.json({
      success: true,
      message: `Notificaci√≥n enviada a ${userIds.length} usuarios`,
      stats: {
        usersCount: userIds.length,
        tokensCount: allTokens.length,
        successCount: totalSuccess,
        failureCount: totalFailure,
        usersWithTokens,
        usersWithoutTokens
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error enviando broadcast:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando broadcast',
      error: error.message
    });
  }
});

// Programar notificaci√≥n para env√≠o futuro
app.post('/api/admin/notifications/schedule', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { title, body, imageUrl, data, screen, userIds, segment, scheduledFor } = req.body;

    if (!title || !body) {
      return res.status(400).json({
        success: false,
        message: 'T√≠tulo y mensaje son requeridos'
      });
    }

    if (!scheduledFor) {
      return res.status(400).json({
        success: false,
        message: 'Fecha de env√≠o programada es requerida'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const scheduledDate = new Date(scheduledFor);
    if (scheduledDate <= new Date()) {
      return res.status(400).json({
        success: false,
        message: 'La fecha programada debe ser futura'
      });
    }

    // Guardar notificaci√≥n programada
    const scheduledNotification = {
      title,
      body,
      imageUrl: imageUrl || null,
      data: data || {},
      screen: screen || 'HomeScreen',
      userIds: userIds || null,
      segment: segment || null,
      scheduledFor: admin.firestore.Timestamp.fromDate(scheduledDate),
      status: 'pending',
      createdBy: req.user.uid,
      createdAt: admin.firestore.Timestamp.fromDate(new Date())
    };

    const docRef = await db.collection('scheduled_notifications').add(scheduledNotification);

    console.log(`‚úÖ [ADMIN] Notificaci√≥n programada para: ${scheduledDate}`);

    res.json({
      success: true,
      message: 'Notificaci√≥n programada exitosamente',
      id: docRef.id,
      scheduledFor: scheduledDate
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error programando notificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error programando notificaci√≥n',
      error: error.message
    });
  }
});

// Listar notificaciones programadas
app.get('/api/admin/notifications/scheduled', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { status = '', page = 1, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones programadas
    const snapshot = await db.collection('scheduled_notifications').get();
    
    // Si la colecci√≥n est√° vac√≠a, devolver array vac√≠o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      scheduledFor: doc.data().scheduledFor?.toDate?.() || doc.data().scheduledFor,
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar por status si se especifica
    if (status) {
      notifications = notifications.filter(n => n.status === status);
    }

    // Ordenar por fecha programada (m√°s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.scheduledFor instanceof Date ? a.scheduledFor : new Date(a.scheduledFor);
      const dateB = b.scheduledFor instanceof Date ? b.scheduledFor : new Date(b.scheduledFor);
      return dateB - dateA;
    });

    // Paginaci√≥n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`‚úÖ [ADMIN] Notificaciones programadas obtenidas: ${paginatedNotifications.length}`);

    res.json({
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo notificaciones programadas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo notificaciones programadas',
      error: error.message
    });
  }
});

// Cancelar notificaci√≥n programada
app.delete('/api/admin/notifications/scheduled/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    await db.collection('scheduled_notifications').doc(id).update({
      status: 'cancelled',
      cancelledBy: req.user.uid,
      cancelledAt: admin.firestore.Timestamp.fromDate(new Date())
    });

    console.log(`‚úÖ [ADMIN] Notificaci√≥n programada cancelada: ${id}`);

    res.json({
      success: true,
      message: 'Notificaci√≥n cancelada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error cancelando notificaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error cancelando notificaci√≥n',
      error: error.message
    });
  }
});

// Obtener historial de notificaciones enviadas
app.get('/api/admin/notifications/history', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 50, type = '' } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener todas las notificaciones
    const snapshot = await db.collection('notifications').get();
    
    // Si est√° vac√≠o, devolver array vac√≠o
    if (snapshot.empty) {
      return res.json({
        success: true,
        data: [],
        pagination: {
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: 0
        }
      });
    }

    let notifications = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Filtrar por tipo si se especifica
    if (type) {
      notifications = notifications.filter(n => n.type === type);
    }

    // Ordenar por fecha de creaci√≥n (m√°s reciente primero)
    notifications.sort((a, b) => {
      const dateA = a.createdAt instanceof Date ? a.createdAt : new Date(a.createdAt);
      const dateB = b.createdAt instanceof Date ? b.createdAt : new Date(b.createdAt);
      return dateB - dateA;
    });

    // Paginaci√≥n
    const total = notifications.length;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);

    console.log(`‚úÖ [ADMIN] Historial de notificaciones obtenido: ${paginatedNotifications.length}`);

    res.json({
      success: true,
      data: paginatedNotifications,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// Estad√≠sticas de notificaciones
app.get('/api/admin/notifications/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const notificationsSnapshot = await db.collection('notifications').get();
    const notifications = notificationsSnapshot.docs.map(doc => doc.data());

    const stats = {
      total: notifications.length,
      byType: {},
      read: notifications.filter(n => n.read).length,
      unread: notifications.filter(n => !n.read).length,
      last24h: notifications.filter(n => {
        const createdAt = n.createdAt?.toDate() || new Date(0);
        const dayAgo = new Date();
        dayAgo.setDate(dayAgo.getDate() - 1);
        return createdAt >= dayAgo;
      }).length,
      last7days: notifications.filter(n => {
        const createdAt = n.createdAt?.toDate() || new Date(0);
        const weekAgo = new Date();
        weekAgo.setDate(weekAgo.getDate() - 7);
        return createdAt >= weekAgo;
      }).length
    };

    // Contar por tipo
    notifications.forEach(n => {
      const type = n.type || 'other';
      stats.byType[type] = (stats.byType[type] || 0) + 1;
    });

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// ============================================================================
// üìÖ NOTIFICACIONES DIARIAS AUTOM√ÅTICAS - Vacunas, Consejos y Recordatorios
// Powered by ChatGPT para mensajes personalizados
// ============================================================================

// Configuraci√≥n por defecto para recordatorios
const DEFAULT_REMINDER_CONFIG = {
  enabled: true,
  frequency: 'daily', // daily, every2days, every3days, weekly
  timeOfDay: '09:00', // Hora local para enviar
  types: {
    vaccines: true,
    tips: true,
    milestones: true
  }
};

// Funci√≥n para generar mensaje personalizado con ChatGPT
async function generatePersonalizedReminder(childData, reminderType, ageInMonths, ageInDays) {
  // Intentar inicializar OpenAI si no est√° disponible (para funciones serverless)
  if (!openai && process.env.OPENAI_API_KEY) {
    console.log('ü§ñ [DAILY] Inicializando OpenAI din√°micamente...');
    try {
      openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
      console.log('‚úÖ [DAILY] OpenAI inicializado correctamente');
    } catch (error) {
      console.error('‚ùå [DAILY] Error inicializando OpenAI:', error.message);
    }
  }
  
  if (!openai) {
    console.warn('‚ö†Ô∏è [DAILY] OpenAI no configurado, usando mensaje por defecto');
    return null;
  }

  try {
    let prompt = '';
    
    const childName = childData.name || 'el beb√©';
    const childGender = childData.gender || 'beb√©';
    
    if (reminderType === 'vaccine') {
      // Buscar vacuna pr√≥xima seg√∫n edad
      const upcomingVaccines = [];
      if (ageInMonths === 0 && ageInDays <= 7) upcomingVaccines.push('BCG y Hepatitis B');
      else if (ageInMonths === 2) upcomingVaccines.push('Pentavalente, Rotavirus y Neumoc√≥cica');
      else if (ageInMonths === 4) upcomingVaccines.push('2da dosis de Pentavalente, Rotavirus y Neumoc√≥cica');
      else if (ageInMonths === 6) upcomingVaccines.push('3ra dosis de Pentavalente y 2da de Rotavirus');
      else if (ageInMonths === 12) upcomingVaccines.push('SRP y Neumoc√≥cica de refuerzo');
      else if (ageInMonths === 18) upcomingVaccines.push('Pentavalente de refuerzo');
      
      if (upcomingVaccines.length > 0) {
        prompt = `Eres una doula experta y c√°lida. Escribe un recordatorio breve (m√°ximo 100 caracteres) para que los padres no olviden las vacunas de ${childName}, un ${childGender} de ${ageInMonths} meses. Las vacunas son: ${upcomingVaccines[0]}. 
        
Debe ser:
- C√°lido y emp√°tico
- Recordar la importancia sin asustar
- Mencionar el nombre del beb√©
- Incluir emoji relevante
- No usar comillas ni puntos finales innecesarios

Ejemplo: "üíâ ${childName} necesita sus vacunas de los ${ageInMonths} meses pronto. ¬°Agenda tu cita!"`;
      }
    } 
    else if (reminderType === 'tip') {
      prompt = `Eres una doula experta y c√°lida. Da un consejo pr√°ctico y valioso para padres de ${childName}, un ${childGender} de ${ageInMonths} meses.

El consejo debe ser:
- Espec√≠fico para la edad de ${ageInMonths} meses
- Pr√°ctico y aplicable hoy
- M√°ximo 120 caracteres
- Incluir emoji relevante
- Mencionar el nombre del beb√© cuando sea natural
- Basado en evidencia cient√≠fica
- C√°lido y emp√°tico

Temas sugeridos seg√∫n edad:
- 0 meses: Contacto piel con piel, lactancia, sue√±o
- 1-2 meses: Estimulaci√≥n visual, hablar mucho, tiempo boca abajo
- 3-5 meses: Juegos, sonidos, agarrar objetos
- 6 meses: Alimentaci√≥n complementaria, gateo, dentici√≥n
- 12 meses: Primeras palabras, caminar, independencia
- 18-24 meses: Lenguaje, juego simb√≥lico, socializaci√≥n

No uses comillas ni puntos finales innecesarios.`;
    }
    else if (reminderType === 'milestone') {
      prompt = `Eres una doula experta. ${childName}, un ${childGender}, cumple ${ageInMonths} meses hoy. Escribe un mensaje celebratorio breve (m√°ximo 100 caracteres) que:
- Celebre el hito
- Mencione 1 logro t√≠pico de esta edad
- Sea emotivo y positivo
- Incluya emoji de celebraci√≥n
- Mencione el nombre del beb√©

No uses comillas ni puntos finales innecesarios.`;
    }

    if (!prompt) return null;

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "Eres una doula experta, c√°lida y emp√°tica. Tus mensajes son breves, pr√°cticos y basados en evidencia."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.8,
      max_tokens: 100
    });

    const message = completion.choices[0]?.message?.content?.trim();
    
    if (!message) {
      console.warn('‚ö†Ô∏è [DAILY] OpenAI no devolvi√≥ mensaje');
      return null;
    }

    // Limpiar comillas y puntos innecesarios
    const cleanedMessage = message.replace(/^["']|["']$/g, '').replace(/\.+$/, '');

    console.log(`‚úÖ [DAILY] Mensaje generado por ChatGPT: "${cleanedMessage}"`);
    
    return {
      title: reminderType === 'vaccine' ? 'üíâ Recordatorio de vacunas' :
             reminderType === 'milestone' ? 'üéâ ¬°Hito especial!' :
             'üë∂ Consejo del d√≠a',
      message: cleanedMessage,
      generatedBy: 'chatgpt',
      model: 'gpt-3.5-turbo',
      prompt: prompt
    };

  } catch (error) {
    console.error('‚ùå [DAILY] Error generando mensaje con ChatGPT:', error.message);
    return null;
  }
}

// Base de datos de recordatorios seg√∫n edad del beb√© (en meses) - FALLBACK
const DAILY_REMINDERS = {
  // Vacunas seg√∫n calendario mexicano
  vaccines: [
    { ageMonths: 0, daysBefore: 3, title: 'üíâ Vacunas del reci√©n nacido', message: 'En unos d√≠as tu beb√© debe recibir BCG y Hepatitis B. ¬°No olvides agendar tu cita!' },
    { ageMonths: 2, daysBefore: 7, title: 'üíâ Vacunas de los 2 meses', message: 'La pr√≥xima semana tu beb√© debe recibir: Pentavalente, Rotavirus y Neumoc√≥cica. ¬°Recuerda agendar!' },
    { ageMonths: 2, daysBefore: 1, title: 'üíâ Vacunas ma√±ana', message: '¬°Ma√±ana toca vacunas de los 2 meses! Pentavalente, Rotavirus y Neumoc√≥cica.' },
    { ageMonths: 4, daysBefore: 7, title: 'üíâ Vacunas de los 4 meses', message: 'La pr√≥xima semana tu beb√© debe recibir su segunda dosis de: Pentavalente, Rotavirus y Neumoc√≥cica.' },
    { ageMonths: 4, daysBefore: 1, title: 'üíâ Vacunas ma√±ana', message: '¬°Ma√±ana toca la segunda dosis de vacunas! Pentavalente, Rotavirus y Neumoc√≥cica.' },
    { ageMonths: 6, daysBefore: 7, title: 'üíâ Vacunas de los 6 meses', message: 'La pr√≥xima semana: tercera dosis de Pentavalente y segunda de Rotavirus. ¬°Agenda tu cita!' },
    { ageMonths: 6, daysBefore: 1, title: 'üíâ Vacunas ma√±ana', message: '¬°Ma√±ana toca vacunas! Tercera dosis de Pentavalente y segunda de Rotavirus.' },
    { ageMonths: 7, daysBefore: 7, title: 'üíâ Vacuna de Influenza', message: 'La pr√≥xima semana tu beb√© debe recibir la primera dosis de Influenza estacional.' },
    { ageMonths: 12, daysBefore: 7, title: 'üíâ Vacunas del primer a√±o', message: 'La pr√≥xima semana: SRP (Sarampi√≥n, Rub√©ola, Parotiditis) y Neumoc√≥cica de refuerzo. ¬°Un a√±o de protecci√≥n!' },
    { ageMonths: 12, daysBefore: 1, title: 'üíâ Vacunas ma√±ana', message: '¬°Ma√±ana toca vacunas del a√±o! SRP y Neumoc√≥cica de refuerzo.' },
    { ageMonths: 18, daysBefore: 7, title: 'üíâ Vacunas de los 18 meses', message: 'La pr√≥xima semana: Pentavalente de refuerzo. ¬°Mant√©n al d√≠a su cartilla!' },
    { ageMonths: 24, daysBefore: 7, title: 'üíâ Vacunas de los 2 a√±os', message: 'La pr√≥xima semana tu peque√±o debe recibir su refuerzo anual de Influenza.' }
  ],
  
  // Consejos seg√∫n edad
  tips: {
    0: [ // Reci√©n nacido
      { title: 'üë∂ Reci√©n nacido', message: 'El contacto piel con piel fortalece el v√≠nculo. Abr√°zalo mucho, es lo que m√°s necesita ahora.' },
      { title: 'üò¥ Sue√±o del beb√©', message: 'Los reci√©n nacidos duermen 16-17 horas al d√≠a. Es normal que se despierten cada 2-3 horas para comer.' },
      { title: 'üçº Alimentaci√≥n', message: 'La leche materna o f√≥rmula es todo lo que necesita. No necesita agua ni otros l√≠quidos.' },
      { title: 'üëÉ Cuidados b√°sicos', message: 'El cord√≥n umbilical se cae solo en 1-2 semanas. Mant√©nlo limpio y seco.' }
    ],
    1: [
      { title: 'üòä Primer mes', message: 'Tu beb√© ya puede enfocar objetos a 20-30 cm. ¬°H√°blale mucho, reconoce tu voz!' },
      { title: 'üëÄ Estimulaci√≥n visual', message: 'Usa colores contrastantes como blanco y negro. Ayuda al desarrollo visual.' },
      { title: 'üéµ M√∫sica suave', message: 'La m√∫sica cl√°sica o canciones de cuna ayudan a calmar y estimular su cerebro.' }
    ],
    2: [
      { title: 'üòÑ ¬°Sonrisas sociales!', message: 'A los 2 meses empiezan las primeras sonrisas sociales. ¬°Sonr√≠ele mucho!' },
      { title: 'üó£Ô∏è Balbuceos', message: 'Tu beb√© empieza a hacer sonidos. Resp√≥ndele para fomentar la comunicaci√≥n.' },
      { title: 'üí™ Tiempo boca abajo', message: '3-5 minutos varias veces al d√≠a fortalece su cuello y espalda. Siempre supervisado.' }
    ],
    3: [
      { title: 'ü§≤ Manos descubiertas', message: 'Empieza a descubrir sus manos. Ofr√©cele juguetes suaves para agarrar.' },
      { title: 'üëÇ Responde a sonidos', message: 'Gira la cabeza hacia los sonidos. Habla y canta para estimular su audici√≥n.' }
    ],
    4: [
      { title: 'üîÑ ¬°Puede girar!', message: 'Muchos beb√©s empiezan a girarse. Nunca lo dejes solo en superficies altas.' },
      { title: 'üòÇ Risas a carcajadas', message: 'Las cosquillas suaves y juegos le hacen re√≠r. ¬°Disfruta este momento!' }
    ],
    5: [
      { title: 'üçé Preparaci√≥n para s√≥lidos', message: 'Pronto empezar√° con s√≥lidos. Observa se√±ales: se sienta con apoyo, muestra inter√©s en comida.' },
      { title: 'üèÉ Muy activo', message: 'Empieza a prepararse para gatear. Dale espacio seguro para moverse.' }
    ],
    6: [
      { title: 'ü•Ñ Alimentaci√≥n complementaria', message: 'A los 6 meses puedes iniciar papillas y pur√©s. La leche sigue siendo su alimento principal.' },
      { title: 'ü¶∑ Posible dentici√≥n', message: 'Pueden aparecer los primeros dientes. Mordederas fr√≠as alivian las molestias.' },
      { title: 'ü™ë ¬°Ya se sienta!', message: 'Muchos beb√©s ya se sientan sin apoyo. Coloca cojines alrededor por seguridad.' }
    ],
    9: [
      { title: 'üëã Dice adi√≥s', message: 'Empieza a imitar gestos como decir adi√≥s. ¬°Practiquen juntos!' },
      { title: 'üß∏ Juego de esconder', message: 'Le encanta el "¬ød√≥nde est√° el beb√©?". Desarrolla permanencia de objeto.' }
    ],
    12: [
      { title: 'üéÇ ¬°Primer a√±o!', message: '¬°Felicidades! Ha sido un a√±o incre√≠ble. Muchos beb√©s ya caminan o est√°n por hacerlo.' },
      { title: 'üó£Ô∏è Primeras palabras', message: 'Puede decir "mam√°" o "pap√°". H√°blale mucho para ampliar su vocabulario.' }
    ],
    18: [
      { title: 'üö∂ Caminando seguro', message: 'Ya camina con confianza. Puede empezar a correr y subir escaleras con ayuda.' },
      { title: 'üìö Cuentos interactivos', message: 'Le encantan los cuentos con im√°genes. Se√±ala y nombra objetos para aprender palabras.' }
    ],
    24: [
      { title: 'üéâ ¬°Dos a√±os!', message: 'Tu peque√±o tiene personalidad propia. Es normal la etapa del "no" y las rabietas.' },
      { title: 'üß© Juego simb√≥lico', message: 'Imita situaciones cotidianas. Dale juguetes para cocinar, limpiar o cuidar mu√±ecos.' }
    ],
    30: [
      { title: 'üó£Ô∏è Lenguaje en desarrollo', message: 'Tu hijo ya forma frases simples. L√©ele cuentos todos los d√≠as para ampliar su vocabulario.' },
      { title: 'üé® Creatividad', message: 'Ofrece crayones, pinturas y plastilina. La creatividad estimula su desarrollo cognitivo.' }
    ],
    36: [
      { title: 'üéâ ¬°Tres a√±os!', message: 'Tu hijo es m√°s independiente. Dale peque√±as responsabilidades apropiadas para su edad.' },
      { title: 'üë• Socializaci√≥n', message: 'Es buen momento para actividades en grupo. Aprende a compartir y hacer amigos.' }
    ],
    42: [
      { title: 'üö≤ Actividad f√≠sica', message: 'Fomenta el juego activo. Puede andar en triciclo, saltar y trepar.' },
      { title: 'üìö Cuentos complejos', message: 'Su atenci√≥n es mayor. Disfruta historias m√°s largas y hace preguntas.' }
    ],
    48: [
      { title: 'üéâ ¬°Cuatro a√±os!', message: 'Tu hijo tiene mucha energ√≠a e imaginaci√≥n. Responde "por qu√©" a todo.' },
      { title: 'üé≠ Juego de rol', message: 'Le encanta disfrazarse y jugar a ser otros. Esto desarrolla su empat√≠a.' }
    ],
    54: [
      { title: '‚úèÔ∏è Pre-escritura', message: 'Practica trazos y figuras. Empieza a reconocer algunas letras.' },
      { title: 'üßÆ N√∫meros y conteo', message: 'Puede contar hasta 10 o m√°s. Incorpora matem√°ticas en juegos diarios.' }
    ],
    60: [
      { title: 'üéâ ¬°Cinco a√±os!', message: 'Tu hijo est√° listo para la escuela. Es m√°s independiente y sociable.' },
      { title: 'üéì Preparaci√≥n escolar', message: 'Practica rutinas, sigue instrucciones y desarrolla habilidades de autoayuda.' }
    ]
  },
  
  // Hitos del desarrollo
  milestones: [
    { ageMonths: 1, title: 'üì∏ Primer mes cumplido', message: '¬°Tu beb√© cumple su primer mes! Es buen momento para fotos y registro de peso/talla.' },
    { ageMonths: 3, title: 'üéØ 3 meses de logros', message: '¬°Ya son 3 meses! Tu beb√© tiene m√°s control de cuello y muestra m√°s expresiones.' },
    { ageMonths: 6, title: 'üéÇ Medio a√±o', message: '¬°6 meses! Tu beb√© ha crecido incre√≠blemente. Tiempo de evaluar su desarrollo con el pediatra.' },
    { ageMonths: 9, title: 'üìä 9 meses de desarrollo', message: '¬°9 meses afuera! Probablemente gatea y explora todo. Seguridad en casa es clave.' },
    { ageMonths: 12, title: 'üéä ¬°Primer a√±o!', message: '¬°Un a√±o! De beb√© reci√©n nacido a peque√±o explorador. ¬°Celebra este gran logro!' }
  ]
};

// Funci√≥n para obtener recordatorio seg√∫n edad
function getDailyReminder(ageInMonths, ageInDays) {
  const reminders = [];
  
  // Verificar vacunas pr√≥ximas
  DAILY_REMINDERS.vaccines.forEach(vaccine => {
    const targetDays = vaccine.ageMonths * 30;
    const daysUntilVaccine = targetDays - ageInDays;
    
    if (daysUntilVaccine === vaccine.daysBefore) {
      reminders.push({
        type: 'vaccine',
        priority: 1,
        title: vaccine.title,
        message: vaccine.message
      });
    }
  });
  
  // Verificar hitos
  DAILY_REMINDERS.milestones.forEach(milestone => {
    if (milestone.ageMonths === ageInMonths && ageInDays % 30 === 0) {
      reminders.push({
        type: 'milestone',
        priority: 2,
        title: milestone.title,
        message: milestone.message
      });
    }
  });
  
  // Consejos seg√∫n edad (rotar diariamente)
  const ageTips = DAILY_REMINDERS.tips[ageInMonths];
  if (ageTips) {
    const dayOfWeek = new Date().getDay(); // 0-6
    const tipIndex = dayOfWeek % ageTips.length;
    reminders.push({
      type: 'tip',
      priority: 3,
      title: ageTips[tipIndex].title,
      message: ageTips[tipIndex].message
    });
  }
  
  // Si no hay consejos espec√≠ficos, usar del mes m√°s cercano (extendido hasta 144 meses = 12 a√±os)
  if (reminders.filter(r => r.type === 'tip').length === 0) {
    const availableAges = [0, 1, 2, 3, 4, 5, 6, 9, 12, 18, 24, 30, 36, 42, 48, 54, 60, 72, 84, 96, 108, 120, 132, 144];
    const nearestAge = availableAges.reduce((prev, curr) => {
      return Math.abs(curr - ageInMonths) < Math.abs(prev - ageInMonths) ? curr : prev;
    });
    const fallbackTips = DAILY_REMINDERS.tips[nearestAge] || DAILY_REMINDERS.tips[24];
    if (fallbackTips) {
      const dayOfWeek = new Date().getDay();
      const tipIndex = dayOfWeek % fallbackTips.length;
      reminders.push({
        type: 'tip',
        priority: 3,
        title: fallbackTips[tipIndex].title,
        message: fallbackTips[tipIndex].message
      });
    }
  }
  
  // GARANTIZAR que siempre haya un recordatorio para TODOS los hijos
  if (reminders.length === 0) {
    // Consejos gen√©ricos por rango de edad
    const genericTips = [
      { title: 'üíù Momento especial', message: 'Dedica unos minutos hoy para jugar y conectar con tu beb√©. Los momentos de calidad fortalecen el v√≠nculo.' },
      { title: 'üåü Tip del d√≠a', message: 'Habla con tu beb√© durante las actividades diarias. Esto estimula su desarrollo del lenguaje.' },
      { title: 'üéà Diversi√≥n en familia', message: 'Los juegos simples como esconderse y aparecer son excelentes para el desarrollo cognitivo.' },
      { title: 'üìö Lectura diaria', message: 'Leer cuentos juntos, aunque sea por pocos minutos, beneficia enormemente su desarrollo.' },
      { title: 'ü§ó Conexi√≥n emocional', message: 'Los abrazos y el contacto f√≠sico son fundamentales para el bienestar emocional de tu peque√±o.' },
      { title: 'üéµ M√∫sica y movimiento', message: 'Cantar y bailar juntos estimula m√∫ltiples √°reas del desarrollo de tu hijo.' },
      { title: 'üåà Exploraci√≥n', message: 'Permite que tu hijo explore de forma segura. La curiosidad es el motor del aprendizaje.' }
    ];
    
    const dayOfWeek = new Date().getDay();
    const tipIndex = dayOfWeek % genericTips.length;
    
    reminders.push({
      type: 'tip',
      priority: 3,
      title: genericTips[tipIndex].title,
      message: genericTips[tipIndex].message
    });
  }
  
  // Ordenar por prioridad (vacunas primero)
  return reminders.sort((a, b) => a.priority - b.priority)[0];
}

const getUpcomingScheduledVaccineReminder = async (childId, childName) => {
  if (!db) return null;
  const now = new Date();
  const targetDate = new Date(now);
  targetDate.setDate(targetDate.getDate() + 7);
  const startOfDay = new Date(targetDate);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(targetDate);
  endOfDay.setHours(23, 59, 59, 999);

  const snapshot = await db.collection('children').doc(childId)
    .collection('vaccines')
    .where('scheduledDate', '>=', startOfDay)
    .where('scheduledDate', '<=', endOfDay)
    .orderBy('scheduledDate', 'asc')
    .limit(1)
    .get();

  if (snapshot.empty) return null;
  const vaccineDoc = snapshot.docs[0].data();
  if (vaccineDoc.status === 'applied') return null;
  const name = vaccineDoc.name || 'vacuna';
  const childLabel = childName || 'tu beb√©';
  return {
    type: 'vaccine',
    priority: 1,
    title: 'üíâ Vacuna pr√≥xima',
    message: `En una semana ${childLabel} tiene la vacuna ${name}.`
  };
};

// Middleware especial para cron jobs: acepta JWT admin o CRON_SECRET
const authenticateCron = (req, res, next) => {
  console.log('üîç [CRON] Headers recibidos:', Object.keys(req.headers));
  
  // Opci√≥n 1: x-cron-secret header (para servicios externos como cron-job.org)
  const cronSecretHeader = req.headers['x-cron-secret'];
  if (cronSecretHeader && cronSecretHeader === process.env.CRON_SECRET) {
    console.log('‚úÖ [CRON] Autenticado con x-cron-secret');
    req.user = { uid: 'cron-job', isAdmin: true };
    return next();
  }

  // Opci√≥n 2: Authorization Bearer (para Vercel Cron Jobs)
  const authHeader = req.headers.authorization;
  if (authHeader) {
    const parts = authHeader.split(' ');
    if (parts.length === 2 && parts[0] === 'Bearer') {
      const token = parts[1];
      
      // Verificar si es el CRON_SECRET
      if (token === process.env.CRON_SECRET) {
        console.log('‚úÖ [CRON] Autenticado con Authorization Bearer (CRON_SECRET)');
        req.user = { uid: 'cron-job', isAdmin: true };
        return next();
      }
      
      // Si no es CRON_SECRET, intentar como JWT de admin
      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        
        // Verificar que es admin
        if (!req.user.isAdmin) {
          return res.status(403).json({
            success: false,
            message: 'Acceso denegado. Se requieren permisos de administrador'
          });
        }
        
        console.log('‚úÖ [CRON] Autenticado con JWT admin');
        return next();
      } catch (error) {
        // No es un JWT v√°lido, continuar con error
      }
    }
  }

  // Si llegamos aqu√≠, no hay autenticaci√≥n v√°lida
  return res.status(401).json({
    success: false,
    message: 'No autorizado. Requiere CRON_SECRET header o token de admin'
  });
};

// Endpoint para enviar notificaciones diarias (llamado por cron job)
// Vercel Cron Jobs usan GET por defecto
app.get('/api/notifications/daily-reminders', authenticateCron, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('üìÖ [DAILY] Iniciando env√≠o de recordatorios diarios...');
    
    let notificationsSent = 0;
    let errors = 0;
    const results = [];
    let usersWithoutTokens = 0;
    let usersWithoutChildren = 0;
    let childrenTooOld = 0;
    let noReminderForAge = 0;

    // Obtener todos los usuarios
    const usersSnapshot = await db.collection('users').get();
    console.log(`üë• [DAILY] Total usuarios en BD: ${usersSnapshot.docs.length}`);

    for (const userDoc of usersSnapshot.docs) {
      try {
        const userData = userDoc.data();
        const userId = userDoc.id;

        // Saltar si no tiene tokens FCM
        if (!userData.fcmTokens || userData.fcmTokens.length === 0) {
          usersWithoutTokens++;
          continue;
        }

        // Obtener hijos del usuario (como padre principal)
        const childrenSnapshot = await db.collection('children')
          .where('parentId', '==', userId)
          .get();

        // Tambi√©n obtener hijos compartidos con el usuario
        const sharedChildrenSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', userId)
          .get();

        const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

        if (allChildren.length === 0) {
          usersWithoutChildren++;
          continue; // Usuario sin hijos asignados
        }

        console.log(`üë∂ [DAILY] Usuario ${userId} tiene ${allChildren.length} hijo(s) total(es)`);

        // Recopilar TODOS los hijos elegibles (< 24 meses) con sus recordatorios
        const eligibleChildren = [];

        for (const childDoc of allChildren) {
          const childData = childDoc.data();
          
          // Calcular edad actual
          if (childData.birthDate) {
            const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
            const now = new Date();
            const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
            const ageInMonths = Math.floor(ageInDays / 30);

            console.log(`   üë∂ Hijo: ${childData.name}, ${ageInMonths} meses, ${ageInDays} d√≠as`);

            // Priorizar vacuna programada 1 semana antes
            let fallbackReminder = null;
            try {
              fallbackReminder = await getUpcomingScheduledVaccineReminder(childDoc.id, childData.name);
            } catch (error) {
              console.warn('‚ö†Ô∏è [DAILY] Error buscando vacuna programada:', error.message);
            }
            if (!fallbackReminder) {
              // Obtener recordatorio sin l√≠mite de edad
              fallbackReminder = getDailyReminder(ageInMonths, ageInDays);
            }
            
            if (fallbackReminder) {
              console.log(`   ‚úÖ Tiene recordatorio: ${fallbackReminder.title}`);
              eligibleChildren.push({
                ...childData,
                id: childDoc.id,
                ageInMonths,
                ageInDays,
                fallbackReminder
              });
            } else {
              console.log(`   ‚è≠Ô∏è No hay recordatorio para ${childData.name} (${ageInMonths} meses, ${ageInDays} d√≠as)`);
              noReminderForAge++;
            }
          } else {
            console.log(`   ‚ö†Ô∏è ${childData.name} no tiene birthDate`);
          }
        }

        console.log(`   üìä Hijos elegibles para ${userId}: ${eligibleChildren.length}/${allChildren.length}`);

        if (eligibleChildren.length === 0) {
          if (allChildren.length > 0) {
            childrenTooOld++;
          }
          continue; // No hay hijos elegibles
        }

        // Generar mensajes para cada hijo
        const childReminders = [];
        for (const child of eligibleChildren) {
          const gptReminder = await generatePersonalizedReminder(
            child,
            child.fallbackReminder.type,
            child.ageInMonths,
            child.ageInDays
          );

          const reminder = gptReminder || child.fallbackReminder;
          let message = reminder.message || child.fallbackReminder.message;
          const childName = child.name || 'tu beb√©';
          message = message.replace(/tu beb√©|el beb√©/gi, childName);

          childReminders.push({
            child,
            reminder,
            message,
            childName
          });
        }

        // Crear t√≠tulo y mensaje combinado
        let title, message;
        if (eligibleChildren.length === 1) {
          // Un solo hijo: mensaje personalizado
          const { child, reminder, message: childMessage, childName } = childReminders[0];
          
          if (childName !== 'tu beb√©') {
            if (child.fallbackReminder.type === 'tip') {
              title = `üë∂ Consejo para ${childName}`;
            } else if (child.fallbackReminder.type === 'milestone') {
              // Formatear edad en t√≠tulo de milestone
              let ageText;
              if (child.ageInMonths < 24) {
                ageText = `${child.ageInMonths} meses`;
              } else {
                const years = Math.floor(child.ageInMonths / 12);
                const remainingMonths = child.ageInMonths % 12;
                if (remainingMonths === 0) {
                  ageText = `${years} ${years === 1 ? 'a√±o' : 'a√±os'}`;
                } else {
                  ageText = `${years} ${years === 1 ? 'a√±o' : 'a√±os'} y ${remainingMonths} meses`;
                }
              }
              title = `üéâ ¬°${childName} cumple ${ageText}!`;
            } else {
              title = reminder.title || child.fallbackReminder.title;
            }
          } else {
            title = reminder.title || child.fallbackReminder.title;
          }
          
          message = childMessage;
        } else {
          // M√∫ltiples hijos: combinar en un mensaje
          const childNames = childReminders.map(r => r.childName).join(' y ');
          title = `üë∂ Consejos para ${childNames}`;
          
          // Combinar mensajes
          const messages = childReminders.map((r, idx) => {
            // Formatear edad: < 24 meses en meses, >= 24 meses en a√±os
            let ageDisplay;
            if (r.child.ageInMonths < 24) {
              ageDisplay = `${r.child.ageInMonths}m`;
            } else {
              const years = Math.floor(r.child.ageInMonths / 12);
              const remainingMonths = r.child.ageInMonths % 12;
              if (remainingMonths === 0) {
                ageDisplay = `${years}a`;
              } else if (remainingMonths === 6) {
                ageDisplay = `${years}.5a`;
              } else {
                ageDisplay = `${years}a ${remainingMonths}m`;
              }
            }
            return `${r.childName} (${ageDisplay}): ${r.message}`;
          });
          message = messages.join('\n\n');
        }

        // Enviar push notification
        await sendPushNotification(
          userData.fcmTokens,
          {
            title: title,
            body: message
          },
          {
            type: 'daily_reminder',
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', ')
          }
        );

        // Guardar notificaci√≥n en Firestore
        await db.collection('notifications').add({
          userId: userId,
          type: 'daily_reminder',
          title: title,
          body: message, // Campo body para consistencia con otras notificaciones
          message: message, // Mantener message para compatibilidad
          data: {
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', '),
            childrenCount: eligibleChildren.length
          },
          read: false,
          createdAt: new Date()
        });

        // Guardar log detallado para cada hijo en el dashboard
        for (const childReminderData of childReminders) {
          await db.collection('reminders_history').add({
            userId: userId,
            userName: userData.displayName || userData.name || 'Usuario',
            childId: childReminderData.child.id,
            childName: childReminderData.childName,
            childAge: childReminderData.child.ageInMonths,
            childAgeDays: childReminderData.child.ageInDays,
            reminderType: childReminderData.child.fallbackReminder.type,
            title: eligibleChildren.length === 1 ? title : `üë∂ Consejo para ${childReminderData.childName}`,
            message: childReminderData.message,
            generatedBy: childReminderData.reminder.generatedBy || 'fallback',
            model: childReminderData.reminder.model || null,
            prompt: childReminderData.reminder.prompt || null,
            sent: true,
            sentAt: new Date(),
            createdAt: new Date()
          });
        }

        notificationsSent++;
        
        const childrenNames = eligibleChildren.map(c => c.name).join(', ');
        results.push({
          userId,
          childrenNames: childrenNames,
          childrenCount: eligibleChildren.length,
          title: title,
          generatedBy: childReminders[0]?.reminder?.generatedBy || 'fallback'
        });

        console.log(`‚úÖ [DAILY] Notificaci√≥n enviada a ${userId} para ${eligibleChildren.length} hijo(s): ${childrenNames}`);

      } catch (userError) {
        errors++;
        console.error(`‚ùå [DAILY] Error procesando usuario ${userDoc.id}:`, userError.message);
      }
    }

    console.log(`üìä [DAILY] Completado: ${notificationsSent} enviadas, ${errors} errores`);
    console.log(`üìä [DAILY] Estad√≠sticas:`);
    console.log(`   üë• Total usuarios en BD: ${usersSnapshot.docs.length}`);
    console.log(`   ‚ùå Sin tokens FCM: ${usersWithoutTokens}`);
    console.log(`   ‚ùå Sin hijos: ${usersWithoutChildren}`);
    console.log(`   ‚ùå Hijos > 24 meses: ${childrenTooOld}`);
    console.log(`   ‚ùå Sin recordatorio para edad: ${noReminderForAge}`);
    console.log(`   ‚úÖ Notificaciones enviadas: ${notificationsSent}`);

    res.json({
      success: true,
      message: 'Recordatorios diarios enviados',
      data: {
        notificationsSent,
        errors,
        results: results.slice(0, 10), // Primeros 10 para muestra
        stats: {
          totalUsers: usersSnapshot.docs.length,
          usersWithoutTokens,
          usersWithoutChildren,
          childrenTooOld,
          noReminderForAge
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [DAILY] Error en recordatorios diarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando recordatorios diarios',
      error: error.message
    });
  }
});

// ============================================================================
// üìÖ RECORDATORIOS SEMANALES ALEATORIOS
// ============================================================================

// Endpoint para enviar notificaciones semanales en horarios aleatorios
// Se ejecuta cada hora entre 9am-7pm, pero solo env√≠a 1 vez por semana
app.get('/api/notifications/weekly-reminders', authenticateCron, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    console.log('üìÖ [WEEKLY] Verificando si enviar recordatorios semanales...');

    // Obtener configuraci√≥n de env√≠o semanal
    const configRef = db.collection('config').doc('weekly_reminders');
    const configDoc = await configRef.get();
    const configData = configDoc.exists ? configDoc.data() : {};

    // Verificar si ya se envi√≥ esta semana
    const now = new Date();
    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay()); // Domingo de esta semana
    startOfWeek.setHours(0, 0, 0, 0);

    if (configData.lastSentAt) {
      const lastSent = configData.lastSentAt.toDate();
      if (lastSent >= startOfWeek) {
        console.log(`‚è≠Ô∏è [WEEKLY] Ya se enviaron notificaciones esta semana (${lastSent.toLocaleString()})`);
        return res.json({
          success: true,
          message: 'Ya se enviaron notificaciones esta semana',
          data: {
            lastSentAt: lastSent,
            nextAvailableAt: new Date(startOfWeek.getTime() + 7 * 24 * 60 * 60 * 1000)
          }
        });
      }
    }

    // Probabilidad aleatoria de env√≠o (15% cada hora = ~100% de probabilidad en el d√≠a)
    const randomChance = Math.random();
    const sendProbability = 0.15; // 15%

    if (randomChance > sendProbability) {
      console.log(`üé≤ [WEEKLY] Probabilidad no cumplida (${(randomChance * 100).toFixed(1)}% > ${(sendProbability * 100)}%). Esperando pr√≥xima ejecuci√≥n...`);
      return res.json({
        success: true,
        message: 'Esperando momento aleatorio para enviar',
        data: {
          randomValue: randomChance,
          threshold: sendProbability,
          willSend: false
        }
      });
    }

    console.log(`üé≤ [WEEKLY] ¬°Momento de enviar! (${(randomChance * 100).toFixed(1)}% <= ${(sendProbability * 100)}%)`);

    // ===== L√ìGICA DE ENV√çO (misma que daily-reminders) =====
    
    let notificationsSent = 0;
    let errors = 0;
    const results = [];
    let usersWithoutTokens = 0;
    let usersWithoutChildren = 0;
    let childrenTooOld = 0;
    let noReminderForAge = 0;

    // Obtener todos los usuarios
    const usersSnapshot = await db.collection('users').get();
    console.log(`üë• [WEEKLY] Total usuarios en BD: ${usersSnapshot.docs.length}`);

    for (const userDoc of usersSnapshot.docs) {
      try {
        const userData = userDoc.data();
        const userId = userDoc.id;

        // Saltar si no tiene tokens FCM
        if (!userData.fcmTokens || userData.fcmTokens.length === 0) {
          usersWithoutTokens++;
          continue;
        }

        // Obtener hijos del usuario (como padre principal)
        const childrenSnapshot = await db.collection('children')
          .where('parentId', '==', userId)
          .get();

        // Tambi√©n obtener hijos compartidos con el usuario
        const sharedChildrenSnapshot = await db.collection('children')
          .where('sharedWith', 'array-contains', userId)
          .get();

        const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

        if (allChildren.length === 0) {
          usersWithoutChildren++;
          continue;
        }

        console.log(`üë∂ [WEEKLY] Usuario ${userId} tiene ${allChildren.length} hijo(s) total(es)`);

        // Recopilar TODOS los hijos elegibles con sus recordatorios
        const eligibleChildren = [];

        for (const childDoc of allChildren) {
          const childData = childDoc.data();
          
          // Calcular edad actual
          if (childData.birthDate) {
            const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
            const now = new Date();
            const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
            const ageInMonths = Math.floor(ageInDays / 30);

            console.log(`   üë∂ Hijo: ${childData.name}, ${ageInMonths} meses, ${ageInDays} d√≠as`);

            // Priorizar vacuna programada 1 semana antes
            let fallbackReminder = null;
            try {
              fallbackReminder = await getUpcomingScheduledVaccineReminder(childDoc.id, childData.name);
            } catch (error) {
              console.warn('‚ö†Ô∏è [WEEKLY] Error buscando vacuna programada:', error.message);
            }
            if (!fallbackReminder) {
              // Obtener recordatorio
              fallbackReminder = getDailyReminder(ageInMonths, ageInDays);
            }
            
            if (fallbackReminder) {
              console.log(`   ‚úÖ Tiene recordatorio: ${fallbackReminder.title}`);
              eligibleChildren.push({
                ...childData,
                id: childDoc.id,
                ageInMonths,
                ageInDays,
                fallbackReminder
              });
            } else {
              console.log(`   ‚è≠Ô∏è No hay recordatorio para ${childData.name} (${ageInMonths} meses, ${ageInDays} d√≠as)`);
              noReminderForAge++;
            }
          } else {
            console.log(`   ‚ö†Ô∏è ${childData.name} no tiene birthDate`);
          }
        }

        console.log(`   üìä Hijos elegibles para ${userId}: ${eligibleChildren.length}/${allChildren.length}`);

        if (eligibleChildren.length === 0) {
          if (allChildren.length > 0) {
            childrenTooOld++;
          }
          continue;
        }

        // Generar mensajes para cada hijo
        const childReminders = [];
        for (const child of eligibleChildren) {
          const gptReminder = await generatePersonalizedReminder(
            child,
            child.fallbackReminder.type,
            child.ageInMonths,
            child.ageInDays
          );

          const reminder = gptReminder || child.fallbackReminder;
          let message = reminder.message || child.fallbackReminder.message;
          const childName = child.name || 'tu beb√©';
          message = message.replace(/tu beb√©|el beb√©/gi, childName);

          childReminders.push({
            child,
            reminder,
            message,
            childName
          });
        }

        // Crear t√≠tulo y mensaje combinado
        let title, message;
        if (eligibleChildren.length === 1) {
          const { child, reminder, message: childMessage, childName } = childReminders[0];
          
          if (childName !== 'tu beb√©') {
            if (child.fallbackReminder.type === 'tip') {
              title = `üë∂ Consejo para ${childName}`;
            } else if (child.fallbackReminder.type === 'milestone') {
              let ageText;
              if (child.ageInMonths < 24) {
                ageText = `${child.ageInMonths} meses`;
              } else {
                const years = Math.floor(child.ageInMonths / 12);
                const remainingMonths = child.ageInMonths % 12;
                if (remainingMonths === 0) {
                  ageText = `${years} ${years === 1 ? 'a√±o' : 'a√±os'}`;
                } else {
                  ageText = `${years} ${years === 1 ? 'a√±o' : 'a√±os'} y ${remainingMonths} meses`;
                }
              }
              title = `üéâ ¬°${childName} cumple ${ageText}!`;
            } else {
              title = reminder.title || child.fallbackReminder.title;
            }
          } else {
            title = reminder.title || child.fallbackReminder.title;
          }
          
          message = childMessage;
        } else {
          const childNames = childReminders.map(r => r.childName).join(' y ');
          title = `üë∂ Consejos para ${childNames}`;
          
          const messages = childReminders.map((r, idx) => {
            let ageDisplay;
            if (r.child.ageInMonths < 24) {
              ageDisplay = `${r.child.ageInMonths}m`;
            } else {
              const years = Math.floor(r.child.ageInMonths / 12);
              const remainingMonths = r.child.ageInMonths % 12;
              if (remainingMonths === 0) {
                ageDisplay = `${years}a`;
              } else if (remainingMonths === 6) {
                ageDisplay = `${years}.5a`;
              } else {
                ageDisplay = `${years}a ${remainingMonths}m`;
              }
            }
            return `${r.childName} (${ageDisplay}): ${r.message}`;
          });
          message = messages.join('\n\n');
        }

        // Enviar push notification
        await sendPushNotification(
          userData.fcmTokens,
          {
            title: title,
            body: message
          },
          {
            type: 'weekly_reminder',
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', ')
          }
        );

        // Guardar notificaci√≥n en Firestore
        await db.collection('notifications').add({
          userId: userId,
          type: 'weekly_reminder',
          title: title,
          body: message,
          message: message,
          data: {
            childrenIds: eligibleChildren.map(c => c.id),
            childrenNames: eligibleChildren.map(c => c.name).join(', '),
            childrenCount: eligibleChildren.length
          },
          read: false,
          createdAt: new Date()
        });

        // Guardar log detallado para cada hijo en el dashboard
        for (const childReminderData of childReminders) {
          await db.collection('reminders_history').add({
            userId: userId,
            userName: userData.displayName || userData.name || 'Usuario',
            childId: childReminderData.child.id,
            childName: childReminderData.childName,
            childAge: childReminderData.child.ageInMonths,
            childAgeDays: childReminderData.child.ageInDays,
            reminderType: childReminderData.child.fallbackReminder.type,
            title: eligibleChildren.length === 1 ? title : `üë∂ Consejo para ${childReminderData.childName}`,
            message: childReminderData.message,
            generatedBy: childReminderData.reminder.generatedBy || 'fallback',
            model: childReminderData.reminder.model || null,
            prompt: childReminderData.reminder.prompt || null,
            sent: true,
            sentAt: new Date(),
            sentType: 'weekly_random',
            createdAt: new Date()
          });
        }

        notificationsSent++;
        
        const childrenNames = eligibleChildren.map(c => c.name).join(', ');
        results.push({
          userId,
          childrenNames: childrenNames,
          childrenCount: eligibleChildren.length,
          title: title,
          generatedBy: childReminders[0]?.reminder?.generatedBy || 'fallback'
        });

        console.log(`‚úÖ [WEEKLY] Notificaci√≥n enviada a ${userId} para ${eligibleChildren.length} hijo(s): ${childrenNames}`);

      } catch (userError) {
        errors++;
        console.error(`‚ùå [WEEKLY] Error procesando usuario ${userDoc.id}:`, userError.message);
      }
    }

    // Registrar que ya se envi√≥ esta semana
    await configRef.set({
      lastSentAt: now,
      lastSentHour: now.getHours(),
      notificationsSent,
      errors
    }, { merge: true });

    console.log(`üìä [WEEKLY] Completado: ${notificationsSent} enviadas, ${errors} errores`);
    console.log(`üìä [WEEKLY] Horario: ${now.toLocaleString()}`);
    console.log(`üìä [WEEKLY] Estad√≠sticas:`);
    console.log(`   üë• Total usuarios en BD: ${usersSnapshot.docs.length}`);
    console.log(`   ‚ùå Sin tokens FCM: ${usersWithoutTokens}`);
    console.log(`   ‚ùå Sin hijos: ${usersWithoutChildren}`);
    console.log(`   ‚ùå Hijos > 24 meses: ${childrenTooOld}`);
    console.log(`   ‚ùå Sin recordatorio para edad: ${noReminderForAge}`);
    console.log(`   ‚úÖ Notificaciones enviadas: ${notificationsSent}`);

    res.json({
      success: true,
      message: 'Recordatorios semanales enviados',
      data: {
        sentAt: now,
        sentHour: now.getHours(),
        notificationsSent,
        errors,
        results: results.slice(0, 10),
        stats: {
          totalUsers: usersSnapshot.docs.length,
          usersWithoutTokens,
          usersWithoutChildren,
          childrenTooOld,
          noReminderForAge
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [WEEKLY] Error en recordatorios semanales:', error);
    res.status(500).json({
      success: false,
      message: 'Error enviando recordatorios semanales',
      error: error.message
    });
  }
});

// Endpoint para probar recordatorio de un usuario espec√≠fico
app.post('/api/notifications/test-daily-reminder', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const userDoc = await db.collection('users').doc(uid).get();
    if (!userDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    const userData = userDoc.data();

    // Obtener hijos
    const childrenSnapshot = await db.collection('children')
      .where('parentId', '==', uid)
      .get();

    const sharedChildrenSnapshot = await db.collection('children')
      .where('sharedWith', 'array-contains', uid)
      .get();

    const allChildren = [...childrenSnapshot.docs, ...sharedChildrenSnapshot.docs];

    if (allChildren.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No tienes hijos registrados'
      });
    }

    // Buscar hijo m√°s peque√±o
    let youngestChild = null;
    let youngestAge = 999;

    for (const childDoc of allChildren) {
      const childData = childDoc.data();
      
      if (childData.birthDate) {
        const birthDate = childData.birthDate.toDate?.() || new Date(childData.birthDate);
        const now = new Date();
        const ageInDays = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
        const ageInMonths = Math.floor(ageInDays / 30);

        if (ageInMonths < youngestAge && ageInMonths <= 24) {
          youngestAge = ageInMonths;
          youngestChild = {
            ...childData,
            id: childDoc.id,
            ageInMonths,
            ageInDays
          };
        }
      }
    }

    if (!youngestChild) {
      return res.status(404).json({
        success: false,
        message: 'No se pudo calcular la edad de los hijos'
      });
    }

    // Priorizar vacuna programada 1 semana antes
    let reminder = null;
    try {
      reminder = await getUpcomingScheduledVaccineReminder(youngestChild.id, youngestChild.name);
    } catch (error) {
      console.warn('‚ö†Ô∏è [TEST] Error buscando vacuna programada:', error.message);
    }
    if (!reminder) {
      // Obtener recordatorio
      reminder = getDailyReminder(youngestChild.ageInMonths, youngestChild.ageInDays);
    }

    if (!reminder) {
      return res.json({
        success: true,
        message: 'No hay recordatorio disponible para hoy',
        data: {
          childName: youngestChild.name,
          ageMonths: youngestChild.ageInMonths,
          ageDays: youngestChild.ageInDays
        }
      });
    }

    const personalizedMessage = reminder.message.replace('tu beb√©', youngestChild.name || 'tu beb√©');

    // Enviar push si tiene tokens
    if (userData.fcmTokens && userData.fcmTokens.length > 0) {
      await sendPushNotification(
        userData.fcmTokens,
        {
          title: `üß™ Test: ${reminder.title}`,
          body: personalizedMessage
        },
        {
          type: 'daily_reminder',
          reminderType: reminder.type,
          childId: youngestChild.id,
          test: true
        }
      );
    }

    res.json({
      success: true,
      message: 'Recordatorio de prueba enviado',
      data: {
        childName: youngestChild.name,
        ageMonths: youngestChild.ageInMonths,
        ageDays: youngestChild.ageInDays,
        reminder: {
          type: reminder.type,
          title: reminder.title,
          message: personalizedMessage
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [DAILY] Error en test:', error);
    res.status(500).json({
      success: false,
      message: 'Error en recordatorio de prueba',
      error: error.message
    });
  }
});

// ============================================================================
// üéõÔ∏è ADMINISTRACI√ìN DE RECORDATORIOS - Dashboard
// ============================================================================

// Obtener configuraci√≥n de recordatorios
app.get('/api/admin/reminders/config', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Obtener configuraci√≥n de Firestore
    const configDoc = await db.collection('system_config').doc('reminders').get();
    
    const config = configDoc.exists ? configDoc.data() : DEFAULT_REMINDER_CONFIG;

    res.json({
      success: true,
      data: config
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo configuraci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo configuraci√≥n',
      error: error.message
    });
  }
});

// Actualizar configuraci√≥n de recordatorios
app.put('/api/admin/reminders/config', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { enabled, frequency, timeOfDay, types } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validar frecuencia
    const validFrequencies = ['daily', 'every2days', 'every3days', 'weekly'];
    if (frequency && !validFrequencies.includes(frequency)) {
      return res.status(400).json({
        success: false,
        message: 'Frecuencia inv√°lida. Debe ser: daily, every2days, every3days, weekly'
      });
    }

    const updateData = {
      updatedAt: new Date(),
      updatedBy: req.user.uid
    };

    if (enabled !== undefined) updateData.enabled = enabled;
    if (frequency) updateData.frequency = frequency;
    if (timeOfDay) updateData.timeOfDay = timeOfDay;
    if (types) updateData.types = types;

    await db.collection('system_config').doc('reminders').set(updateData, { merge: true });

    console.log('‚úÖ [ADMIN] Configuraci√≥n de recordatorios actualizada:', updateData);

    res.json({
      success: true,
      message: 'Configuraci√≥n actualizada exitosamente',
      data: updateData
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error actualizando configuraci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando configuraci√≥n',
      error: error.message
    });
  }
});

// Obtener historial de recordatorios enviados
app.get('/api/admin/reminders/history', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 50, childName, reminderType, generatedBy } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('reminders_history');

    // Filtros opcionales
    if (childName) {
      query = query.where('childName', '==', childName);
    }
    if (reminderType) {
      query = query.where('reminderType', '==', reminderType);
    }
    if (generatedBy) {
      query = query.where('generatedBy', '==', generatedBy);
    }

    // Obtener todos los documentos que cumplan con los filtros
    const snapshot = await query.get();

    // Ordenar y paginar en memoria
    let reminders = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      sentAt: doc.data().sentAt?.toDate?.() || doc.data().sentAt,
      createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt
    }));

    // Ordenar por fecha descendente
    reminders.sort((a, b) => {
      const dateA = a.sentAt || a.createdAt || new Date(0);
      const dateB = b.sentAt || b.createdAt || new Date(0);
      return dateB - dateA;
    });

    // Paginar
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;

    const paginatedReminders = reminders.slice(startIndex, endIndex);
    const totalPages = Math.ceil(reminders.length / limitNum);

    res.json({
      success: true,
      data: paginatedReminders,
      pagination: {
        currentPage: pageNum,
        totalPages: totalPages,
        itemsPerPage: limitNum,
        totalItems: reminders.length
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo historial:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo historial',
      error: error.message
    });
  }
});

// Obtener estad√≠sticas de recordatorios
app.get('/api/admin/reminders/stats', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const remindersSnapshot = await db.collection('reminders_history').get();
    const reminders = remindersSnapshot.docs.map(doc => doc.data());

    const now = new Date();
    const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const stats = {
      total: reminders.length,
      last24h: 0,
      last7days: 0,
      last30days: 0,
      byType: {},
      bySource: {
        chatgpt: 0,
        fallback: 0
      },
      mostActiveUsers: {},
      averagePerDay: 0
    };

    reminders.forEach(reminder => {
      const sentAt = reminder.sentAt?.toDate?.() || reminder.sentAt || new Date(0);
      
      // Conteo por per√≠odo
      if (sentAt >= dayAgo) stats.last24h++;
      if (sentAt >= weekAgo) stats.last7days++;
      if (sentAt >= monthAgo) stats.last30days++;

      // Conteo por tipo
      const type = reminder.reminderType || 'unknown';
      stats.byType[type] = (stats.byType[type] || 0) + 1;

      // Conteo por fuente
      const source = reminder.generatedBy || 'fallback';
      if (source === 'chatgpt') {
        stats.bySource.chatgpt++;
      } else {
        stats.bySource.fallback++;
      }

      // Usuarios m√°s activos
      const userName = reminder.userName || 'Usuario';
      stats.mostActiveUsers[userName] = (stats.mostActiveUsers[userName] || 0) + 1;
    });

    // Promedio por d√≠a (√∫ltimos 30 d√≠as)
    stats.averagePerDay = stats.last30days > 0 ? (stats.last30days / 30).toFixed(1) : 0;

    // Top 10 usuarios m√°s activos
    stats.topUsers = Object.entries(stats.mostActiveUsers)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));

    delete stats.mostActiveUsers; // No enviamos el objeto completo

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

// Ver detalle de un recordatorio espec√≠fico
app.get('/api/admin/reminders/history/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const reminderDoc = await db.collection('reminders_history').doc(id).get();

    if (!reminderDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Recordatorio no encontrado'
      });
    }

    const reminderData = reminderDoc.data();

    res.json({
      success: true,
      data: {
        id: reminderDoc.id,
        ...reminderData,
        sentAt: reminderData.sentAt?.toDate?.() || reminderData.sentAt,
        createdAt: reminderData.createdAt?.toDate?.() || reminderData.createdAt
      }
    });

  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo detalle:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo detalle',
      error: error.message
    });
  }
});

// ============================================================================
// üõå SISTEMA DE PREDICCI√ìN DE SUE√ëO (Tipo Napper)
// ============================================================================
const sleepController = require('./controllers/sleepPredictionController');

// Registrar evento de sue√±o
app.post('/api/sleep/record', authenticateToken, (req, res) => {
  sleepController.recordSleepEvent(req, res);
});

// Registrar hora de despertar
app.post('/api/sleep/wake-time', authenticateToken, (req, res) => {
  sleepController.recordWakeTime(req, res);
});

// Obtener hora de despertar de hoy
app.get('/api/sleep/wake-time/:childId', authenticateToken, (req, res) => {
  sleepController.getWakeTime(req, res);
});

// Obtener predicci√≥n de sue√±o (GET con childId en URL)
app.get('/api/sleep/predict/:childId', authenticateToken, (req, res) => {
  sleepController.predictSleep(req, res);
});

// Obtener predicci√≥n de sue√±o (POST con childId en body) - compatibilidad
app.post('/api/sleep/predict', authenticateToken, (req, res) => {
  // Mover childId del body a params para compatibilidad
  if (req.body.childId) {
    req.params.childId = req.body.childId;
  }
  sleepController.predictSleep(req, res);
});

// Obtener historial de sue√±o
app.get('/api/sleep/history/:childId', authenticateToken, (req, res) => {
  sleepController.getSleepHistoryEndpoint(req, res);
});

// ============================================================================
// üîî SISTEMA DE NOTIFICACIONES DE SUE√ëO
// ============================================================================
const sleepNotificationsController = require('./controllers/sleepNotificationsController');
const medicationsController = require('./controllers/medicationsController');

// Programar notificaciones 30min antes de cada siesta
app.post('/api/sleep/notifications/pre-nap/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.schedulePreNapNotifications(req, res);
});

// Programar notificaciones a la hora exacta de cada siesta/bedtime
app.post('/api/sleep/notifications/nap-time/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.scheduleNapTimeNotifications(req, res);
});

// Verificar y notificar si hay registro tarde (30+ min despu√©s)
app.post('/api/sleep/notifications/check-late/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.checkLateNapRegistration(req, res);
});

// Verificar y notificar siestas largas (4+ horas)
app.post('/api/sleep/notifications/check-long/:childId', authenticateToken, (req, res) => {
  sleepNotificationsController.checkLongNaps(req, res);
});

// Enviar notificaci√≥n inmediata personalizada
app.post('/api/sleep/notifications/send', authenticateToken, (req, res) => {
  sleepNotificationsController.sendSleepNotification(req, res);
});

// Procesar notificaciones programadas (para cron job)
app.post('/api/sleep/notifications/process-scheduled', (req, res) => {
  sleepNotificationsController.processScheduledNotifications(req, res);
});
// Vercel cron usa GET por defecto; soportar ambos m√©todos
app.get('/api/sleep/notifications/process-scheduled', (req, res) => {
  sleepNotificationsController.processScheduledNotifications(req, res);
});

// ============================================================================
// üíä SISTEMA DE MEDICAMENTOS Y RECORDATORIOS
// ============================================================================
app.post('/api/medications', authenticateToken, (req, res) => {
  medicationsController.createMedication(req, res);
});

app.get('/api/medications/:childId', authenticateToken, (req, res) => {
  medicationsController.listMedications(req, res);
});

app.put('/api/medications/:medicationId', authenticateToken, (req, res) => {
  medicationsController.updateMedication(req, res);
});

app.delete('/api/medications/:medicationId', authenticateToken, (req, res) => {
  medicationsController.deleteMedication(req, res);
});

app.post('/api/medications/reminders/:reminderId/taken', authenticateToken, (req, res) => {
  medicationsController.markMedicationTaken(req, res);
});

// ============================================================================
// üé® SISTEMA DE ACTIVIDADES PARA BEB√âS
// ============================================================================
const activitiesController = require('./controllers/activitiesController');

// Obtener sugerencias de actividades basadas en edad y ventanas de vigilia
app.get('/api/activities/suggestions/:childId', authenticateToken, (req, res) => {
  activitiesController.getActivitySuggestions(req, res);
});

// Actualizar evento de sue√±o
app.put('/api/sleep/:eventId', authenticateToken, (req, res) => {
  sleepController.updateSleepEvent(req, res);
});

// Eliminar evento de sue√±o
app.delete('/api/sleep/:eventId', authenticateToken, (req, res) => {
  sleepController.deleteSleepEvent(req, res);
});

// Agregar pausa a un evento de sue√±o
app.post('/api/sleep/:eventId/pause', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId } = req.params;
    const { startTime, endTime, duration, reason } = req.body;

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Calcular duraci√≥n de la pausa si no se proporciona
    let pauseDuration = duration;
    if (startTime && endTime && !duration) {
      const start = new Date(startTime);
      const end = new Date(endTime);
      pauseDuration = Math.floor((end - start) / 1000 / 60); // en minutos
    }

    // Crear objeto de pausa
    const pause = {
      id: `pause_${Date.now()}`,
      startTime: startTime || null,
      endTime: endTime || null,
      duration: pauseDuration || 0,
      reason: reason || 'Despert√≥',
      createdAt: new Date().toISOString()
    };

    // Obtener pausas existentes
    const pauses = eventData.pauses || [];
    pauses.push(pause);

    // Recalcular duraci√≥n neta
    const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
    const grossDuration = eventData.grossDuration || eventData.duration || 0;
    const netDuration = Math.max(0, grossDuration - totalPauseTime);

    // Actualizar evento
    await db.collection('sleepEvents').doc(eventId).update({
      pauses,
      netDuration,
      duration: netDuration,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    res.json({
      success: true,
      message: 'Pausa agregada exitosamente',
      pause,
      totalPauses: pauses.length,
      netDuration
    });

  } catch (error) {
    console.error('‚ùå Error al agregar pausa:', error);
    res.status(500).json({
      error: 'Error al agregar pausa',
      details: error.message
    });
  }
});

// Eliminar pausa de un evento de sue√±o
app.delete('/api/sleep/:eventId/pause/:pauseId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId, pauseId } = req.params;

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Filtrar pausas para eliminar la especificada
    const pauses = (eventData.pauses || []).filter(p => p.id !== pauseId);

    // Recalcular duraci√≥n neta
    const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
    const grossDuration = eventData.grossDuration || eventData.duration || 0;
    const netDuration = Math.max(0, grossDuration - totalPauseTime);

    // Actualizar evento
    await db.collection('sleepEvents').doc(eventId).update({
      pauses,
      netDuration,
      duration: netDuration,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    res.json({
      success: true,
      message: 'Pausa eliminada exitosamente',
      totalPauses: pauses.length,
      netDuration
    });

  } catch (error) {
    console.error('‚ùå Error al eliminar pausa:', error);
    res.status(500).json({
      error: 'Error al eliminar pausa',
      details: error.message
    });
  }
});

// Editar horarios de un evento (inicio/fin)
app.patch('/api/sleep/:eventId/times', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { eventId } = req.params;
    const { startTime, endTime } = req.body;

    if (!startTime && !endTime) {
      return res.status(400).json({
        error: 'Debes proporcionar al menos startTime o endTime'
      });
    }

    // Verificar que el evento existe y pertenece al usuario
    const eventDoc = await db.collection('sleepEvents').doc(eventId).get();
    
    if (!eventDoc.exists) {
      return res.status(404).json({ error: 'Evento no encontrado' });
    }

    const eventData = eventDoc.data();
    if (eventData.userId !== userId) {
      return res.status(403).json({ error: 'No autorizado' });
    }

    // Preparar actualizaciones
    const updates = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    // Actualizar horarios
    const newStartTime = startTime 
      ? new Date(startTime) 
      : eventData.startTime.toDate();
    
    const newEndTime = endTime 
      ? new Date(endTime) 
      : (eventData.endTime ? eventData.endTime.toDate() : null);

    if (startTime) {
      updates.startTime = admin.firestore.Timestamp.fromDate(new Date(startTime));
    }
    if (endTime) {
      updates.endTime = admin.firestore.Timestamp.fromDate(new Date(endTime));
    }

    // Recalcular duraciones
    if (newStartTime && newEndTime) {
      const grossDuration = Math.floor((newEndTime - newStartTime) / 1000 / 60);
      const pauses = eventData.pauses || [];
      const totalPauseTime = pauses.reduce((sum, p) => sum + (p.duration || 0), 0);
      const netDuration = Math.max(0, grossDuration - totalPauseTime);

      updates.grossDuration = grossDuration;
      updates.netDuration = netDuration;
      updates.duration = netDuration;
    }

    await db.collection('sleepEvents').doc(eventId).update(updates);

    // Obtener evento actualizado
    const updatedDoc = await db.collection('sleepEvents').doc(eventId).get();
    const updatedData = updatedDoc.data();

    res.json({
      success: true,
      message: 'Horarios actualizados exitosamente',
      sleepEvent: {
        id: eventId,
        startTime: updatedData.startTime.toDate().toISOString(),
        endTime: updatedData.endTime ? updatedData.endTime.toDate().toISOString() : null,
        duration: updatedData.duration,
        grossDuration: updatedData.grossDuration,
        netDuration: updatedData.netDuration,
        pauses: updatedData.pauses || []
      }
    });

  } catch (error) {
    console.error('‚ùå Error al actualizar horarios:', error);
    res.status(500).json({
      error: 'Error al actualizar horarios',
      details: error.message
    });
  }
});

// Obtener an√°lisis detallado de patrones
app.get('/api/sleep/analysis/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;
    const { days = 30 } = req.query;

    // Obtener informaci√≥n del ni√±o
    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({ error: 'Ni√±o no encontrado' });
    }

    const childData = childDoc.data();
    const birthDate = childData.birthDate.toDate();
    const ageInMonths = sleepController.calculateAgeInMonths(birthDate);

    // Obtener historial
    const sleepHistory = await sleepController.getSleepHistory(userId, childId, parseInt(days));

    if (sleepHistory.length === 0) {
      return res.json({
        success: true,
        message: 'No hay datos de sue√±o registrados',
        childInfo: { name: childData.name, ageInMonths }
      });
    }

    // Analizar patrones
    const patterns = sleepController.analyzeSleepPatterns(sleepHistory, ageInMonths);
    const recommendations = sleepController.generateRecommendations(patterns, ageInMonths, sleepHistory);

    res.json({
      success: true,
      analysis: {
        patterns,
        recommendations,
        childInfo: {
          name: childData.name,
          ageInMonths
        },
        dataRange: {
          days: parseInt(days),
          totalEvents: sleepHistory.length,
          firstEvent: sleepHistory[0].startTime,
          lastEvent: sleepHistory[sleepHistory.length - 1].startTime
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Error en an√°lisis de sue√±o:', error);
    res.status(500).json({
      error: 'Error al generar an√°lisis',
      details: error.message
    });
  }
});

// Obtener estad√≠sticas semanales/mensuales
app.get('/api/sleep/stats/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;
    const { period = 'week' } = req.query; // 'week' o 'month'
    
    const days = period === 'week' ? 7 : 30;
    const sleepHistory = await sleepController.getSleepHistory(userId, childId, days);

    if (sleepHistory.length === 0) {
      return res.json({
        success: true,
        message: 'No hay datos disponibles',
        stats: null
      });
    }

    // Agrupar por d√≠as
    const dailyStats = {};
    
    sleepHistory.forEach(event => {
      const date = new Date(event.startTime).toISOString().split('T')[0];
      
      if (!dailyStats[date]) {
        dailyStats[date] = {
          date,
          totalSleep: 0,
          naps: 0,
          nightSleep: 0,
          events: []
        };
      }

      dailyStats[date].events.push(event);
      dailyStats[date].totalSleep += event.duration || 0;
      
      if (event.type === 'nap') {
        dailyStats[date].naps++;
      } else {
        dailyStats[date].nightSleep += event.duration || 0;
      }
    });

    const dailyArray = Object.values(dailyStats).sort((a, b) => 
      new Date(a.date) - new Date(b.date)
    );

    res.json({
      success: true,
      period,
      days,
      dailyStats: dailyArray,
      summary: {
        totalEvents: sleepHistory.length,
        avgSleepPerDay: Math.round(
          dailyArray.reduce((sum, day) => sum + day.totalSleep, 0) / dailyArray.length
        ),
        avgNapsPerDay: parseFloat(
          (dailyArray.reduce((sum, day) => sum + day.naps, 0) / dailyArray.length).toFixed(1)
        )
      }
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      error: 'Error al obtener estad√≠sticas',
      details: error.message
    });
  }
});

// Endpoint para obtener recordatorios inteligentes
app.get('/api/sleep/reminders/:childId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.uid;
    const { childId } = req.params;

    // Obtener predicci√≥n
    const childDoc = await db.collection('children').doc(childId).get();
    
    if (!childDoc.exists) {
      return res.status(404).json({ error: 'Ni√±o no encontrado' });
    }

    const childData = childDoc.data();
    const birthDate = childData.birthDate.toDate();
    const ageInMonths = sleepController.calculateAgeInMonths(birthDate);

    // ‚úÖ Construir childInfo correctamente (con id y userId)
    const childInfo = {
      id: childId,
      userId: userId,
      name: childData.name,
      ageInMonths: ageInMonths
    };

    // ‚úÖ CAMBIO: Siempre generar predicci√≥n (eliminar validaci√≥n de 3 datos)
    // Incluso sin historial, dar√° horarios por defecto

    // üåç Obtener timezone del usuario
    const TimezoneHelper = require('./utils/timezoneHelper');
    const userTimezone = TimezoneHelper.getUserTimezone(req);

    // ‚ö° Intentar usar cache de predicciones recientes (evitar recomputo)
    const todayInfo = TimezoneHelper.getTodayInUserTimezone(userTimezone);
    const todayStr = format(todayInfo.userLocalTime, 'yyyy-MM-dd');
    const predictionDoc = await db.collection('sleepPredictions').doc(`${childId}_${todayStr}`).get();
    const forceRefresh = req.query?.force === 'true' || req.headers['x-force-refresh'] === 'true';
    const cacheTtlMinutes = 5;

    if (!forceRefresh && predictionDoc.exists) {
      const cached = predictionDoc.data();
      const lastUpdated = cached.lastUpdated?.toDate ? cached.lastUpdated.toDate() : null;
      const cacheAgeMinutes = lastUpdated ? Math.floor((Date.now() - lastUpdated.getTime()) / 60000) : null;
      const hasPredictions = (cached.predictedNaps && cached.predictedNaps.length > 0) || cached.predictedBedtime;

      if (hasPredictions && cacheAgeMinutes !== null && cacheAgeMinutes <= cacheTtlMinutes) {
        const reminders = [];
        const now = new Date();

        const nextNap = cached.predictedNaps && cached.predictedNaps.length > 0
          ? cached.predictedNaps[0]
          : null;

        if (nextNap?.time) {
          const napTime = new Date(nextNap.time);
          const minutesUntilNap = Math.floor((napTime - now) / 60000);
          if (minutesUntilNap > 0 && minutesUntilNap <= 30) {
            reminders.push({
              type: 'nap',
              title: 'üõå Hora de siesta pronto',
              message: `La pr√≥xima siesta de ${childData.name} es en ${minutesUntilNap} minutos`,
              time: nextNap.time,
              minutesUntil: minutesUntilNap,
              priority: minutesUntilNap <= 15 ? 'high' : 'medium'
            });
          }
        }

        if (cached.predictedBedtime?.time) {
          const bedtime = new Date(cached.predictedBedtime.time);
          const minutesUntilBedtime = Math.floor((bedtime - now) / 60000);
          if (minutesUntilBedtime > 0 && minutesUntilBedtime <= 60) {
            reminders.push({
              type: 'bedtime',
              title: 'üåô Hora de dormir se acerca',
              message: `Es hora de empezar la rutina de ${childData.name}`,
              time: cached.predictedBedtime.time,
              minutesUntil: minutesUntilBedtime,
              priority: minutesUntilBedtime <= 30 ? 'high' : 'medium'
            });
          }
        }

        return res.json({
          success: true,
          reminders,
          sleepPressure: cached.sleepPressure || null,
          nextPrediction: {
            nap: nextNap,
            bedtime: cached.predictedBedtime || null
          },
          timezone: userTimezone,
          cached: true
        });
      }
    }

    const sleepHistory = await sleepController.getSleepHistory(userId, childId, 7);
    const prediction = await sleepController.generateSleepPrediction(
      sleepHistory,
      ageInMonths,
      childInfo,  // ‚úÖ Pasar childInfo, no childData
      userTimezone  // ‚úÖ Pasar timezone
    );

    const reminders = [];
    const now = new Date();

    // Recordatorio de siesta
    if (prediction.nextNap && prediction.nextNap.time) {
      const napTime = new Date(prediction.nextNap.time);
      const minutesUntilNap = Math.floor((napTime - now) / 1000 / 60);

      if (minutesUntilNap > 0 && minutesUntilNap <= 30) {
        reminders.push({
          type: 'nap',
          title: 'üõå Hora de siesta pronto',
          message: `La pr√≥xima siesta de ${childData.name} es en ${minutesUntilNap} minutos`,
          time: prediction.nextNap.time,
          minutesUntil: minutesUntilNap,
          priority: minutesUntilNap <= 15 ? 'high' : 'medium'
        });
      }
    }

    // Recordatorio de hora de dormir
    if (prediction.bedtime && prediction.bedtime.time) {
      const bedtime = new Date(prediction.bedtime.time);
      const minutesUntilBedtime = Math.floor((bedtime - now) / 1000 / 60);

      if (minutesUntilBedtime > 0 && minutesUntilBedtime <= 60) {
        reminders.push({
          type: 'bedtime',
          title: 'üåô Hora de dormir se acerca',
          message: `Es hora de empezar la rutina de ${childData.name}`,
          time: prediction.bedtime.time,
          minutesUntil: minutesUntilBedtime,
          priority: minutesUntilBedtime <= 30 ? 'high' : 'medium'
        });
      }
    }

    // Recordatorio de presi√≥n de sue√±o alta
    if (prediction.sleepPressure && prediction.sleepPressure.level === 'critical') {
      reminders.push({
        type: 'urgent',
        title: '‚ö†Ô∏è Necesita dormir urgentemente',
        message: prediction.sleepPressure.recommendation,
        priority: 'critical'
      });
    }

    // üåç Localizar las fechas a la timezone del usuario
    const localizedPrediction = sleepController.localizePredictionDates(prediction, userTimezone);
    
    res.json({
      success: true,
      reminders,
      sleepPressure: localizedPrediction.sleepPressure,
      nextPrediction: {
        nap: localizedPrediction.nextNap,
        bedtime: localizedPrediction.bedtime
      },
      timezone: userTimezone  // ‚úÖ Indicar timezone
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo recordatorios:', error);
    res.status(500).json({
      error: 'Error al obtener recordatorios',
      details: error.message
    });
  }
});

console.log('üõå Sistema de predicci√≥n de sue√±o cargado');

// ============================================================================
// üì∞ ARTICULOS (BLOG) - DASHBOARD Y APP
// ============================================================================

const slugifyText = (value) => {
  if (!value) return '';
  return String(value)
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

const stripHtml = (html) => {
  if (!html) return '';
  return String(html).replace(/<[^>]*>/g, ' ');
};

const calculateReadingTimeMinutes = (html) => {
  const text = stripHtml(html);
  const words = text.trim().split(/\s+/).filter(Boolean).length;
  return Math.max(1, Math.ceil(words / 200));
};

const resolveAuthorInfo = async (uid, fallbackName) => {
  if (!db) {
    return { uid, name: fallbackName || 'Usuario' };
  }
  const userDoc = await db.collection('users').doc(uid).get();
  const userData = userDoc.exists ? userDoc.data() : {};
  return {
    uid,
    name: fallbackName || userData.displayName || userData.name || userData.email || 'Usuario'
  };
};

const resolveProfessionalAuthor = async (professionalId) => {
  if (!db) {
    return { id: professionalId, name: 'Profesional' };
  }
  const doc = await db.collection('professionals').doc(professionalId).get();
  if (!doc.exists) {
    const error = new Error('Perfil profesional no encontrado');
    error.code = 'professional-not-found';
    throw error;
  }
  const data = doc.data() || {};
  return {
    id: doc.id,
    userId: data.userId || null,
    name: data.name || 'Profesional',
    headline: data.headline || null,
    photoUrl: data.photoUrl || null,
    contactEmail: data.contactEmail || null,
    contactPhone: data.contactPhone || null,
    website: data.website || null
  };
};

const resolveProfessionalProfileCategory = async (categoryId) => {
  if (!db) {
    return { id: categoryId, name: 'Categor√≠a' };
  }
  const doc = await db.collection('professional_profile_categories').doc(categoryId).get();
  if (!doc.exists) {
    const error = new Error('Categor√≠a de perfil no encontrada');
    error.code = 'professional-profile-category-not-found';
    throw error;
  }
  const data = doc.data() || {};
  return {
    id: doc.id,
    name: data.name || 'Categor√≠a',
    logoUrl: data.logoUrl || null
  };
};

const fetchProfessionalsMap = async (ids) => {
  const map = new Map();
  if (!db || !Array.isArray(ids) || ids.length === 0) return map;
  const uniqueIds = Array.from(new Set(ids.filter(Boolean)));
  const chunkSize = 10;
  for (let i = 0; i < uniqueIds.length; i += chunkSize) {
    const chunk = uniqueIds.slice(i, i + chunkSize);
    const snapshot = await db.collection('professionals')
      .where(admin.firestore.FieldPath.documentId(), 'in', chunk)
      .get();
    snapshot.forEach(doc => {
      const data = doc.data() || {};
      map.set(doc.id, {
        id: doc.id,
        userId: data.userId || null,
        name: data.name || 'Profesional',
        headline: data.headline || null,
        photoUrl: data.photoUrl || null,
        contactEmail: data.contactEmail || null,
        contactPhone: data.contactPhone || null,
        website: data.website || null
      });
    });
  }
  return map;
};

const fetchCategoriesMap = async () => {
  if (!db) return new Map();
  const snapshot = await db.collection('article_categories').get();
  const map = new Map();
  snapshot.forEach(doc => {
    map.set(doc.id, { id: doc.id, ...doc.data() });
  });
  return map;
};

const fetchKeywordsMap = async () => {
  if (!db) return new Map();
  const snapshot = await db.collection('article_keywords').get();
  const map = new Map();
  snapshot.forEach(doc => {
    map.set(doc.id, { id: doc.id, ...doc.data() });
  });
  return map;
};

// =========================
// Categorias (admin/app)
// =========================

app.get('/api/articles/categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('article_categories').orderBy('name', 'asc').get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('‚ùå Error obteniendo categorias:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categorias', error: error.message });
  }
});

app.post('/api/admin/article-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description } = req.body || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const slug = slugifyText(name);
    const categoryData = {
      name,
      description: description || '',
      slug,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('article_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('‚ùå Error creando categoria:', error);
    res.status(500).json({ success: false, message: 'Error creando categoria', error: error.message });
  }
});

app.put('/api/admin/article-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    await db.collection('article_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå Error actualizando categoria:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categoria', error: error.message });
  }
});

app.delete('/api/admin/article-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('article_categories').doc(id).delete();
    res.json({ success: true, message: 'Categoria eliminada' });
  } catch (error) {
    console.error('‚ùå Error eliminando categoria:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categoria', error: error.message });
  }
});

// =========================
// Palabras clave (admin/app)
// =========================

app.get('/api/articles/keywords', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('article_keywords').orderBy('name', 'asc').get();
    const keywords = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: keywords });
  } catch (error) {
    console.error('‚ùå Error obteniendo palabras clave:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo palabras clave', error: error.message });
  }
});

app.post('/api/admin/article-keywords', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name } = req.body || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const slug = slugifyText(name);
    const keywordData = {
      name,
      slug,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('article_keywords').add(keywordData);
    res.json({ success: true, data: { id: ref.id, ...keywordData } });
  } catch (error) {
    console.error('‚ùå Error creando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error creando palabra clave', error: error.message });
  }
});

app.put('/api/admin/article-keywords/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    await db.collection('article_keywords').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå Error actualizando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error actualizando palabra clave', error: error.message });
  }
});

app.delete('/api/admin/article-keywords/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('article_keywords').doc(id).delete();
    res.json({ success: true, message: 'Palabra clave eliminada' });
  } catch (error) {
    console.error('‚ùå Error eliminando palabra clave:', error);
    res.status(500).json({ success: false, message: 'Error eliminando palabra clave', error: error.message });
  }
});

// =========================
// Articulos (dashboard/app)
// =========================

// Subir imagen para art√≠culos (admin)
app.post('/api/admin/articles/upload-image', authenticateToken, isAdmin, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se envi√≥ ninguna imagen'
      });
    }

    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Storage no disponible'
      });
    }

    const fileName = `images/articles/article-${req.user.uid}-${Date.now()}-${req.file.originalname}`;
    const file = bucket.file(fileName);

    const stream = file.createWriteStream({
      metadata: {
        contentType: req.file.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('‚ùå [ARTICLES] Error subiendo imagen:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo imagen',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      try {
        await file.makePublic();
      } catch (error) {
        console.warn('‚ö†Ô∏è [ARTICLES] Error haciendo imagen p√∫blica:', error.message);
      }

      res.json({
        success: true,
        data: {
          imageUrl: `https://storage.googleapis.com/${bucket.name}/${fileName}`,
          imageStoragePath: fileName
        }
      });
    });

    stream.end(req.file.buffer);
  } catch (error) {
    console.error('‚ùå [ARTICLES] Error subiendo imagen:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo imagen',
      error: error.message
    });
  }
});

// Listar art√≠culos (admin)
app.get('/api/admin/articles', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', status } = req.query;

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('articles');
    if (status) {
      query = query.where('status', '==', status);
    }

    const snapshot = await query.orderBy('publishedAt', 'desc').get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const bannerIds = new Set();
    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.bannerId) bannerIds.add(data.bannerId);
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const bannerMap = new Map();
    if (bannerIds.size > 0) {
      const bannerSnapshot = await db.collection('banners')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(bannerIds).slice(0, 10))
        .get();
      bannerSnapshot.forEach(doc => {
        bannerMap.set(doc.id, { id: doc.id, ...doc.data() });
      });
    }
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const banner = data.bannerId ? bannerMap.get(data.bannerId) || null : null;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo art√≠culos:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo art√≠culos', error: error.message });
  }
});

app.get('/api/articles', authenticateToken, async (req, res) => {
  try {
    const { categoryId, keywordId, search = '', page = 1, limit = 20 } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('articles').where('status', '==', 'published');
    if (categoryId) query = query.where('categoryId', '==', categoryId);
    if (keywordId) query = query.where('keywordIds', 'array-contains', keywordId);

    const snapshot = await query.orderBy('publishedAt', 'desc').get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const bannerIds = new Set();
    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.bannerId) bannerIds.add(data.bannerId);
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const bannerMap = new Map();
    if (bannerIds.size > 0) {
      const bannerSnapshot = await db.collection('banners')
        .where(admin.firestore.FieldPath.documentId(), 'in', Array.from(bannerIds).slice(0, 10))
        .get();
      bannerSnapshot.forEach(doc => {
        bannerMap.set(doc.id, { id: doc.id, ...doc.data() });
      });
    }
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const banner = data.bannerId ? bannerMap.get(data.bannerId) || null : null;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo articulos:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulos', error: error.message });
  }
});

// Listar art√≠culos por categor√≠a (app)
app.get('/api/articles/category/:categoryId', authenticateToken, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const { search = '', page = 1, limit = 20 } = req.query;

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('articles')
      .where('status', '==', 'published')
      .where('categoryId', '==', categoryId)
      .orderBy('publishedAt', 'desc');

    const snapshot = await query.get();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();

    const professionalIds = new Set();
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.professionalId) professionalIds.add(data.professionalId);
    });
    const professionalsMap = await fetchProfessionalsMap(Array.from(professionalIds));

    let articles = snapshot.docs.map(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      const shareUrl = `munpa://article/${doc.id}`;
      const webUrl = `https://munpa.online/article/${doc.id}`;
      const authorProfessional = data.professionalId ? professionalsMap.get(data.professionalId) || null : null;
      return {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        shareUrl,
        webUrl
      };
    });

    if (search) {
      const searchLower = String(search).toLowerCase();
      articles = articles.filter(article =>
        article.title?.toLowerCase().includes(searchLower) ||
        article.authorProfessional?.name?.toLowerCase().includes(searchLower) ||
        article.author?.name?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = articles.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: articles.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(articles.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå [ARTICLES] Error obteniendo art√≠culos por categor√≠a:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo art√≠culos', error: error.message });
  }
});

app.get('/api/articles/:articleId', authenticateToken, async (req, res) => {
  try {
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const doc = await db.collection('articles').doc(articleId).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Articulo no encontrado' });
    }
    const data = doc.data();
    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();
    const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
    const keywords = Array.isArray(data.keywordIds)
      ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
      : [];
    const shareUrl = `munpa://article/${doc.id}`;
    const webUrl = `https://munpa.online/article/${doc.id}`;
    let banner = null;
    if (data.bannerId) {
      try {
        const bannerDoc = await db.collection('banners').doc(data.bannerId).get();
        if (bannerDoc.exists) {
          banner = { id: bannerDoc.id, ...bannerDoc.data() };
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è [ARTICLES] Error obteniendo banner:', error.message);
      }
    }
    let authorProfessional = null;
    if (data.professionalId) {
      try {
        authorProfessional = await resolveProfessionalAuthor(data.professionalId);
      } catch (error) {
        console.warn('‚ö†Ô∏è [ARTICLES] Error obteniendo profesional:', error.message);
      }
    }
    res.json({
      success: true,
      data: {
        id: doc.id,
        ...data,
        authorProfessional,
        category,
        categoryName: category?.name || null,
        keywords,
        keywordNames: keywords.map(k => k.name).filter(Boolean),
        banner,
        shareUrl,
        webUrl
      }
    });
  } catch (error) {
    console.error('‚ùå Error obteniendo articulo:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulo', error: error.message });
  }
});

app.post('/api/admin/articles', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { uid } = req.user;
    const {
      title,
      htmlContent,
      publishedAt,
      readingTimeMinutes,
      authorName,
      professionalId,
      categoryId,
      keywordIds,
      coverImageUrl,
      bannerId,
      summary,
      status = 'published'
    } = req.body || {};

    if (!title || !htmlContent || !professionalId) {
      return res.status(400).json({ success: false, message: 'title, htmlContent y professionalId son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const authorProfessional = await resolveProfessionalAuthor(professionalId);
    const author = {
      uid: authorProfessional.userId || uid,
      name: authorProfessional.name || authorName || 'Profesional'
    };
    const articleData = {
      title,
      htmlContent,
      summary: summary || '',
      coverImageUrl: coverImageUrl || '',
      categoryId: categoryId || null,
      keywordIds: Array.isArray(keywordIds) ? keywordIds : [],
      readingTimeMinutes: readingTimeMinutes || calculateReadingTimeMinutes(htmlContent),
      publishedAt: publishedAt ? new Date(publishedAt) : new Date(),
      author,
      professionalId,
      authorProfessional,
      bannerId: bannerId || null,
      status,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const ref = await db.collection('articles').add(articleData);
    res.json({ success: true, data: { id: ref.id, ...articleData } });
  } catch (error) {
    console.error('‚ùå Error creando articulo:', error);
    res.status(500).json({ success: false, message: 'Error creando articulo', error: error.message });
  }
});

app.put('/api/admin/articles/:articleId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    const {
      title,
      htmlContent,
      publishedAt,
      readingTimeMinutes,
      authorName,
      professionalId,
      categoryId,
      keywordIds,
      coverImageUrl,
      bannerId,
      summary,
      status
    } = req.body || {};

    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const updateData = { updatedAt: new Date() };
    if (title) updateData.title = title;
    if (htmlContent) {
      updateData.htmlContent = htmlContent;
      updateData.readingTimeMinutes = readingTimeMinutes || calculateReadingTimeMinutes(htmlContent);
    } else if (readingTimeMinutes) {
      updateData.readingTimeMinutes = readingTimeMinutes;
    }
    if (publishedAt) updateData.publishedAt = new Date(publishedAt);
    if (categoryId !== undefined) updateData.categoryId = categoryId;
    if (Array.isArray(keywordIds)) updateData.keywordIds = keywordIds;
    if (summary !== undefined) updateData.summary = summary;
    if (coverImageUrl !== undefined) updateData.coverImageUrl = coverImageUrl;
    if (bannerId !== undefined) updateData.bannerId = bannerId || null;
    if (status) updateData.status = status;
    if (authorName && professionalId === undefined) {
      return res.status(400).json({ success: false, message: 'Para cambiar autor se requiere professionalId' });
    }
    if (professionalId !== undefined) {
      const authorProfessional = await resolveProfessionalAuthor(professionalId);
      updateData.professionalId = professionalId;
      updateData.authorProfessional = authorProfessional;
      updateData.author = {
        uid: authorProfessional.userId || uid,
        name: authorProfessional.name || authorName || 'Profesional'
      };
    }

    await db.collection('articles').doc(articleId).update(updateData);
    res.json({ success: true, data: { id: articleId, ...updateData } });
  } catch (error) {
    console.error('‚ùå Error actualizando articulo:', error);
    res.status(500).json({ success: false, message: 'Error actualizando articulo', error: error.message });
  }
});

app.delete('/api/admin/articles/:articleId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('articles').doc(articleId).delete();
    res.json({ success: true, message: 'Articulo eliminado' });
  } catch (error) {
    console.error('‚ùå Error eliminando articulo:', error);
    res.status(500).json({ success: false, message: 'Error eliminando articulo', error: error.message });
  }
});

// =========================
// Guardar articulos (app)
// =========================

app.post('/api/articles/:articleId/save', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const articleDoc = await db.collection('articles').doc(articleId).get();
    if (!articleDoc.exists) {
      return res.status(404).json({ success: false, message: 'Articulo no encontrado' });
    }
    await db.collection('users').doc(uid)
      .collection('saved_articles')
      .doc(articleId)
      .set({
        articleId,
        savedAt: new Date()
      });
    res.json({ success: true, message: 'Articulo guardado' });
  } catch (error) {
    console.error('‚ùå Error guardando articulo:', error);
    res.status(500).json({ success: false, message: 'Error guardando articulo', error: error.message });
  }
});

app.delete('/api/articles/:articleId/save', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { articleId } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('users').doc(uid)
      .collection('saved_articles')
      .doc(articleId)
      .delete();
    res.json({ success: true, message: 'Articulo eliminado de guardados' });
  } catch (error) {
    console.error('‚ùå Error eliminando articulo guardado:', error);
    res.status(500).json({ success: false, message: 'Error eliminando articulo guardado', error: error.message });
  }
});

app.get('/api/articles/saved', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const savedSnapshot = await db.collection('users').doc(uid)
      .collection('saved_articles')
      .orderBy('savedAt', 'desc')
      .get();

    if (savedSnapshot.empty) {
      return res.json({ success: true, data: [] });
    }

    const articleIds = savedSnapshot.docs.map(doc => doc.id);
    const articlesSnapshot = await db.collection('articles')
      .where(admin.firestore.FieldPath.documentId(), 'in', articleIds.slice(0, 10))
      .get();

    const categoriesMap = await fetchCategoriesMap();
    const keywordsMap = await fetchKeywordsMap();
    const articlesMap = new Map();
    articlesSnapshot.forEach(doc => {
      const data = doc.data();
      const category = data.categoryId ? categoriesMap.get(data.categoryId) || null : null;
      const keywords = Array.isArray(data.keywordIds)
        ? data.keywordIds.map(id => keywordsMap.get(id)).filter(Boolean)
        : [];
      articlesMap.set(doc.id, { id: doc.id, ...data, category, keywords });
    });

    const savedArticles = savedSnapshot.docs.map(doc => articlesMap.get(doc.id)).filter(Boolean);
    res.json({ success: true, data: savedArticles });
  } catch (error) {
    console.error('‚ùå Error obteniendo articulos guardados:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo articulos guardados', error: error.message });
  }
});

// ============================================================================
// üì± VERSIONES DE APP (ADMIN + PUBLICO)
// ============================================================================

// Obtener configuraci√≥n de versi√≥n (p√∫blico)
app.get('/api/app/version', async (req, res) => {
  try {
    const { platform } = req.query;
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('app_versions').doc(normalizedPlatform).get();
    if (!doc.exists) {
      return res.json({
        success: true,
        data: {
          platform: normalizedPlatform,
          minVersion: null,
          latestVersion: null,
          forceUpdate: false,
          message: null
        }
      });
    }

    res.json({
      success: true,
      data: {
        platform: normalizedPlatform,
        ...doc.data()
      }
    });
  } catch (error) {
    console.error('‚ùå [APP] Error obteniendo versi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo versi√≥n',
      error: error.message
    });
  }
});

// Crear/actualizar configuraci√≥n de versi√≥n (admin)
app.post('/api/admin/app/version', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { platform, minVersion, latestVersion, forceUpdate, message } = req.body || {};
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const payload = {
      minVersion: minVersion || null,
      latestVersion: latestVersion || null,
      forceUpdate: Boolean(forceUpdate),
      message: message || null,
      updatedAt: new Date()
    };

    await db.collection('app_versions').doc(normalizedPlatform).set(payload, { merge: true });

    res.json({
      success: true,
      data: { platform: normalizedPlatform, ...payload }
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error guardando versi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error guardando versi√≥n',
      error: error.message
    });
  }
});

// Obtener configuraci√≥n de versi√≥n (admin)
app.get('/api/admin/app/version', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { platform } = req.query;
    const normalizedPlatform = String(platform || '').toLowerCase();
    if (!['ios', 'android'].includes(normalizedPlatform)) {
      return res.status(400).json({
        success: false,
        message: 'platform es requerido (ios | android)'
      });
    }

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('app_versions').doc(normalizedPlatform).get();
    if (!doc.exists) {
      return res.json({
        success: true,
        data: {
          platform: normalizedPlatform,
          minVersion: null,
          latestVersion: null,
          forceUpdate: false,
          message: null
        }
      });
    }

    res.json({
      success: true,
      data: {
        platform: normalizedPlatform,
        ...doc.data()
      }
    });
  } catch (error) {
    console.error('‚ùå [ADMIN] Error obteniendo versi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo versi√≥n',
      error: error.message
    });
  }
});

// ============================================================================
// üë©‚Äç‚öïÔ∏è SERVICIOS PROFESIONALES (PERFILES + SERVICIOS + PAQUETES)
// ============================================================================

const buildProfessionalPayload = (data) => ({
  userId: data.userId,
  name: data.name || '',
  headline: data.headline || '',
  bio: data.bio || '',
  photoUrl: data.photoUrl || '',
  specialties: Array.isArray(data.specialties) ? data.specialties : [],
  tags: Array.isArray(data.tags) ? data.tags : [],
  profileCategoryId: data.profileCategoryId || null,
  profileCategory: data.profileCategory || null,
  location: data.location || '',
  countryId: data.countryId || null,
  countryName: data.countryName || null,
  cityId: data.cityId || null,
  cityName: data.cityName || null,
  locations: Array.isArray(data.locations) ? data.locations : [],
  contactEmail: data.contactEmail || '',
  contactPhone: data.contactPhone || '',
  website: data.website || '',
  address: data.address || '',
  latitude: Number.isFinite(data.latitude) ? data.latitude : null,
  longitude: Number.isFinite(data.longitude) ? data.longitude : null,
  instagram: data.instagram || '',
  whatsappLink: data.whatsappLink || '',
  extraInfo: data.extraInfo || '',
  logoUrl: data.logoUrl || '',
  status: data.status || 'pending', // pending | active | suspended
  createdAt: new Date(),
  updatedAt: new Date()
});

// =========================
// Solicitudes de servicios profesionales (pre-registro)
// =========================

app.post('/api/professionals/requests/upload-logo', authenticateToken, upload.fields([{ name: 'logo', maxCount: 1 }, { name: 'image', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.logo?.[0] || req.files?.image?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se envi√≥ ning√∫n logo (usa logo o image)' });
    }
    const allowedTypes = ['image/png', 'image/jpeg', 'image/jpg'];
    if (!allowedTypes.includes(fileUpload.mimetype)) {
      return res.status(400).json({ success: false, message: 'El logo debe ser PNG o JPG' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-requests/logo-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: { contentType: fileUpload.mimetype }
    });

    stream.on('error', (error) => {
      console.error('‚ùå [PRO-REQ] Error subiendo logo:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('‚ö†Ô∏è [PRO-REQ] Error haciendo logo p√∫blico:', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error subiendo logo:', error);
    res.status(500).json({ success: false, message: 'Error subiendo logo', error: error.message });
  }
});

app.post('/api/professionals/requests', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const {
      businessName,
      summary,
      profileCategoryId,
      logoUrl,
      logoStoragePath,
      address,
      countryId,
      cityId,
      latitude,
      longitude,
      website,
      instagram,
      whatsappLink,
      extraInfo
    } = req.body || {};

    if (!businessName || String(businessName).trim().length < 3) {
      return res.status(400).json({ success: false, message: 'businessName es requerido' });
    }
    if (!summary || String(summary).trim().length < 10) {
      return res.status(400).json({ success: false, message: 'summary es requerido (m√≠nimo 10 caracteres)' });
    }
    if (!profileCategoryId) {
      return res.status(400).json({ success: false, message: 'profileCategoryId es requerido' });
    }
    const categoryData = await resolveProfessionalProfileCategory(profileCategoryId);
    if (!logoUrl) {
      return res.status(400).json({ success: false, message: 'logoUrl es requerido' });
    }
    if (!address) {
      return res.status(400).json({ success: false, message: 'address es requerido' });
    }
    if (!countryId || !cityId) {
      return res.status(400).json({ success: false, message: 'countryId y cityId son requeridos' });
    }
    const lat = latitude !== undefined ? parseFloat(latitude) : NaN;
    const lng = longitude !== undefined ? parseFloat(longitude) : NaN;
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return res.status(400).json({ success: false, message: 'latitude y longitude son requeridos' });
    }

    let locationData = {};
    try {
      locationData = await resolveCountryCity(countryId, cityId);
    } catch (err) {
      return res.status(400).json({ success: false, message: err.message });
    }

    const payload = {
      userId: req.user.uid,
      businessName: String(businessName).trim(),
      summary: String(summary).trim(),
      profileCategoryId,
      profileCategory: categoryData,
      logoUrl,
      logoStoragePath: logoStoragePath || null,
      address: String(address).trim(),
      countryId: locationData.countryId,
      countryName: locationData.countryName,
      cityId: locationData.cityId,
      cityName: locationData.cityName,
      latitude: lat,
      longitude: lng,
      website: website || null,
      instagram: instagram || null,
      whatsappLink: whatsappLink || null,
      extraInfo: extraInfo || null,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    const ref = await db.collection('professional_service_requests').add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error creando solicitud:', error);
    res.status(500).json({ success: false, message: 'Error creando solicitud', error: error.message });
  }
});

app.get('/api/admin/professionals/requests', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, status, search = '' } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let query = db.collection('professional_service_requests');
    if (status) {
      query = query.where('status', '==', status);
    }
    const snapshot = await query.orderBy('createdAt', 'desc').get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.businessName?.toLowerCase().includes(searchLower) ||
        item.summary?.toLowerCase().includes(searchLower)
      );
    }
    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);
    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error listando solicitudes:', error);
    res.status(500).json({ success: false, message: 'Error listando solicitudes', error: error.message });
  }
});

app.get('/api/admin/professionals/requests/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const doc = await db.collection('professional_service_requests').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error obteniendo solicitud:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo solicitud', error: error.message });
  }
});

app.put('/api/admin/professionals/requests/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const docRef = db.collection('professional_service_requests').doc(id);
    const doc = await docRef.get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }

    const updateData = { ...req.body };
    if (Object.prototype.hasOwnProperty.call(updateData, 'countryId')
      || Object.prototype.hasOwnProperty.call(updateData, 'cityId')) {
      try {
        const resolved = await resolveCountryCity(updateData.countryId, updateData.cityId);
        updateData.countryId = resolved.countryId;
        updateData.countryName = resolved.countryName;
        updateData.cityId = resolved.cityId;
        updateData.cityName = resolved.cityName;
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }
    if (Object.prototype.hasOwnProperty.call(updateData, 'profileCategoryId')) {
      if (!updateData.profileCategoryId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId inv√°lido' });
      }
      try {
        const categoryData = await resolveProfessionalProfileCategory(updateData.profileCategoryId);
        updateData.profileCategory = categoryData;
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    if (Object.prototype.hasOwnProperty.call(updateData, 'latitude')
      || Object.prototype.hasOwnProperty.call(updateData, 'longitude')) {
      const lat = updateData.latitude !== undefined ? parseFloat(updateData.latitude) : NaN;
      const lng = updateData.longitude !== undefined ? parseFloat(updateData.longitude) : NaN;
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        return res.status(400).json({ success: false, message: 'latitude y longitude inv√°lidos' });
      }
      updateData.latitude = lat;
      updateData.longitude = lng;
    }

    updateData.updatedAt = new Date();
    await docRef.update(stripUndefined(updateData));
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error actualizando solicitud (admin):', error);
    res.status(500).json({ success: false, message: 'Error actualizando solicitud', error: error.message });
  }
});

app.patch('/api/admin/professionals/requests/:id/status', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { status, notes } = req.body || {};
    if (!['pending', 'approved', 'rejected'].includes(status)) {
      return res.status(400).json({ success: false, message: 'status inv√°lido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const requestRef = db.collection('professional_service_requests').doc(id);
    const requestDoc = await requestRef.get();
    if (!requestDoc.exists) {
      return res.status(404).json({ success: false, message: 'Solicitud no encontrada' });
    }
    const requestData = requestDoc.data() || {};

    let professionalId = requestData.professionalId || null;
    let professionalPayload = null;
    if (status === 'approved') {
      if (professionalId) {
        return res.status(400).json({
          success: false,
          message: 'La solicitud ya tiene un perfil asociado',
          professionalId
        });
      }
      const missingFields = [];
      if (!requestData.userId) missingFields.push('userId');
      if (!requestData.businessName) missingFields.push('businessName');
      if (!requestData.summary) missingFields.push('summary');
      if (!requestData.profileCategoryId) missingFields.push('profileCategoryId');
      if (!requestData.logoUrl) missingFields.push('logoUrl');
      if (!requestData.address) missingFields.push('address');
      if (!requestData.countryId) missingFields.push('countryId');
      if (!requestData.cityId) missingFields.push('cityId');
      if (!Number.isFinite(parseFloat(requestData.latitude))) missingFields.push('latitude');
      if (!Number.isFinite(parseFloat(requestData.longitude))) missingFields.push('longitude');
      if (missingFields.length) {
        return res.status(400).json({
          success: false,
          message: 'Faltan campos obligatorios para aprobar',
          fields: missingFields
        });
      }

      let categoryData;
      try {
        categoryData = await resolveProfessionalProfileCategory(requestData.profileCategoryId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }

      professionalPayload = stripUndefined({
        userId: requestData.userId,
        name: requestData.businessName,
        headline: requestData.summary,
        bio: requestData.summary,
        photoUrl: requestData.logoUrl,
        profileCategoryId: requestData.profileCategoryId,
        profileCategory: categoryData,
        location: requestData.address,
        address: requestData.address,
        countryId: requestData.countryId,
        countryName: requestData.countryName,
        cityId: requestData.cityId,
        cityName: requestData.cityName,
        latitude: parseFloat(requestData.latitude),
        longitude: parseFloat(requestData.longitude),
        website: requestData.website || '',
        instagram: requestData.instagram || '',
        whatsappLink: requestData.whatsappLink || '',
        extraInfo: requestData.extraInfo || '',
        logoUrl: requestData.logoUrl,
        status: 'active',
        updatedAt: new Date()
      });

      const existingProfile = await db.collection('professionals')
        .where('userId', '==', requestData.userId)
        .limit(1)
        .get();
      if (!existingProfile.empty) {
        return res.status(400).json({
          success: false,
          message: 'El usuario ya tiene un perfil profesional',
          professionalId: existingProfile.docs[0].id
        });
      }
      const payload = buildProfessionalPayload({
        ...professionalPayload,
        status: 'active'
      });
      const createdRef = await db.collection('professionals').add(payload);
      professionalId = createdRef.id;
    }

    await requestRef.update(stripUndefined({
      status,
      professionalId: professionalId || null,
      adminNotes: notes || null,
      updatedAt: new Date()
    }));

    res.json({ success: true, data: { id, status, professionalId: professionalId || null } });
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error actualizando solicitud:', error);
    res.status(500).json({ success: false, message: 'Error actualizando solicitud', error: error.message });
  }
});

// =========================
// Categor√≠as de perfil profesional (admin/app)
// =========================

app.get('/api/professionals/profile-categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professional_profile_categories')
      .orderBy('name', 'asc')
      .get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('‚ùå [PRO] Error obteniendo categor√≠as de perfil:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categor√≠as', error: error.message });
  }
});

app.post('/api/admin/professionals/profile-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, logoUrl } = req.body || {};
    if (!name || !logoUrl) {
      return res.status(400).json({ success: false, message: 'name y logoUrl son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const categoryData = {
      name,
      description: description || '',
      logoUrl: logoUrl || '',
      slug: slugifyText(name),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professional_profile_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando categor√≠a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error creando categor√≠a', error: error.message });
  }
});

app.put('/api/admin/professionals/profile-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, logoUrl } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    if (logoUrl !== undefined) updateData.logoUrl = logoUrl || '';
    await db.collection('professional_profile_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando categor√≠a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categor√≠a', error: error.message });
  }
});

app.delete('/api/admin/professionals/profile-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('professional_profile_categories').doc(id).delete();
    res.json({ success: true, message: 'Categor√≠a eliminada' });
  } catch (error) {
    console.error('‚ùå [PRO] Error eliminando categor√≠a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categor√≠a', error: error.message });
  }
});

// Subir logo de categor√≠a de perfil (admin)
app.post('/api/admin/professionals/profile-categories/upload-logo', authenticateToken, isAdmin, upload.fields([{ name: 'image', maxCount: 1 }, { name: 'logo', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.image?.[0] || req.files?.logo?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se envi√≥ ninguna imagen' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-profile-categories/cat-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('‚ùå [PRO] Error subiendo logo categor√≠a de perfil:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('‚ö†Ô∏è [PRO] Error haciendo logo p√∫blico (perfil):', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('‚ùå [PRO] Error subiendo logo categor√≠a de perfil:', error);
    res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
  }
});

// =========================
// Categor√≠as de servicios profesionales (admin/app)
// =========================

app.get('/api/professionals/service-categories', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professional_service_categories')
      .orderBy('name', 'asc')
      .get();
    const categories = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.json({ success: true, data: categories });
  } catch (error) {
    console.error('‚ùå [PRO] Error obteniendo categor√≠as:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo categor√≠as', error: error.message });
  }
});

app.post('/api/admin/professionals/service-categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { name, description, logoUrl } = req.body || {};
    if (!name || !logoUrl) {
      return res.status(400).json({ success: false, message: 'name y logoUrl son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const categoryData = {
      name,
      description: description || '',
      logoUrl: logoUrl || '',
      slug: slugifyText(name),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professional_service_categories').add(categoryData);
    res.json({ success: true, data: { id: ref.id, ...categoryData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando categor√≠a:', error);
    res.status(500).json({ success: false, message: 'Error creando categor√≠a', error: error.message });
  }
});

app.put('/api/admin/professionals/service-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, logoUrl } = req.body || {};
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const updateData = { updatedAt: new Date() };
    if (name) {
      updateData.name = name;
      updateData.slug = slugifyText(name);
    }
    if (description !== undefined) updateData.description = description;
    if (logoUrl !== undefined) updateData.logoUrl = logoUrl || '';
    await db.collection('professional_service_categories').doc(id).update(updateData);
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando categor√≠a:', error);
    res.status(500).json({ success: false, message: 'Error actualizando categor√≠a', error: error.message });
  }
});

app.delete('/api/admin/professionals/service-categories/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    await db.collection('professional_service_categories').doc(id).delete();
    res.json({ success: true, message: 'Categor√≠a eliminada' });
  } catch (error) {
    console.error('‚ùå [PRO] Error eliminando categor√≠a:', error);
    res.status(500).json({ success: false, message: 'Error eliminando categor√≠a', error: error.message });
  }
});

// Subir logo de categor√≠a de servicio (admin)
app.post('/api/admin/professionals/service-categories/upload-logo', authenticateToken, isAdmin, upload.fields([{ name: 'image', maxCount: 1 }, { name: 'logo', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.image?.[0] || req.files?.logo?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({ success: false, message: 'No se envi√≥ ninguna imagen' });
    }
    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({ success: false, message: 'Storage no disponible' });
    }
    const fileName = `images/professional-service-categories/cat-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);
    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('‚ùå [PRO] Error subiendo logo categor√≠a:', error);
      res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('‚ö†Ô∏è [PRO] Error haciendo logo p√∫blico:', error.message);
      }
      const imageUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
      res.json({ success: true, data: { imageUrl, imageStoragePath: fileName } });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('‚ùå [PRO] Error subiendo logo categor√≠a:', error);
    res.status(500).json({ success: false, message: 'Error subiendo imagen', error: error.message });
  }
});

// Subir foto del profesional (usuario)
app.post('/api/professionals/upload-photo', authenticateToken, upload.fields([{ name: 'photo', maxCount: 1 }, { name: 'image', maxCount: 1 }]), async (req, res) => {
  try {
    const fileUpload = req.files?.photo?.[0] || req.files?.image?.[0] || null;
    if (!fileUpload) {
      return res.status(400).json({
        success: false,
        message: 'No se envi√≥ ninguna foto (usa campo photo o image)'
      });
    }

    const bucket = admin.storage().bucket();
    if (!bucket) {
      return res.status(500).json({
        success: false,
        message: 'Storage no disponible'
      });
    }

    const fileName = `images/professionals/pro-${req.user.uid}-${Date.now()}-${fileUpload.originalname}`;
    const storageFile = bucket.file(fileName);

    const stream = storageFile.createWriteStream({
      metadata: {
        contentType: fileUpload.mimetype
      }
    });

    stream.on('error', (error) => {
      console.error('‚ùå [PRO] Error subiendo foto:', error);
      res.status(500).json({
        success: false,
        message: 'Error subiendo foto',
        error: error.message
      });
    });

    stream.on('finish', async () => {
      try {
        await storageFile.makePublic();
      } catch (error) {
        console.warn('‚ö†Ô∏è [PRO] Error haciendo foto p√∫blica:', error.message);
      }

      res.json({
        success: true,
        data: {
          photoUrl: `https://storage.googleapis.com/${bucket.name}/${fileName}`,
          photoStoragePath: fileName
        }
      });
    });

    stream.end(fileUpload.buffer);
  } catch (error) {
    console.error('‚ùå [PRO] Error subiendo foto:', error);
    res.status(500).json({
      success: false,
      message: 'Error subiendo foto',
      error: error.message
    });
  }
});

// Proxy para avatar (evita CORS de ui-avatars.com)
app.get('/api/professionals/avatar', async (req, res) => {
  try {
    const { name, background = '667eea', color = 'fff', size = 120 } = req.query || {};
    if (!name) {
      return res.status(400).json({ success: false, message: 'name es requerido' });
    }
    const sizeNumber = Math.max(16, Math.min(512, parseInt(size, 10) || 120));
    const url = `https://ui-avatars.com/api/?name=${encodeURIComponent(String(name))}&background=${encodeURIComponent(String(background))}&color=${encodeURIComponent(String(color))}&size=${sizeNumber}`;
    const response = await fetch(url);
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo avatar' });
    }
    const contentType = response.headers.get('content-type') || 'image/png';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('‚ùå [PRO] Error en proxy de avatar:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo avatar', error: error.message });
  }
});

// Proxy de im√°genes para fotos de profesionales (evita CORS de Storage)
app.get('/api/professionals/photo', async (req, res) => {
  try {
    const { url } = req.query || {};
    if (!url || !isValidUrl(String(url))) {
      return res.status(400).json({ success: false, message: 'url inv√°lida' });
    }
    const response = await fetch(String(url));
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo imagen' });
    }
    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('‚ùå [PRO] Error en proxy de foto:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo imagen', error: error.message });
  }
});

// Proxy logo solicitudes profesionales (evita CORS)
app.get('/api/professionals/requests/logo', authenticateToken, async (req, res) => {
  try {
    const { url } = req.query || {};
    if (!url || !isValidUrl(String(url))) {
      return res.status(400).json({ success: false, message: 'url inv√°lida' });
    }
    const response = await fetch(String(url));
    if (!response.ok) {
      return res.status(502).json({ success: false, message: 'Error obteniendo imagen' });
    }
    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const arrayBuffer = await response.arrayBuffer();
    res.set('Content-Type', contentType);
    res.set('Cache-Control', 'public, max-age=86400');
    res.send(Buffer.from(arrayBuffer));
  } catch (error) {
    console.error('‚ùå [PRO-REQ] Error en proxy de logo:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo imagen', error: error.message });
  }
});

// Crear perfil profesional (usuario)
app.post('/api/professionals', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const existing = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (!existing.empty) {
      return res.status(400).json({ success: false, message: 'El perfil ya existe' });
    }

    const { profileCategoryId, categoryId } = req.body || {};
    const resolvedProfileCategoryId = profileCategoryId || categoryId || null;
    if (!resolvedProfileCategoryId) {
      return res.status(400).json({ success: false, message: 'profileCategoryId es requerido' });
    }
    let categoryData = null;
    try {
      categoryData = await resolveProfessionalProfileCategory(resolvedProfileCategoryId);
    } catch (err) {
      return res.status(400).json({ success: false, message: err.message });
    }

    let locationData = {};
    if (req.body?.countryId || req.body?.cityId) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = [];
    if (Array.isArray(req.body?.locations)) {
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    const payload = buildProfessionalPayload({
      ...req.body,
      profileCategoryId: resolvedProfileCategoryId,
      profileCategory: categoryData,
      ...locationData,
      locations,
      userId: req.user.uid
    });

    const ref = await db.collection('professionals').add(payload);
    res.json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando perfil:', error);
    res.status(500).json({ success: false, message: 'Error creando perfil', error: error.message });
  }
});

// Obtener perfil propio
app.get('/api/professionals/me', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('‚ùå [PRO] Error obteniendo perfil:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo perfil', error: error.message });
  }
});

// Actualizar perfil propio
app.put('/api/professionals/me', authenticateToken, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    let locationData = {};
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'locations')) {
      if (!Array.isArray(req.body.locations)) {
        return res.status(400).json({ success: false, message: 'locations debe ser un array' });
      }
      locations = [];
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    let categoryData = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'profileCategoryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'categoryId')) {
      const incomingId = req.body.profileCategoryId || req.body.categoryId;
      if (!incomingId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId inv√°lido' });
      }
      try {
        categoryData = await resolveProfessionalProfileCategory(incomingId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    const updateData = {
      ...req.body,
      ...locationData,
      updatedAt: new Date()
    };
    if (categoryData !== undefined) {
      updateData.profileCategoryId = req.body.profileCategoryId || req.body.categoryId;
      updateData.profileCategory = categoryData;
    }
    if (locations !== undefined) {
      updateData.locations = locations;
    }
    delete updateData.userId;
    delete updateData.status;

    await db.collection('professionals').doc(doc.id).update(stripUndefined(updateData));
    res.json({ success: true, data: { id: doc.id, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando perfil:', error);
    res.status(500).json({ success: false, message: 'Error actualizando perfil', error: error.message });
  }
});

// Admin: actualizar perfil profesional por ID
app.put('/api/professionals/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    const doc = await db.collection('professionals').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }

    let locationData = {};
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'countryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'cityId')) {
      try {
        locationData = await resolveCountryCity(req.body.countryId, req.body.cityId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    let locations = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'locations')) {
      if (!Array.isArray(req.body.locations)) {
        return res.status(400).json({ success: false, message: 'locations debe ser un array' });
      }
      locations = [];
      for (const loc of req.body.locations) {
        try {
          const resolved = await resolveCountryCity(loc?.countryId, loc?.cityId);
          locations.push({
            countryId: resolved.countryId,
            countryName: resolved.countryName,
            cityId: resolved.cityId,
            cityName: resolved.cityName
          });
        } catch (err) {
          return res.status(400).json({ success: false, message: err.message });
        }
      }
    }

    let categoryData = undefined;
    if (Object.prototype.hasOwnProperty.call(req.body || {}, 'profileCategoryId')
      || Object.prototype.hasOwnProperty.call(req.body || {}, 'categoryId')) {
      const incomingId = req.body.profileCategoryId || req.body.categoryId;
      if (!incomingId) {
        return res.status(400).json({ success: false, message: 'profileCategoryId inv√°lido' });
      }
      try {
        categoryData = await resolveProfessionalProfileCategory(incomingId);
      } catch (err) {
        return res.status(400).json({ success: false, message: err.message });
      }
    }

    const updateData = {
      ...req.body,
      ...locationData,
      updatedAt: new Date()
    };
    if (categoryData !== undefined) {
      updateData.profileCategoryId = req.body.profileCategoryId || req.body.categoryId;
      updateData.profileCategory = categoryData;
    }
    if (locations !== undefined) {
      updateData.locations = locations;
    }
    delete updateData.userId;

    await db.collection('professionals').doc(id).update(stripUndefined(updateData));
    res.json({ success: true, data: { id, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando perfil (admin):', error);
    res.status(500).json({ success: false, message: 'Error actualizando perfil', error: error.message });
  }
});

// Listado p√∫blico de profesionales (solo activos)
app.get('/api/professionals', authenticateToken, async (req, res) => {
  try {
    const { search = '', page = 1, limit = 20 } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const snapshot = await db.collection('professionals')
      .where('status', '==', 'active')
      .get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.name?.toLowerCase().includes(searchLower) ||
        item.headline?.toLowerCase().includes(searchLower) ||
        item.specialties?.join(' ').toLowerCase().includes(searchLower)
      );
    }
    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);
    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando profesionales:', error);
    res.status(500).json({ success: false, message: 'Error listando profesionales', error: error.message });
  }
});

// Detalle p√∫blico de profesional (admin puede ver aunque est√© pending)
app.get('/api/professionals/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let isAdminUser = false;
    try {
      const userDoc = await db.collection('users').doc(req.user.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        isAdminUser = userData.role === 'admin' || userData.isAdmin === true;
      }
    } catch (_) {
      // Si falla la verificaci√≥n, se mantiene como no admin
    }
    const doc = await db.collection('professionals').doc(id).get();
    if (!doc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    if (!isAdminUser && doc.data().status !== 'active') {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    res.json({ success: true, data: { id: doc.id, ...doc.data() } });
  } catch (error) {
    console.error('‚ùå [PRO] Error obteniendo profesional:', error);
    res.status(500).json({ success: false, message: 'Error obteniendo profesional', error: error.message });
  }
});

// Admin: aprobar/suspender
app.patch('/api/admin/professionals/:id/status', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body || {};
    if (!['pending', 'active', 'suspended'].includes(status)) {
      return res.status(400).json({ success: false, message: 'status inv√°lido' });
    }
    await db.collection('professionals').doc(id).update({ status, updatedAt: new Date() });
    res.json({ success: true, message: 'Estado actualizado', data: { id, status } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando estado:', error);
    res.status(500).json({ success: false, message: 'Error actualizando estado', error: error.message });
  }
});

// Admin: enlazar profesional con usuario del app (userId o email)
app.patch('/api/admin/professionals/:id/link-user', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { userId, email } = req.body || {};
    if (!userId && !email) {
      return res.status(400).json({ success: false, message: 'userId o email es requerido' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let resolvedUserId = userId;
    if (!resolvedUserId && email) {
      if (!auth) {
        return res.status(500).json({ success: false, message: 'Auth no disponible' });
      }
      const userRecord = await auth.getUserByEmail(String(email).trim());
      resolvedUserId = userRecord?.uid;
    }
    if (!resolvedUserId) {
      return res.status(404).json({ success: false, message: 'Usuario no encontrado' });
    }

    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }

    await db.collection('professionals').doc(id).update({
      userId: resolvedUserId,
      updatedAt: new Date()
    });
    res.json({ success: true, message: 'Perfil enlazado', data: { id, userId: resolvedUserId } });
  } catch (error) {
    console.error('‚ùå [PRO] Error enlazando usuario:', error);
    res.status(500).json({ success: false, message: 'Error enlazando usuario', error: error.message });
  }
});

// Admin: listar profesionales
app.get('/api/admin/professionals', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', status } = req.query;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }

    let query = db.collection('professionals');
    if (status) {
      query = query.where('status', '==', status);
    }

    const snapshot = await query.orderBy('createdAt', 'desc').get();
    let items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    if (search) {
      const searchLower = String(search).toLowerCase();
      items = items.filter(item =>
        item.name?.toLowerCase().includes(searchLower) ||
        item.headline?.toLowerCase().includes(searchLower) ||
        item.contactEmail?.toLowerCase().includes(searchLower)
      );
    }

    const pageNumber = Math.max(parseInt(page), 1);
    const limitNumber = Math.max(parseInt(limit), 1);
    const startIndex = (pageNumber - 1) * limitNumber;
    const paginated = items.slice(startIndex, startIndex + limitNumber);

    res.json({
      success: true,
      data: paginated,
      pagination: {
        total: items.length,
        page: pageNumber,
        limit: limitNumber,
        totalPages: Math.ceil(items.length / limitNumber)
      }
    });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando profesionales (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando profesionales', error: error.message });
  }
});

// =========================
// Servicios (por profesional)
// =========================

// Servicios p√∫blicos por profesional (admin puede ver todos)
app.get('/api/professionals/:id/services', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    let isAdminUser = false;
    try {
      const userDoc = await db.collection('users').doc(req.user.uid).get();
      if (userDoc.exists) {
        const userData = userDoc.data();
        isAdminUser = userData.role === 'admin' || userData.isAdmin === true;
      }
    } catch (_) {
      // Mantener no admin si falla
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    if (!isAdminUser && proDoc.data().status !== 'active') {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    let servicesQuery = db.collection('professionals').doc(id)
      .collection('services')
      .orderBy('createdAt', 'desc');
    if (!isAdminUser) {
      servicesQuery = servicesQuery.where('isActive', '==', true);
    }
    const servicesSnapshot = await servicesQuery.get();
    const services = servicesSnapshot.docs.map(s => ({ id: s.id, ...s.data() }));
    res.json({ success: true, data: services });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando servicios p√∫blicos:', error);
    res.status(500).json({ success: false, message: 'Error listando servicios', error: error.message });
  }
});

// Admin: crear servicio para un profesional espec√≠fico
app.post('/api/professionals/:id/services', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, price, durationMinutes, type, currency, isActive, mediaUrl, categoryId } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const now = new Date();
    const payload = {
      title,
      description: description || null,
      price,
      durationMinutes: durationMinutes || null,
      type: type || 'consulta',
      currency: currency || 'USD',
      isActive: isActive !== undefined ? isActive : true,
      mediaUrl: mediaUrl || null,
      categoryId: categoryId || null,
      createdAt: now,
      updatedAt: now
    };
    const ref = await db.collection('professionals').doc(id)
      .collection('services')
      .add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando servicio (admin):', error);
    res.status(500).json({ success: false, message: 'Error creando servicio', error: error.message });
  }
});

app.get('/api/professionals/me/services', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const servicesSnapshot = await db.collection('professionals').doc(doc.id)
      .collection('services')
      .orderBy('createdAt', 'desc')
      .get();
    const services = servicesSnapshot.docs.map(s => ({ id: s.id, ...s.data() }));
    res.json({ success: true, data: services });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando servicios:', error);
    res.status(500).json({ success: false, message: 'Error listando servicios', error: error.message });
  }
});

app.post('/api/professionals/me/services', authenticateToken, async (req, res) => {
  try {
    const { title, description, price, durationMinutes, type, currency, isActive, mediaUrl, categoryId } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    if (categoryId) {
      const categoryDoc = await db.collection('professional_service_categories').doc(categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({ success: false, message: 'categoryId inv√°lido' });
      }
    }

    const serviceData = {
      title,
      description: description || '',
      price,
      currency: currency || 'USD',
      type: type || 'consulta', // consulta | asesoria | producto | otro
      categoryId: categoryId || null,
      durationMinutes: durationMinutes || null,
      isActive: isActive !== undefined ? Boolean(isActive) : true,
      mediaUrl: mediaUrl || null,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professionals').doc(doc.id)
      .collection('services')
      .add(serviceData);
    res.json({ success: true, data: { id: ref.id, ...serviceData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando servicio:', error);
    res.status(500).json({ success: false, message: 'Error creando servicio', error: error.message });
  }
});

app.put('/api/professionals/me/services/:serviceId', authenticateToken, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const updateData = { ...req.body, updatedAt: new Date() };
    if (updateData.isActive !== undefined) {
      updateData.isActive = Boolean(updateData.isActive);
    }
    if (updateData.categoryId !== undefined && updateData.categoryId !== null) {
      const categoryDoc = await db.collection('professional_service_categories').doc(updateData.categoryId).get();
      if (!categoryDoc.exists) {
        return res.status(400).json({ success: false, message: 'categoryId inv√°lido' });
      }
    }
    await db.collection('professionals').doc(doc.id)
      .collection('services').doc(serviceId)
      .update(updateData);
    res.json({ success: true, data: { id: serviceId, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando servicio:', error);
    res.status(500).json({ success: false, message: 'Error actualizando servicio', error: error.message });
  }
});

app.delete('/api/professionals/me/services/:serviceId', authenticateToken, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    await db.collection('professionals').doc(doc.id)
      .collection('services').doc(serviceId)
      .delete();
    res.json({ success: true, message: 'Servicio eliminado' });
  } catch (error) {
    console.error('‚ùå [PRO] Error eliminando servicio:', error);
    res.status(500).json({ success: false, message: 'Error eliminando servicio', error: error.message });
  }
});

// =========================
// Paquetes (por profesional)
// =========================

app.get('/api/professionals/me/packages', authenticateToken, async (req, res) => {
  try {
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const packagesSnapshot = await db.collection('professionals').doc(doc.id)
      .collection('packages')
      .orderBy('createdAt', 'desc')
      .get();
    const packages = packagesSnapshot.docs.map(p => ({ id: p.id, ...p.data() }));
    res.json({ success: true, data: packages });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando paquetes:', error);
    res.status(500).json({ success: false, message: 'Error listando paquetes', error: error.message });
  }
});

// Admin: listar paquetes de un profesional por ID
app.get('/api/professionals/:id/packages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const profDoc = await db.collection('professionals').doc(id).get();
    if (!profDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const packagesSnapshot = await db.collection('professionals').doc(id)
      .collection('packages')
      .orderBy('createdAt', 'desc')
      .get();
    const packages = packagesSnapshot.docs.map(p => ({ id: p.id, ...p.data() }));
    res.json({ success: true, data: packages });
  } catch (error) {
    console.error('‚ùå [PRO] Error listando paquetes (admin):', error);
    res.status(500).json({ success: false, message: 'Error listando paquetes', error: error.message });
  }
});

// Admin: crear paquete para un profesional espec√≠fico
app.post('/api/professionals/:id/packages', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, price, currency, isActive, items, validDays } = req.body || {};
    if (!title || price === undefined) {
      return res.status(400).json({ success: false, message: 'title y price son requeridos' });
    }
    if (!db) {
      return res.status(500).json({ success: false, message: 'Base de datos no disponible' });
    }
    const proDoc = await db.collection('professionals').doc(id).get();
    if (!proDoc.exists) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const now = new Date();
    const payload = {
      title,
      description: description || null,
      price,
      currency: currency || 'USD',
      isActive: isActive !== undefined ? isActive : true,
      items: Array.isArray(items) ? items : [],
      validDays: validDays || null,
      createdAt: now,
      updatedAt: now
    };
    const ref = await db.collection('professionals').doc(id)
      .collection('packages')
      .add(payload);
    res.status(201).json({ success: true, data: { id: ref.id, ...payload } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando paquete (admin):', error);
    res.status(500).json({ success: false, message: 'Error creando paquete', error: error.message });
  }
});

app.post('/api/professionals/me/packages', authenticateToken, async (req, res) => {
  try {
    const { title, description, price, sessionCount } = req.body || {};
    if (!title || price === undefined || !sessionCount) {
      return res.status(400).json({ success: false, message: 'title, price y sessionCount son requeridos' });
    }
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const packageData = {
      title,
      description: description || '',
      price,
      sessionCount,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const ref = await db.collection('professionals').doc(doc.id)
      .collection('packages')
      .add(packageData);
    res.json({ success: true, data: { id: ref.id, ...packageData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error creando paquete:', error);
    res.status(500).json({ success: false, message: 'Error creando paquete', error: error.message });
  }
});

app.put('/api/professionals/me/packages/:packageId', authenticateToken, async (req, res) => {
  try {
    const { packageId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    const updateData = { ...req.body, updatedAt: new Date() };
    await db.collection('professionals').doc(doc.id)
      .collection('packages').doc(packageId)
      .update(updateData);
    res.json({ success: true, data: { id: packageId, ...updateData } });
  } catch (error) {
    console.error('‚ùå [PRO] Error actualizando paquete:', error);
    res.status(500).json({ success: false, message: 'Error actualizando paquete', error: error.message });
  }
});

app.delete('/api/professionals/me/packages/:packageId', authenticateToken, async (req, res) => {
  try {
    const { packageId } = req.params;
    const snapshot = await db.collection('professionals')
      .where('userId', '==', req.user.uid)
      .limit(1)
      .get();
    if (snapshot.empty) {
      return res.status(404).json({ success: false, message: 'Perfil no encontrado' });
    }
    const doc = snapshot.docs[0];
    await db.collection('professionals').doc(doc.id)
      .collection('packages').doc(packageId)
      .delete();
    res.json({ success: true, message: 'Paquete eliminado' });
  } catch (error) {
    console.error('‚ùå [PRO] Error eliminando paquete:', error);
    res.status(500).json({ success: false, message: 'Error eliminando paquete', error: error.message });
  }
});


// ============================================================================
// üìä HITOS DEL DESARROLLO INFANTIL
// ============================================================================

// ==========================================
// ADMIN - Gesti√≥n de Categor√≠as de Hitos
// ==========================================

// Crear categor√≠a (Admin)
app.post('/api/admin/milestones/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      name,
      description,
      icon,
      color,
      order = 999,
      isActive = true
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validaciones
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: 'El nombre de la categor√≠a es requerido'
      });
    }

    // Verificar si ya existe una categor√≠a con ese nombre
    const existingCategory = await db.collection('milestoneCategories')
      .where('name', '==', name.trim())
      .get();

    if (!existingCategory.empty) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una categor√≠a con ese nombre'
      });
    }

    const categoryData = {
      name: name.trim(),
      description: description?.trim() || '',
      icon: icon || 'üìã',
      color: color || '#2196F3',
      order: parseInt(order) || 999,
      isActive: isActive !== undefined ? isActive : true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    const docRef = await db.collection('milestoneCategories').add(categoryData);

    console.log(`‚úÖ [MILESTONES] Categor√≠a creada: ${docRef.id}`);

    res.status(201).json({
      success: true,
      message: 'Categor√≠a creada exitosamente',
      data: {
        id: docRef.id,
        ...categoryData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error creando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando categor√≠a',
      error: error.message
    });
  }
});

// Listar categor√≠as (Admin)
app.get('/api/admin/milestones/categories', authenticateToken, isAdmin, async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('milestoneCategories')
      .orderBy('order', 'asc')
      .orderBy('name', 'asc')
      .get();

    const categories = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      categories.push({
        id: doc.id,
        name: data.name,
        description: data.description || '',
        icon: data.icon || 'üìã',
        color: data.color || '#2196F3',
        order: data.order || 999,
        isActive: data.isActive !== undefined ? data.isActive : true,
        createdAt: data.createdAt?.toDate()?.toISOString() || null,
        updatedAt: data.updatedAt?.toDate()?.toISOString() || null
      });
    });

    res.json({
      success: true,
      data: categories,
      total: categories.length
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Obtener detalle de categor√≠a (Admin)
app.get('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    const data = doc.data();
    const category = {
      id: doc.id,
      name: data.name,
      description: data.description || '',
      icon: data.icon || 'üìã',
      color: data.color || '#2196F3',
      order: data.order || 999,
      isActive: data.isActive !== undefined ? data.isActive : true,
      createdAt: data.createdAt?.toDate()?.toISOString() || null,
      updatedAt: data.updatedAt?.toDate()?.toISOString() || null
    };

    res.json({
      success: true,
      data: category
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠a',
      error: error.message
    });
  }
});

// Actualizar categor√≠a (Admin)
app.put('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;
    const {
      name,
      description,
      icon,
      color,
      order,
      isActive
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    // Si se est√° cambiando el nombre, verificar que no exista otra con ese nombre
    if (name && name.trim() !== doc.data().name) {
      const existingCategory = await db.collection('milestoneCategories')
        .where('name', '==', name.trim())
        .get();

      if (!existingCategory.empty) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una categor√≠a con ese nombre'
        });
      }
    }

    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (name !== undefined) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description.trim();
    if (icon !== undefined) updateData.icon = icon;
    if (color !== undefined) updateData.color = color;
    if (order !== undefined) updateData.order = parseInt(order);
    if (isActive !== undefined) updateData.isActive = isActive;

    await db.collection('milestoneCategories').doc(categoryId).update(updateData);

    console.log(`‚úÖ [MILESTONES] Categor√≠a actualizada: ${categoryId}`);

    // Obtener datos actualizados
    const updatedDoc = await db.collection('milestoneCategories').doc(categoryId).get();
    const updatedData = updatedDoc.data();

    res.json({
      success: true,
      message: 'Categor√≠a actualizada exitosamente',
      data: {
        id: categoryId,
        name: updatedData.name,
        description: updatedData.description || '',
        icon: updatedData.icon || 'üìã',
        color: updatedData.color || '#2196F3',
        order: updatedData.order || 999,
        isActive: updatedData.isActive !== undefined ? updatedData.isActive : true,
        createdAt: updatedData.createdAt?.toDate()?.toISOString() || null,
        updatedAt: updatedData.updatedAt?.toDate()?.toISOString() || null
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error actualizando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando categor√≠a',
      error: error.message
    });
  }
});

// Eliminar categor√≠a (Admin)
app.delete('/api/admin/milestones/categories/:categoryId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { categoryId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const doc = await db.collection('milestoneCategories').doc(categoryId).get();

    if (!doc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Categor√≠a no encontrada'
      });
    }

    // Verificar si hay hitos usando esta categor√≠a
    const categoryName = doc.data().name;
    const milestonesUsingCategory = await db.collection('milestones')
      .where('category', '==', categoryName)
      .limit(1)
      .get();

    if (!milestonesUsingCategory.empty) {
      return res.status(400).json({
        success: false,
        message: 'No se puede eliminar la categor√≠a porque tiene hitos asociados'
      });
    }

    await db.collection('milestoneCategories').doc(categoryId).delete();

    console.log(`‚úÖ [MILESTONES] Categor√≠a eliminada: ${categoryId}`);

    res.json({
      success: true,
      message: 'Categor√≠a eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error eliminando categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando categor√≠a',
      error: error.message
    });
  }
});

// ==========================================
// ADMIN - Gesti√≥n de Hitos
// ==========================================

// Carga masiva de hitos (Admin) - Endpoint temporal
app.post('/api/admin/milestones/bulk', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestones_0_12_months } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    if (!milestones_0_12_months || !Array.isArray(milestones_0_12_months)) {
      return res.status(400).json({
        success: false,
        message: 'Datos de hitos inv√°lidos'
      });
    }

    // Mapeo de categor√≠as del JSON a nombres de categor√≠as en BD
    const categoryMapping = {
      'social': 'Social y Emocional',
      'cognitivo': 'Cognitivo',
      'motriz': 'Motor Grueso',
      'comunicacion': 'Lenguaje y Comunicaci√≥n'
    };

    const createdMilestones = [];
    const errors = [];

    // Procesar cada mes
    for (const monthData of milestones_0_12_months) {
      const { month, social, cognitivo, motriz, comunicacion } = monthData;
      
      const allCategories = {
        social,
        cognitivo,
        motriz,
        comunicacion
      };

      // Por cada categor√≠a en el mes
      for (const [categoryKey, items] of Object.entries(allCategories)) {
        if (!items || !Array.isArray(items)) continue;

        const categoryName = categoryMapping[categoryKey];
        if (!categoryName) {
          console.warn(`‚ö†Ô∏è Categor√≠a no mapeada: ${categoryKey}`);
          continue;
        }

        // Por cada hito en la categor√≠a
        for (let i = 0; i < items.length; i++) {
          const title = items[i];
          
          try {
            const milestoneData = {
              title: title.trim(),
              description: `Hito del desarrollo para el mes ${month}`,
              category: categoryName,
              ageRangeMonths: {
                min: month,
                max: month
              },
              order: i + 1,
              isActive: true,
              tips: '',
              videoUrl: null,
              imageUrl: null,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              createdBy: req.user.uid
            };

            const docRef = await db.collection('milestones').add(milestoneData);
            
            createdMilestones.push({
              id: docRef.id,
              month,
              category: categoryName,
              title
            });

            console.log(`‚úÖ Hito creado: ${title} (Mes ${month}, ${categoryName})`);

          } catch (error) {
            console.error(`‚ùå Error creando hito "${title}":`, error);
            errors.push({
              title,
              month,
              category: categoryName,
              error: error.message
            });
          }
        }
      }
    }

    res.status(201).json({
      success: true,
      message: `Carga masiva completada. ${createdMilestones.length} hitos creados`,
      data: {
        created: createdMilestones.length,
        errors: errors.length,
        createdMilestones: createdMilestones.slice(0, 10), // Primeros 10 para no saturar respuesta
        errorDetails: errors
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error en carga masiva:', error);
    res.status(500).json({
      success: false,
      message: 'Error en carga masiva',
      error: error.message
    });
  }
});

// Crear hito (Admin)
app.post('/api/admin/milestones', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      title,
      description,
      categoryId,
      ageMonthsMin,
      ageMonthsMax,
      order = 999,
      tips,
      videoUrl,
      imageUrl,
      isActive = true
    } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Validaciones
    if (!title || title.trim().length < 3) {
      return res.status(400).json({
        success: false,
        message: 'El t√≠tulo debe tener al menos 3 caracteres'
      });
    }

    if (!categoryId) {
      return res.status(400).json({
        success: false,
        message: 'El ID de categor√≠a es requerido'
      });
    }

    // Verificar que la categor√≠a existe
    const categoryDoc = await db.collection('milestoneCategories').doc(categoryId).get();
    if (!categoryDoc.exists) {
      return res.status(400).json({
        success: false,
        message: 'La categor√≠a especificada no existe'
      });
    }

    if (ageMonthsMin === undefined || ageMonthsMax === undefined) {
      return res.status(400).json({
        success: false,
        message: 'El rango de edad es requerido (ageMonthsMin y ageMonthsMax)'
      });
    }

    const milestoneData = {
      title: title.trim(),
      description: description?.trim() || '',
      categoryId,
      ageMonthsMin: parseInt(ageMonthsMin),
      ageMonthsMax: parseInt(ageMonthsMax),
      order: parseInt(order),
      tips: tips?.trim() || '',
      videoUrl: videoUrl || null,
      imageUrl: imageUrl || null,
      isActive: Boolean(isActive),
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: req.user.uid
    };

    const milestoneRef = await db.collection('milestones').add(milestoneData);

    console.log(`‚úÖ [MILESTONES] Hito creado: ${milestoneRef.id}`);

    res.json({
      success: true,
      message: 'Hito creado exitosamente',
      data: {
        id: milestoneRef.id,
        ...milestoneData
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error creando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error creando hito',
      error: error.message
    });
  }
});

// Listar hitos (Admin)
app.get('/api/admin/milestones', authenticateToken, isAdmin, async (req, res) => {
  try {
    const {
      category,
      ageMin,
      ageMax,
      includeInactive = 'false',
      page = 1,
      limit = 100
    } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    let query = db.collection('milestones');

    // Filtros
    if (category) {
      query = query.where('categoryId', '==', category);
    }

    if (includeInactive !== 'true') {
      query = query.where('isActive', '==', true);
    }

    // Ordenar solo por ageMonthsMin para evitar √≠ndices compuestos complejos
    query = query.orderBy('ageMonthsMin', 'asc');

    const snapshot = await query.get();
    let milestones = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title,
        description: data.description || '',
        categoryId: data.categoryId,
        ageMonthsMin: data.ageMonthsMin,
        ageMonthsMax: data.ageMonthsMax,
        order: data.order || 999,
        isActive: data.isActive !== undefined ? data.isActive : true,
        tips: data.tips || '',
        videoUrl: data.videoUrl || null,
        imageUrl: data.imageUrl || null,
        createdAt: data.createdAt?.toDate()?.toISOString() || null,
        updatedAt: data.updatedAt?.toDate()?.toISOString() || null,
        createdBy: data.createdBy || null
      };
    });

    // Ordenar en memoria por categoryId y order
    milestones.sort((a, b) => {
      if (a.ageMonthsMin !== b.ageMonthsMin) {
        return a.ageMonthsMin - b.ageMonthsMin;
      }
      if (a.categoryId !== b.categoryId) {
        return a.categoryId.localeCompare(b.categoryId);
      }
      return a.order - b.order;
    });

    // Filtrar por rango de edad si se especifica
    if (ageMin !== undefined || ageMax !== undefined) {
      milestones = milestones.filter(m => {
        const matchesMin = ageMin === undefined || m.ageMonthsMax >= parseInt(ageMin);
        const matchesMax = ageMax === undefined || m.ageMonthsMin <= parseInt(ageMax);
        return matchesMin && matchesMax;
      });
    }

    // Paginaci√≥n
    const total = milestones.length;
    const startIndex = (parseInt(page) - 1) * parseInt(limit);
    const endIndex = startIndex + parseInt(limit);
    const paginatedMilestones = milestones.slice(startIndex, endIndex);

    res.json({
      success: true,
      data: paginatedMilestones,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / parseInt(limit))
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo hitos:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Obtener hito espec√≠fico (Admin)
app.get('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    res.json({
      success: true,
      data: {
        id: milestoneDoc.id,
        ...milestoneDoc.data()
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hito',
      error: error.message
    });
  }
});

// Actualizar hito (Admin)
app.put('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;
    const updateData = { ...req.body, updatedAt: new Date() };

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    // Validar categor√≠a si se actualiza
    if (updateData.category) {
      const validCategories = ['social', 'motor-grueso', 'motor-fino', 'lenguaje', 'cognitivo'];
      if (!validCategories.includes(updateData.category)) {
        return res.status(400).json({
          success: false,
          message: `Categor√≠a inv√°lida. Debe ser: ${validCategories.join(', ')}`
        });
      }
    }

    await db.collection('milestones').doc(milestoneId).update(updateData);

    const updatedDoc = await db.collection('milestones').doc(milestoneId).get();

    console.log(`‚úÖ [MILESTONES] Hito actualizado: ${milestoneId}`);

    res.json({
      success: true,
      message: 'Hito actualizado exitosamente',
      data: {
        id: milestoneId,
        ...updatedDoc.data()
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error actualizando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error actualizando hito',
      error: error.message
    });
  }
});

// Eliminar hito (Admin)
app.delete('/api/admin/milestones/:milestoneId', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    await db.collection('milestones').doc(milestoneId).delete();

    console.log(`‚úÖ [MILESTONES] Hito eliminado: ${milestoneId}`);

    res.json({
      success: true,
      message: 'Hito eliminado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error eliminando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando hito',
      error: error.message
    });
  }
});

// ==========================================
// APP - Hitos para Usuarios
// ==========================================

// Obtener categor√≠as de hitos (p√∫blico)
app.get('/api/milestones/categories', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    const snapshot = await db.collection('milestoneCategories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .orderBy('name', 'asc')
      .get();

    const categories = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      categories.push({
        id: doc.id,
        name: data.name,
        description: data.description || '',
        icon: data.icon || 'üìã',
        color: data.color || '#2196F3',
        order: data.order || 999
      });
    });

    res.json({
      success: true,
      data: categories,
      total: categories.length
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo categor√≠as:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo categor√≠as',
      error: error.message
    });
  }
});

// Obtener hitos por edad del ni√±o
app.get('/api/children/:childId/milestones', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { category, ageBuffer = 3 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el ni√±o pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Ni√±o no encontrado'
      });
    }

    const childData = childDoc.data();

    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para acceder a este ni√±o'
      });
    }

    // Calcular edad del ni√±o en meses
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    // Obtener hitos
    let query = db.collection('milestones').where('isActive', '==', true);

    if (category) {
      query = query.where('categoryId', '==', category);
    }

    const milestonesSnapshot = await query.get();
    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por rango de edad con buffer
    const minAge = Math.max(0, ageMonths - parseInt(ageBuffer));
    const maxAge = ageMonths + parseInt(ageBuffer);

    console.log(`[MILESTONES] Filtro edad - ageMonths: ${ageMonths}, buffer: ${ageBuffer}, minAge: ${minAge}, maxAge: ${maxAge}`);

    milestones = milestones.filter(m => {
      return m.ageMonthsMax >= minAge && m.ageMonthsMin <= maxAge;
    });

    console.log(`[MILESTONES] Hitos filtrados por edad: ${milestones.length}`);

    // Ordenar
    milestones.sort((a, b) => {
      if (a.ageMonthsMin !== b.ageMonthsMin) {
        return a.ageMonthsMin - b.ageMonthsMin;
      }
      if (a.categoryId !== b.categoryId) {
        return a.categoryId.localeCompare(b.categoryId);
      }
      return a.order - b.order;
    });

    // Obtener progreso del ni√±o
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .get();

    const progressMap = {};
    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = {
        completed: data.completed,
        completedAt: data.completedAt,
        notes: data.notes || null
      };
    });

    // Agregar estado de completado a cada hito
    const milestonesWithProgress = milestones.map(m => ({
      ...m,
      completed: progressMap[m.id]?.completed || false,
      completedAt: progressMap[m.id]?.completedAt || null,
      notes: progressMap[m.id]?.notes || null
    }));

    // Calcular estad√≠sticas
    const completedCount = milestonesWithProgress.filter(m => m.completed).length;

    res.json({
      success: true,
      data: milestonesWithProgress,
      metadata: {
        childAge: {
          months: ageMonths,
          displayAge: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        ageRange: {
          min: minAge,
          max: maxAge
        },
        summary: {
          total: milestonesWithProgress.length,
          completed: completedCount,
          completionRate: milestonesWithProgress.length > 0 
            ? Math.round((completedCount / milestonesWithProgress.length) * 100)
            : 0
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo hitos del ni√±o:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Obtener hitos agrupados por categor√≠a
app.get('/api/children/:childId/milestones/by-category', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;
    const { ageBuffer = 3 } = req.query;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar que el ni√±o pertenece al usuario
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Ni√±o no encontrado'
      });
    }

    const childData = childDoc.data();

    if (childData.parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Calcular edad
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    // Obtener hitos
    const milestonesSnapshot = await db.collection('milestones')
      .where('isActive', '==', true)
      .get();

    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar por edad
    const minAge = Math.max(0, ageMonths - parseInt(ageBuffer));
    const maxAge = ageMonths + parseInt(ageBuffer);

    milestones = milestones.filter(m => {
      return m.ageMonthsMax >= minAge && m.ageMonthsMin <= maxAge;
    });

    // Obtener progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .get();

    const progressMap = {};
    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = {
        completed: data.completed,
        completedAt: data.completedAt,
        notes: data.notes || null
      };
    });

    // Obtener categor√≠as de la BD
    const categoriesSnapshot = await db.collection('milestoneCategories')
      .where('isActive', '==', true)
      .orderBy('order', 'asc')
      .get();

    const categoryInfo = {};
    categoriesSnapshot.forEach(doc => {
      const data = doc.data();
      categoryInfo[doc.id] = {
        id: doc.id,
        name: data.name,
        icon: data.icon || 'üìù',
        color: data.color || '#757575'
      };
    });

    // Agrupar por categor√≠a
    const categorized = {};
    
    milestones.forEach(m => {
      const catId = m.categoryId;
      if (!catId) return; // Ignorar hitos sin categor√≠a
      
      if (!categorized[catId]) {
        categorized[catId] = [];
      }
      categorized[catId].push({
        ...m,
        completed: progressMap[m.id]?.completed || false,
        completedAt: progressMap[m.id]?.completedAt || null,
        notes: progressMap[m.id]?.notes || null
      });
    });

    // Crear array de categor√≠as con estad√≠sticas
    const categories = Object.keys(categorized).map(catId => {
      const items = categorized[catId];
      const completedCount = items.filter(i => i.completed).length;
      const catInfo = categoryInfo[catId] || { name: 'Sin categor√≠a', icon: 'üìù', color: '#757575' };
      
      return {
        categoryId: catId,
        categoryName: catInfo.name,
        icon: catInfo.icon,
        color: catInfo.color,
        milestones: items.sort((a, b) => a.order - b.order),
        stats: {
          total: items.length,
          completed: completedCount,
          completionRate: items.length > 0 
            ? Math.round((completedCount / items.length) * 100)
            : 0
        }
      };
    });

    // Calcular estad√≠sticas generales
    const totalMilestones = milestones.length;
    const totalCompleted = Object.values(progressMap).filter(p => p.completed).length;

    res.json({
      success: true,
      data: {
        childAge: {
          months: ageMonths,
          displayAge: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        categories,
        overall: {
          total: totalMilestones,
          completed: totalCompleted,
          completionRate: totalMilestones > 0 
            ? Math.round((totalCompleted / totalMilestones) * 100)
            : 0
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error obteniendo hitos por categor√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo hitos',
      error: error.message
    });
  }
});

// Marcar hito como completado
app.post('/api/children/:childId/milestones/:milestoneId/complete', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;
    const { notes = '' } = req.body;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Verificar que el hito existe
    const milestoneDoc = await db.collection('milestones').doc(milestoneId).get();

    if (!milestoneDoc.exists) {
      return res.status(404).json({
        success: false,
        message: 'Hito no encontrado'
      });
    }

    // Buscar si ya existe un registro de progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('milestoneId', '==', milestoneId)
      .limit(1)
      .get();

    const progressData = {
      childId,
      milestoneId,
      completed: true,
      completedAt: new Date(),
      completedBy: uid,
      notes: notes.trim(),
      updatedAt: new Date()
    };

    if (progressSnapshot.empty) {
      // Crear nuevo registro
      progressData.createdAt = new Date();
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .add(progressData);
    } else {
      // Actualizar existente
      const doc = progressSnapshot.docs[0];
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .doc(doc.id)
        .update(progressData);
    }

    console.log(`‚úÖ [MILESTONES] Hito ${milestoneId} completado para ni√±o ${childId}`);

    res.json({
      success: true,
      message: 'Hito marcado como completado',
      data: {
        milestoneId,
        completed: true,
        completedAt: progressData.completedAt,
        notes: progressData.notes
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error marcando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error marcando hito',
      error: error.message
    });
  }
});

// Desmarcar hito
app.delete('/api/children/:childId/milestones/:milestoneId/complete', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId, milestoneId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    // Buscar y eliminar el registro de progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('milestoneId', '==', milestoneId)
      .limit(1)
      .get();

    if (!progressSnapshot.empty) {
      const doc = progressSnapshot.docs[0];
      await db.collection('children').doc(childId)
        .collection('milestoneProgress')
        .doc(doc.id)
        .delete();
    }

    console.log(`‚úÖ [MILESTONES] Hito ${milestoneId} desmarcado para ni√±o ${childId}`);

    res.json({
      success: true,
      message: 'Hito desmarcado'
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error desmarcando hito:', error);
    res.status(500).json({
      success: false,
      message: 'Error desmarcando hito',
      error: error.message
    });
  }
});

// Reporte de progreso completo
app.get('/api/children/:childId/milestones/progress-report', authenticateToken, async (req, res) => {
  try {
    const { uid } = req.user;
    const { childId } = req.params;

    if (!db) {
      return res.status(500).json({
        success: false,
        message: 'Base de datos no disponible'
      });
    }

    // Verificar permisos
    const childDoc = await db.collection('children').doc(childId).get();

    if (!childDoc.exists || childDoc.data().parentId !== uid) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso'
      });
    }

    const childData = childDoc.data();

    // Calcular edad
    const birthDate = childData.birthDate.toDate();
    const now = new Date();
    const ageMonths = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24 * 30.44));

    // Obtener todos los hitos activos
    const milestonesSnapshot = await db.collection('milestones')
      .where('isActive', '==', true)
      .get();

    let milestones = milestonesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Filtrar relevantes para la edad (con buffer amplio)
    milestones = milestones.filter(m => {
      return m.ageMonthsMax >= (ageMonths - 6) && m.ageMonthsMin <= (ageMonths + 12);
    });

    // Obtener progreso
    const progressSnapshot = await db.collection('children').doc(childId)
      .collection('milestoneProgress')
      .where('completed', '==', true)
      .get();

    const progressMap = {};
    const completedMilestones = [];

    progressSnapshot.docs.forEach(doc => {
      const data = doc.data();
      progressMap[data.milestoneId] = data;
      
      const milestone = milestones.find(m => m.id === data.milestoneId);
      if (milestone) {
        completedMilestones.push({
          milestoneId: data.milestoneId,
          title: milestone.title,
          categoryId: milestone.categoryId,
          completedAt: data.completedAt,
          ageAtCompletion: Math.floor((data.completedAt.toDate() - birthDate) / (1000 * 60 * 60 * 24 * 30.44))
        });
      }
    });

    // Ordenar por fecha de completado (m√°s reciente primero)
    completedMilestones.sort((a, b) => b.completedAt.toDate() - a.completedAt.toDate());

    // Agrupar por categor√≠a
    const categoryInfo = {
      'social': { name: 'Social y Emocional', icon: 'üë•', color: '#4CAF50' },
      'motor-grueso': { name: 'Motor Grueso', icon: 'üèÉ', color: '#2196F3' },
      'motor-fino': { name: 'Motor Fino', icon: '‚úã', color: '#FF9800' },
      'lenguaje': { name: 'Lenguaje y Comunicaci√≥n', icon: 'üí¨', color: '#9C27B0' },
      'cognitivo': { name: 'Cognitivo', icon: 'üß†', color: '#F44336' }
    };

    const progressByCategory = Object.keys(categoryInfo).map(cat => {
      const categoryMilestones = milestones.filter(m => m.category === cat);
      const completed = categoryMilestones.filter(m => progressMap[m.id]?.completed).length;
      
      return {
        category: cat,
        categoryName: categoryInfo[cat].name,
        icon: categoryInfo[cat].icon,
        color: categoryInfo[cat].color,
        total: categoryMilestones.length,
        completed,
        completionRate: categoryMilestones.length > 0 
          ? Math.round((completed / categoryMilestones.length) * 100)
          : 0
      };
    }).filter(c => c.total > 0);

    // Pr√≥ximos hitos (no completados, edad apropiada)
    const upcomingMilestones = milestones
      .filter(m => !progressMap[m.id]?.completed)
      .filter(m => m.ageMonthsMin <= (ageMonths + 3))
      .sort((a, b) => a.ageMonthsMin - b.ageMonthsMin)
      .slice(0, 5)
      .map(m => ({
        milestoneId: m.id,
        title: m.title,
        categoryId: m.categoryId,
        expectedAge: `${m.ageMonthsMin}-${m.ageMonthsMax} meses`
      }));

    res.json({
      success: true,
      data: {
        child: {
          id: childId,
          name: childData.name,
          birthDate: childData.birthDate,
          ageMonths,
          ageDisplay: `${ageMonths} ${ageMonths === 1 ? 'mes' : 'meses'}`
        },
        overallProgress: {
          totalMilestones: milestones.length,
          completed: Object.keys(progressMap).length,
          completionRate: milestones.length > 0 
            ? Math.round((Object.keys(progressMap).length / milestones.length) * 100)
            : 0,
          lastUpdated: completedMilestones.length > 0 
            ? completedMilestones[0].completedAt
            : null
        },
        progressByCategory,
        recentlyCompleted: completedMilestones.slice(0, 5),
        upcomingMilestones
      }
    });

  } catch (error) {
    console.error('‚ùå [MILESTONES] Error generando reporte:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando reporte',
      error: error.message
    });
  }
});

// ============================================================================
// ‚ö†Ô∏è MIDDLEWARE CATCH-ALL - DEBE ESTAR AL FINAL
// ============================================================================

// Middleware para rutas no encontradas (DEBE estar despu√©s de todas las rutas)
app.use('*', (req, res) => {
  console.log('‚ö†Ô∏è [404] Ruta no encontrada:', req.method, req.originalUrl);
  res.status(404).json({
    success: false,
    message: 'Ruta no encontrada',
    path: req.originalUrl,
    method: req.method
  });
});

